TKDFS2:
* TestKern Disk Filesystem
* Intended to be a basic filesystem for disk-like media.
* Intended to limit design complexity.

General Image Structure
* Boot Block (512B)
* Data Region
** Inode Table
** Directories
** Allocation Bitmaps
** File Data

The data region covers the entire volume, just marks the superblock and similar "in-use", with everything else allocated as normal blocks.

 BootBlock {
	byte pad_jmp[3];			//0x00, Boot JMP, Eg, EB-5E-90
	byte oem_name[8];			//0x03, "TKDFS2  "
	byte bytes_sector[2];		//0x0B, 512
	byte sectors_cluster;		//0x0D, 2/4/8/16/32
	byte reserved_sectors[2];	//0x0E, 0
	byte num_fats;				//0x10, 0
	byte root_dirents[2];		//0x11, 0
	byte lba_count16[2];		//0x13, 0
	byte media_type;            //0x15, 0xF8
	u16 sectors_fat;            //0x16, 0
	u16 sectors_track;          //0x18, 63 / ignored
	u16 heads;                  //0x1A, 255 / ignored
	u32 hidden_sectors;         //0x1C, 0
	u32 lba_count32;			//0x20, 0 | sector-count

	byte drive_number;			//0x24, hint
	byte drive_flags;			//0x25, 0
	byte ebp_sig;               //0x26, 0x80
	byte resv1;                 //0x27, 0
	u64 lba_count64;            //0x28, Total Sectors
    u64 blk_inotab;             //0x30, First Block of Inode Table.
    u64 blk_inotab;             //0x38, Backup Inode Table.
    byte ln2_sz_ino;            //0x40, Size of inode (Log2, 8 or 9)
    byte ln2_sz_de;             //0x41, Size of Dirent (log2, 6)
    byte resv2[6];              //0x42, reserved
    u64 vol_id;                 //0x48, Volume ID Number
    byte label[16];             //0x50, Volume Label
    byte bootstrap[414];        //0x60, x86 bootstrap or similar (N/A)
    byte magic_55aa[2];         //0x1FE, 55-AA
 };

BootBlock will have the similar structure to the NTFS Boot Block.


Inodes:
* 256 or 512 Bytes
* Will have a multi-purpose data area:
** Small files / Symlinks, inlined directly into inode.
* Will follow a basic TLV structure.

 Inode_TLV_TCC {
   TWOCC tag;       //0x00, Tag
   u16 len;         //0x02, Length, Bitwise Inverse
   byte data[~len]; //0x04, Data
 }
 Inode_TLV_FCC {
   FOURCC tag;      //0x00, Tag
   u16 len;         //0x04, Length, Bitwise Inverse
   u16 resv;        //0x06, reserved
   byte data[~len]; //0x08, Data
 }


"FH" / "FHDR": Holds an INode_File structure.

 INode_File {
 U64	dsize;		//0x00, File Size (Logical)
 U64	csize;		//0x08, File Size (Compressed)
 U64	ctime;		//0x10, Creation Time
 U64	mtime;		//0x18, Modified Time
 U16	uid;		//0x20, Owner UID
 U16	gid;		//0x22, Owner GID
 U16	mode;		//0x34, File Mode Flags
 BYTE	cmpmode;	//0x26, Compression Type
 BYTE	etype;		//0x27, File Entry Type
 }

File Mode:
* 0001: XO
* 0002: WO
* 0004: RO
* 0008: XG
* 0010: WG
* 0020: RG
* 0040: XU
* 0080: WU
* 0100: RU
* 0400: SetGID
* 0800: SetUID
* High Bits give Type:
** 4000: DIR
** 8000: FILE
** A000: SYMLINK

File Data:
* "ID" / "IDAT": Inline Data
** Consists of raw data.

* "I4" / "IDX4": File Block Index, with 32-bit block numbers, 128 bytes.
** May be used if volume has fewer than 2^32 blocks.
* "I6" / "IDX6": File Block Index, with 48-bit block numbers, 192 bytes.
** May be used if volume has fewer than 2^48 blocks.
* "I8" / "IDX8": File Block Index, with 64-bit block numbers, 256 bytes.

 FileBlockIndex4 {
   u32 block_0l[16];  //direct blocks
   u32 block_1l[ 8];  //indirect blocks (1-level)
   u32 block_2l[ 4];  //indirect blocks (2-level)
   u32 block_3l[ 2];  //indirect blocks (3-level)
   u32 block_4l;      //indirect blocks (4-level)
   u32 block_5l;      //indirect blocks (5-level)
 }
 FileBlockIndex6 {
   u32 block_0l[16];  //direct blocks
   u32 block_1l[ 8];  //indirect blocks (1-level)
   u32 block_2l[ 4];  //indirect blocks (2-level)
   u32 block_3l[ 2];  //indirect blocks (3-level)
   u32 block_4l;      //indirect blocks (4-level)
   u32 block_5l;      //indirect blocks (5-level)
   u16 block_0h[16];  //direct block, high bits
   u16 block_1h[ 8];  //
   u16 block_2h[ 4];  //
   u16 block_3h[ 2];  //
   u16 block_4h;      //
   u16 block_5h;      //
 };
 FileBlockIndex8 {
   u64 block_0l[16];  //direct blocks
   u64 block_1l[ 8];  //indirect blocks (1-level)
   u64 block_2l[ 4];  //indirect blocks (2-level)
   u64 block_3l[ 2];  //indirect blocks (3-level)
   u64 block_4l;      //indirect blocks (4-level)
   u64 block_5l;      //indirect blocks (5-level)
 }

* "IS" / "IDXS"
  FileBlockIndexSpan {
  u128 span[8];		//span bits
  }

Span (Possible):
* ( 47: 0)=File Base (Blocks)
* ( 63:48)=Logical Size (Blocks)
* ( 95:64)=Disk Block Number
* (127:96)=Size on Disk (if Compressed)
* If logical_size=0001..7FFF, and logical_size==size_disk, it is stored.
* If logical_size=0001..7FFF, and size_disk==0, it is uninitialized.
* If logical_size=0001..7FFF, and size_disk==0001..7FFF, it is compressed.
* If size_disk=8000..FFFF, this entry points at a span table.
** Logical Span will give the area covered by the span table.
** Or 0000, if the span-table covers more than 32767 blocks.

Would have fixed inode numbers for:
* 0, Inode Table
* 1, Root Directory
* 2, Block Allocation Bitmap
* 3, Inode Table Bitmap
* 8+, Generic File Inodes


Backup tables and/or a journal could be optional features (to improve reliability). Optional because these are not always needed.

The inode table would have its own inode, superblock holding the first span of the inode table, which would (necessarily) contain the inode-table inode and other fixed inodes (with table being expanded if/when the initial part gets full).



Directories will be represented similar to files, but will hold directory entries rather than file data. Each directory will be organized into an AVL tree. The first entry in the directory will be special in that it will serve as a directory root rather than a file entry. This entry will point to the root node of the tree.

Directory Entry:
* Directories are organized as an AVL Tree
* Names are UTF-8 and Zero Padded

 DirEnt_Basic {
 u32 ino;			//00, inode number
 u32 lsn;			//04, left child node
 u32 rsn;			//08, right child node
 u16 ino_hi;		//0C, inode high bits
 byte zdepth;		//0E, Z height of node (0=Leaf)
 byte etype;		//0F, dirent type
 byte name[48];		//10, name
 };
 DirEnt_Namefrag {
 byte name1[12];    //00, name 1
 byte fe_hash;      //0C, hash of first 48 bytes of name
 byte resv1;        //0D, reserved
 byte index;        //0E, Z height of node (0=Leaf)
 byte etype;        //0F, dirent type
 byte name2[48];    //10, name 2
 };


Entry Type:
* 0: Free (No File)
* 1: Basic File (single part name)
* 2: File with multipart name.
* 3: Name Fragment

The number of multipart name fragments will be variable, but will be enough to encode the name up to a certain maximum number of bytes. Names will be encoded in a variant of UTF-8.

Names will be case-sensitive and sorted in codepoint order (as defined by the UTF-8 encoding with each byte understood as unsigned).
