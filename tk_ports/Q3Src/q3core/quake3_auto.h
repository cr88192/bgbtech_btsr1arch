//AHSRC:qcommon/cm_load.c
void SetPlaneSignbits (cplane_t *out);
void	CM_InitBoxHull (void);
void	CM_FloodAreaConnections (void);
void CMod_LoadShaders( lump_t *l );
void CMod_LoadSubmodels( lump_t *l );
void CMod_LoadNodes( lump_t *l );
void CM_BoundBrush( cbrush_t *b );
void CMod_LoadBrushes( lump_t *l );
void CMod_LoadLeafs (lump_t *l);
void CMod_LoadPlanes (lump_t *l);
void CMod_LoadLeafBrushes (lump_t *l);
void CMod_LoadLeafSurfaces( lump_t *l );
void CMod_LoadBrushSides (lump_t *l);
void CMod_LoadEntityString( lump_t *l );
void CMod_LoadVisibility( lump_t *l );
void CMod_LoadPatches( lump_t *surfs, lump_t *verts );
unsigned CM_LumpChecksum(lump_t *lump);
unsigned CM_Checksum(dheader_t *header);
void CM_LoadMap( const char *name, qboolean clientload, int *checksum );
void CM_ClearMap( void );
cmodel_t	*CM_ClipHandleToModel( clipHandle_t handle );
clipHandle_t	CM_InlineModel( int index );
int		CM_NumClusters( void );
int		CM_NumInlineModels( void );
char	*CM_EntityString( void );
int		CM_LeafCluster( int leafnum );
int		CM_LeafArea( int leafnum );
void CM_InitBoxHull (void);
clipHandle_t CM_TempBoxModel( const vec3_t mins, const vec3_t maxs, int capsule );
void CM_ModelBounds( clipHandle_t model, vec3_t mins, vec3_t maxs );
//AHSRC:qcommon/cm_patch.c
void CM_ClearLevelPatches( void );
void CM_TraceThroughPatchCollide( traceWork_t *tw, const struct patchCollide_s *pc );
qboolean CM_PositionTestInPatchCollide( traceWork_t *tw, const struct patchCollide_s *pc );
void CM_DrawDebugSurface( void (*drawPoly)(int color, int numPoints, flaot *points) );
void CM_ClearLevelPatches( void );
int CM_PlaneEqual(patchPlane_t *p, float plane[4], int *flipped);
void CM_SnapVector(vec3_t normal);
int CM_FindPlane2(float plane[4], int *flipped);
void CM_AddFacetBevels( facet_t *facet );
void CM_TracePointThroughPatchCollide(traceWork_t *tw, const struct patchCollide_s *pc );
int CM_CheckFacetPlane(float *plane, vec3_t start, vec3_t end, float *enterFrac, float *leaveFrac, int *hit);
void CM_TraceThroughPatchCollide(traceWork_t *tw, const struct patchCollide_s *pc );
qboolean CM_PositionTestInPatchCollide(traceWork_t *tw, const struct patchCollide_s *pc );
void BotDrawDebugPolygons(void (*drawPoly)(int color, int numPoints, float *points), int value);
void CM_DrawDebugSurface( void (*drawPoly)(int color, int numPoints, float *points) );
//AHSRC:qcommon/cm_polylib.c
void pw(winding_t *w);
winding_t	*AllocWinding (int points);
void FreeWinding (winding_t *w);
void	RemoveColinearPoints (winding_t *w);
void WindingPlane (winding_t *w, vec3_t normal, vec_t *dist);
vec_t	WindingArea (winding_t *w);
void	WindingBounds (winding_t *w, vec3_t mins, vec3_t maxs);
void	WindingCenter (winding_t *w, vec3_t center);
winding_t *BaseWindingForPlane (vec3_t normal, vec_t dist);
winding_t	*CopyWinding (winding_t *w);
winding_t	*ReverseWinding (winding_t *w);
void	ClipWindingEpsilon (winding_t *in, vec3_t normal, vec_t dist, vec_t epsilon, winding_t **front, winding_t **back);
void ChopWindingInPlace (winding_t **inout, vec3_t normal, vec_t dist, vec_t epsilon);
winding_t	*ChopWinding (winding_t *in, vec3_t normal, vec_t dist);
void CheckWinding (winding_t *w);
int		WindingOnPlaneSide (winding_t *w, vec3_t normal, vec_t dist);
void	AddWindingToConvexHull( winding_t *w, winding_t **hull, vec3_t normal );
//AHSRC:qcommon/cm_test.c
int CM_PointLeafnum_r( const vec3_t p, int num );
int CM_PointLeafnum( const vec3_t p );
void CM_StoreLeafs( leafList_t *ll, int nodenum );
void CM_StoreBrushes( leafList_t *ll, int nodenum );
void CM_BoxLeafnums_r( leafList_t *ll, int nodenum );
int	CM_BoxLeafnums( const vec3_t mins, const vec3_t maxs, int *list, int listsize, int *lastLeaf);
int CM_BoxBrushes( const vec3_t mins, const vec3_t maxs, cbrush_t **list, int listsize );
int CM_PointContents( const vec3_t p, clipHandle_t model );
int	CM_TransformedPointContents( const vec3_t p, clipHandle_t model, const vec3_t origin, const vec3_t angles);
byte	*CM_ClusterPVS (int cluster);
void CM_FloodArea_r( int areaNum, int floodnum);
void	CM_FloodAreaConnections( void );
void	CM_AdjustAreaPortalState( int area1, int area2, qboolean open );
qboolean	CM_AreasConnected( int area1, int area2 );
int CM_WriteAreaBits (byte *buffer, int area);
//AHSRC:qcommon/cm_trace.c
void RotatePoint(vec3_t point, /*const*/ vec3_t matrix[3]);
void TransposeMatrix(/*const*/ vec3_t matrix[3], vec3_t transpose[3]);
void CreateRotationMatrix(const vec3_t angles, vec3_t matrix[3]);
void CM_ProjectPointOntoVector( vec3_t point, vec3_t vStart, vec3_t vDir, vec3_t vProj );
float CM_DistanceFromLineSquared(vec3_t p, vec3_t lp1, vec3_t lp2, vec3_t dir);
float CM_VectorDistanceSquared(vec3_t p1, vec3_t p2);
float SquareRootFloat(float number);
void CM_TestBoxInBrush( traceWork_t *tw, cbrush_t *brush );
void CM_TestInLeaf( traceWork_t *tw, cLeaf_t *leaf );
void CM_TestCapsuleInCapsule( traceWork_t *tw, clipHandle_t model );
void CM_TestBoundingBoxInCapsule( traceWork_t *tw, clipHandle_t model );
void CM_PositionTest( traceWork_t *tw );
void CM_TraceThroughPatch( traceWork_t *tw, cPatch_t *patch );
void CM_TraceThroughBrush( traceWork_t *tw, cbrush_t *brush );
void CM_TraceThroughLeaf( traceWork_t *tw, cLeaf_t *leaf );
void CM_TraceThroughSphere( traceWork_t *tw, vec3_t origin, float radius, vec3_t start, vec3_t end );
void CM_TraceThroughVerticalCylinder( traceWork_t *tw, vec3_t origin, float radius, float halfheight, vec3_t start, vec3_t end);
void CM_TraceCapsuleThroughCapsule( traceWork_t *tw, clipHandle_t model );
void CM_TraceBoundingBoxThroughCapsule( traceWork_t *tw, clipHandle_t model );
void CM_TraceThroughTree( traceWork_t *tw, int num, float p1f, float p2f, vec3_t p1, vec3_t p2);
void CM_Trace( trace_t *results,const vec3_t start, const vec3_t end, //	vec3_t mins, vec3_t maxs, float *mins, float *maxs, clipHandle_t model, const vec3_t origin, int brushmask, int capsule, sphere_t *sphere );
void CM_BoxTrace( trace_t *results, const vec3_t start, const vec3_t end,vec3_t mins, vec3_t maxs, clipHandle_t model, int brushmask, int capsule );
void CM_TransformedBoxTrace( trace_t *results,const vec3_t start, const vec3_t end, //						vec3_t mins, vec3_t maxs, float *mins, float *maxs, clipHandle_t model, int brushmask, const vec3_t origin, const vec3_t angles, int capsule );
//AHSRC:qcommon/cmd.c
void Cmd_Wait_f( void );
void Cbuf_Init (void);
void Cbuf_AddText( const char *text );
void Cbuf_InsertText( const char *text );
void Cbuf_ExecuteText (int exec_when, const char *text);
void Cbuf_Execute (void);
void Cmd_Exec_f( void );
void Cmd_Vstr_f( void );
void Cmd_Echo_f (void);
int		Cmd_Argc( void );
char	*Cmd_Argv( int arg );
void	Cmd_ArgvBuffer( int arg, char *buffer, int bufferLength );
char	*Cmd_Args( void );
char *Cmd_ArgsFrom( int arg );
void	Cmd_ArgsBuffer( char *buffer, int bufferLength );
char *Cmd_Cmd();
void Cmd_TokenizeString( const char *text_in );
void	Cmd_AddCommand( const char *cmd_name, xcommand_t function );
void	Cmd_RemoveCommand( const char *cmd_name );
void	Cmd_CommandCompletion( void(*callback)(const char *s) );
void	Cmd_ExecuteString( const char *text );
void Cmd_List_f (void);
void Cmd_Init (void);
//AHSRC:qcommon/common.c
void Com_WriteConfig_f( void );
void CIN_CloseAllVideos();
void Com_BeginRedirect (char *buffer, int buffersize, void (*flush)( char *) );
void Com_EndRedirect (void);
void Com_Quit_f( void );
void Com_ParseCommandLine( char *commandLine );
qboolean Com_SafeMode( void );
void Com_StartupVariable( const char *match );
qboolean Com_AddStartupCommands( void );
void Info_Print( const char *s );
char *Com_StringContains(char *str1, char *str2, int casesensitive);
int Com_Filter(char *filter, char *name, int casesensitive);
int Com_FilterPath(char *filter, char *name, int casesensitive);
int Com_HashKey(char *string, int maxlen);
int Com_RealTime(qtime_t *qtime);
void Z_CheckHeap( void );
void Z_ClearZone( memzone_t *zone, int size );
int Z_AvailableZoneMemory( memzone_t *zone );
int Z_AvailableMemory( void );
void Z_Free( void *ptr );
void Z_FreeTags( int tag );
void *Z_TagMallocDebug( int size, int tag, char *label, char *file, int line );
void *Z_TagMalloc( int size, int tag );
void *Z_MallocDebug( int size, char *label, char *file, int line );
void *Z_Malloc( int size );
void *S_MallocDebug( int size, char *label, char *file, int line );
void *S_Malloc( int size );
void *S_MallocStatic( int size );
void Z_CheckHeap( void );
void Z_LogZoneHeap( memzone_t *zone, char *name );
void Z_LogHeap( void );
char *CopyString( const char *in );
int		Hunk_GetOffsForPtr(void *ptr);
void *Hunk_GetPtrForOffs(int offs);
void Com_Meminfo_f( void );
void Com_TouchMemory( void );
void Com_InitSmallZoneMemory( void );
void Com_InitZoneMemory( void );
void Hunk_Log( void);
void Hunk_SmallLog( void);
void Com_InitHunkMemory( void );
int	Hunk_MemoryRemaining( void );
void Hunk_SetMark( void );
void Hunk_ClearToMark( void );
qboolean Hunk_CheckMark( void );
void CL_ShutdownCGame( void );
void CL_ShutdownUI( void );
void SV_ShutdownGameProgs( void );
void Hunk_Clear( void );
Allocate permanent (until the hunk is cleared);
void *Hunk_AllocDebug( int size, ha_pref preference, char *label, char *file, int line );
void *Hunk_Alloc( int size, ha_pref preference );
void *Hunk_AllocateTempMemory( int size );
void Hunk_FreeTempMemory( void *buf );
void Hunk_ClearTempMemory( void );
void Hunk_Trash( void );
void Com_InitJournaling( void );
sysEvent_t	Com_GetRealEvent( void );
void Com_InitPushEvent( void );
void Com_PushEvent( sysEvent_t *event );
sysEvent_t	Com_GetEvent( void );
void Com_RunAndTimeServerPacket( netadr_t *evFrom, msg_t *buf );
int Com_EventLoop( void );
int Com_Milliseconds (void);
qboolean CL_CDKeyValidate( const char *key, const char *checksum );
void Com_ReadCDKey( const char *filename );
void Com_AppendCDKey( const char *filename );
void Com_Init( char *commandLine );
void Com_WriteConfigToFile( const char *filename );
void Com_WriteConfiguration( void );
void Com_WriteConfig_f( void );
int Com_ModifyMsec( int msec );
void Com_Frame( void );
void Com_Shutdown (void);
void Com_Memcpy (void* dest, const void* src, const size_t count);
void Com_Memset (void* dest, const int val, const size_t count);
void Com_Prefetch (const void *s, const unsigned int bytes, e_prefetch type);
void _copyDWord (unsigned int* dest, const unsigned int constant, const unsigned int count);
void Com_Memcpy (void* dest, const void* src, const size_t count);
void Com_Memset (void* dest, const int val, const size_t count);
qboolean Com_Memcmp (const void *src0, const void *src1, const unsigned int count);
void Com_Prefetch (const void *s, const unsigned int bytes, e_prefetch type);
float Q_acos(float c);
void Field_Clear( field_t *edit );
void Field_CompleteCommand( field_t *field );
//AHSRC:qcommon/cvar.c
cvar_t *Cvar_Set2( const char *var_name, const char *value, qboolean force);
float Cvar_VariableValue( const char *var_name );
int Cvar_VariableIntegerValue( const char *var_name );
char *Cvar_VariableString( const char *var_name );
void Cvar_VariableStringBuffer( const char *var_name, char *buffer, int bufsize );
void	Cvar_CommandCompletion( void(*callback)(const char *s) );
cvar_t *Cvar_Get( const char *var_name, const char *var_value, int flags );
cvar_t *Cvar_Set2( const char *var_name, const char *value, qboolean force );
void Cvar_Set( const char *var_name, const char *value);
void Cvar_SetLatched( const char *var_name, const char *value);
void Cvar_SetValue( const char *var_name, float value);
void Cvar_Reset( const char *var_name );
void Cvar_SetCheatState( void );
qboolean Cvar_Command( void );
void Cvar_Toggle_f( void );
void Cvar_Set_f( void );
void Cvar_SetU_f( void );
void Cvar_SetS_f( void );
void Cvar_SetA_f( void );
void Cvar_Reset_f( void );
void Cvar_WriteVariables( fileHandle_t f );
void Cvar_List_f( void );
void Cvar_Restart_f( void );
char	*Cvar_InfoString( int bit );
char	*Cvar_InfoString_Big( int bit );
void Cvar_InfoStringBuffer( int bit, char* buff, int buffsize );
void	Cvar_Register( vmCvar_t *vmCvar, const char *varName, const char *defaultValue, int flags );
void	Cvar_Update( vmCvar_t *vmCvar );
void Cvar_Init (void);
//AHSRC:qcommon/files.c
qboolean FS_Initialized();
qboolean FS_PakIsPure( pack_t *pack );
int FS_LoadStack();
void	FS_ForceFlush( fileHandle_t f );
int FS_filelength( fileHandle_t f );
char *FS_BuildOSPath( const char *base, const char *game, const char *qpath );
qboolean FS_FileExists( const char *file );
qboolean FS_SV_FileExists( const char *file );
fileHandle_t FS_SV_FOpenFileWrite( const char *filename );
int FS_SV_FOpenFileRead( const char *filename, fileHandle_t *fp );
void FS_SV_Rename( const char *from, const char *to );
void FS_Rename( const char *from, const char *to );
void FS_FCloseFile( fileHandle_t f );
fileHandle_t FS_FOpenFileWrite( const char *filename );
fileHandle_t FS_FOpenFileAppend( const char *filename );
qboolean FS_FilenameCompare( const char *s1, const char *s2 );
char *FS_ShiftedStrStr(const char *string, const char *substring, int shift);
int FS_FOpenFileRead( const char *filename, fileHandle_t *file, qboolean uniqueFILE );
int FS_Read2( void *buffer, int len, fileHandle_t f );
int FS_Read( void *buffer, int len, fileHandle_t f );
int FS_Write( const void *buffer, int len, fileHandle_t h );
int FS_Seek( fileHandle_t f, long offset, int origin );
int	FS_FileIsInPAK(const char *filename, int *pChecksum );
int FS_ReadFile( const char *qpath, void **buffer );
void FS_FreeFile( void *buffer );
void FS_WriteFile( const char *qpath, const void *buffer, int size );
char **FS_ListFilteredFiles( const char *path, const char *extension, char *filter, int *numfiles );
char **FS_ListFiles( const char *path, const char *extension, int *numfiles );
void FS_FreeFileList( char **list );
int	FS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize );
int	FS_GetModList( char *listbuf, int bufsize );
void FS_Dir_f( void );
void FS_ConvertPath( char *s );
int FS_PathCmp( const char *s1, const char *s2 );
void FS_SortFileList(char **filelist, int numfiles);
void FS_NewDir_f( void );
void FS_Path_f( void );
void FS_TouchFile_f( void );
qboolean FS_idPak( char *pak, char *base );
qboolean FS_ComparePaks( char *neededpaks, int len, qboolean dlstring );
void FS_Shutdown( qboolean closemfp );
void Com_AppendCDKey( const char *filename );
void Com_ReadCDKey( const char *filename );
void FS_ClearPakReferences( int flags );
void FS_PureServerSetLoadedPaks( const char *pakSums, const char *pakNames );
void FS_PureServerSetReferencedPaks( const char *pakSums, const char *pakNames );
void FS_InitFilesystem( void );
void FS_Restart( int checksumFeed );
qboolean FS_ConditionalRestart( int checksumFeed );
int		FS_FOpenFileByMode( const char *qpath, fileHandle_t *f, fsMode_t mode );
int		FS_FTell( fileHandle_t f );
void	FS_Flush( fileHandle_t f );
//AHSRC:qcommon/huffman.c
void	Huff_putBit( int bit, byte *fout, int *offset);
int		Huff_getBit( byte *fin, int *offset);
void Huff_addRef(huff_t* huff, byte ch);
int Huff_Receive (node_t *node, int *ch, byte *fin);
void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset);
void Huff_transmit (huff_t *huff, int ch, byte *fout);
void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset);
void Huff_Decompress(msg_t *mbuf, int offset);
void Huff_Compress(msg_t *mbuf, int offset);
void Huff_Init(huffman_t *huff);
//AHSRC:qcommon/md4.c
void MD4Init (MD4_CTX *);
void MD4Update (MD4_CTX *, const unsigned char *, unsigned int);
void MD4Final (unsigned char [16], MD4_CTX *);
void Com_Memset (void* dest, const int val, const size_t count);
void Com_Memcpy (void* dest, const void* src, const size_t count);
void MD4Init (MD4_CTX *context);
void MD4Update (MD4_CTX *context, const unsigned char *input, unsigned int inputLen);
void MD4Final (unsigned char digest[16], MD4_CTX *context);
unsigned Com_BlockChecksum (void *buffer, int length);
unsigned Com_BlockChecksumKey (void *buffer, int length, int key);
//AHSRC:qcommon/msg.c
void MSG_initHuffman();
void MSG_Init( msg_t *buf, byte *data, int length );
void MSG_InitOOB( msg_t *buf, byte *data, int length );
void MSG_Clear( msg_t *buf );
void MSG_Bitstream( msg_t *buf );
void MSG_BeginReading( msg_t *msg );
void MSG_BeginReadingOOB( msg_t *msg );
void MSG_Copy(msg_t *buf, byte *data, int length, msg_t *src);
void MSG_WriteBits( msg_t *msg, int value, int bits );
int MSG_ReadBits( msg_t *msg, int bits );
void MSG_WriteChar( msg_t *sb, int c );
void MSG_WriteByte( msg_t *sb, int c );
void MSG_WriteData( msg_t *buf, const void *data, int length );
void MSG_WriteShort( msg_t *sb, int c );
void MSG_WriteLong( msg_t *sb, int c );
void MSG_WriteFloat( msg_t *sb, float f );
void MSG_WriteString( msg_t *sb, const char *s );
void MSG_WriteBigString( msg_t *sb, const char *s );
void MSG_WriteAngle( msg_t *sb, float f );
void MSG_WriteAngle16( msg_t *sb, float f );
int MSG_ReadChar (msg_t *msg );
int MSG_ReadByte( msg_t *msg );
int MSG_ReadShort( msg_t *msg );
int MSG_ReadLong( msg_t *msg );
float MSG_ReadFloat( msg_t *msg );
char *MSG_ReadString( msg_t *msg );
char *MSG_ReadBigString( msg_t *msg );
char *MSG_ReadStringLine( msg_t *msg );
float MSG_ReadAngle16( msg_t *msg );
void MSG_ReadData( msg_t *msg, void *data, int len );
void MSG_WriteDelta( msg_t *msg, int oldV, int newV, int bits );
int	MSG_ReadDelta( msg_t *msg, int oldV, int bits );
void MSG_WriteDeltaFloat( msg_t *msg, float oldV, float newV );
float MSG_ReadDeltaFloat( msg_t *msg, float oldV );
void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits );
int	MSG_ReadDeltaKey( msg_t *msg, int key, int oldV, int bits );
void MSG_WriteDeltaKeyFloat( msg_t *msg, int key, float oldV, float newV );
float MSG_ReadDeltaKeyFloat( msg_t *msg, int key, float oldV );
void MSG_WriteDeltaUsercmd( msg_t *msg, usercmd_t *from, usercmd_t *to );
void MSG_ReadDeltaUsercmd( msg_t *msg, usercmd_t *from, usercmd_t *to );
void MSG_WriteDeltaUsercmdKey( msg_t *msg, int key, usercmd_t *from, usercmd_t *to );
void MSG_ReadDeltaUsercmdKey( msg_t *msg, int key, usercmd_t *from, usercmd_t *to );
void MSG_ReportChangeVectors_f( void );
void MSG_WriteDeltaEntity( msg_t *msg, struct entityState_s *from, struct entityState_s *to, qboolean force );
void MSG_ReadDeltaEntity( msg_t *msg, entityState_t *from, entityState_t *to, int number);
void MSG_WriteDeltaPlayerstate(msg_t *msg, struct playerState_s *from, struct playerState_s *to );
void MSG_ReadDeltaPlayerstate (msg_t *msg, playerState_t *from, playerState_t *to );
void MSG_initHuffman();
void MSG_NUinitHuffman();
//AHSRC:qcommon/net_chan.c
void Netchan_Init( int port );
void Netchan_Setup( netsrc_t sock, netchan_t *chan, netadr_t adr, int qport );
void Netchan_TransmitNextFragment( netchan_t *chan );
void Netchan_Transmit( netchan_t *chan, int length, const byte *data );
qboolean Netchan_Process( netchan_t *chan, msg_t *msg );
qboolean	NET_CompareBaseAdr (netadr_t a, netadr_t b);
qboolean	NET_CompareAdr (netadr_t a, netadr_t b);
qboolean	NET_IsLocalAddress( netadr_t adr );
qboolean	NET_GetLoopPacket (netsrc_t sock, netadr_t *net_from, msg_t *net_message);
void NET_SendLoopPacket (netsrc_t sock, int length, const void *data, netadr_t to);
void NET_SendPacket( netsrc_t sock, int length, const void *data, netadr_t to );
qboolean	NET_StringToAdr( const char *s, netadr_t *a );
//AHSRC:qcommon/unzip.c
typedef uLong (*check_func);
void inflate_blocks_reset(inflate_blocks_statef *s, z_streamp z, uLong *c);
inflate_blocks_statef *inflate_blocks_new(z_streamp z, check_func c, uInt w);
int inflate_blocks(inflate_blocks_statef *s, z_streamp z, int r);
int inflate_blocks_free(inflate_blocks_statef *s, z_streamp z);
void inflate_set_dictionary(inflate_blocks_statef *s, const Byte *d, uInt n);
int inflate_blocks_sync_point(inflate_blocks_statef *s);
int inflate_flush(inflate_blocks_statef *s, z_streamp z, int r);
int inflate_trees_bits(uInt *c, uInt *bb, inflate_huft * *tb, inflate_huft *hp, z_streamp z);
int inflate_trees_dynamic(uInt nl, uInt nd, uInt *c, uInt *bl, uInt *bd, inflate_huft * *tl, inflate_huft * *td, inflate_huft *hp, z_streamp z);
int inflate_trees_fixed(uInt *bl, uInt *bd, inflate_huft * *tl, inflate_huft * *td, z_streamp z);
inflate_codes_statef *inflate_codes_new(uInt bl, uInt bd, inflate_huft *tl, inflate_huft *td, z_streamp z);
int inflate_codes(inflate_blocks_statef *s, z_streamp z, int r);
void inflate_codes_free(inflate_codes_statef *c, z_streamp z);
int inflateReset(z_streamp z);
int inflateEnd(z_streamp z);
int inflateInit2_(z_streamp z, int w, const char *version, int stream_size);
int inflateInit_(z_streamp z, const char *version, int stream_size);
int inflate(z_streamp z, int f);
int inflateSetDictionary(z_streamp z, const Byte *dictionary, uInt dictLength);
int inflateSync(z_streamp z);
int inflateSyncPoint(z_streamp z);
voidp zcalloc (voidp opaque, unsigned items, unsigned size);
void  zcfree (voidp opaque, voidp ptr);
//AHSRC:qcommon/vm.c
void VM_VmInfo_f( void );
void VM_VmProfile_f( void );
void	*VM_VM2C( vmptr_t p, int length );
void	*VM_UnwrapPtr(nlint vptr);
nlint	VM_WrapPtr(void *ptr);
void VM_Debug( int level );
void VM_Init( void );
vmSymbol_t *VM_ValueToFunctionSymbol( vm_t *vm, int value );
int VM_SymbolToValue( vm_t *vm, const char *symbol );
int	ParseHex( const char *text );
void VM_LoadSymbols( vm_t *vm );
vm_t *VM_Restart( vm_t *vm );
vm_t *VM_Create( const char *module,//	int (*systemCalls)(int *),  nlint (*systemCalls)(nlint *),  vmInterpret_t interpret );
void VM_Free( vm_t *vm );
void VM_Clear(void);
void *VM_ArgPtr( nlint intValue );
void *VM_ExplicitArgPtr( vm_t *vm, nlint intValue );
void VM_VmProfile_f( void );
void VM_VmInfo_f( void );
void VM_LogSyscalls( nlint *args );
int VM_SyscallInt( vm_t *vm, int *args );
int	VM_CallCompiled( vm_t *vm, int *args );
void VM_Compile( vm_t *vm, vmHeader_t *header );
//AHSRC:qcommon/vm_interpreted.c
char *VM_Indent( vm_t *vm );
void VM_StackTrace( vm_t *vm, int programCounter, int programStack );
void VM_PrepareInterpreter( vm_t *vm, vmHeader_t *header );
int	VM_CallInterpreted( vm_t *vm, int *args );
//AHSRC:game/q_math.c
int		Q_rand( int *seed );
float	Q_random( int *seed );
float	Q_crandom( int *seed );
int VectorCompare( const vec3_t v1, const vec3_t v2 );
vec_t VectorLength( const vec3_t v );
vec_t VectorLengthSquared( const vec3_t v );
vec_t Distance( const vec3_t p1, const vec3_t p2 );
vec_t DistanceSquared( const vec3_t p1, const vec3_t p2 );
void VectorNormalizeFast( vec3_t v );
void VectorInverse( vec3_t v );
void CrossProduct( const vec3_t v1, const vec3_t v2, vec3_t cross );
int DirToByte( vec3_t dir );
void ByteToDir( int b, vec3_t dir );
unsigned ColorBytes3 (float r, float g, float b);
unsigned ColorBytes4 (float r, float g, float b, float a);
float NormalizeColor( const vec3_t in, vec3_t out );
qboolean PlaneFromPoints( vec4_t plane, const vec3_t a, const vec3_t b, const vec3_t c );
void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point,float degrees );
void RotateAroundDirection( vec3_t axis[3], float yaw );
void vectoangles( const vec3_t value1, vec3_t angles );
void AnglesToAxis( const vec3_t angles, vec3_t axis[3] );
void AxisClear( vec3_t axis[3] );
void AxisCopy( vec3_t in[3], vec3_t out[3] );
void ProjectPointOnPlane( vec3_t dst, const vec3_t p, const vec3_t normal );
void MakeNormalVectors( const vec3_t forward, vec3_t right, vec3_t up);
void VectorRotate( vec3_t in, vec3_t matrix[3], vec3_t out );
float Q_rsqrt( float number );
float Q_fabs( float f );
float LerpAngle (float from, float to, float frac);
float	AngleSubtract( float a1, float a2 );
void AnglesSubtract( vec3_t v1, vec3_t v2, vec3_t v3 );
float	AngleMod(float a);
float AngleNormalize360 ( float angle );
float AngleNormalize180 ( float angle );
float AngleDelta ( float angle1, float angle2 );
void SetPlaneSignbits (cplane_t *out);
int BoxOnPlaneSide2 (vec3_t emins, vec3_t emaxs, struct cplane_s *p);
int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, struct cplane_s *p);
float RadiusFromBounds( const vec3_t mins, const vec3_t maxs );
void ClearBounds( vec3_t mins, vec3_t maxs );
void AddPointToBounds( const vec3_t v, vec3_t mins, vec3_t maxs );
vec_t VectorNormalize( vec3_t v );
vec_t VectorNormalize2( const vec3_t v, vec3_t out);
void _VectorMA( const vec3_t veca, float scale, const vec3_t vecb, vec3_t vecc);
vec_t _DotProduct( const vec3_t v1, const vec3_t v2 );
void _VectorSubtract( const vec3_t veca, const vec3_t vecb, vec3_t out );
void _VectorAdd( const vec3_t veca, const vec3_t vecb, vec3_t out );
void _VectorCopy( const vec3_t in, vec3_t out );
void _VectorScale( const vec3_t in, vec_t scale, vec3_t out );
void Vector4Scale( const vec4_t in, vec_t scale, vec4_t out );
int Q_log2( int val );
int	PlaneTypeForNormal (vec3_t normal);
void MatrixMultiply(float in1[3][3], float in2[3][3], float out[3][3]);
void AngleVectors( const vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
void PerpendicularVector( vec3_t dst, const vec3_t src );
//AHSRC:game/q_shared.c
float Com_Clamp( float min, float max, float value );
char *COM_SkipPath (char *pathname);
void COM_StripExtension( const char *in, char *out );
void COM_DefaultExtension (char *path, int maxSize, const char *extension );
short	BigShort(short l);
short	LittleShort(short l);
int		BigLong (int l);
int		LittleLong (int l);
qint64 	BigLong64 (qint64 l);
qint64 	LittleLong64 (qint64 l);
float	BigFloat (const float *l);
float	LittleFloat (const float *l);
short   ShortSwap (short l);
short	ShortNoSwap (short l);
int    LongSwap (int l);
int	LongNoSwap (int l);
qint64 Long64Swap (qint64 ll);
qint64 Long64NoSwap (qint64 ll);
float FloatSwap (const float *f);
float FloatNoSwap (const float *f);
void Swap_Init (void);
void COM_BeginParseSession( const char *name );
int COM_GetCurrentParseLine( void );
char *COM_Parse( char **data_p );
void COM_ParseError( char *format, ... );
void COM_ParseWarning( char *format, ... );
int COM_Compress( char *data_p );
char *COM_ParseExt( char **data_p, qboolean allowLineBreaks );
int COM_ParseInfos( char *buf, int max, char infos[][MAX_INFO_STRING] );
void COM_MatchToken( char **buf_p, char *match );
void SkipBracedSection (char **program);
void SkipRestOfLine ( char **data );
void Parse1DMatrix (char **buf_p, int x, float *m);
void Parse2DMatrix (char **buf_p, int y, int x, float *m);
void Parse3DMatrix (char **buf_p, int z, int y, int x, float *m);
int Q_isprint( int c );
int Q_islower( int c );
int Q_isupper( int c );
int Q_isalpha( int c );
void Q_strncpyz( char *dest, const char *src, int destsize );
int Q_stricmpn (const char *s1, const char *s2, int n);
int Q_strncmp (const char *s1, const char *s2, int n);
int Q_stricmp (const char *s1, const char *s2);
char *Q_strlwr( char *s1 );
char *Q_strupr( char *s1 );
void Q_strcat( char *dest, int size, const char *src );
int Q_PrintStrlen( const char *string );
char *Q_CleanStr( char *string );
char *Info_ValueForKey( const char *s, const char *key );
void Info_NextPair( const char **head, char *key, char *value );
void Info_RemoveKey( char *s, const char *key );
void Info_RemoveKey_Big( char *s, const char *key );
qboolean Info_Validate( const char *s );
void Info_SetValueForKey( char *s, const char *key, const char *value );
void Info_SetValueForKey_Big( char *s, const char *key, const char *value );
void *Q_MallocLLn(int sz, char *lfn, int lln);
int Q_MallocCheckSane(void);
void *Q_MallocBulkLLn(int sz, char *lfn, int lln);
void Q_FreeLLn(void *ptr, char *lfn, int lln);
void *Q_AllocTemp(int sz);
void Q_FreeTemp(void *ptr);
void Q_AllocaStart(void **mark);
void Q_AllocaEnd(void **mark);
void *Q_Alloca(void **mark, int sz);
void Q_MemcpySafe(void *dst, void *src, int sz);
//AHSRC:client/cl_cgame.c
void CL_GetGameState( gameState_t *gs );
void CL_GetGlconfig( glconfig_t *glconfig );
qboolean CL_GetUserCmd( int cmdNumber, usercmd_t *ucmd );
int CL_GetCurrentCmdNumber( void );
qboolean	CL_GetParseEntityState( int parseEntityNumber, entityState_t *state );
void	CL_GetCurrentSnapshotNumber( int *snapshotNumber, int *serverTime );
qboolean	CL_GetSnapshot( int snapshotNumber, snapshot_t *snapshot );
void CL_SetUserCmdValue( int userCmdValue, float sensitivityScale );
void CL_AddCgameCommand( const char *cmdName );
void CL_CgameError( const char *string );
void CL_ConfigstringModified( void );
qboolean CL_GetServerCommand( int serverCommandNumber );
void CL_CM_LoadMap( const char *mapname );
void CL_ShutdownCGame( void );
nlint CL_CgameSystemCalls( nlint *args );
void CL_InitCGame( void );
qboolean CL_GameCommand( void );
void CL_CGameRendering( stereoFrame_t stereo );
void CL_AdjustTimeDelta( void );
void CL_FirstSnapshot( void );
void CL_SetCGameTime( void );
//AHSRC:client/cl_cin.c
void CIN_CloseAllVideos(void);
long RllDecodeMonoToMono(unsigned char *from,short *to,unsigned int size,char signedOutput ,unsigned short flag);
long RllDecodeMonoToStereo(unsigned char *from,short *to,unsigned int size,char signedOutput,unsigned short flag);
long RllDecodeStereoToStereo(unsigned char *from,short *to,unsigned int size,char signedOutput, unsigned short flag);
long RllDecodeStereoToMono(unsigned char *from,short *to,unsigned int size,char signedOutput, unsigned short flag);
e_status CIN_StopCinematic(int handle);
e_status CIN_RunCinematic (int handle);
int CIN_PlayCinematic( const char *arg, int x, int y, int w, int h, int systemBits );
void CIN_SetExtents (int handle, int x, int y, int w, int h);
void CIN_SetLooping(int handle, qboolean loop);
void CIN_DrawCinematic (int handle);
void CL_PlayCinematic_f(void);
void SCR_DrawCinematic (void);
void SCR_RunCinematic (void);
void SCR_StopCinematic(void);
void CIN_UploadCinematic(int handle);
//AHSRC:client/cl_console.c
void Con_ToggleConsole_f (void);
void Con_MessageMode_f (void);
void Con_MessageMode2_f (void);
void Con_MessageMode3_f (void);
void Con_MessageMode4_f (void);
void Con_Clear_f (void);
void Con_Dump_f (void);
void Con_ClearNotify( void );
void Con_CheckResize (void);
void Con_Init (void);
void Con_Linefeed (qboolean skipnotify);
void CL_ConsolePrint( char *txt );
void Con_DrawInput (void);
void Con_DrawNotify (void);
void Con_DrawSolidConsole( float frac );
void Con_DrawConsole( void );
void Con_RunConsole (void);
void Con_PageUp( void );
void Con_PageDown( void );
void Con_Top( void );
void Con_Bottom( void );
void Con_Close( void );
//AHSRC:client/cl_input.c
input sources (say, mouse button 1 and the control key);
void IN_MLookDown( void );
void IN_MLookUp( void );
void IN_KeyDown( kbutton_t *b );
void IN_KeyUp( kbutton_t *b );
float CL_KeyState( kbutton_t *key );
void IN_UpDown(void);
void IN_UpUp(void);
void IN_DownDown(void);
void IN_DownUp(void);
void IN_LeftDown(void);
void IN_LeftUp(void);
void IN_RightDown(void);
void IN_RightUp(void);
void IN_ForwardDown(void);
void IN_ForwardUp(void);
void IN_BackDown(void);
void IN_BackUp(void);
void IN_LookupDown(void);
void IN_LookupUp(void);
void IN_LookdownDown(void);
void IN_LookdownUp(void);
void IN_MoveleftDown(void);
void IN_MoveleftUp(void);
void IN_MoverightDown(void);
void IN_MoverightUp(void);
void IN_SpeedDown(void);
void IN_SpeedUp(void);
void IN_StrafeDown(void);
void IN_StrafeUp(void);
void IN_Button0Down(void);
void IN_Button0Up(void);
void IN_Button1Down(void);
void IN_Button1Up(void);
void IN_Button2Down(void);
void IN_Button2Up(void);
void IN_Button3Down(void);
void IN_Button3Up(void);
void IN_Button4Down(void);
void IN_Button4Up(void);
void IN_Button5Down(void);
void IN_Button5Up(void);
void IN_Button6Down(void);
void IN_Button6Up(void);
void IN_Button7Down(void);
void IN_Button7Up(void);
void IN_Button8Down(void);
void IN_Button8Up(void);
void IN_Button9Down(void);
void IN_Button9Up(void);
void IN_Button10Down(void);
void IN_Button10Up(void);
void IN_Button11Down(void);
void IN_Button11Up(void);
void IN_Button12Down(void);
void IN_Button12Up(void);
void IN_Button13Down(void);
void IN_Button13Up(void);
void IN_Button14Down(void);
void IN_Button14Up(void);
void IN_Button15Down(void);
void IN_Button15Up(void);
void IN_ButtonDown (void);
void IN_ButtonUp (void);
void IN_CenterView (void);
void CL_AdjustAngles( void );
void CL_KeyMove( usercmd_t *cmd );
void CL_MouseEvent( int dx, int dy, int time );
void CL_JoystickEvent( int axis, int value, int time );
void CL_JoystickMove( usercmd_t *cmd );
void CL_MouseMove( usercmd_t *cmd );
void CL_CmdButtons( usercmd_t *cmd );
void CL_FinishMove( usercmd_t *cmd );
usercmd_t CL_CreateCmd( void );
void CL_CreateNewCommands( void );
qboolean CL_ReadyToSendPacket( void );
void CL_WritePacket( void );
void CL_SendCmd( void );
void CL_InitInput( void );
//AHSRC:client/cl_keys.c
void Field_VariableSizeDraw( field_t *edit, int x, int y, int width, int size, qboolean showCursor );
void Field_Draw( field_t *edit, int x, int y, int width, qboolean showCursor );
void Field_BigDraw( field_t *edit, int x, int y, int width, qboolean showCursor );
void Field_Paste( field_t *edit );
void Field_KeyDownEvent( field_t *edit, int key );
void Field_CharEvent( field_t *edit, int ch );
void Console_Key (int key);
void Message_Key( int key );
qboolean Key_GetOverstrikeMode( void );
void Key_SetOverstrikeMode( qboolean state );
qboolean Key_IsDown( int keynum );
int Key_StringToKeynum( char *str );
char *Key_KeynumToString( int keynum );
void Key_SetBinding( int keynum, const char *binding );
char *Key_GetBinding( int keynum );
int Key_GetKey(const char *binding);
void Key_Unbind_f (void);
void Key_Unbindall_f (void);
void Key_Bind_f (void);
void Key_WriteBindings( fileHandle_t f );
void Key_Bindlist_f( void );
void CL_InitKeyCommands( void );
void CL_AddKeyUpCommands( int key, char *kb );
void CL_KeyEvent (int key, qboolean down, unsigned time);
void CL_CharEvent( int key );
void Key_ClearStates (void);
//AHSRC:client/cl_main.c
void CL_CheckForResend( void );
void CL_ShowIP_f(void);
void CL_ServerStatus_f(void);
void CL_ServerStatusResponse( netadr_t from, msg_t *msg );
void CL_CDDialog( void );
void CL_AddReliableCommand( const char *cmd );
void CL_ChangeReliableCommand( void );
void CL_WriteDemoMessage ( msg_t *msg, int headerBytes );
void CL_StopRecord_f( void );
void CL_DemoFilename( int number, char *fileName );
void CL_Record_f( void );
void CL_DemoCompleted( void );
void CL_ReadDemoMessage( void );
void CL_PlayDemo_f( void );
void CL_StartDemoLoop( void );
void CL_NextDemo( void );
void CL_ShutdownAll(void);
void CL_FlushMemory( void );
void CL_MapLoading( void );
void CL_ClearState (void);
void CL_Disconnect( qboolean showMainMenu );
void CL_ForwardCommandToServer( const char *string );
void CL_RequestMotd( void );
void CL_RequestAuthorization( void );
void CL_ForwardToServer_f( void );
void CL_Setenv_f( void );
void CL_Disconnect_f( void );
void CL_Reconnect_f( void );
void CL_Connect_f( void );
void CL_Rcon_f( void );
void CL_SendPureChecksums( void );
void CL_ResetPureClientAtServer( void );
void CL_Vid_Restart_f( void );
void CL_Snd_Restart_f( void );
void CL_OpenedPK3List_f( void );
void CL_ReferencedPK3List_f( void );
void CL_Configstrings_f( void );
void CL_Clientinfo_f( void );
void CL_DownloadsComplete( void );
void CL_BeginDownload( const char *localName, const char *remoteName );
void CL_NextDownload(void);
void CL_InitDownloads(void);
void CL_CheckForResend( void );
void CL_DisconnectPacket( netadr_t from );
void CL_MotdPacket( netadr_t from );
void CL_InitServerInfo( serverInfo_t *server, serverAddress_t *address );
void CL_ServersResponsePacket( netadr_t from, msg_t *msg );
void CL_ConnectionlessPacket( netadr_t from, msg_t *msg );
void CL_PacketEvent( netadr_t from, msg_t *msg );
void CL_CheckTimeout( void );
void CL_CheckUserinfo( void );
void CL_Frame ( int msec );
void CL_ShutdownRef( void );
void CL_InitRenderer( void );
void CL_StartHunkUsers( void );
void *CL_RefMalloc( int size );
int CL_ScaledMilliseconds(void);
void CL_InitRef( void );
void CL_SetModel_f( void );
void CL_DoAllocs( void );
void CL_Init( void );
void CL_Shutdown( void );
void CL_ServerInfoPacket( netadr_t from, msg_t *msg );
serverStatus_t *CL_GetServerStatus( netadr_t from );
int CL_ServerStatus( char *serverAddress, char *serverStatusString, int maxLen );
void CL_ServerStatusResponse( netadr_t from, msg_t *msg );
void CL_LocalServers_f( void );
void CL_GlobalServers_f( void );
void CL_GetPing( int n, char *buf, int buflen, int *pingtime );
void CL_UpdateServerInfo( int n );
void CL_GetPingInfo( int n, char *buf, int buflen );
void CL_ClearPing( int n );
int CL_GetPingQueueCount( void );
void CL_Ping_f( void );
qboolean CL_UpdateVisiblePings_f(int source);
void CL_ServerStatus_f(void);
void CL_ShowIP_f(void);
qboolean CL_CDKeyValidate( const char *key, const char *checksum );
//AHSRC:client/cl_net_chan.c
void CL_Netchan_TransmitNextFragment( netchan_t *chan );
void CL_Netchan_Transmit( netchan_t *chan, msg_t* msg );
qboolean CL_Netchan_Process( netchan_t *chan, msg_t *msg );
//AHSRC:client/cl_parse.c
void SHOWNET( msg_t *msg, char *s);
void CL_DeltaEntity (msg_t *msg, clSnapshot_t *frame, int newnum, entityState_t *old, qboolean unchanged);
void CL_ParsePacketEntities( msg_t *msg, clSnapshot_t *oldframe, clSnapshot_t *newframe);
void CL_ParseSnapshot( msg_t *msg );
void CL_SystemInfoChanged( void );
void CL_ParseGamestate( msg_t *msg );
void CL_ParseDownload ( msg_t *msg );
void CL_ParseCommandString( msg_t *msg );
void CL_ParseServerMessage( msg_t *msg );
//AHSRC:client/cl_scrn.c
void SCR_DrawNamedPic( float x, float y, float width, float height, const char *picname );
void SCR_AdjustFrom640( float *x, float *y, float *w, float *h );
void SCR_FillRect( float x, float y, float width, float height, const float *color );
void SCR_DrawPic( float x, float y, float width, float height, qhandle_t hShader );
void SCR_DrawSmallChar( int x, int y, int ch );
void SCR_DrawStringExt( int x, int y, float size, const char *string, float *setColor, qboolean forceColor );
void SCR_DrawBigString( int x, int y, const char *s, float alpha );
void SCR_DrawBigStringColor( int x, int y, const char *s, vec4_t color );
void SCR_DrawSmallStringExt( int x, int y, const char *string, float *setColor, qboolean forceColor );
int	SCR_GetBigStringWidth( const char *str );
void SCR_DrawDemoRecording( void );
void SCR_DebugGraph (float value, int color);
void SCR_DrawDebugGraph (void);
void SCR_Init( void );
void SCR_DrawScreenField( stereoFrame_t stereoFrame );
void SCR_UpdateScreen( void );
//AHSRC:client/cl_ui.c
void LAN_LoadCachedServers( );
void LAN_SaveServersToCache( );
qboolean LAN_UpdateVisiblePings(int source );
int LAN_GetServerStatus( char *serverAddress, char *serverStatus, int maxLen );
int Key_GetCatcher( void );
void Key_SetCatcher( int catcher );
void *VM_ArgPtr( nlint intValue );
nlint CL_UISystemCalls( nlint *args );
void CL_ShutdownUI( void );
void CL_InitUI( void );
qboolean UI_usesUniqueCDKey();
qboolean UI_GameCommand( void );
//AHSRC:client/snd_adpcm.c
void S_AdpcmEncode( short indata[], char outdata[], int len, struct adpcm_state *state );
int S_AdpcmMemoryNeeded( const wavinfo_t *info );
void S_AdpcmGetSamples(sndBuffer *chunk, short *to);
void S_AdpcmEncodeSound( sfx_t *sfx, short *samples );
//AHSRC:client/snd_dma.c
void S_Play_f(void);
void S_SoundList_f(void);
void S_Music_f(void);
void S_Update_();
void S_StopAllSounds(void);
void S_UpdateBackgroundTrack( void );
void S_SoundInfo_f(void);
void S_Init( void );
void S_ChannelFree(channel_t *v);
void S_ChannelSetup();
void S_Shutdown( void );
void S_DefaultSound( sfx_t *sfx );
void S_DisableSounds( void );
void S_BeginRegistration( void );
sfxHandle_t	S_RegisterSound( const char *name, qboolean compressed );
void S_memoryLoad(sfx_t	*sfx);
void S_SpatializeOrigin (vec3_t origin, int master_vol, int *left_vol, int *right_vol);
void S_StartSound(vec3_t origin, int entityNum, int entchannel, sfxHandle_t sfxHandle );
void S_StartLocalSound( sfxHandle_t sfxHandle, int channelNum );
void S_ClearSoundBuffer( void );
void S_StopAllSounds(void);
void S_StopLoopingSound(int entityNum);
void S_ClearLoopingSounds( qboolean killall );
void S_AddLoopingSound( int entityNum, const vec3_t origin, const vec3_t velocity, sfxHandle_t sfxHandle );
void S_AddRealLoopingSound( int entityNum, const vec3_t origin, const vec3_t velocity, sfxHandle_t sfxHandle );
void S_AddLoopSounds (void);
void S_ByteSwapRawSamples( int samples, int width, int s_channels, const byte *data );
portable_samplepair_t *S_GetRawSamplePointer();
void S_RawSamples( int samples, int rate, int width, int s_channels, const byte *data, float volume );
void S_UpdateEntityPosition( int entityNum, const vec3_t origin );
void S_Respatialize( int entityNum, const vec3_t head, vec3_t axis[3], int inwater );
qboolean S_ScanChannelStarts( void );
void S_Update( void );
void S_GetSoundtime(void);
void S_Update_(void);
void S_Play_f( void );
void S_Music_f( void );
void S_SoundList_f( void );
int	FGetLittleLong( fileHandle_t f );
int	FGetLittleShort( fileHandle_t f );
int S_FindWavChunk( fileHandle_t f, char *chunk );
void S_StopBackgroundTrack( void );
void S_StartBackgroundTrack( const char *intro, const char *loop );
void S_UpdateBackgroundTrack( void );
void S_FreeOldestSound();
//AHSRC:client/snd_mem.c
void	SND_free(sndBuffer *v);
void SND_setup();
qboolean S_LoadSound( sfx_t *sfx );
void S_DisplayFreeMemory();
//AHSRC:client/snd_mix.c
void S_WriteLinearBlastStereo16 (void);
void S_WriteLinearBlastStereo16 (void);
void S_TransferStereo16 (unsigned long *pbuf, int endtime);
void S_TransferPaintBuffer(int endtime);
void S_PaintChannelFromWavelet( channel_t *ch, sfx_t *sc, int count, int sampleOffset, int bufferOffset );
void S_PaintChannelFromADPCM( channel_t *ch, sfx_t *sc, int count, int sampleOffset, int bufferOffset );
void S_PaintChannelFromMuLaw( channel_t *ch, sfx_t *sc, int count, int sampleOffset, int bufferOffset );
void S_PaintChannels( int endtime );
//AHSRC:client/snd_wavelet.c
long myftol( float f );
void daub4(float b[], unsigned long n, int isign);
void wt1(float a[], unsigned long n, int isign);
byte MuLawEncode(short s);
short MuLawDecode(byte uLaw);
void NXPutc(NXStream *stream, char out);
void encodeWavelet( sfx_t *sfx, short *packets);
void decodeWavelet(sndBuffer *chunk, short *to);
void encodeMuLaw( sfx_t *sfx, short *packets);
void decodeMuLaw(sndBuffer *chunk, short *to);
//AHSRC:server/sv_bot.c
int SV_BotAllocateClient(void);
void SV_BotFreeClient( int clientNum );
void BotDrawDebugPolygons(void (*drawPoly)(int color, int numPoints, float *points), int value);
void BotImport_Trace(bsp_trace_t *bsptrace, vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, int passent, int contentmask);
void BotImport_EntityTrace(bsp_trace_t *bsptrace, vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, int entnum, int contentmask);
int BotImport_PointContents(vec3_t point);
int BotImport_inPVS(vec3_t p1, vec3_t p2);
char *BotImport_BSPEntityData(void);
void BotImport_BSPModelMinsMaxsOrigin(int modelnum, vec3_t angles, vec3_t outmins, vec3_t outmaxs, vec3_t origin);
void *BotImport_GetMemory(int size);
void BotImport_FreeMemory(void *ptr);
void *BotImport_HunkAlloc( int size );
int BotImport_DebugPolygonCreate(int color, int numPoints, vec3_t *points);
void BotImport_DebugPolygonShow(int id, int color, int numPoints, vec3_t *points);
void BotImport_DebugPolygonDelete(int id);
int BotImport_DebugLineCreate(void);
void BotImport_DebugLineDelete(int line);
void BotImport_DebugLineShow(int line, vec3_t start, vec3_t end, int color);
void BotClientCommand( int client, char *command );
void SV_BotFrame( int time );
int SV_BotLibSetup( void );
int SV_BotLibShutdown( void );
void SV_BotInitCvars(void);
void SV_BotInitBotLib(void);
int SV_BotGetConsoleMessage( int client, char *buf, int size );
int EntityInPVS( int client, int entityNum );
int SV_BotGetSnapshotEntity( int client, int sequence );
//AHSRC:server/sv_ccmds.c
void SV_Heartbeat_f( void );
void SV_AddOperatorCommands( void );
void SV_RemoveOperatorCommands( void );
//AHSRC:server/sv_client.c
void SV_GetChallenge( netadr_t from );
void SV_AuthorizeIpPacket( netadr_t from );
void SV_DirectConnect( netadr_t from );
void SV_DropClient( client_t *drop, const char *reason );
void SV_SendClientGameState( client_t *client );
void SV_ClientEnterWorld( client_t *client, usercmd_t *cmd );
void SV_StopDownload_f( client_t *cl );
void SV_DoneDownload_f( client_t *cl );
void SV_NextDownload_f( client_t *cl );
void SV_BeginDownload_f( client_t *cl );
void SV_WriteDownloadToClient( client_t *cl , msg_t *msg );
void SV_UserinfoChanged( client_t *cl );
void SV_ExecuteClientCommand( client_t *cl, const char *s, qboolean clientOK );
void SV_ClientThink (client_t *cl, usercmd_t *cmd);
void SV_ExecuteClientMessage( client_t *cl, msg_t *msg );
//AHSRC:server/sv_game.c
void SV_GameError( const char *string );
void SV_GamePrint( const char *string );
int	SV_NumForGentity( sharedEntity_t *ent );
sharedEntity_t *SV_GentityNum( int num );
playerState_t *SV_GameClientNum( int num );
svEntity_t	*SV_SvEntityForGentity( sharedEntity_t *gEnt );
sharedEntity_t *SV_GEntityForSvEntity( svEntity_t *svEnt );
void SV_GameSendServerCommand( int clientNum, const char *text );
void SV_GameDropClient( int clientNum, const char *reason );
void SV_SetBrushModel( sharedEntity_t *ent, const char *name );
qboolean SV_inPVS (const vec3_t p1, const vec3_t p2);
qboolean SV_inPVSIgnorePortals( const vec3_t p1, const vec3_t p2);
void SV_AdjustAreaPortalState( sharedEntity_t *ent, qboolean open );
qboolean	SV_EntityContact( vec3_t mins, vec3_t maxs, const sharedEntity_t *gEnt, int capsule );
void SV_GetServerinfo( char *buffer, int bufferSize );
void SV_LocateGameData( sharedEntity_t *gEnts, int numGEntities, int sizeofGEntity_t,playerState_t *clients, int sizeofGameClient );
void SV_GetUsercmd( int clientNum, usercmd_t *cmd );
nlint SV_GameSystemCalls( nlint *args );
void SV_ShutdownGameProgs( void );
void SV_RestartGameProgs( void );
void SV_InitGameProgs( void );
qboolean SV_GameCommand( void );
//AHSRC:server/sv_init.c
void SV_SetConfigstring (int index, const char *val);
void SV_GetConfigstring( int index, char *buffer, int bufferSize );
void SV_SetUserinfo( int index, const char *val );
void SV_GetUserinfo( int index, char *buffer, int bufferSize );
void SV_CreateBaseline( void );
void SV_BoundMaxClients( int minimum );
void SV_Startup( void );
void SV_ChangeMaxClients( void );
void SV_ClearServer(void);
void SV_TouchCGame(void);
void SV_SpawnServer( char *server, qboolean killBots );
void SV_BotInitBotLib(void);
void SV_Init (void);
void SV_FinalMessage( char *message );
void SV_Shutdown( char *finalmsg );
//AHSRC:server/sv_main.c
char	*SV_ExpandNewlines( char *in );
int SV_ReplacePendingServerCommands( client_t *client, const char *cmd );
void SV_AddServerCommand( client_t *client, const char *cmd );
void SV_MasterHeartbeat( void );
void SV_MasterShutdown( void );
void SVC_Status( netadr_t from );
void SVC_Info( netadr_t from );
void SV_FlushRedirect( char *outputbuf );
void SVC_RemoteCommand( netadr_t from, msg_t *msg );
void SV_ConnectionlessPacket( netadr_t from, msg_t *msg );
void SV_PacketEvent( netadr_t from, msg_t *msg );
void SV_CalcPings( void );
void SV_CheckTimeouts( void );
qboolean SV_CheckPaused( void );
void SV_Frame( int msec );
//AHSRC:server/sv_net_chan.c
void SV_Netchan_TransmitNextFragment( client_t *client );
void SV_Netchan_Transmit( client_t *client, msg_t *msg);
qboolean SV_Netchan_Process( client_t *client, msg_t *msg );
//AHSRC:server/sv_snapshot.c
void SV_UpdateServerCommandsToClient( client_t *client, msg_t *msg );
void SV_SendMessageToClient( msg_t *msg, client_t *client );
void SV_SendClientSnapshot( client_t *client );
void SV_SendClientMessages( void );
//AHSRC:server/sv_world.c
clipHandle_t SV_ClipHandleForEntity( const sharedEntity_t *ent );
void SV_SectorList_f( void );
worldSector_t *SV_CreateworldSector( int depth, vec3_t mins, vec3_t maxs );
void SV_ClearWorld( void );
void SV_UnlinkEntity( sharedEntity_t *gEnt );
void SV_LinkEntity( sharedEntity_t *gEnt );
void SV_AreaEntities_r( worldSector_t *node, areaParms_t *ap );
int SV_AreaEntities( const vec3_t mins, const vec3_t maxs, int *entityList, int maxcount );
void SV_ClipToEntity( trace_t *trace, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int entityNum, int contentmask, int capsule );
void SV_ClipMoveToEntities( moveclip_t *clip );
void SV_Trace( trace_t *results, const vec3_t start,//	vec3_t mins, vec3_t maxs, float *mins, float *maxs, const vec3_t end, int passEntityNum, int contentmask, int capsule );
int SV_PointContents( const vec3_t p, int passEntityNum );
//AHSRC:botlib/be_aas_bspq3.c
void PrintContents(int contents);
bsp_trace_t AAS_Trace(vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, int passent, int contentmask);
int AAS_PointContents(vec3_t point);
qboolean AAS_EntityCollision(int entnum,vec3_t start, vec3_t boxmins, vec3_t boxmaxs, vec3_t end, int contentmask, bsp_trace_t *trace);
qboolean AAS_inPVS(vec3_t p1, vec3_t p2);
qboolean AAS_inPHS(vec3_t p1, vec3_t p2);
void AAS_BSPModelMinsMaxsOrigin(int modelnum, vec3_t angles, vec3_t mins, vec3_t maxs, vec3_t origin);
void AAS_UnlinkFromBSPLeaves(bsp_link_t *leaves);
bsp_link_t *AAS_BSPLinkEntity(vec3_t absmins, vec3_t absmaxs, int entnum, int modelnum);
int AAS_BoxEntities(vec3_t absmins, vec3_t absmaxs, int *list, int maxcount);
int AAS_NextBSPEntity(int ent);
int AAS_BSPEntityInRange(int ent);
int AAS_ValueForBSPEpairKey(int ent, char *key, char *value, int size);
int AAS_VectorForBSPEpairKey(int ent, char *key, vec3_t v);
int AAS_FloatForBSPEpairKey(int ent, char *key, float *value);
int AAS_IntForBSPEpairKey(int ent, char *key, int *value);
void AAS_FreeBSPEntities(void);
void AAS_ParseBSPEntities(void);
int AAS_BSPTraceLight(vec3_t start, vec3_t end, vec3_t endpos, int *red, int *green, int *blue);
void AAS_DumpBSPData(void);
int AAS_LoadBSPFile(void);
//AHSRC:botlib/be_aas_cluster.c
void AAS_RemoveClusterAreas(void);
void AAS_ClearCluster(int clusternum);
void AAS_RemovePortalsClusterReference(int clusternum);
int AAS_UpdatePortal(int areanum, int clusternum);
int AAS_FloodClusterAreas_r(int areanum, int clusternum);
int AAS_FloodClusterAreasUsingReachabilities(int clusternum);
void AAS_NumberClusterPortals(int clusternum);
void AAS_NumberClusterAreas(int clusternum);
int AAS_FindClusters(void);
void AAS_CreatePortals(void);
int AAS_MapContainsTeleporters(void);
int AAS_NonConvexFaces(aas_face_t *face1, aas_face_t *face2, int side1, int side2);
qboolean AAS_CanMergeAreas(int *areanums, int numareas);
qboolean AAS_NonConvexEdges(aas_edge_t *edge1, aas_edge_t *edge2, int side1, int side2, int planenum);
qboolean AAS_CanMergeFaces(int *facenums, int numfaces, int planenum);
void AAS_ConnectedAreas_r(int *areanums, int numareas, int *connectedareas, int curarea);
qboolean AAS_ConnectedAreas(int *areanums, int numareas);
int AAS_GetAdjacentAreasWithLessPresenceTypes_r(int *areanums, int numareas, int curareanum);
int AAS_CheckAreaForPossiblePortals(int areanum);
void AAS_FindPossiblePortals(void);
void AAS_RemoveAllPortals(void);
void AAS_FloodCluster_r(int areanum, int clusternum);
void AAS_RemoveTeleporterPortals(void);
void AAS_FloodClusterReachabilities(int clusternum);
void AAS_RemoveNotClusterClosingPortals(void);
void AAS_RemoveNotClusterClosingPortals(void);
void AAS_AddTeleporterPortals(void);
void AAS_AddTeleporterPortals(void);
int AAS_TestPortals(void);
void AAS_CountForcedClusterPortals(void);
void AAS_CreateViewPortals(void);
void AAS_SetViewPortalsAsClusterPortals(void);
void AAS_InitClustering(void);
//AHSRC:botlib/be_aas_debug.c
void AAS_ClearShownPolygons(void);
void AAS_ShowPolygon(int color, int numpoints, vec3_t *points);
void AAS_ClearShownDebugLines(void);
void AAS_DebugLine(vec3_t start, vec3_t end, int color);
void AAS_PermanentLine(vec3_t start, vec3_t end, int color);
void AAS_DrawPermanentCross(vec3_t origin, float size, int color);
void AAS_DrawPlaneCross(vec3_t point, vec3_t normal, float dist, int type, int color);
void AAS_ShowBoundingBox(vec3_t origin, vec3_t mins, vec3_t maxs);
void AAS_ShowFace(int facenum);
void AAS_ShowFacePolygon(int facenum, int color, int flip);
void AAS_ShowArea(int areanum, int groundfacesonly);
void AAS_ShowAreaPolygons(int areanum, int color, int groundfacesonly);
void AAS_DrawCross(vec3_t origin, float size, int color);
void AAS_PrintTravelType(int traveltype);
void AAS_DrawArrow(vec3_t start, vec3_t end, int linecolor, int arrowcolor);
void AAS_ShowReachability(aas_reachability_t *reach);
void AAS_ShowReachableAreas(int areanum);
void AAS_FloodAreas_r(int areanum, int cluster, int *done);
void AAS_FloodAreas(vec3_t origin);
//AHSRC:botlib/be_aas_entity.c
int AAS_UpdateEntity(int entnum, bot_entitystate_t *state);
void AAS_EntityInfo(int entnum, aas_entityinfo_t *info);
void AAS_EntityOrigin(int entnum, vec3_t origin);
int AAS_EntityModelindex(int entnum);
int AAS_EntityType(int entnum);
int AAS_EntityModelNum(int entnum);
int AAS_OriginOfMoverWithModelNum(int modelnum, vec3_t origin);
void AAS_EntitySize(int entnum, vec3_t mins, vec3_t maxs);
void AAS_EntityBSPData(int entnum, bsp_entdata_t *entdata);
void AAS_ResetEntityLinks(void);
void AAS_InvalidateEntities(void);
void AAS_UnlinkInvalidEntities(void);
int AAS_NearestEntity(vec3_t origin, int modelindex);
int AAS_BestReachableEntityArea(int entnum);
int AAS_NextEntity(int entnum);
//AHSRC:botlib/be_aas_file.c
void AAS_SwapAASData(void);
void AAS_DumpAASData(void);
void AAS_FileInfo(void);
char *AAS_LoadAASLump(fileHandle_t fp, int offset, int length, int *lastoffset, int size);
void AAS_DData(unsigned char *data, int size);
int AAS_LoadAASFile(char *filename);
int AAS_WriteAASLump(fileHandle_t fp, aas_header_t *h, int lumpnum, void *data, int length);
qboolean AAS_WriteAASFile(char *filename);
//AHSRC:botlib/be_aas_main.c
char *AAS_StringFromIndex(char *indexname, char *stringindex[], int numindexes, int index);
int AAS_IndexFromString(char *indexname, char *stringindex[], int numindexes, char *string);
char *AAS_ModelFromIndex(int index);
int AAS_IndexFromModel(char *modelname);
void AAS_UpdateStringIndexes(int numconfigstrings, char *configstrings[]);
int AAS_Loaded(void);
int AAS_Initialized(void);
void AAS_SetInitialized(void);
void AAS_ContinueInit(float time);
int AAS_StartFrame(float time);
float AAS_Time(void);
void AAS_ProjectPointOntoVector( vec3_t point, vec3_t vStart, vec3_t vEnd, vec3_t vProj );
int AAS_LoadFiles(const char *mapname);
int AAS_LoadMap(const char *mapname);
int AAS_Setup(void);
void AAS_Shutdown(void);
//AHSRC:botlib/be_aas_move.c
int AAS_DropToFloor(vec3_t origin, vec3_t mins, vec3_t maxs);
void AAS_InitSettings(void);
int AAS_AgainstLadder(vec3_t origin);
int AAS_OnGround(vec3_t origin, int presencetype, int passent);
int AAS_Swimming(vec3_t origin);
void AAS_SetMovedir(vec3_t angles, vec3_t movedir);
void AAS_JumpReachRunStart(aas_reachability_t *reach, vec3_t runstart);
float AAS_WeaponJumpZVelocity(vec3_t origin, float radiusdamage);
float AAS_RocketJumpZVelocity(vec3_t origin);
float AAS_BFGJumpZVelocity(vec3_t origin);
void AAS_Accelerate(vec3_t velocity, float frametime, vec3_t wishdir, float wishspeed, float accel);
void AAS_AirControl(vec3_t start, vec3_t end, vec3_t velocity, vec3_t cmdmove);
void AAS_ApplyFriction(vec3_t vel, float friction, float stopspeed,float frametime);
int AAS_ClipToBBox(aas_trace_t *trace, vec3_t start, vec3_t end, int presencetype, vec3_t mins, vec3_t maxs);
int AAS_ClientMovementPrediction(struct aas_clientmove_s *move,int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum, vec3_t mins, vec3_t maxs, int visualize);
int AAS_PredictClientMovement(struct aas_clientmove_s *move,int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum, int visualize);
int AAS_ClientMovementHitBBox(struct aas_clientmove_s *move,int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, vec3_t mins, vec3_t maxs, int visualize);
void AAS_TestMovementPrediction(int entnum, vec3_t origin, vec3_t dir);
int AAS_HorizontalVelocityForJump(float zvel, vec3_t start, vec3_t end, float *velocity);
//AHSRC:botlib/be_aas_optimize.c
int AAS_KeepEdge(aas_edge_t *edge);
int AAS_OptimizeEdge(optimized_t *optimized, int edgenum);
int AAS_KeepFace(aas_face_t *face);
int AAS_OptimizeFace(optimized_t *optimized, int facenum);
void AAS_OptimizeArea(optimized_t *optimized, int areanum);
void AAS_OptimizeAlloc(optimized_t *optimized);
void AAS_OptimizeStore(optimized_t *optimized);
void AAS_Optimize(void);
//AHSRC:botlib/be_aas_reach.c
float AAS_FaceArea(aas_face_t *face);
float AAS_AreaVolume(int areanum);
int AAS_BestReachableLinkArea(aas_link_t *areas);
int AAS_GetJumpPadInfo(int ent, vec3_t areastart, vec3_t absmins, vec3_t absmaxs, vec3_t velocity);
int AAS_BestReachableFromJumpPadArea(vec3_t origin, vec3_t mins, vec3_t maxs);
int AAS_BestReachableArea(vec3_t origin, vec3_t mins, vec3_t maxs, vec3_t goalorigin);
void AAS_SetupReachabilityHeap(void);
void AAS_ShutDownReachabilityHeap(void);
aas_lreachability_t *AAS_AllocReachability(void);
void AAS_FreeReachability(aas_lreachability_t *lreach);
int AAS_AreaReachability(int areanum);
float AAS_AreaGroundFaceArea(int areanum);
void AAS_FaceCenter(int facenum, vec3_t center);
int AAS_FallDamageDistance(void);
float AAS_FallDelta(float distance);
float AAS_MaxJumpHeight(float phys_jumpvel);
float AAS_MaxJumpDistance(float phys_jumpvel);
int AAS_AreaCrouch(int areanum);
int AAS_AreaSwim(int areanum);
int AAS_AreaLiquid(int areanum);
int AAS_AreaLava(int areanum);
int AAS_AreaSlime(int areanum);
int AAS_AreaGrounded(int areanum);
int AAS_AreaLadder(int areanum);
int AAS_AreaJumpPad(int areanum);
int AAS_AreaTeleporter(int areanum);
int AAS_AreaClusterPortal(int areanum);
int AAS_AreaDoNotEnter(int areanum);
qboolean AAS_ReachabilityExists(int area1num, int area2num);
int AAS_NearbySolidOrGap(vec3_t start, vec3_t end);
int AAS_Reachability_Swim(int area1num, int area2num);
int AAS_Reachability_EqualFloorHeight(int area1num, int area2num);
int AAS_Reachability_Step_Barrier_WaterJump_WalkOffLedge(int area1num, int area2num);
float VectorDistance(vec3_t v1, vec3_t v2);
int VectorBetweenVectors(vec3_t v, vec3_t v1, vec3_t v2);
void VectorMiddle(vec3_t v1, vec3_t v2, vec3_t middle);
float AAS_ClosestEdgePoints(vec3_t v1, vec3_t v2, vec3_t v3, vec3_t v4,aas_plane_t *plane1, aas_plane_t *plane2, vec3_t beststart, vec3_t bestend, float bestdist);
float AAS_ClosestEdgePoints(vec3_t v1, vec3_t v2, vec3_t v3, vec3_t v4,aas_plane_t *plane1, aas_plane_t *plane2, vec3_t beststart1, vec3_t bestend1, vec3_t beststart2, vec3_t bestend2, float bestdist);
int AAS_Reachability_Jump(int area1num, int area2num);
int AAS_Reachability_Ladder(int area1num, int area2num);
int AAS_TravelFlagsForTeam(int ent);
void AAS_Reachability_Teleport(void);
void AAS_Reachability_Elevator(void);
aas_lreachability_t *AAS_FindFaceReachabilities(vec3_t *facepoints, int numpoints, aas_plane_t *plane, int towardsface);
void AAS_Reachability_FuncBobbing(void);
void AAS_Reachability_JumpPad(void);
int AAS_Reachability_Grapple(int area1num, int area2num);
void AAS_SetWeaponJumpAreaFlags(void);
int AAS_Reachability_WeaponJump(int area1num, int area2num);
void AAS_Reachability_WalkOffLedge(int areanum);
void AAS_StoreReachability(void);
int AAS_ContinueInitReachability(float time);
void AAS_InitReachability(void);
//AHSRC:botlib/be_aas_route.c
void AAS_RoutingInfo(void);
void AAS_InitTravelFlagFromType(void);
int AAS_TravelFlagForType(int traveltype);
void AAS_UnlinkCache(aas_routingcache_t *cache);
void AAS_LinkCache(aas_routingcache_t *cache);
void AAS_FreeRoutingCache(aas_routingcache_t *cache);
void AAS_RemoveRoutingCacheInCluster( int clusternum );
void AAS_RemoveRoutingCacheUsingArea( int areanum );
int AAS_EnableRoutingArea(int areanum, int enable);
int AAS_GetAreaContentsTravelFlags(int areanum);
int AAS_AreaContentsTravelFlags(int areanum);
void AAS_InitAreaContentsTravelFlags(void);
void AAS_CreateReversedReachability(void);
void AAS_CalculateAreaTravelTimes(void);
int AAS_PortalMaxTravelTime(int portalnum);
void AAS_InitPortalMaxTravelTimes(void);
int AAS_FreeOldestCache(void);
int AAS_FreeOldestCache(void);
aas_routingcache_t *AAS_AllocRoutingCache(int numtraveltimes);
void AAS_FreeAllClusterAreaCache(void);
void AAS_InitClusterAreaCache(void);
void AAS_FreeAllPortalCache(void);
void AAS_InitPortalCache(void);
void AAS_InitRoutingUpdate(void);
void AAS_CreateAllRoutingCache(void);
void AAS_WriteRouteCache(void);
aas_routingcache_t *AAS_ReadCache(fileHandle_t fp);
int AAS_ReadRouteCache(void);
void AAS_InitReachabilityAreas(void);
void AAS_InitRouting(void);
void AAS_FreeRoutingCaches(void);
void AAS_UpdateAreaRoutingCache(aas_routingcache_t *areacache);
aas_routingcache_t *AAS_GetAreaRoutingCache(int clusternum, int areanum, int travelflags);
void AAS_UpdatePortalRoutingCache(aas_routingcache_t *portalcache);
aas_routingcache_t *AAS_GetPortalRoutingCache(int clusternum, int areanum, int travelflags);
int AAS_AreaRouteToGoalArea(int areanum, vec3_t origin, int goalareanum, int travelflags, int *traveltime, int *reachnum);
int AAS_AreaTravelTimeToGoalArea(int areanum, vec3_t origin, int goalareanum, int travelflags);
int AAS_AreaReachabilityToGoalArea(int areanum, vec3_t origin, int goalareanum, int travelflags);
int AAS_PredictRoute(struct aas_predictroute_s *route, int areanum, vec3_t origin,int goalareanum, int travelflags, int maxareas, int maxtime, int stopevent, int stopcontents, int stoptfl, int stopareanum);
int AAS_BridgeWalkable(int areanum);
void AAS_ReachabilityFromNum(int num, struct aas_reachability_s *reach);
int AAS_NextAreaReachability(int areanum, int reachnum);
int AAS_NextModelReachability(int num, int modelnum);
int AAS_RandomGoalArea(int areanum, int travelflags, int *goalareanum, vec3_t goalorigin);
int AAS_AreaVisible(int srcarea, int destarea);
float DistancePointToLine(vec3_t v1, vec3_t v2, vec3_t point);
int AAS_NearestHideArea(int srcnum, vec3_t origin, int areanum, int enemynum, vec3_t enemyorigin, int enemyareanum, int travelflags);
//AHSRC:botlib/be_aas_routealt.c
void AAS_AltRoutingFloodCluster_r(int areanum);
int AAS_AlternativeRouteGoals(vec3_t start, int startareanum, vec3_t goal, int goalareanum, int travelflags,aas_altroutegoal_t *altroutegoals, int maxaltroutegoals, int type);
void AAS_InitAlternativeRouting(void);
void AAS_ShutdownAlternativeRouting(void);
//AHSRC:botlib/be_aas_sample.c
void AAS_PresenceTypeBoundingBox(int presencetype, vec3_t mins, vec3_t maxs);
void AAS_InitAASLinkHeap(void);
void AAS_FreeAASLinkHeap(void);
aas_link_t *AAS_AllocAASLink(void);
void AAS_DeAllocAASLink(aas_link_t *link);
void AAS_InitAASLinkedEntities(void);
void AAS_FreeAASLinkedEntities(void);
int AAS_PointAreaNum(vec3_t point);
int AAS_PointReachabilityAreaIndex( vec3_t origin );
int AAS_AreaCluster(int areanum);
int AAS_AreaPresenceType(int areanum);
int AAS_PointPresenceType(vec3_t point);
vec_t AAS_BoxOriginDistanceFromPlane(vec3_t normal, vec3_t mins, vec3_t maxs, int side);
qboolean AAS_AreaEntityCollision(int areanum, vec3_t start, vec3_t end,int presencetype, int passent, aas_trace_t *trace);
aas_trace_t AAS_TraceClientBBox(vec3_t start, vec3_t end, int presencetype,int passent);
int AAS_TraceAreas(vec3_t start, vec3_t end, int *areas, vec3_t *points, int maxareas);
qboolean AAS_InsideFace(aas_face_t *face, vec3_t pnormal, vec3_t point, float epsilon);
qboolean AAS_PointInsideFace(int facenum, vec3_t point, float epsilon);
aas_face_t *AAS_AreaGroundFace(int areanum, vec3_t point);
void AAS_FacePlane(int facenum, vec3_t normal, float *dist);
aas_face_t *AAS_TraceEndFace(aas_trace_t *trace);
int AAS_BoxOnPlaneSide2(vec3_t absmins, vec3_t absmaxs, aas_plane_t *p);
void AAS_UnlinkFromAreas(aas_link_t *areas);
aas_link_t *AAS_AASLinkEntity(vec3_t absmins, vec3_t absmaxs, int entnum);
aas_link_t *AAS_LinkEntityClientBBox(vec3_t absmins, vec3_t absmaxs, int entnum, int presencetype);
int AAS_BBoxAreas(vec3_t absmins, vec3_t absmaxs, int *areas, int maxareas);
int AAS_AreaInfo( int areanum, aas_areainfo_t *info );
aas_plane_t *AAS_PlaneFromNum(int planenum);
//AHSRC:botlib/be_ai_char.c
bot_character_t *BotCharacterFromHandle(int handle);
void BotDumpCharacter(bot_character_t *ch);
void BotFreeCharacterStrings(bot_character_t *ch);
void BotFreeCharacter2(int handle);
void BotFreeCharacter(int handle);
void BotDefaultCharacteristics(bot_character_t *ch, bot_character_t *defaultch);
bot_character_t *BotLoadCharacterFromFile(char *charfile, int skill);
int BotFindCachedCharacter(char *charfile, float skill);
int BotLoadCachedCharacter(char *charfile, float skill, int reload);
int BotLoadCharacterSkill(char *charfile, float skill);
int BotInterpolateCharacters(int handle1, int handle2, float desiredskill);
int BotLoadCharacter(char *charfile, float skill);
int CheckCharacteristicIndex(int character, int index);
float Characteristic_Float(int character, int index);
float Characteristic_BFloat(int character, int index, float min, float max);
int Characteristic_Integer(int character, int index);
int Characteristic_BInteger(int character, int index, int min, int max);
void Characteristic_String(int character, int index, char *buf, int size);
void BotShutdownCharacters(void);
//AHSRC:botlib/be_ai_chat.c
bot_chatstate_t *BotChatStateFromHandle(int handle);
void InitConsoleMessageHeap(void);
bot_consolemessage_t *AllocConsoleMessage(void);
void FreeConsoleMessage(bot_consolemessage_t *message);
void BotRemoveConsoleMessage(int chatstate, int handle);
void BotQueueConsoleMessage(int chatstate, int type, char *message);
int BotNextConsoleMessage(int chatstate, bot_consolemessage_t *cm);
int BotNumConsoleMessages(int chatstate);
int IsWhiteSpace(char c);
void BotRemoveTildes(char *message);
void UnifyWhiteSpaces(char *string);
int StringContains(char *str1, char *str2, int casesensitive);
char *StringContainsWord(char *str1, char *str2, int casesensitive);
void StringReplaceWords(char *string, char *synonym, char *replacement);
void BotDumpSynonymList(bot_synonymlist_t *synlist);
bot_synonymlist_t *BotLoadSynonyms(char *filename);
void BotReplaceSynonyms(char *string, unsigned long int context);
void BotReplaceWeightedSynonyms(char *string, unsigned long int context);
void BotReplaceReplySynonyms(char *string, unsigned long int context);
int BotLoadChatMessage(source_t *source, char *chatmessagestring);
void BotDumpRandomStringList(bot_randomlist_t *randomlist);
bot_randomlist_t *BotLoadRandomStrings(char *filename);
char *RandomString(char *name);
void BotDumpMatchTemplates(bot_matchtemplate_t *matches);
void BotFreeMatchPieces(bot_matchpiece_t *matchpieces);
bot_matchpiece_t *BotLoadMatchPieces(source_t *source, char *endtoken);
void BotFreeMatchTemplates(bot_matchtemplate_t *mt);
bot_matchtemplate_t *BotLoadMatchTemplates(char *matchfile);
int StringsMatch(bot_matchpiece_t *pieces, bot_match_t *match);
int BotFindMatch(char *str, bot_match_t *match, unsigned long int context);
void BotMatchVariable(bot_match_t *match, int variable, char *buf, int size);
bot_stringlist_t *BotFindStringInList(bot_stringlist_t *list, char *string);
bot_stringlist_t *BotCheckChatMessageIntegrety(char *message, bot_stringlist_t *stringlist);
void BotCheckInitialChatIntegrety(bot_chat_t *chat);
void BotCheckReplyChatIntegrety(bot_replychat_t *replychat);
void BotDumpReplyChat(bot_replychat_t *replychat);
void BotFreeReplyChat(bot_replychat_t *replychat);
void BotCheckValidReplyChatKeySet(source_t *source, bot_replychatkey_t *keys);
bot_replychat_t *BotLoadReplyChat(char *filename);
void BotDumpInitialChat(bot_chat_t *chat);
bot_chat_t *BotLoadInitialChat(char *chatfile, char *chatname);
void BotFreeChatFile(int chatstate);
int BotLoadChatFile(int chatstate, char *chatfile, char *chatname);
int BotExpandChatMessage(char *outmessage, char *message, unsigned long mcontext,bot_match_t *match, unsigned long vcontext, int reply);
void BotConstructChatMessage(bot_chatstate_t *chatstate, char *message, unsigned long mcontext,bot_match_t *match, unsigned long vcontext, int reply);
char *BotChooseInitialChatMessage(bot_chatstate_t *cs, char *type);
int BotNumInitialChats(int chatstate, char *type);
void BotInitialChat(int chatstate, char *type, int mcontext, char *var0, char *var1, char *var2, char *var3, char *var4, char *var5, char *var6, char *var7);
void BotPrintReplyChatKeys(bot_replychat_t *replychat);
int BotReplyChat(int chatstate, char *message, int mcontext, int vcontext, char *var0, char *var1, char *var2, char *var3, char *var4, char *var5, char *var6, char *var7);
int BotChatLength(int chatstate);
void BotEnterChat(int chatstate, int clientto, int sendto);
void BotGetChatMessage(int chatstate, char *buf, int size);
void BotSetChatGender(int chatstate, int gender);
void BotSetChatName(int chatstate, char *name, int client);
void BotResetChatAI(void);
int BotAllocChatState(void);
void BotFreeChatState(int handle);
int BotSetupChatAI(void);
void BotShutdownChatAI(void);
//AHSRC:botlib/be_ai_gen.c
int GeneticSelection(int numranks, float *rankings);
int GeneticParentsAndChildSelection(int numranks, float *ranks, int *parent1, int *parent2, int *child);
//AHSRC:botlib/be_ai_goal.c
bot_goalstate_t *BotGoalStateFromHandle(int handle);
void BotInterbreedGoalFuzzyLogic(int parent1, int parent2, int child);
void BotSaveGoalFuzzyLogic(int goalstate, char *filename);
void BotMutateGoalFuzzyLogic(int goalstate, float range);
itemconfig_t *LoadItemConfig(char *filename);
int *ItemWeightIndex(weightconfig_t *iwc, itemconfig_t *ic);
void InitLevelItemHeap(void);
levelitem_t *AllocLevelItem(void);
void FreeLevelItem(levelitem_t *li);
void AddLevelItemToList(levelitem_t *li);
void RemoveLevelItemFromList(levelitem_t *li);
void BotFreeInfoEntities(void);
void BotInitInfoEntities(void);
void BotInitLevelItems(void);
void BotGoalName(int number, char *name, int size);
void BotResetAvoidGoals(int goalstate);
void BotDumpAvoidGoals(int goalstate);
void BotAddToAvoidGoals(bot_goalstate_t *gs, int number, float avoidtime);
void BotRemoveFromAvoidGoals(int goalstate, int number);
float BotAvoidGoalTime(int goalstate, int number);
void BotSetAvoidGoalTime(int goalstate, int number, float avoidtime);
int BotGetLevelItemGoal(int index, char *name, bot_goal_t *goal);
int BotGetMapLocationGoal(char *name, bot_goal_t *goal);
int BotGetNextCampSpotGoal(int num, bot_goal_t *goal);
void BotFindEntityForLevelItem(levelitem_t *li);
void BotUpdateEntityItems(void);
void BotDumpGoalStack(int goalstate);
void BotPushGoal(int goalstate, bot_goal_t *goal);
void BotPopGoal(int goalstate);
void BotEmptyGoalStack(int goalstate);
int BotGetTopGoal(int goalstate, bot_goal_t *goal);
int BotGetSecondGoal(int goalstate, bot_goal_t *goal);
int BotChooseLTGItem(int goalstate, vec3_t origin, int *inventory, int travelflags);
int BotChooseNBGItem(int goalstate, vec3_t origin, int *inventory, int travelflags,bot_goal_t *ltg, float maxtime);
int BotTouchingGoal(vec3_t origin, bot_goal_t *goal);
int BotItemGoalInVisButNotVisible(int viewer, vec3_t eye, vec3_t viewangles, bot_goal_t *goal);
void BotResetGoalState(int goalstate);
int BotLoadItemWeights(int goalstate, char *filename);
void BotFreeItemWeights(int goalstate);
int BotAllocGoalState(int client);
void BotFreeGoalState(int handle);
int BotSetupGoalAI(void);
void BotShutdownGoalAI(void);
//AHSRC:botlib/be_ai_move.c
int BotAllocMoveState(void);
void BotFreeMoveState(int handle);
bot_movestate_t *BotMoveStateFromHandle(int handle);
void BotInitMoveState(int handle, bot_initmove_t *initmove);
float AngleDiff(float ang1, float ang2);
int BotFuzzyPointReachabilityArea(vec3_t origin);
int BotReachabilityArea(vec3_t origin, int client);
int BotReachabilityArea(vec3_t origin, int testground);
int BotOnMover(vec3_t origin, int entnum, aas_reachability_t *reach);
int MoverDown(aas_reachability_t *reach);
void BotSetBrushModelTypes(void);
int BotOnTopOfEntity(bot_movestate_t *ms);
int BotValidTravel(vec3_t origin, aas_reachability_t *reach, int travelflags);
void BotAddToAvoidReach(bot_movestate_t *ms, int number, float avoidtime);
float DistanceFromLineSquared(vec3_t p, vec3_t lp1, vec3_t lp2);
float VectorDistanceSquared(vec3_t p1, vec3_t p2);
int BotAvoidSpots(vec3_t origin, aas_reachability_t *reach, bot_avoidspot_t *avoidspots, int numavoidspots);
void BotAddAvoidSpot(int movestate, vec3_t origin, float radius, int type);
int BotGetReachabilityToGoal(vec3_t origin, int areanum,int lastgoalareanum, int lastareanum, int *avoidreach, float *avoidreachtimes, int *avoidreachtries, bot_goal_t *goal, int travelflags, int movetravelflags, struct bot_avoidspot_s *avoidspots, int numavoidspots, int *flags);
int BotAddToTarget(vec3_t start, vec3_t end, float maxdist, float *dist, vec3_t target);
int BotMovementViewTarget(int movestate, bot_goal_t *goal, int travelflags, float lookahead, vec3_t target);
int BotVisible(int ent, vec3_t eye, vec3_t target);
int BotPredictVisiblePosition(vec3_t origin, int areanum, bot_goal_t *goal, int travelflags, vec3_t target);
void MoverBottomCenter(aas_reachability_t *reach, vec3_t bottomcenter);
float BotGapDistance(vec3_t origin, vec3_t hordir, int entnum);
int BotCheckBarrierJump(bot_movestate_t *ms, vec3_t dir, float speed);
int BotSwimInDirection(bot_movestate_t *ms, vec3_t dir, float speed, int type);
int BotWalkInDirection(bot_movestate_t *ms, vec3_t dir, float speed, int type);
int BotMoveInDirection(int movestate, vec3_t dir, float speed, int type);
int Intersection(vec2_t p1, vec2_t p2, vec2_t p3, vec2_t p4, vec2_t out);
void BotCheckBlocked(bot_movestate_t *ms, vec3_t dir, int checkbottom, bot_moveresult_t *result);
void BotClearMoveResult(bot_moveresult_t *moveresult);
bot_moveresult_t BotTravel_Walk(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotFinishTravel_Walk(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_Crouch(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_BarrierJump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotFinishTravel_BarrierJump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_Swim(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_WaterJump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotFinishTravel_WaterJump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_WalkOffLedge(bot_movestate_t *ms, aas_reachability_t *reach);
int BotAirControl(vec3_t origin, vec3_t velocity, vec3_t goal, vec3_t dir, float *speed);
bot_moveresult_t BotFinishTravel_WalkOffLedge(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_Jump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_Jump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_Jump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotFinishTravel_Jump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_Ladder(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_Teleport(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_Elevator(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotFinishTravel_Elevator(bot_movestate_t *ms, aas_reachability_t *reach);
void BotFuncBobStartEnd(aas_reachability_t *reach, vec3_t start, vec3_t end, vec3_t origin);
bot_moveresult_t BotTravel_FuncBobbing(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotFinishTravel_FuncBobbing(bot_movestate_t *ms, aas_reachability_t *reach);
int GrappleState(bot_movestate_t *ms, aas_reachability_t *reach);
void BotResetGrapple(bot_movestate_t *ms);
bot_moveresult_t BotTravel_Grapple(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_RocketJump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_BFGJump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotFinishTravel_WeaponJump(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotTravel_JumpPad(bot_movestate_t *ms, aas_reachability_t *reach);
bot_moveresult_t BotFinishTravel_JumpPad(bot_movestate_t *ms, aas_reachability_t *reach);
int BotReachabilityTime(aas_reachability_t *reach);
bot_moveresult_t BotMoveInGoalArea(bot_movestate_t *ms, bot_goal_t *goal);
void BotMoveToGoal(bot_moveresult_t *result, int movestate, bot_goal_t *goal, int travelflags);
void BotResetAvoidReach(int movestate);
void BotResetLastAvoidReach(int movestate);
void BotResetMoveState(int movestate);
int BotSetupMoveAI(void);
void BotShutdownMoveAI(void);
//AHSRC:botlib/be_ai_weap.c
int BotValidWeaponNumber(int weaponnum);
bot_weaponstate_t *BotWeaponStateFromHandle(int handle);
void DumpWeaponConfig(weaponconfig_t *wc);
weaponconfig_t *LoadWeaponConfig(char *filename);
int *WeaponWeightIndex(weightconfig_t *wwc, weaponconfig_t *wc);
void BotFreeWeaponWeights(int weaponstate);
int BotLoadWeaponWeights(int weaponstate, char *filename);
void BotGetWeaponInfo(int weaponstate, int weapon, weaponinfo_t *weaponinfo);
int BotChooseBestFightWeapon(int weaponstate, int *inventory);
void BotResetWeaponState(int weaponstate);
int BotAllocWeaponState(void);
void BotFreeWeaponState(int handle);
int BotSetupWeaponAI(void);
void BotShutdownWeaponAI(void);
//AHSRC:botlib/be_ai_weight.c
int ReadValue(source_t *source, float *value);
int ReadFuzzyWeight(source_t *source, fuzzyseperator_t *fs);
void FreeFuzzySeperators_r(fuzzyseperator_t *fs);
void FreeWeightConfig2(weightconfig_t *config);
void FreeWeightConfig(weightconfig_t *config);
fuzzyseperator_t *ReadFuzzySeperators_r(source_t *source);
weightconfig_t *ReadWeightConfig(char *filename);
qboolean WriteFuzzyWeight(FILE *fp, fuzzyseperator_t *fs);
qboolean WriteFuzzySeperators_r(FILE *fp, fuzzyseperator_t *fs, int indent);
qboolean WriteWeightConfig(char *filename, weightconfig_t *config);
int FindFuzzyWeight(weightconfig_t *wc, char *name);
float FuzzyWeight_r(int *inventory, fuzzyseperator_t *fs);
float FuzzyWeightUndecided_r(int *inventory, fuzzyseperator_t *fs);
float FuzzyWeight(int *inventory, weightconfig_t *wc, int weightnum);
float FuzzyWeightUndecided(int *inventory, weightconfig_t *wc, int weightnum);
void EvolveFuzzySeperator_r(fuzzyseperator_t *fs);
void EvolveWeightConfig(weightconfig_t *config);
void ScaleFuzzySeperator_r(fuzzyseperator_t *fs, float scale);
void ScaleWeight(weightconfig_t *config, char *name, float scale);
void ScaleFuzzySeperatorBalanceRange_r(fuzzyseperator_t *fs, float scale);
void ScaleFuzzyBalanceRange(weightconfig_t *config, float scale);
int InterbreedFuzzySeperator_r(fuzzyseperator_t *fs1, fuzzyseperator_t *fs2,fuzzyseperator_t *fsout);
void InterbreedWeightConfigs(weightconfig_t *config1, weightconfig_t *config2,weightconfig_t *configout);
void BotShutdownWeights(void);
//AHSRC:botlib/be_ea.c
void EA_Say(int client, char *str);
void EA_SayTeam(int client, char *str);
void EA_Tell(int client, int clientto, char *str);
void EA_UseItem(int client, char *it);
void EA_DropItem(int client, char *it);
void EA_UseInv(int client, char *inv);
void EA_DropInv(int client, char *inv);
void EA_Gesture(int client);
void EA_Command(int client, char *command);
void EA_SelectWeapon(int client, int weapon);
void EA_Attack(int client);
void EA_Talk(int client);
void EA_Use(int client);
void EA_Respawn(int client);
void EA_Jump(int client);
void EA_DelayedJump(int client);
void EA_Crouch(int client);
void EA_Walk(int client);
void EA_Action(int client, int action);
void EA_MoveUp(int client);
void EA_MoveDown(int client);
void EA_MoveForward(int client);
void EA_MoveBack(int client);
void EA_MoveLeft(int client);
void EA_MoveRight(int client);
void EA_Move(int client, vec3_t dir, float speed);
void EA_View(int client, vec3_t viewangles);
void EA_EndRegular(int client, float thinktime);
void EA_GetInput(int client, float thinktime, bot_input_t *input);
void EA_ResetInput(int client);
int EA_Setup(void);
void EA_Shutdown(void);
//AHSRC:botlib/be_interface.c
int Sys_MilliSeconds(void);
qboolean ValidClientNumber(int num, char *str);
qboolean ValidEntityNumber(int num, char *str);
qboolean BotLibSetup(char *str);
int Export_BotLibSetup(void);
int Export_BotLibShutdown(void);
int Export_BotLibVarSet(char *var_name, char *value);
int Export_BotLibVarGet(char *var_name, char *value, int size);
int Export_BotLibStartFrame(float time);
int Export_BotLibLoadMap(const char *mapname);
int Export_BotLibUpdateEntity(int ent, bot_entitystate_t *state);
void AAS_TestMovementPrediction(int entnum, vec3_t origin, vec3_t dir);
void ElevatorBottomCenter(aas_reachability_t *reach, vec3_t bottomcenter);
int BotGetReachabilityToGoal(vec3_t origin, int areanum,int lastgoalareanum, int lastareanum, int *avoidreach, float *avoidreachtimes, int *avoidreachtries, bot_goal_t *goal, int travelflags, int movetravelflags, struct bot_avoidspot_s *avoidspots, int numavoidspots, int *flags);
int AAS_PointLight(vec3_t origin, int *red, int *green, int *blue);
int AAS_TraceAreas(vec3_t start, vec3_t end, int *areas, vec3_t *points, int maxareas);
int AAS_Reachability_WeaponJump(int area1num, int area2num);
int BotFuzzyPointReachabilityArea(vec3_t origin);
float BotGapDistance(vec3_t origin, vec3_t hordir, int entnum);
void AAS_FloodAreas(vec3_t origin);
int BotExportTest(int parm0, char *parm1, vec3_t parm2, vec3_t parm3);
botlib_export_t *GetBotLibAPI(int apiVersion, botlib_import_t *import);
//AHSRC:botlib/l_crc.c
void CRC_Init(unsigned short *crcvalue);
void CRC_ProcessByte(unsigned short *crcvalue, byte data);
void CRC_ContinueProcessString(unsigned short *crc, char *data, int length);
//AHSRC:botlib/l_libvar.c
float LibVarStringValue(char *string);
libvar_t *LibVarAlloc(char *var_name);
void LibVarDeAlloc(libvar_t *v);
void LibVarDeAllocAll(void);
libvar_t *LibVarGet(char *var_name);
char *LibVarGetString(char *var_name);
float LibVarGetValue(char *var_name);
libvar_t *LibVar(char *var_name, char *value);
char *LibVarString(char *var_name, char *value);
float LibVarValue(char *var_name, char *value);
void LibVarSet(char *var_name, char *value);
qboolean LibVarChanged(char *var_name);
void LibVarSetNotModified(char *var_name);
//AHSRC:botlib/l_log.c
void Log_Open(char *filename);
void Log_Close(void);
void Log_Shutdown(void);
FILE *Log_FilePointer(void);
void Log_Flush(void);
//AHSRC:botlib/l_memory.c
void LinkMemoryBlock(memoryblock_t *block);
void UnlinkMemoryBlock(memoryblock_t *block);
void *GetMemoryDebug(unsigned long size, char *label, char *file, int line);
void *GetMemory(unsigned long size);
void *GetClearedMemoryDebug(unsigned long size, char *label, char *file, int line);
void *GetClearedMemory(unsigned long size);
void *GetHunkMemoryDebug(unsigned long size, char *label, char *file, int line);
void *GetHunkMemory(unsigned long size);
void *GetClearedHunkMemoryDebug(unsigned long size, char *label, char *file, int line);
void *GetClearedHunkMemory(unsigned long size);
memoryblock_t *BlockFromPointer(void *ptr, char *str);
void FreeMemory(void *ptr);
int AvailableMemory(void);
int MemoryByteSize(void *ptr);
void PrintUsedMemorySize(void);
void PrintMemoryLabels(void);
void DumpMemory(void);
void *GetMemoryDebug(unsigned long size, char *label, char *file, int line);
void *GetMemory(unsigned long size);
void *GetClearedMemoryDebug(unsigned long size, char *label, char *file, int line);
void *GetClearedMemory(unsigned long size);
void *GetHunkMemoryDebug(unsigned long size, char *label, char *file, int line);
void *GetHunkMemory(unsigned long size);
void *GetClearedHunkMemoryDebug(unsigned long size, char *label, char *file, int line);
void *GetClearedHunkMemory(unsigned long size);
void FreeMemory(void *ptr);
int AvailableMemory(void);
void PrintUsedMemorySize(void);
void PrintMemoryLabels(void);
//AHSRC:botlib/l_precomp.c
void PC_PushIndent(source_t *source, int type, int skip);
void PC_PopIndent(source_t *source, int *type, int *skip);
void PC_PushScript(source_t *source, script_t *script);
void PC_InitTokenHeap(void);
token_t *PC_CopyToken(token_t *token);
void PC_FreeToken(token_t *token);
int PC_ReadSourceToken(source_t *source, token_t *token);
int PC_UnreadSourceToken(source_t *source, token_t *token);
int PC_ReadDefineParms(source_t *source, define_t *define, token_t **parms, int maxparms);
int PC_StringizeTokens(token_t *tokens, token_t *token);
int PC_MergeTokens(token_t *t1, token_t *t2);
void PC_PrintDefine(define_t *define);
void PC_PrintDefineHashTable(define_t **definehash);
int PC_NameHash(char *name);
void PC_AddDefineToHash(define_t *define, define_t **definehash);
define_t *PC_FindHashedDefine(define_t **definehash, char *name);
define_t *PC_FindDefine(define_t *defines, char *name);
int PC_FindDefineParm(define_t *define, char *name);
void PC_FreeDefine(define_t *define);
void PC_AddBuiltinDefines(source_t *source);
int PC_ExpandBuiltinDefine(source_t *source, token_t *deftoken, define_t *define,token_t **firsttoken, token_t **lasttoken);
int PC_ExpandDefine(source_t *source, token_t *deftoken, define_t *define,token_t **firsttoken, token_t **lasttoken);
int PC_ExpandDefineIntoSource(source_t *source, token_t *deftoken, define_t *define);
void PC_ConvertPath(char *path);
int PC_Directive_include(source_t *source);
int PC_ReadLine(source_t *source, token_t *token);
int PC_WhiteSpaceBeforeToken(token_t *token);
void PC_ClearTokenWhiteSpace(token_t *token);
int PC_Directive_undef(source_t *source);
int PC_Directive_define(source_t *source);
define_t *PC_DefineFromString(char *string);
int PC_AddDefine(source_t *source, char *string);
int PC_AddGlobalDefine(char *string);
int PC_RemoveGlobalDefine(char *name);
void PC_RemoveAllGlobalDefines(void);
define_t *PC_CopyDefine(source_t *source, define_t *define);
void PC_AddGlobalDefinesToSource(source_t *source);
int PC_Directive_if_def(source_t *source, int type);
int PC_Directive_ifdef(source_t *source);
int PC_Directive_ifndef(source_t *source);
int PC_Directive_else(source_t *source);
int PC_Directive_endif(source_t *source);
int PC_OperatorPriority(int op);
int PC_EvaluateTokens(source_t *source, token_t *tokens, signed long int *intvalue,double *floatvalue, int integer);
int PC_Evaluate(source_t *source, signed long int *intvalue,double *floatvalue, int integer);
int PC_DollarEvaluate(source_t *source, signed long int *intvalue,double *floatvalue, int integer);
int PC_Directive_elif(source_t *source);
int PC_Directive_if(source_t *source);
int PC_Directive_line(source_t *source);
int PC_Directive_error(source_t *source);
int PC_Directive_pragma(source_t *source);
void UnreadSignToken(source_t *source);
int PC_Directive_eval(source_t *source);
int PC_Directive_evalfloat(source_t *source);
int PC_ReadDirective(source_t *source);
int PC_DollarDirective_evalint(source_t *source);
int PC_DollarDirective_evalfloat(source_t *source);
int PC_ReadDollarDirective(source_t *source);
int BuiltinFunction(source_t *source);
int QuakeCMacro(source_t *source);
int PC_ReadToken(source_t *source, token_t *token);
int PC_ExpectTokenString(source_t *source, char *string);
int PC_ExpectTokenType(source_t *source, int type, int subtype, token_t *token);
int PC_ExpectAnyToken(source_t *source, token_t *token);
int PC_CheckTokenString(source_t *source, char *string);
int PC_CheckTokenType(source_t *source, int type, int subtype, token_t *token);
int PC_SkipUntilString(source_t *source, char *string);
void PC_UnreadLastToken(source_t *source);
void PC_UnreadToken(source_t *source, token_t *token);
void PC_SetIncludePath(source_t *source, char *path);
void PC_SetPunctuations(source_t *source, punctuation_t *p);
source_t *LoadSourceFile(const char *filename);
source_t *LoadSourceMemory(char *ptr, int length, char *name);
void FreeSource(source_t *source);
int PC_LoadSourceHandle(const char *filename);
int PC_FreeSourceHandle(int handle);
int PC_ReadTokenHandle(int handle, pc_token_t *pc_token);
int PC_SourceFileAndLine(int handle, char *filename, int *line);
void PC_SetBaseFolder(char *path);
void PC_CheckOpenSourceHandles(void);
//AHSRC:botlib/l_script.c
void PS_CreatePunctuationTable(script_t *script, punctuation_t *punctuations);
char *PunctuationFromNum(script_t *script, int num);
void SetScriptPunctuations(script_t *script, punctuation_t *p);
int PS_ReadWhiteSpace(script_t *script);
int PS_ReadEscapeCharacter(script_t *script, char *ch);
int PS_ReadString(script_t *script, token_t *token, int quote);
int PS_ReadName(script_t *script, token_t *token);
void NumberValue(char *string, int subtype, unsigned long int *intvalue,long double *floatvalue);
int PS_ReadNumber(script_t *script, token_t *token);
int PS_ReadLiteral(script_t *script, token_t *token);
int PS_ReadPunctuation(script_t *script, token_t *token);
int PS_ReadPrimitive(script_t *script, token_t *token);
int PS_ReadToken(script_t *script, token_t *token);
int PS_ExpectTokenString(script_t *script, char *string);
int PS_ExpectTokenType(script_t *script, int type, int subtype, token_t *token);
int PS_ExpectAnyToken(script_t *script, token_t *token);
int PS_CheckTokenString(script_t *script, char *string);
int PS_CheckTokenType(script_t *script, int type, int subtype, token_t *token);
int PS_SkipUntilString(script_t *script, char *string);
void PS_UnreadLastToken(script_t *script);
void PS_UnreadToken(script_t *script, token_t *token);
char PS_NextWhiteSpaceChar(script_t *script);
void StripDoubleQuotes(char *string);
void StripSingleQuotes(char *string);
void SetScriptFlags(script_t *script, int flags);
int GetScriptFlags(script_t *script);
void ResetScript(script_t *script);
int EndOfScript(script_t *script);
int NumLinesCrossed(script_t *script);
int ScriptSkipTo(script_t *script, char *value);
int FileLength(FILE *fp);
script_t *LoadScriptFile(const char *filename);
script_t *LoadScriptMemory(char *ptr, int length, char *name);
void FreeScript(script_t *script);
void PS_SetBaseFolder(char *path);
//AHSRC:botlib/l_struct.c
fielddef_t *FindField(fielddef_t *defs, char *name);
qboolean ReadNumber(source_t *source, fielddef_t *fd, void *p);
qboolean ReadChar(source_t *source, fielddef_t *fd, void *p);
int ReadString(source_t *source, fielddef_t *fd, void *p);
int ReadStructure(source_t *source, structdef_t *def, char *structure);
int WriteIndent(FILE *fp, int indent);
int WriteFloat(FILE *fp, float value);
int WriteStructWithIndent(FILE *fp, structdef_t *def, char *structure, int indent);
int WriteStructure(FILE *fp, structdef_t *def, char *structure);
//AHSRC:renderer/tr_animation.c
void R_AddAnimSurfaces( trRefEntity_t *ent );
void RB_SurfaceAnim( md4Surface_t *surface );
//AHSRC:renderer/tr_backend.c
void GL_Bind( image_t *image );
void GL_SelectTexture( int unit );
void GL_BindMultitexture( image_t *image0, GLuint env0, image_t *image1, GLuint env1 );
void GL_Cull( int cullType );
void GL_TexEnv( int env );
void GL_State( unsigned long stateBits );
void RB_BeginDrawingView (void);
void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs );
void	RB_SetGL2D (void);
void RE_StretchRaw (int x, int y, int w, int h, int cols, int rows, const byte *data, int client, qboolean dirty);
void RE_UploadCinematic (int w, int h, int cols, int rows, const byte *data, int client, qboolean dirty);
void RB_ShowImages( void );
void RB_ExecuteRenderCommands( const void *data );
void RB_RenderThread( void );
//AHSRC:renderer/tr_bsp.c
void RE_LoadWorldMap( const char *name );
void		RE_SetWorldVisData( const byte *vis );
int R_MergedWidthPoints(srfGridMesh_t *grid, int offset);
int R_MergedHeightPoints(srfGridMesh_t *grid, int offset);
void R_FixSharedVertexLodError_r( int start, srfGridMesh_t *grid1 );
void R_FixSharedVertexLodError( void );
int R_StitchPatches( int grid1num, int grid2num );
int R_TryStitchingPatch( int grid1num );
void R_StitchAllPatches( void );
void R_MovePatchSurfacesToHunk(void);
void R_LoadLightGrid( lump_t *l );
void R_LoadEntities( lump_t *l );
qboolean R_GetEntityToken( char *buffer, int size );
void RE_LoadWorldMap( const char *name );
//AHSRC:renderer/tr_cmds.c
void R_PerformanceCounters( void );
void R_InitCommandBuffers( void );
void R_ShutdownCommandBuffers( void );
void R_IssueRenderCommands( qboolean runPerformanceCounters );
void R_SyncRenderThread( void );
void *R_GetCommandBuffer( int bytes );
void	R_AddDrawSurfCmd( drawSurf_t *drawSurfs, int numDrawSurfs );
void	RE_SetColor( const float *rgba );
void RE_StretchPic ( float x, float y, float w, float h, float s1, float t1, float s2, float t2, qhandle_t hShader );
void RE_BeginFrame( stereoFrame_t stereoFrame );
void RE_EndFrame( int *frontEndMsec, int *backEndMsec );
//AHSRC:renderer/tr_curve.c
srfGridMesh_t *R_SubdividePatchToGrid( int width, int height,drawVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE] );
srfGridMesh_t *R_CreateSurfaceGridMesh(int width, int height,drawVert_t ctrl[MAX_GRID_SIZE][MAX_GRID_SIZE], float errorTable[2][MAX_GRID_SIZE] );
void R_FreeSurfaceGridMesh( srfGridMesh_t *grid );
srfGridMesh_t *R_SubdividePatchToGrid( int width, int height,drawVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE] );
srfGridMesh_t *R_GridInsertColumn( srfGridMesh_t *grid, int column, int row, vec3_t point, float loderror );
srfGridMesh_t *R_GridInsertRow( srfGridMesh_t *grid, int row, int column, vec3_t point, float loderror );
//AHSRC:renderer/tr_flares.c
void R_ClearFlares( void );
void RB_AddFlare( void *surface, int fogNum, vec3_t point, vec3_t color, vec3_t normal );
void RB_AddDlightFlares( void );
void RB_TestFlare( flare_t *f );
void RB_RenderFlare( flare_t *f );
void RB_RenderFlares (void);
//AHSRC:renderer/tr_font.c
void R_GetGlyphInfo(FT_GlyphSlot glyph, int *left, int *right, int *width, int *top, int *bottom, int *height, int *pitch);
FT_Bitmap *R_RenderGlyph(FT_GlyphSlot glyph, glyphInfo_t* glyphOut);
void WriteTGA (char *filename, byte *data, int width, int height);
int readInt();
float readFloat();
void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font);
void R_InitFreeType();
void R_DoneFreeType();
//AHSRC:renderer/tr_image.c
void R_GammaCorrect( byte *buffer, int bufSize );
void GL_TextureMode( const char *string );
int R_SumOfUsedImages( void );
void R_ImageList_f( void );
void R_LightScaleTexture (unsigned *in, int inwidth, int inheight, qboolean only_gamma );
int GL_LumaForPix24(unsigned pix);
int GL_LumaForPix24Ax(unsigned pix, int ax);
int GL_ConvPix24To565(unsigned pix);
void GL_EncodeBlockDxt1(unsigned *src, byte *dst, int ystr, int isdxt5);
void GL_EncodeBlockBC4(unsigned *src, byte *dst, int ystr);
void GL_EncodeSquareDxt1(unsigned *src, byte *dst, int szlg2);
void GL_EncodeSquareDxt5(unsigned *src, byte *dst, int szlg2);
void GL_EncodeDDS (unsigned *data, int width, int height,qboolean mipmap, qboolean alpha);
void GL_UploadCompressed (byte *data, int width, int height, qboolean mipmap, qboolean alpha);
void R_UploadCompressed (byte *data, int width, int height, qboolean mipmap, int fmt);
image_t *R_CreateImage2( const char *name,const byte *pic, int width, int height,  qboolean mipmap, qboolean allowPicmip, int glWrapClampMode, int fmt );
image_t *R_CreateImage( const char *name,const byte *pic, int width, int height,  qboolean mipmap, qboolean allowPicmip, int glWrapClampMode );
image_t *R_CreateImageDxt1( const char *name,const byte *pic, int width, int height,  qboolean mipmap, qboolean allowPicmip, int glWrapClampMode );
void init_destination (j_compress_ptr cinfo);
boolean empty_output_buffer (j_compress_ptr cinfo);
void term_destination (j_compress_ptr cinfo);
void jpegDest (j_compress_ptr cinfo, byte* outfile, int size);
void SaveJPG(char * filename, int quality, int image_width, int image_height, unsigned char *image_buffer);
void R_LoadImage( const char *name, byte **pic, int *width, int *height );
image_t	*R_FindImageFile( const char *name,qboolean mipmap, qboolean allowPicmip, int glWrapClampMode );
void R_InitFogTable( void );
float	R_FogFactor( float s, float t );
void R_CreateBuiltinImages( void );
void R_SetColorMappings( void );
void	R_InitImages( void );
void R_DeleteTextures( void );
qhandle_t RE_RegisterSkin( const char *name );
void	R_InitSkins( void );
skin_t	*R_GetSkinByHandle( qhandle_t hSkin );
void	R_SkinList_f( void );
//AHSRC:renderer/tr_init.c
void GL_CheckErrors( void );
qboolean R_GetModeInfo( int *width, int *height, float *windowAspect, int mode );
void RB_TakeScreenshot( int x, int y, int width, int height, char *fileName );
void RB_TakeScreenshotJPEG( int x, int y, int width, int height, char *fileName );
void R_TakeScreenshot( int x, int y, int width, int height, char *name, qboolean jpeg );
void R_ScreenshotFilename( int lastNumber, char *fileName );
void R_ScreenshotFilenameJPEG( int lastNumber, char *fileName );
void R_LevelShot( void );
void R_ScreenShot_f (void);
void R_ScreenShotJPEG_f (void);
void GL_SetDefaultState( void );
void GfxInfo_f( void );
void R_Register( void );
void R_Init( void );
void RE_Shutdown( qboolean destroyWindow );
void RE_EndRegistration( void );
refexport_t *GetRefAPI ( int apiVersion, refimport_t *rimp );
//AHSRC:renderer/tr_light.c
void R_TransformDlights( int count, dlight_t *dl, orientationr_t *or);
void R_DlightBmodel( bmodel_t *bmodel );
void R_SetupEntityLighting( const trRefdef_t *refdef, trRefEntity_t *ent );
int R_LightForPoint( vec3_t point, vec3_t ambientLight, vec3_t directedLight, vec3_t lightDir );
//AHSRC:renderer/tr_main.c
int R_CullLocalBox (vec3_t bounds[2]);
int R_CullLocalPointAndRadius( vec3_t pt, float radius );
int R_CullPointAndRadius( vec3_t pt, float radius );
void R_LocalNormalToWorld (vec3_t local, vec3_t world);
void R_LocalPointToWorld (vec3_t local, vec3_t world);
void R_WorldToLocal (vec3_t world, vec3_t local);
void R_TransformModelToClip(const vec3_t src, const float *modelMatrix, const float *projectionMatrix, vec4_t eye, vec4_t dst );
void R_TransformClipToWindow(const vec4_t clip, const viewParms_t *view, vec4_t normalized, vec4_t window );
void myGlMultMatrix( const float *a, const float *b, float *out );
void R_RotateForEntity(const trRefEntity_t *ent, const viewParms_t *viewParms, orientationr_t *or );
void R_RotateForViewer (void);
void R_SetupProjection( void );
void R_SetupFrustum (void);
void R_MirrorPoint (vec3_t in, orientation_t *surface, orientation_t *camera, vec3_t out);
void R_MirrorVector (vec3_t in, orientation_t *surface, orientation_t *camera, vec3_t out);
void R_PlaneForSurface (surfaceType_t *surfType, cplane_t *plane);
qboolean R_GetPortalOrientations( drawSurf_t *drawSurf, int entityNum, orientation_t *surface, orientation_t *camera, vec3_t pvsOrigin, qboolean *mirror );
qboolean R_MirrorViewBySurface (drawSurf_t *drawSurf, int entityNum);
int R_SpriteFogNum( trRefEntity_t *ent );
void SwapDrawSurf(drawSurf_t *a, drawSurf_t *b);
void qsortFast (void *base, unsigned num, unsigned width );
int CompareDrawSurf(drawSurf_t *a, drawSurf_t *b);
void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader, int fogIndex, int dlightMap );
void R_DecomposeSort( unsigned sort, int *entityNum, shader_t **shader, int *fogNum, int *dlightMap );
void R_SortDrawSurfs( drawSurf_t *drawSurfs, int numDrawSurfs );
void R_AddEntitySurfaces (void);
void R_GenerateDrawSurfs( void );
void R_DebugPolygon( int color, int numPoints, float *points );
void R_DebugGraphics( void );
void R_RenderView (viewParms_t *parms);
//AHSRC:renderer/tr_marks.c
void R_BoxSurfaces_r(mnode_t *node, vec3_t mins, vec3_t maxs, surfaceType_t **list, int listsize, int *listlength, vec3_t dir);
void R_AddMarkFragments(int numClipPoints, vec3_t clipPoints[2][MAX_VERTS_ON_POLY],int numPlanes, vec3_t *normals, float *dists, int maxPoints, vec3_t pointBuffer, int maxFragments, markFragment_t *fragmentBuffer, int *returnedPoints, int *returnedFragments, vec3_t mins, vec3_t maxs);
int R_MarkFragments( int numPoints, const vec3_t *points, const vec3_t projection,int maxPoints, vec3_t pointBuffer, int maxFragments, markFragment_t *fragmentBuffer );
//AHSRC:renderer/tr_mesh.c
int R_ComputeLOD( trRefEntity_t *ent );
int R_ComputeFogNum( md3Header_t *header, trRefEntity_t *ent );
void R_AddMD3Surfaces( trRefEntity_t *ent );
//AHSRC:renderer/tr_model.c
model_t	*R_GetModelByHandle( qhandle_t index );
model_t *R_AllocModel( void );
qhandle_t RE_RegisterModel( const char *name );
void RE_BeginRegistration( glconfig_t *glconfigOut );
void R_ModelInit( void );
void R_Modellist_f( void );
int R_LerpTag( orientation_t *tag, qhandle_t handle, int startFrame, int endFrame, float frac, const char *tagName );
void R_ModelBounds( qhandle_t handle, vec3_t mins, vec3_t maxs );
//AHSRC:renderer/tr_noise.c
void R_NoiseInit( void );
float R_NoiseGet4f( float x, float y, float z, float t );
//AHSRC:renderer/tr_scene.c
void R_ToggleSmpFrame( void );
void RE_ClearScene( void );
void R_AddPolygonSurfaces( void );
void RE_AddPolyToScene( qhandle_t hShader, int numVerts, const polyVert_t *verts, int numPolys );
void RE_AddRefEntityToScene( const refEntity_t *ent );
void RE_AddDynamicLightToScene( const vec3_t org, float intensity, float r, float g, float b, int additive );
void RE_AddLightToScene( const vec3_t org, float intensity, float r, float g, float b );
void RE_AddAdditiveLightToScene( const vec3_t org, float intensity, float r, float g, float b );
void RE_RenderScene( const refdef_t *fd );
//AHSRC:renderer/tr_shade.c
void RB_BeginSurface( shader_t *shader, int fogNum );
void RB_StageIteratorGeneric( void );
void RB_StageIteratorVertexLitTexture( void );
void RB_StageIteratorLightmappedMultitexture( void );
void RB_EndSurface( void );
//AHSRC:renderer/tr_shade_calc.c
void RB_CalcStretchTexCoords( const waveForm_t *wf, float *st );
void RB_CalcDeformVertexes( deformStage_t *ds );
void RB_CalcDeformNormals( deformStage_t *ds );
void RB_CalcBulgeVertexes( deformStage_t *ds );
void RB_CalcMoveVertexes( deformStage_t *ds );
void DeformText( const char *text );
void RB_DeformTessGeometry( void );
void RB_CalcColorFromEntity( unsigned char *dstColors );
void RB_CalcColorFromOneMinusEntity( unsigned char *dstColors );
void RB_CalcAlphaFromEntity( unsigned char *dstColors );
void RB_CalcAlphaFromOneMinusEntity( unsigned char *dstColors );
void RB_CalcWaveColor( const waveForm_t *wf, unsigned char *dstColors );
void RB_CalcWaveAlpha( const waveForm_t *wf, unsigned char *dstColors );
void RB_CalcModulateColorsByFog( unsigned char *colors );
void RB_CalcModulateAlphasByFog( unsigned char *colors );
void RB_CalcModulateRGBAsByFog( unsigned char *colors );
void RB_CalcFogTexCoords( float *st );
void RB_CalcEnvironmentTexCoords( float *st );
void RB_CalcTurbulentTexCoords( const waveForm_t *wf, float *st );
void RB_CalcScaleTexCoords( const float scale[2], float *st );
void RB_CalcScrollTexCoords( const float scrollSpeed[2], float *st );
void RB_CalcTransformTexCoords( const texModInfo_t *tmi, float *st  );
void RB_CalcRotateTexCoords( float degsPerSecond, float *st );
long myftol( float f );
void RB_CalcSpecularAlpha( unsigned char *alphas );
void RB_CalcDiffuseColor( unsigned char *colors );
//AHSRC:renderer/tr_shader.c
void R_RemapShader(const char *shaderName, const char *newShaderName, const char *timeOffset);
void ParseSort( char **text );
shader_t *R_FindShaderByName( const char *name );
shader_t *R_FindShader( const char *name, int lightmapIndex, qboolean mipRawImage );
qhandle_t RE_RegisterShaderFromImage(const char *name, int lightmapIndex, image_t *image, qboolean mipRawImage);
qhandle_t RE_RegisterShaderLightMap( const char *name, int lightmapIndex );
qhandle_t RE_RegisterShader( const char *name );
qhandle_t RE_RegisterShaderNoMip( const char *name );
shader_t *R_GetShaderByHandle( qhandle_t hShader );
void	R_ShaderList_f (void);
void R_InitShaders( void );
//AHSRC:renderer/tr_shadows.c
void R_AddEdgeDef( int i1, int i2, int facing );
void R_RenderShadowEdges( void );
void RB_ShadowTessEnd( void );
void RB_ShadowFinish( void );
void RB_ProjectionShadowDeform( void );
//AHSRC:renderer/tr_sky.c
void RB_ClipSkyPolygons( shaderCommands_t *input );
void R_BuildCloudData( shaderCommands_t *input );
void R_InitSkyTexCoords( float heightCloud );
void RB_DrawSun( void );
void RB_StageIteratorSky( void );
//AHSRC:renderer/tr_surface.c
void RB_CheckOverflow( int verts, int indexes );
void RB_AddQuadStampExt( vec3_t origin, vec3_t left, vec3_t up, byte *color, float s1, float t1, float s2, float t2 );
void RB_AddQuadStamp( vec3_t origin, vec3_t left, vec3_t up, byte *color );
void RB_SurfacePolychain( srfPoly_t *p );
void RB_SurfaceTriangles( srfTriangles_t *srf );
void RB_SurfaceBeam( void );
void RB_SurfaceRailRings( void );
void RB_SurfaceRailCore( void );
void RB_SurfaceLightningBolt( void );
void RB_SurfaceMesh(md3Surface_t *surface);
void RB_SurfaceFace( srfSurfaceFace_t *surf );
void RB_SurfaceGrid( srfGridMesh_t *cv );
void RB_SurfaceAxis( void );
void RB_SurfaceEntity( surfaceType_t *surfType );
void RB_SurfaceBad( surfaceType_t *surfType );
void RB_SurfaceFlare( srfFlare_t *surf );
void RB_SurfaceFlare( srfFlare_t *surf );
void RB_SurfaceDisplayList( srfDisplayList_t *surf );
void RB_SurfaceSkip( void *surf );
//AHSRC:renderer/tr_world.c
void R_AddBrushModelSurfaces ( trRefEntity_t *ent );
qboolean R_inPVS( const vec3_t p1, const vec3_t p2 );
void R_AddWorldSurfaces (void);
//AHSRC:jpeg-6/jcapimin.c
//AHSRC:jpeg-6/jccoefct.c
//AHSRC:jpeg-6/jccolor.c
//AHSRC:jpeg-6/jcdctmgr.c
//AHSRC:jpeg-6/jchuff.c
//AHSRC:jpeg-6/jcinit.c
//AHSRC:jpeg-6/jcmainct.c
//AHSRC:jpeg-6/jcmarker.c
//AHSRC:jpeg-6/jcmaster.c
//AHSRC:jpeg-6/jcomapi.c
//AHSRC:jpeg-6/jcparam.c
//AHSRC:jpeg-6/jcphuff.c
//AHSRC:jpeg-6/jcprepct.c
//AHSRC:jpeg-6/jcsample.c
typedef JMETHOD(void, downsample1_ptr,(j_compress_ptr cinfo, jpeg_component_info * compptr, JSAMPARRAY input_data, JSAMPARRAY output_data));
//AHSRC:jpeg-6/jctrans.c
//AHSRC:jpeg-6/jdapimin.c
//AHSRC:jpeg-6/jdapistd.c
//AHSRC:jpeg-6/jdatadst.c
//AHSRC:jpeg-6/jdatasrc.c
//AHSRC:jpeg-6/jdcoefct.c
//AHSRC:jpeg-6/jdcolor.c
//AHSRC:jpeg-6/jddctmgr.c
//AHSRC:jpeg-6/jdhuff.c
//AHSRC:jpeg-6/jdinput.c
//AHSRC:jpeg-6/jdmainct.c
//AHSRC:jpeg-6/jdmarker.c
//AHSRC:jpeg-6/jdmaster.c
//AHSRC:jpeg-6/jdpostct.c
//AHSRC:jpeg-6/jdsample.c
typedef JMETHOD(void, upsample1_ptr,(j_decompress_ptr cinfo, jpeg_component_info * compptr, JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
//AHSRC:jpeg-6/jdtrans.c
//AHSRC:jpeg-6/jerror.c
//AHSRC:jpeg-6/jfdctflt.c
//AHSRC:jpeg-6/jidctflt.c
//AHSRC:jpeg-6/jmemmgr.c
//AHSRC:jpeg-6/jmemnobs.c
//AHSRC:jpeg-6/jutils.c
//AHSRC:bjx2tk/tksh_glimp.c
void I_InitTkGdi();
int TKRA_SetupContextBasic(int xs, int ys);
void *TKRA_GetCurrentScreenBuffer_RGB(void);
void *tkra_wglGetProcAddress(char *name);
qboolean QGL_Init( const char *dllname );
void I_InitTkGl();
void		GLimp_EndFrame( void );
int 		GLimp_Init( void );
void		GLimp_Shutdown( void );
void		GLimp_EnableLogging( qboolean enable );
void GLimp_LogComment( char *comment );
qboolean QGL_Init( const char *dllname );
void		QGL_Shutdown( void );
void		GLimp_SetGamma(unsigned char red[256], unsigned char green[256], unsigned char blue[256] );
void GLimp_WakeRenderer( void *data );
void *GLimp_RendererSleep( void );
void GLimp_FrontEndSleep( void );
qboolean GLimp_SpawnRenderThread( void (*function)( void ) );
//AHSRC:bjx2tk/tksh_input.c
void Sys_QueEvent(int time, sysEventType_t type, int value, int value2, int ptrLength, void *ptr );
void IN_Init( void );
void IN_Frame (void);
void IN_Shutdown( void );
int I_TkgRemapKey(int keysym, int *key);
void I_KeyEvent(int keysym, int dn);
void Sys_SendKeyEvents (void);
//AHSRC:bjx2tk/tksh_main.c
qboolean	Sys_GetPacket ( netadr_t *net_from, msg_t *net_message );
short BigShort(short l);
short LittleShort(short l);
int	BigLong (int l);
int	LittleLong (int l);
qint64  BigLong64 (qint64 l);
qint64  LittleLong64 (qint64 l);
float	BigFloat (float l);
float	LittleFloat (float l);
void Sys_BeginStreamedFile( fileHandle_t f, int readAhead );
void Sys_EndStreamedFile( fileHandle_t f );
int Sys_StreamedRead( void *buffer, int size, int count, fileHandle_t f );
void Sys_StreamSeek( fileHandle_t f, int offset, int origin );
void Sys_mkdir ( const char *path );
void Sys_Error (char *error, ...);
void Sys_Print (char *error, ...);
void Sys_Quit (void);
void	Sys_UnloadGame (void);
void	*Sys_GetGameAPI (void *parms);
char *Sys_GetClipboardData( void );
int TK_GetTimeMs();
int		Sys_Milliseconds (void);
void	Sys_Mkdir (char *path);
char	*Sys_FindFirst (char *path, unsigned musthave, unsigned canthave);
char	*Sys_FindNext (unsigned musthave, unsigned canthave);
void	Sys_FindClose (void);
void	Sys_Init (void);
void	Sys_EarlyOutput( char *string );
void Sys_ListFilteredFiles(const char *basedir, char *subdirs, char *filter, char **list, int *numfiles );
char **Sys_ListFiles(const char *directory, const char *extension, char *filter, int *numfiles, qboolean wantsubs );
void	Sys_FreeFileList( char **list );
void Sys_ShowConsole( int visLevel, qboolean quitOnClose );
char *Sys_Cwd( void );
char *Sys_DefaultHomePath(void);
char *Sys_DefaultInstallPath(void);
char *Sys_DefaultCDPath(void);
qboolean Sys_CheckCD( void );
void Sys_QueEvent(int time, sysEventType_t type, int value, int value2, int ptrLength, void *ptr );
sysEvent_t Sys_GetEvent( void );
void Sys_UnloadDll( void *dllHandle );
void *Sys_LoadDll( const char *name, char *fqpath ,int (**entryPoint)(int, ...), int (*systemcalls)(int, ...) );
void Sys_SnapVector( float *v );
void Sys_BeginProfiling( void );
qboolean Sys_LowPhysicalMemory();
void main (int argc, char **argv);
//AHSRC:bjx2tk/tksh_net.c
qboolean	NET_StringToAdr (char *s, netadr_t *a);
void Sys_SendPacket( int length, void *data, netadr_t to );
qboolean	Sys_GetPacket ( netadr_t *net_from, msg_t *net_message );
qboolean	Sys_IsLANAddress (netadr_t adr);
void NET_Sleep(int msec);
void Sys_ShowIP();
//AHSRC:bjx2tk/tksh_qgl.c
void QGL_EnableLogging( qboolean enable );
void QGL_Shutdown( void );
void *tkra_wglGetProcAddress(char *name);
qboolean QGL_Init( const char *dllname );
//AHSRC:bjx2tk/tksh_snddma.c
qboolean SNDDMA_Init(void);
int	SNDDMA_GetDMAPos(void);
void SNDDMA_Shutdown(void);
void SNDDMA_BeginPainting (void);
void SNDDMA_Submit(void);
sfxHandle_t S_RegisterSound( const char *name, qboolean compressed );
void S_StartLocalSound( sfxHandle_t sfxHandle, int channelNum );
void S_ClearSoundBuffer( void );
