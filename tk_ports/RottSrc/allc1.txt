/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "cin_glob.h"
#include "cin_def.h"
#include "cin_actr.h"
#include "cin_efct.h"
#include "modexlib.h"
//MED
// #include "memcheck.h"

actortype * firstcinematicactor;
actortype * lastcinematicactor;


// LOCALS

boolean cinematicactorsystemstarted=false;
static int numcinematicactors;

/*
===============
=
= AddCinematicActor
=
===============
*/

void AddCinematicActor ( actortype * actor )
{
   if (!firstcinematicactor)
      {
      firstcinematicactor  = actor;
      }
   else
      {
      actor->prev = lastcinematicactor;
      lastcinematicactor->next = actor;
      }
   lastcinematicactor = actor;
}


/*
===============
=
= DeleteCinematicActor
=
===============
*/

void DeleteCinematicActor ( actortype * actor)
{
   if (actor == lastcinematicactor)
      {
      lastcinematicactor = actor->prev;
      }
   else
      {
      actor->next->prev = actor->prev;
      }

   if (actor == firstcinematicactor)
      {
      firstcinematicactor = actor->next;
      }
   else
      {
      actor->prev->next = actor->next;
      }

   actor->prev = NULL;
   actor->next = NULL;

   if (actor->effect != NULL)
      SafeFree(actor->effect);
   SafeFree(actor);
}

/*
===============
=
= GetNewCinematicActor
=
===============
*/

actortype * GetNewCinematicActor ( void )
{
   actortype * actor;

   numcinematicactors++;

   if ( numcinematicactors > MAXCINEMATICACTORS )
      Error ("Too many Cinematic actors\n");

   actor = SafeMalloc( sizeof (actortype) );

   actor->next=NULL;
   actor->prev=NULL;

   AddCinematicActor ( actor );

   return actor;
}

/*
===============
=
= StartupCinematicActors
=
===============
*/

void StartupCinematicActors ( void )
{
   if (cinematicactorsystemstarted==true)
      return;
   cinematicactorsystemstarted=true;
   firstcinematicactor = NULL;
   lastcinematicactor  = NULL;

   numcinematicactors=0;
}

/*
===============
=
= ShutdownCinematicActors
=
===============
*/

void ShutdownCinematicActors ( void )
{
   actortype * actor;
   if (cinematicactorsystemstarted==false)
      return;
   cinematicactorsystemstarted=false;

   actor=firstcinematicactor;
   while (actor != NULL)
      {
      actortype * nextactor;

      nextactor=actor->next;
      DeleteCinematicActor(actor);
      actor=nextactor;
      }
}

/*
===============
=
= SpawnCinematicActor
=
===============
*/

void SpawnCinematicActor ( enum_eventtype type, void * effect )
{
   actortype * actor;

   actor = GetNewCinematicActor ();
   actor->effecttype=type;
   actor->effect=effect;
}

/*
===============
=
= UpdateCinematicActors
=
===============
*/
void UpdateCinematicActors ( void )
{
   actortype * actor;

   for (actor=firstcinematicactor;actor != NULL;)
      {
      if (UpdateCinematicEffect ( actor->effecttype, actor->effect ) == false)
         {
         actortype * nextactor;

         nextactor=actor->next;
         DeleteCinematicActor(actor);
         actor=nextactor;
         }
      else
         actor=actor->next;
      }
}

/*
===============
=
= DrawCinematicActors
=
===============
*/
typedef enum {
        screenfunctions,
        background,
        backgroundsprites,
        backdrop,
        foregroundsprites,
        palettefunctions,
        numdrawphases
} enum_drawphases;

void DrawCinematicActors ( void )
{
   actortype * actor;
   actortype * nextactor;
   boolean draw;
   enum_drawphases sequence;
#if DUMP
   int numactors=0;
#endif
   boolean flippage=true;

   for (sequence=screenfunctions;sequence<numdrawphases;sequence++)
      {
      for (actor=firstcinematicactor;actor != NULL;)
         {
         draw=false;
         switch (actor->effecttype)
            {
            case fadeout:
            case blankscreen:
            case clearbuffer:
            case cinematicend:
            case flic:
               if (sequence==screenfunctions)
                  draw=true;
               flippage=false;
               break;
            case palette:
               if (sequence==palettefunctions)
                  draw=true;
               flippage=false;
               break;
            case background_noscrolling:
            case background_scrolling:
            case background_multi:
               if (sequence==background)
                  draw=true;
               break;
            case sprite_background:
               if (sequence==backgroundsprites)
                  draw=true;
               break;
            case backdrop_noscrolling:
            case backdrop_scrolling:
               if (sequence==backdrop)
                  draw=true;
               break;
            case sprite_foreground:
               if (sequence==foregroundsprites)
                  draw=true;
               break;
            }
         nextactor=actor->next;
         if (draw==true)
            {
#if DUMP
            printf("drawing type=%ld\n",actor->effecttype);
#endif
            if (DrawCinematicEffect ( actor->effecttype, actor->effect ) == false)
               {
               DeleteCinematicActor(actor);
               }
#if DUMP
            numactors++;
#endif
            }
         actor=nextactor;
         }
      }
      if (flippage==true)
         XFlipPage ();
#if DUMP
      printf("Total actors drawn=%ld\n",numactors);
#endif
}


/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "cin_glob.h"
#include "cin_util.h"
#include "cin_def.h"
#include "cin_main.h"
#include "f_scale.h"
#include "watcom.h"
#include "lumpy.h"
#include "w_wad.h"
#include "z_zone.h"
#include <string.h>
// #include <conio.h>

#include "modexlib.h"
#include "fli_glob.h"
//MED
// #include "memcheck.h"

static int cin_sprtopoffset;
static int cin_invscale;

/*
===============
=
= SpawnCinematicFlic
=
===============
*/

void DrawCinFadeout ( void );
void DrawBlankScreen ( void );
void DrawClearBuffer ( void );

flicevent * SpawnCinematicFlic ( char * name, boolean loop, boolean usefile )
{
	flicevent * flic;

	flic = SafeMalloc ( sizeof(flicevent) );

	// copy name of flic

	strcpy ( flic->name, name );

	flic->loop=loop;

	flic->usefile=usefile;

	return flic;
}

/*
===============
=
= SpawnCinematicSprite
=
===============
*/

spriteevent * SpawnCinematicSprite ( char * name,
												 int duration,
												 int numframes,
												 int framedelay,
												 int x,
												 int y,
												 int scale,
												 int endx,
												 int endy,
												 int endscale
											  )
{
	spriteevent * sprite;
	patch_t *p;

	sprite = SafeMalloc ( sizeof (spriteevent) );

	// copy name of sprite

	strcpy ( sprite->name, name );

	// copy rest of sprite information

	sprite->duration = duration;
	sprite->numframes = numframes;
	sprite->framedelay = framedelay;
	sprite->frame=0;
	sprite->frametime=framedelay;

	p=(patch_t *)W_CacheLumpNum( W_GetNumForName(sprite->name), PU_CACHE);

	sprite->x=x << FRACTIONBITS;
	sprite->y=y << FRACTIONBITS;

//	sprite->y+=(p->width-p->height)<<(FRACTIONBITS-1);

	sprite->scale=scale << FRACTIONBITS;
	sprite->dx= ( (endx-x) << FRACTIONBITS ) / duration;
	sprite->dy= ( (endy-y) << FRACTIONBITS ) / duration;
	sprite->dscale= ( (endscale-scale) << FRACTIONBITS ) / duration;

	return sprite;
}

/*
===============
=
= SpawnCinematicBack
=
===============
*/

backevent * SpawnCinematicBack ( char * name,
											int duration,
											int width,
											int startx,
											int endx,
											int yoffset
										 )
{
	backevent * back;

	back = SafeMalloc ( sizeof (backevent) );

	// copy name of back

	strcpy ( back->name, name );

	// copy rest of back information

	back->duration = duration;
	back->backdropwidth = width;
	back->dx = ((endx-startx) << FRACTIONBITS)/duration;
	back->currentoffset = startx << FRACTIONBITS;
	back->yoffset=yoffset;

	return back;
}

/*
===============
=
= SpawnCinematicMultiBack
=
===============
*/

backevent * SpawnCinematicMultiBack ( char * name,
												  char * name2,
												  int duration,
												  int startx,
												  int endx,
												  int yoffset
												)
{
	backevent * back;
	lpic_t * pic1;
	lpic_t * pic2;

	pic1=(lpic_t *)W_CacheLumpName(name,PU_CACHE);
	pic2=(lpic_t *)W_CacheLumpName(name2,PU_CACHE);

	back = SafeMalloc ( sizeof (backevent) );

	// copy name of back

	strcpy ( back->name, name );

	// copy rest of back information

	back->duration = duration;
	back->dx = ((endx-startx) << FRACTIONBITS)/duration;
	back->currentoffset = startx << FRACTIONBITS;
	back->yoffset=yoffset;
	if (pic1->height != pic2->height)
		{
		Error("SpawnCinematicMultiBack: heights are not the same\n"
				"								 name1=%s name2=%s\n",name,name2);
		}
	back->backdropwidth=pic1->width+pic2->width;
	back->height=pic1->height;
	back->data=SafeMalloc (back->backdropwidth*back->height);
	memcpy( back->data, &(pic1->data), pic1->width*pic1->height);
	memcpy( back->data+(pic1->width*pic1->height),
			  &(pic2->data),
			  pic2->width*pic2->height
			);
	return back;
}

/*
===============
=
= SpawnCinematicPalette
=
===============
*/

paletteevent * SpawnCinematicPalette ( char * name )
{
	paletteevent * palette;

	palette = SafeMalloc ( sizeof (paletteevent) );

	// copy name of palette

	strcpy ( palette->name, name );

	return palette;
}


/*
=================
=
= ScaleFilmPost
=
=================
*/
// void ScaleFilmPost (byte * src, byte * buf)
void ScaleFilmPost (byte * src, unsigned buf)
{
	int  offset;
	int  length;
	int  topscreen;
	int  bottomscreen;


	offset=*(src++);
	for (;offset!=255;)
		{
		length=*(src++);
		topscreen = cin_sprtopoffset + (cin_invscale*offset);
		bottomscreen = topscreen + (cin_invscale*length);
		cin_yl = (topscreen+FRACTIONUNIT-1)>>FRACTIONBITS;
		cin_yh = (bottomscreen-FRACTIONUNIT)>>FRACTIONBITS;
		if (cin_yh >= MAXSCREENHEIGHT)
			cin_yh = MAXSCREENHEIGHT-1;
		if (cin_yl < 0)
			cin_yl = 0;
		if (cin_yl <= cin_yh)
			{
			cin_source=src-offset;
			R_DrawFilmColumn (buf);
			}
		src+=length;
		offset=*(src++);
		}

}

/*
=================
=
= DrawFlic
=
=================
*/
void DrawFlic ( flicevent * flic )
{
	byte * curpal;
	byte * buf;
	char flicname[40];

	curpal = SafeMalloc (768);

	CinematicGetPalette (curpal);

	DrawCinFadeout ( );

	if (flic->usefile==false)
	{
		buf=W_CacheLumpName(flic->name,PU_CACHE);
		strcpy(flicname,flic->name);
	}
	else
	{
		strcpy(flicname,flic->name);
		strcat(flicname,".fli");
	}

// med
//	PlayFlic ( flicname, buf, flic->usefile, flic->loop);

	if (flic->loop==true)
		ClearCinematicAbort();

	DrawCinFadeout ( );

	DrawBlankScreen ( );

	VL_SetVGAPlaneMode ();

	CinematicSetPalette (curpal);

	SafeFree (curpal);
	GetCinematicTics ();
	GetCinematicTics ();
}

/*
=================
=
= PrecacheFlic
=
=================
*/

void PrecacheFlic (flicevent * flic)
{
	if (flic->usefile==false)
	{
		W_CacheLumpName(flic->name,PU_CACHE);
	}
}

/*
===============
=
= DrawCinematicBackground
=
===============
*/

void DrawCinematicBackground ( backevent * back )
{
	byte * src;
//	byte * buf;
	int	buf;
	lpic_t * pic;
	int i;
	int plane;
	int offset;
	int height;

	pic=(lpic_t *)W_CacheLumpName(back->name,PU_CACHE);

	height = pic->height;
	if (height+back->yoffset>MAXSCREENHEIGHT)
		height=MAXSCREENHEIGHT-back->yoffset;

	if (height!=MAXSCREENHEIGHT)
		DrawClearBuffer ();

	for (plane=0;plane<4;plane++)
		{
//		buf=(byte *)bufferofs+ylookup[back->yoffset];
		buf=bufferofs+ylookup[back->yoffset];
		offset=(back->currentoffset>>FRACTIONBITS)+plane;

		VGAWRITEMAP(plane);

		for (i=plane;i<MAXSCREENWIDTH;i+=4,offset+=4,buf++)
			{
			if (offset>=back->backdropwidth)
				src=&(pic->data) + ( (offset - back->backdropwidth) * (pic->height) );
			else if (offset<0)
				src=&(pic->data) + ( (offset + back->backdropwidth) * (pic->height) );
			else
				src=&(pic->data) + ( offset * (pic->height) );
			DrawFilmPost(buf,src,height);
			}
		}
}

/*
===============
=
= DrawCinematicMultiBackground
=
===============
*/

void DrawCinematicMultiBackground ( backevent * back )
{
	byte * src;
//	byte * buf;
	unsigned buf;
	int i;
	int plane;
	int offset;
	int height;

	height = back->height;
	if (height+back->yoffset>MAXSCREENHEIGHT)
		height=MAXSCREENHEIGHT-back->yoffset;

	if (height!=MAXSCREENHEIGHT)
		DrawClearBuffer ();

	for (plane=0;plane<4;plane++)
		{
//		buf=(byte *)bufferofs+ylookup[back->yoffset];
		buf=bufferofs+ylookup[back->yoffset];
		offset=(back->currentoffset>>FRACTIONBITS)+plane;

		VGAWRITEMAP(plane);

		for (i=plane;i<MAXSCREENWIDTH;i+=4,offset+=4,buf++)
			{
			if (offset>=back->backdropwidth)
				src=back->data + ( (offset - back->backdropwidth) * (back->height) );
			else if (offset<0)
				src=back->data + ( (offset + back->backdropwidth) * (back->height) );
			else
				src=back->data + ( offset * (back->height) );
			DrawFilmPost(buf,src,height);
			}
		}
}

/*
===============
=
= DrawCinematicBackdrop
=
===============
*/

void DrawCinematicBackdrop ( backevent * back )
{
	byte * src;
	byte * shape;
//	byte * buf;
	unsigned buf;
	patch_t * p;
	int i;
	int plane;
	int offset;
	int postoffset;
	int postlength;
	int toppost;

	shape=W_CacheLumpName(back->name,PU_CACHE);
	p=(patch_t *)shape;

	toppost=-p->topoffset+back->yoffset;

	for (plane=0;plane<4;plane++)
		{
//		buf=(byte *)bufferofs;
		buf=bufferofs;
		offset=(back->currentoffset>>FRACTIONBITS)+plane;

		VGAWRITEMAP(plane);

		for (i=plane;i<MAXSCREENWIDTH;i+=4,offset+=4,buf++)
			{
			if (offset>=back->backdropwidth)
				src = shape + p->collumnofs[offset - back->backdropwidth];
			else if (offset<0)
				src=shape + p->collumnofs[offset + back->backdropwidth];
			else
				src = shape + p->collumnofs[offset];

			postoffset=*(src++);
			for (;postoffset!=255;)
				{
				postlength=*(src++);
				DrawFilmPost(buf + ylookup[toppost+postoffset],src,postlength);
				src+=postlength;
				postoffset=*(src++);
				}
			}
		}
}

/*
=================
=
= PrecacheBack
=
=================
*/
void PrecacheBack ( backevent * back )
{
	W_CacheLumpName( back->name, PU_CACHE);
}


/*
=================
=
= DrawCinematicSprite
=
=================
*/
void DrawCinematicSprite ( spriteevent * sprite )
{
	byte	*shape;
	int	 frac;
	patch_t *p;
	int	 x1,x2;
	int	 tx;
	int	 xcent;
//	byte * buf;
	unsigned buf;
	int	 height;

	height = sprite->scale >> FRACTIONBITS;

	if (height<2)
		return;

	shape=W_CacheLumpNum( W_GetNumForName(sprite->name)+sprite->frame, PU_CACHE);
	p=(patch_t *)shape;

	cin_ycenter=sprite->y >> FRACTIONBITS;
	cin_invscale = (height<<FRACTIONBITS)/p->origsize;
//	buf=(byte *)bufferofs;
	buf=bufferofs;
	tx=-p->leftoffset;
	xcent=(sprite->x & 0xffff0000)-(height<<(FRACTIONBITS-1))+(FRACTIONUNIT>>1);

//
// calculate edges of the shape
//
	x1 = (xcent+(tx*cin_invscale))>>FRACTIONBITS;
	if (x1 >= MAXSCREENWIDTH)
		return;					// off the right side
	tx+=p->width;
	x2 = ((xcent+(tx*cin_invscale)) >>FRACTIONBITS) - 1 ;
	if (x2 < 0)
		return;			// off the left side

	cin_iscale=(p->origsize<<FRACTIONBITS)/height;

	if (x1<0)
		{
		frac=cin_iscale*(-x1);
		x1=0;
		}
	else
		frac=0;
	x2 = x2 >= MAXSCREENWIDTH ? (MAXSCREENWIDTH-1) : x2;

	cin_texturemid = (((p->origsize>>1)+p->topoffset)<<FRACTIONBITS)+(FRACTIONUNIT>>1);
	cin_sprtopoffset = (cin_ycenter<<16) - FixedMul(cin_texturemid,cin_invscale);

	for (; x1<=x2 ; x1++, frac += cin_iscale)
	  {
	  VGAWRITEMAP(x1&3);
	  ScaleFilmPost(((p->collumnofs[frac>>FRACTIONBITS])+shape),buf+(x1>>2));
	  }
}

/*
=================
=
= PrecacheCinematicSprite
=
=================
*/
void PrecacheCinematicSprite ( spriteevent * sprite )
{
	int i;

	for (i=0;i<sprite->numframes;i++)
	{
		W_CacheLumpNum( W_GetNumForName(sprite->name)+i, PU_CACHE);
	}
}


/*
=================
=
= DrawPalette
=
=================
*/

void DrawPalette (paletteevent * event)
{
	byte * pal;

	pal=W_CacheLumpName(event->name,PU_CACHE);
	XFlipPage ();
	CinematicSetPalette (pal);
}

/*
=================
=
= PrecachePalette
=
=================
*/

void PrecachePalette (paletteevent * event)
{
	W_CacheLumpName(event->name,PU_CACHE);
}


/*
=================
=
= DrawCinFadeout
=
=================
*/
#define FADEOUTTIME 20

void DrawCinFadeout ( void )
{
	byte origpal[768];
	byte newpal[768];
	int		i,j;

	CinematicGetPalette (&origpal[0]);
	for (j = 0; j < FADEOUTTIME; j++)
		{
		for (i = 0; i < 768; i++)
			{
			newpal[i] = ( origpal[i] * (FADEOUTTIME - j - 1) ) / FADEOUTTIME;
			}
		WaitVBL();
		CinematicSetPalette (&newpal[0]);
		CinematicDelay();
		}
	VL_ClearVideo (0);
	GetCinematicTics ();
	GetCinematicTics ();
}

/*
=================
=
= DrawBlankScreen
=
=================
*/
void DrawBlankScreen ( void )
{
	VL_ClearVideo (0);
}

/*
=================
=
= DrawClearBuffer
=
=================
*/
void DrawClearBuffer ( void )
{
  VGAMAPMASK(15);
//  memset((byte *)bufferofs,0,SCREENBWIDE*MAXSCREENHEIGHT);
  VGAMEMSET(bufferofs,0,SCREENBWIDE*MAXSCREENHEIGHT);
}

/*
===============
=
= UpdateCinematicBack
=
===============
*/

boolean UpdateCinematicBack ( backevent * back )
{
	back->duration--;

	if (back->duration<0)
		return false;

	back->currentoffset += back->dx;

	return true;
}

/*
=================
=
= UpdateCinematicSprite
=
=================
*/
boolean UpdateCinematicSprite ( spriteevent * sprite )
{
	sprite->duration--;

	if (sprite->duration<0)
		return false;

	sprite->framedelay--;

	if (sprite->framedelay==0)
		{
		sprite->frame++;
		if (sprite->frame==sprite->numframes)
			sprite->frame=0;
		sprite->framedelay=sprite->frametime;
		}

	sprite->x+=sprite->dx;
	sprite->y+=sprite->dy;
	sprite->scale+=sprite->dscale;

	return true;
}

/*
=================
=
= UpdateCinematicEffect
=
=================
*/
boolean UpdateCinematicEffect ( enum_eventtype type, void * effect )
{
	switch (type)
		{
		case background_noscrolling:
		case background_scrolling:
		case backdrop_scrolling:
		case backdrop_noscrolling:
		case background_multi:
			return UpdateCinematicBack ( (backevent *) effect );
			break;
		case sprite_background:
		case sprite_foreground:
			return UpdateCinematicSprite ( (spriteevent *) effect );
			break;
		case flic:
			return true;
			break;
		case palette:
		case fadeout:
		case blankscreen:
		case clearbuffer:
			return true;
			break;
		case cinematicend:
			cinematicdone=true;
			return true;
			break;
		}
	return true;
}
/*
=================
=
= DrawCinematicEffect
=
=================
*/
boolean DrawCinematicEffect ( enum_eventtype type, void * effect )
{
	switch (type)
		{
		case background_noscrolling:
		case background_scrolling:
			DrawCinematicBackground ( (backevent *) effect );
			return true;
			break;
		case background_multi:
			DrawCinematicMultiBackground ( (backevent *) effect );
			return true;
			break;
		case backdrop_scrolling:
		case backdrop_noscrolling:
			DrawCinematicBackdrop ( (backevent *) effect );
			return true;
			break;
		case sprite_background:
		case sprite_foreground:
			DrawCinematicSprite ( (spriteevent *) effect );
			return true;
			break;
		case flic:
			DrawFlic ( (flicevent *) effect );
			return false;
			break;
		case palette:
			DrawPalette ( (paletteevent *) effect );
			return false;
			break;
		case fadeout:
			DrawCinFadeout ();
			return false;
			break;
		case blankscreen:
			DrawBlankScreen ();
			return false;
			break;
		case clearbuffer:
			DrawClearBuffer ();
			return false;
			break;
		case cinematicend:
			return true;
			break;
		}
	return true;
}

/*
=================
=
= PrecacheCinematicEffect
=
=================
*/
void PrecacheCinematicEffect ( enum_eventtype type, void * effect )
{
	switch (type)
		{
		case background_noscrolling:
		case background_scrolling:
		case backdrop_scrolling:
		case backdrop_noscrolling:
			PrecacheBack ( (backevent *) effect );
			break;
		case sprite_background:
		case sprite_foreground:
			PrecacheCinematicSprite ( (spriteevent *) effect );
			break;
		case palette:
			PrecachePalette ( (paletteevent *) effect );
			break;
		case flic:
			PrecacheFlic ( (flicevent *) effect );
			break;
		}
}

/*
===============
=
= ProfileDisplay
=
===============
*/

void ProfileDisplay ( void )
{
//	byte * buf;
	unsigned buf;
	int i;
	int plane;
	byte src[200];

	DrawClearBuffer ();

	for (plane=0;plane<4;plane++)
		{
//		buf=(byte *)bufferofs;
		buf=bufferofs;
		VGAWRITEMAP(plane);

		for (i=plane;i<MAXSCREENWIDTH;i+=4,buf++)
			{
			DrawFilmPost(buf,&src[0],200);
			}
		}
}

/*
===============
=
= DrawPostPic
=
===============
*/

void DrawPostPic ( int lumpnum )
{
	byte * src;
//	byte * buf;
	unsigned buf;
	lpic_t * pic;
	int i;
	int plane;
	int height;

	pic=(lpic_t *)W_CacheLumpNum(lumpnum,PU_CACHE);

	height = pic->height;

	for (plane=0;plane<4;plane++)
		{
//		buf=(byte *)bufferofs;
		buf=bufferofs;

		src=&(pic->data) + (plane*pic->height);

		VGAWRITEMAP(plane);

		for (i=plane;i<MAXSCREENWIDTH;i+=4,src+=(pic->height<<2),buf++)
			{
			DrawFilmPost(buf,src,height);
			}
		}
}

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "cin_glob.h"
#include "cin_evnt.h"
#include "cin_efct.h"
#include "cin_actr.h"
#include "cin_def.h"
#include "scriplib.h"
#include "lumpy.h"
#include "w_wad.h"
#include "z_zone.h"
#include <string.h>
//MED
// #include "memcheck.h"

eventtype * firstevent;
eventtype * lastevent;

// LOCALS

static int numevents=0;
static boolean eventsystemstarted=false;


/*
===============
=
= AddEvent
=
===============
*/

void AddEvent (eventtype * event)
{
   if (!firstevent)
      firstevent  = event;
   else
      {
      event->prev = lastevent;
      lastevent->next = event;
      }
   lastevent = event;
}


/*
===============
=
= DeleteEvent
=
===============
*/

void DeleteEvent(eventtype * event)
{
   if (event == lastevent)
      lastevent = event->prev;
   else
      event->next->prev = event->prev;

   if (event == firstevent)
      firstevent = event->next;
   else
      event->prev->next = event->next;

   event->prev = NULL;
   event->next = NULL;

   SafeFree ( event );
}

/*
===============
=
= GetNewEvent
=
===============
*/

eventtype * GetNewEvent ( void )
{
   eventtype * event;

   numevents++;

   if ( numevents > MAXCINEMATICEVENTS )
      Error ("Too many Cinematic events\n");

   event = SafeMalloc( sizeof (eventtype) );

   event->next=NULL;
   event->prev=NULL;

   return event;
}

/*
===============
=
= StartupEvents
=
===============
*/

void StartupEvents ( void )
{
   if (eventsystemstarted==true)
      return;
   eventsystemstarted=true;
   firstevent = NULL;
   lastevent  = NULL;

   numevents=0;
}

/*
===============
=
= ShutdownEvents
=
===============
*/

void ShutdownEvents ( void )
{
   eventtype * event;

   if (eventsystemstarted==false)
      return;
   eventsystemstarted=false;

   event=firstevent;
   while (event != NULL)
      {
      eventtype * nextevent;

      nextevent=event->next;
      DeleteEvent(event);
      event=nextevent;
      }
}

/*
===============
=
= CreateEvent
=
===============
*/
eventtype * CreateEvent ( int time, int type )
{
   eventtype * event;

   event = GetNewEvent ();

   event->time = time;
   event->effecttype = type;
   event->effect = NULL;

   AddEvent (event);

   return event;
}

/*
===============
=
= GetEventType
=
= Gets event type from token
=
===============
*/
enum_eventtype GetEventType ( void )
{
   // Get Event Token

   GetToken (false);

   if (!strcmpi (token,"BACKGROUND"))
      {
      GetToken (false);
      if (!strcmpi (token,"SCROLL"))
         {
         return background_scrolling;
         }
      else if (!strcmpi (token,"NOSCROLL"))
         {
         return background_noscrolling;
         }
      else if (!strcmpi (token,"MULTISCROLL"))
         {
         return background_multi;
         }
      else
         {
         Error("Illegal Background Scrolling token\n");
         }
      }
   else if (!strcmpi (token,"BACKDROP"))
      {
      GetToken (false);
      if (!strcmpi (token,"SCROLL"))
         {
         return backdrop_scrolling;
         }
      else if (!strcmpi (token,"NOSCROLL"))
         {
         return backdrop_noscrolling;
         }
      else
         {
         Error("Illegal Backdrop Scrolling token\n");
         }
      }
   else if (!strcmpi (token,"BACKGROUNDSPRITE"))
      {
      return sprite_background;
      }
   else if (!strcmpi (token,"FOREGROUNDSPRITE"))
      {
      return sprite_foreground;
      }
   else if (!strcmpi (token,"PALETTE"))
      {
      return palette;
      }
   else if (!strcmpi (token,"FADEOUT"))
      {
      return fadeout;
      }
   else if (!strcmpi (token,"FLIC"))
      {
      return flic;
      }
   else if (!strcmpi (token,"MOVIEEND"))
      {
      return cinematicend;
      }
   else if (!strcmpi (token,"BLANKSCREEN"))
      {
      return blankscreen;
      }
   else if (!strcmpi (token,"CLEARBUFFER"))
      {
      return clearbuffer;
      }
   else
      {
      Error("GetEventType: Illegal Token %s\n",token);
      }
   return -1;
}

/*
===============
=
= ParseBack
=
===============
*/
void ParseBack ( eventtype * event )
{
   char name[10];
   char name2[10];
   int duration;
   int yoffset;
   int width;
   int startx;
   int endx;

   GetToken (false);
   strcpy(&(name[0]),token);

   if (event->effecttype==background_multi)
      {
      GetToken (false);
      strcpy(&(name2[0]),token);
      }

   GetToken (false);
   duration=ParseNum(token);
   GetToken (false);
   yoffset=ParseNum(token);
   if (
       (event->effecttype==background_noscrolling) ||
       (event->effecttype==background_scrolling)
      )
      {
      lpic_t * lpic;

      lpic = (lpic_t *)W_CacheLumpName(name,PU_CACHE);
      width = lpic->width;
      }
   else if (event->effecttype!=background_multi)
      {
      patch_t * patch;

      patch = (patch_t *)W_CacheLumpName(name,PU_CACHE);
      width = patch->width;
      }

   startx=0;
   endx=0;
   if (
       (event->effecttype==backdrop_scrolling) ||
       (event->effecttype==background_scrolling) ||
       (event->effecttype==background_multi)
      )
      {
      GetToken (false);
      startx=ParseNum(token);
      GetToken (false);
      endx=ParseNum(token);
      }

   if (event->effecttype==background_multi)
      event->effect = SpawnCinematicMultiBack ( name, name2, duration, startx, endx, yoffset);
   else
      event->effect = SpawnCinematicBack ( name, duration, width, startx, endx, yoffset);
}

/*
===============
=
= ParseSprite
=
===============
*/
void ParseSprite ( eventtype * event )
{
   char name[10];
   int duration;
   int numframes;
   int framedelay;
   int x,y,scale;
   int endx,endy,endscale;

   GetToken (false);
   strcpy(&(name[0]),token);
   GetToken (false);
   duration=ParseNum(token);
   GetToken (false);
   numframes=ParseNum(token);
   GetToken (false);
   framedelay=ParseNum(token);
   GetToken (false);
   x=ParseNum(token);
   GetToken (false);
   y=ParseNum(token);
   GetToken (false);
   scale=ParseNum(token);
   GetToken (false);
   endx=ParseNum(token);
   GetToken (false);
   endy=ParseNum(token);
   GetToken (false);
   endscale=ParseNum(token);

   event->effect = SpawnCinematicSprite ( name, duration, numframes,
                                          framedelay, x, y, scale,
                                          endx, endy, endscale
                                        );
}

/*
===============
=
= ParseFlic
=
===============
*/
void ParseFlic ( eventtype * event )
{
   char name[10];
   boolean loop;
   boolean usefile;

   GetToken (false);
   strcpy(&(name[0]),token);

   GetToken (false);
   if (!strcmpi (token,"LOOP"))
      {
      loop = true;
      }
   else if (!strcmpi (token,"NOLOOP"))
      {
      loop = false;
      }
   else
      Error("ParseFlic: Illegal or missing flic loop token %s\n",token);

   GetToken (false);
   if (!strcmpi (token,"FILE"))
      {
      usefile=true;
      }
   else if (!strcmpi (token,"LUMP"))
      {
      usefile=false;
      }
   else
      Error("ParseFlic: Illegal or missing flic use token %s\n",token);

   event->effect = SpawnCinematicFlic ( name, loop, usefile );
}

/*
===============
=
= ParsePalette
=
===============
*/
void ParsePalette ( eventtype * event )
{
   char name[10];

   GetToken (false);
   strcpy(&(name[0]),token);

   event->effect = SpawnCinematicPalette ( name );
}

/*
===============
=
= ParseEvent
=
===============
*/
void ParseEvent ( int time )
{
   eventtype * event;

   event = CreateEvent ( time, GetEventType() );

   switch (event->effecttype)
      {
      case background_noscrolling:
      case background_scrolling:
      case background_multi:
      case backdrop_scrolling:
      case backdrop_noscrolling:
         ParseBack(event);
         break;
      case sprite_background:
      case sprite_foreground:
         ParseSprite(event);
         break;
      case palette:
         ParsePalette(event);
         break;
      case flic:
         ParseFlic(event);
         break;
      case fadeout:
      case blankscreen:
      case clearbuffer:
      case cinematicend:
         break;
      }
}

/*
===============
=
= UpdateCinematicEvents
=
===============
*/
void UpdateCinematicEvents ( int time )
{
   eventtype * event;

   for (event=firstevent;event != NULL;)
      {
      if (event->time==time)
         {
         eventtype * nextevent;

         nextevent=event->next;
         SpawnCinematicActor ( event->effecttype, event->effect );
         DeleteEvent(event);
         event=nextevent;
         }
      else if (event->time>time)
         break;
      else
         event=event->next;
      }
}

/*
===============
=
= PrecacheCinematic
=
===============
*/
void PrecacheCinematic ( void )
{
   eventtype * event;

   for (event=firstevent;event != NULL;)
      {
      PrecacheCinematicEffect ( event->effecttype, event->effect );
      event=event->next;
      }
}

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "cin_glob.h"
#include "rt_in.h"
#include "rt_draw.h"
#include "isr.h"
//MED
// #include "memcheck.h"

void CinematicDelay ( void )
{
	CalcTics();
}

int GetCinematicTime ( void )
{
	I_PollTimer();
	return ticcount;
}

boolean CinematicAbort( void )
{
	return (IN_CheckAck ());
}

void ClearCinematicAbort( void )
{
	IN_StartAck ();
}

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// #include <malloc.h>
// #include <dos.h>
#include <stdio.h>
#include <stdlib.h>
// #include <fcntl.h>
// #include <io.h>
// #include <conio.h>
#include <string.h>
#include "cin_glob.h"
#include "scriplib.h"
#include "watcom.h"
#include "z_zone.h"
#include "w_wad.h"
#include "cin_main.h"
#include "modexlib.h"
#include "lumpy.h"

#include "cin_actr.h"
#include "cin_evnt.h"
#include "cin_efct.h"
//MED
// #include "memcheck.h"

int cin_yl;
int cin_yh;
int cin_ycenter;
int cin_iscale;
int cin_texturemid;
byte * cin_source;

boolean cinematicdone;
static int cinematictime;
static int cinematictics;
static int cinematictictime;
static int profiletics=-1;

/*
================
=
= ProfileMachine
=
================
*/
void ProfileMachine ( void )
{
   int i;
   int time;
   int endtime;

   if (profiletics>0)
      return;
   time=GetCinematicTime();
   for (i=0;i<4;i++)
      {
      ProfileDisplay();
      }
   endtime=GetCinematicTime();

   profiletics = (endtime-time)>>2;
   if (profiletics<1)
      profiletics=1;
}

/*
================
=
= StartupCinematic
=
================
*/
void StartupCinematic ( void )
{
   StartupEvents ();
   StartupCinematicActors ();
   cinematicdone=false;
   cinematictime=0;
   GetCinematicTics ();
   ClearCinematicAbort();
   ProfileMachine();
}


/*
================
=
= ShutdownCinematic
=
================
*/
void ShutdownCinematic ( void )
{
   ShutdownEvents ();
   ShutdownCinematicActors ();
}


/*
================
=
= ParseCinematicScript
=
================
*/

void ParseCinematicScript (void)
{
   int time;

   time=0;
   do
      {
      //
      // get next command time
      //
      GetToken (true);
      if (endofscript)
         break;
      time+=ParseNum(token);
      ParseEvent ( time );
      }
   while (script_p < scriptend_p);
}


/*
==============
=
= CacheScriptFile
=
==============
*/

void CacheScriptFile (char *filename)
{
	long            size;
   int lump;

   lump=W_GetNumForName(filename);

   scriptbuffer=W_CacheLumpNum(lump,PU_CACHE);
	size = W_LumpLength(lump);

	script_p = scriptbuffer;
	scriptend_p = script_p + size;
	scriptline = 1;
	endofscript = false;
	tokenready = false;
}


/*
=================
=
= GrabCinematicScript
=
=================
*/

void GrabCinematicScript (char const *basename, boolean uselumpy)
{
   char script[256];

//
// read in the script file
//
   strcpy (script, basename);
   strcat (script,".ms");
   if (uselumpy==false)
      LoadScriptFile (script);
   else
      CacheScriptFile ((char *)basename);

   ParseCinematicScript ();
}

/*
==============
=
= GetCinematicTics
=
==============
*/

void GetCinematicTics ( void )
{
   int time;

   time=GetCinematicTime();
   while (time==cinematictictime)
      {
      time=GetCinematicTime();
      }
   cinematictics=(time-cinematictictime);
   cinematictictime=time;
   cinematictics=profiletics;
}


void PlayMovie ( char * name, boolean uselumpy )
{
   int i;

   StartupCinematic ( );
   GrabCinematicScript (name, uselumpy);

   PrecacheCinematic ( );
   GetCinematicTics();
   while (cinematicdone==false)
      {
      cinematicdone=CinematicAbort();
#if DUMP
      printf("time=%ld\n",cinematictime);
#endif
      for (i=0;i<cinematictics;i++)
         {
         UpdateCinematicEvents ( cinematictime );
         UpdateCinematicActors ( );
         cinematictime++;
         }
      DrawCinematicActors ();
      GetCinematicTics();
      }

   ShutdownCinematic ();
}
































































/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "cin_glob.h"
#include "modexlib.h"
// #include <conio.h>
//MED
// #include "memcheck.h"

/*
==============
=
= CinematicGetPalette
=
= Return an 8 bit / color palette
=
==============
*/

void CinematicGetPalette (byte *pal)
{
	int	i;

//   outp (PEL_READ_ADR,0);
//	for (i=0 ; i<768 ; i++)
//      pal[i] = ((inp (PEL_DATA))<<2);

	VL_GetPalette(pal);
}

/*
==============
=
= CinematicSetPalette
=
= Sets an 8 bit / color palette
=
==============
*/

void CinematicSetPalette (byte *pal)
{
	int	i;

	VL_SetPalette(pal);
//   outp (PEL_WRITE_ADR,0);
//	for (i=0 ; i<768 ; i++)
//      outp (PEL_DATA, pal[i]>>2);
}


/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "watcom.h"
#include "engine.h"
#include "_engine.h"
#include "rt_eng.h"
#include "rt_draw.h"
#include "rt_door.h"
#include "rt_stat.h"
#include "rt_ted.h"
#include "rt_view.h"
#include <stdlib.h>
//MED
// #include "memcheck.h"


/*
=============================================================================

Global Variables																																											GLOBAL VARIABLES

=============================================================================
*/

wallcast_t posts[321];
int lasttilex;
int lasttiley;
/*
=============================================================================

Local Variables																																											GLOBAL VARIABLES

=============================================================================
*/

static int xtilestep,ytilestep;
static int c_vx,c_vy;



void Interpolate (int x1, int x2)
{
	int i;
	int dtexture;
	int frac;
	int dheight;
	int hfrac;
	int dx;

	dx=x2-x1;
	dtexture=(((posts[x2].texture-posts[x1].texture)<<12)+0x800)/dx;
	dheight=(((posts[x2].wallheight-posts[x1].wallheight)<<8)+0x80)/dx;
	frac=dtexture+(posts[x1].texture<<12);
	hfrac=dheight+(posts[x1].wallheight<<8);
	for (i=x1+1;i<=x2-1;i++,frac+=dtexture,hfrac+=dheight)
	{
		posts[i].lump=posts[x1].lump;
		posts[i].posttype=posts[x1].posttype;
		posts[i].offset=posts[x1].offset;
		posts[i].alttile=posts[x1].alttile;
		posts[i].texture=(frac>>12);
		posts[i].wallheight=hfrac>>8;
	}
}

void Refresh ( void )
{
	int x;

// Cast Initial comb filter

	InitialCast();

	for (x=0;x<=viewwidth-4;x+=4)
		{
		if NOTSAMETILE(x,x+4)
			{
			Cast(x+2);
			if NOTSAMETILE(x,x+2)
				{
				Cast(x+1);
				}
			else
				Interpolate (x,x+2);
			if NOTSAMETILE(x+2,x+4)
				{
				Cast(x+3);
				}
			else
				Interpolate (x+2,x+4);
			}
		else
			Interpolate(x,x+4);
		}
}

static int rte_wrapxcnt[2];

void HitWall(int curx, int vertical, int xtile, int ytile)
{
	int xtile1, ytile1, xti, yti, xtd, ytd;
	int num;

	posts[curx].offset=(xtile<<7)+ytile;
	posts[curx].lump = tilemap[xtile][ytile];
	posts[curx].alttile=0;
	posts[curx].posttype=0;

	xtile1=xtile;
	ytile1=ytile;
	
	xtile1+=rte_wrapxcnt[0]*MAPSIZE;
	ytile1+=rte_wrapxcnt[1]*MAPSIZE;

#if 0
	xti=viewx>>16;
	yti=viewy>>16;
	xti&=(MAPSIZE-1);		//BGB: debug
	yti&=(MAPSIZE-1);		//BGB: debug

	if			((xtilestep>0) && (xtile<xti))xtile1+=128;
	else if	((xtilestep<0) && (xtile>xti))xtile1-=128;
	if			((ytilestep>0) && (ytile<yti))ytile1+=128;
	else if	((ytilestep<0) && (ytile>yti))ytile1-=128;
	
	xtd=xtile1-xti;
	ytd=ytile1-yti;
	num=(xtd^(xtd>>16))+(ytd^(ytd>>16));
	if(num>192)
	{
		posts[curx].wallheight=0;
		return;
	}
#endif

	if (vertical<0)
	{
		xintercept=xtile1<<16;
		if (xtilestep<0)
			xintercept+=0xffff;
		yintercept=FixedScale(xintercept-viewx,c_vy,c_vx)+viewy;
		if (posts[curx].lump & 0x4000)
		{
			xti=(xtile-(xtilestep>>7))&(MAPSIZE-1);
			if (tilemap[xti][ytile]&0x8000)
			{
				num=tilemap[xti][ytile];
				if (num&0x4000)
				{
					if (maskobjlist[num&0x3ff]->sidepic)
						posts[curx].lump = maskobjlist[num&0x3ff]->sidepic;
					else
						posts[curx].lump &= 0x3ff;
				}
				else
					posts[curx].lump = doorobjlist[num&0x3ff]->sidepic;
			}
			else
			{
				if (posts[curx].lump&0x1000)
					posts[curx].lump=animwalls[posts[curx].lump&0x3ff].texture;
				else
					posts[curx].lump &= 0x3ff;
			}
		}
		else if (posts[curx].lump & 0x2000)
		{
			if (IsWindow(xtile,ytile))
				posts[curx].alttile=-1;
			else
				posts[curx].alttile=(MAPSPOT(xtile,ytile,2))+1;
			posts[curx].lump &= 0x3ff;
		}
		else if (posts[curx].lump & 0x1000)
		{
			posts[curx].lump=animwalls[posts[curx].lump&0x3ff].texture;
		}
		else if (posts[curx].lump & 0x800)
		{
			posts[curx].lump &= 0x3ff;
			posts[curx].posttype=2;
		}
		posts[curx].texture=yintercept-(ytile1<<16);
//		posts[curx].texture&=0xffff;
		if (posts[curx].texture<0)
			posts[curx].texture=0;
		if (posts[curx].texture>65535)
			posts[curx].texture=65535;
		if (xtilestep<0)
			posts[curx].texture^=0xffff;
		posts[curx].posttype+=1;
//		posts[curx].texture=(posts[curx].texture+firstcoloffset)&65535;
	}
	else
	{
		yintercept=ytile1<<16;
		if (ytilestep<0)
			yintercept+=0xffff;
		xintercept=FixedScale(yintercept-viewy,c_vx,c_vy)+viewx;
		if (posts[curx].lump & 0x4000)
		{
			// check for adjacent doors
			yti=(ytile-ytilestep)&(MAPSIZE-1);
			if (tilemap[xtile][yti]&0x8000)
			{
				num=tilemap[xtile][yti];
				if (num&0x4000)
				{
					if (maskobjlist[num&0x3ff]->sidepic)
						posts[curx].lump = maskobjlist[num&0x3ff]->sidepic;
					else
						posts[curx].lump &= 0x3ff;
				}
				else
					posts[curx].lump = doorobjlist[num&0x3ff]->sidepic;
			}
			else
			{
				if (posts[curx].lump&0x1000)
					posts[curx].lump=animwalls[posts[curx].lump&0x3ff].texture;
				else
					posts[curx].lump &= 0x3ff;
			}
		}
		else if (posts[curx].lump & 0x2000)
		{
			if (IsWindow(xtile,ytile))
				posts[curx].alttile=-1;
			else
				posts[curx].alttile=(MAPSPOT(xtile,ytile,2))+1;
			posts[curx].lump &= 0x3ff;
		}
		else if (posts[curx].lump & 0x1000)
		{
			posts[curx].lump=animwalls[posts[curx].lump&0x3ff].texture;
		}
		else if (posts[curx].lump & 0x800)
		{
			posts[curx].lump &= 0x3ff;
			posts[curx].posttype=2;
		}
		posts[curx].texture=xintercept-(xtile1<<16);
//		posts[curx].texture&=0xffff;
		if (posts[curx].texture<0)
			posts[curx].texture=0;
		if (posts[curx].texture>65535)
			posts[curx].texture=65535;
		if (ytilestep>0)
			posts[curx].texture^=0xffff;
//		posts[curx].posttype+=0;
//		posts[curx].texture=(posts[curx].texture+firstcoloffset)&65535;
	}
	posts[curx].wallheight=CalcHeight();
}

void InitialCast ( void )
{
	int snx,sny;
	int incr[2];
	int thedir[2];
	int cnt, nn, tmp1;
	int grid[2];
	int index;
	int curx;

	c_vx=c_startx;
	c_vy=c_starty;
	for (curx=0; curx<=viewwidth; curx+=4)
	{
		snx=viewx&0xffff;
		sny=viewy&0xffff;

		if (c_vx>0)
		{
			thedir[0]=1;
			xtilestep=0x80;
			snx^=0xffff;
			incr[1]=-c_vx;
		}
		else
		{
			thedir[0]=-1;
			xtilestep=-0x80;
			incr[1]=c_vx;
		}
		if (c_vy>0)
		{
			thedir[1]=1;
			ytilestep=1;
			sny^=0xffff;
			incr[0]=c_vy;
		}
		else
		{
			thedir[1]=-1;
			ytilestep=-1;
			incr[0]=-c_vy;
		}

		cnt=FixedMul(snx,incr[0])+FixedMul(sny,incr[1]);
		grid[0]=viewx>>16;
		grid[1]=viewy>>16;
		grid[0]&=(MAPSIZE-1);		//BGB: debug
		grid[1]&=(MAPSIZE-1);		//BGB: debug
		
		rte_wrapxcnt[0]=0;
		rte_wrapxcnt[1]=0;
		
//		nn=512;
		nn=256;
//		nn=128;

		do
		{
			int tile;

			index=(cnt>=0);
			cnt+=incr[index];
			spotvis[grid[0]][grid[1]]=1;

//			grid[index]+=thedir[index];
//			grid[index]&=(MAPSIZE-1);		//BGB: debug

			tmp1=grid[index]+thedir[index];
			if(tmp1&(~(MAPSIZE-1)))
			{
				rte_wrapxcnt[index]+=(tmp1>=0)?1:(-1);
				tmp1&=(MAPSIZE-1);		//BGB: debug
			}
			grid[index]=tmp1;

			if ((tile=tilemap[grid[0]][grid[1]])!=0)
			{
				if (tile&0x8000)
				{
					if ( (!(tile&0x4000)) && doorobjlist[tile&0x3ff] &&
						(doorobjlist[tile&0x3ff]->action==dr_closed))
					{
						spotvis[grid[0]][grid[1]]=1;
						if (doorobjlist[tile&0x3ff]->flags&DF_MULTI)
							MakeWideDoorVisible(tile&0x3ff);
						do
						{
							index=(cnt>=0);
							cnt+=incr[index];
							grid[index]+=thedir[index];
							grid[index]&=(MAPSIZE-1);		//BGB: debug

							if ((tilemap[grid[0]][grid[1]]!=0) &&
								(!(tilemap[grid[0]][grid[1]]&0x8000)) )
								break;
						}
//						while (1);
						while ((--nn)>0);
						break;
					}
					else
						continue;
				}
				else
				{
					mapseen[grid[0]][grid[1]]=1;
					break;
				}
			}
		}
//		while (1);
		while ((--nn)>0);
		if(nn>0)
		{
			HitWall(curx, cnt-incr[index], grid[0], grid[1]);
		}else
		{
			posts[curx].wallheight=0;
		}
		c_vx+=viewsin<<2;
		c_vy+=viewcos<<2;
	}
}


void Cast ( int curx )
{
	int snx,sny;
	int incr[2];
	int thedir[2];
	int cnt, nn, tmp1;
	int grid[2];
	int index;

	c_vx=c_startx+(curx*viewsin);
	c_vy=c_starty+(curx*viewcos);
	snx=viewx&0xffff;
	sny=viewy&0xffff;

	if (c_vx>0)
	{
		thedir[0]=1;
		xtilestep=0x80;
		snx^=0xffff;
		incr[1]=-c_vx;
	}
	else
	{
		thedir[0]=-1;
		xtilestep=-0x80;
		incr[1]=c_vx;
	}
	if (c_vy>0)
	{
		thedir[1]=1;
		ytilestep=1;
		sny^=0xffff;
		incr[0]=c_vy;
	}
	else
	{
		thedir[1]=-1;
		ytilestep=-1;
		incr[0]=-c_vy;
	}

	cnt=FixedMul(snx,incr[0])+FixedMul(sny,incr[1]);
	grid[0]=viewx>>16;
	grid[1]=viewy>>16;
	grid[0]&=(MAPSIZE-1);		//BGB: debug
	grid[1]&=(MAPSIZE-1);		//BGB: debug

	rte_wrapxcnt[0]=0;
	rte_wrapxcnt[1]=0;
		
//	nn=512;
	nn=256;
//	nn=128;
	do
	{
		int tile;

		index=(cnt>=0);
		cnt+=incr[index];
		spotvis[grid[0]][grid[1]]=1;

//		grid[index]+=thedir[index];
//		grid[index]&=(MAPSIZE-1);		//BGB: debug

		tmp1=grid[index]+thedir[index];
		if(tmp1&(~(MAPSIZE-1)))
		{
			rte_wrapxcnt[index]+=((tmp1>>8)>=0)?1:(-1);
			tmp1&=(MAPSIZE-1);		//BGB: debug
		}
		grid[index]=tmp1;

		if ((tile=tilemap[grid[0]][grid[1]])!=0)
		{
			if (tile&0x8000)
			{
				if ( (!(tile&0x4000)) && doorobjlist[tile&0x3ff] &&
					(doorobjlist[tile&0x3ff]->action==dr_closed))
				{
					spotvis[grid[0]][grid[1]]=1;
					if (doorobjlist[tile&0x3ff]->flags&DF_MULTI)
						MakeWideDoorVisible(tile&0x3ff);
					do
					{
						index=(cnt>=0);
						cnt+=incr[index];
						grid[index]+=thedir[index];
						grid[index]&=(MAPSIZE-1);		//BGB: debug
						if ((tilemap[grid[0]][grid[1]]!=0) &&
							(!(tilemap[grid[0]][grid[1]]&0x8000)) )
							break;
					}
					while ((--nn)>0);
//					while (1);
					break;
				}
				else
					continue;
			}
			else
			{
				mapseen[grid[0]][grid[1]]=1;
				break;
			}
		}
	}
//	while (1);
	while ((nn--)>0);
	
	if(nn>0)
	{
		HitWall(curx, cnt-incr[index], grid[0], grid[1]);
	}else
	{
		posts[curx].wallheight=0;
	}
}

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
/* readflic.c - This module contains the routines to read and decompress
 * a flic.  They assume Intel byte ordering,  but otherwise should be
 * fairly portable.  They call machine specific stuff in pcclone.c.
 * This file starts with the low level decompression routines - first
 * for colors and then for pixels.  Then it goes to the higher level
 * exported flic_xxxx routines as prototyped in readflic.h.
 *
 * Copyright (c) 1992 Jim Kent.  This file may be freely used, modified,
 * copied and distributed.  This file was first published as part of
 * an article for Dr. Dobb's Journal March 1993 issue.
 */

#include "cin_glob.h"
#include <errno.h>
#include <string.h>
// #include <io.h>
#include "fli_type.h"
#include "fli_util.h"
#include "fli_def.h"
#include "fli_main.h"
#include "isr.h"
//MED
// #include "memcheck.h"



typedef void ColorOut(Screen *s, int start, Color  *colors, int count);
	/* This is the type of output parameter to our decode_color below.
	* Not coincedently screen_put_color is of this type. */

static void decode_color(Uchar  *data
, Flic *flic, Screen *s, ColorOut *output)
	/* Decode color map.  Put results into output.  The two color
	* compressions are identical except for whether the RGB values
	* are 0-63 or 0-255.  Passing in an output that does the appropriate
	* shifting on the way to the real pallete lets us use the same
	* code for both COLOR_64 and COLOR_256 compression.
	*/
{
	int start = 0;
	Uchar  *cbuf = (Uchar  *)data;
	Short  *wp = (Short  *)cbuf;
	Short ops;
	int count;

	ops = *wp;
	cbuf += sizeof(*wp);
	while (--ops >= 0)
	{
		start += *cbuf++;
		if ((count = *cbuf++) == 0)
			count = 256;
		(*output)(s, start, (Color  *)cbuf, count);
		cbuf += 3*count;
		start += count;
	}
}

static void decode_color_256(Uchar  *data, Flic *flic, Screen *s)
	/* Decode COLOR_256 chunk. */
{
	decode_color(data, flic, s, screen_put_colors);
}

static void decode_color_64(Uchar  *data, Flic *flic, Screen *s)
	/* Decode COLOR_64 chunk. */
{
	decode_color(data, flic, s, screen_put_colors_64);
}


static void decode_byte_run(Uchar  *data, Flic *flic, Screen *s)
	/* Byte-run-length decompression. */
{
	int x,y;
	int width = flic->head.width;
	int height = flic->head.height;
	Char psize;
	Char  *cpt = data;
	int end;

	y = flic->yoff;
	end = flic->xoff + width;
	while (--height >= 0)
	{
		x = flic->xoff;
		cpt += 1;	/* skip over obsolete opcount byte */
		psize = 0;
		while ((x+=psize) < end)
		{
			psize = *cpt++;
			if (psize >= 0)
			{
				screen_repeat_one(s, x, y, *cpt++, psize);
			}
			else
			{
				psize = -psize;
				screen_copy_seg(s, x, y, (Pixel  *)cpt, psize);
				cpt += psize;
			}
		}
		y++;
	}
}

static void decode_delta_fli(Uchar  *data, Flic *flic, Screen *s)
	/* Fli style delta decompression. */
{
	int xorg = flic->xoff;
	int yorg = flic->yoff;
	Short  *wpt = (Short  *)data;
	Uchar  *cpt = (Uchar  *)(wpt + 2);
	int x,y;
	Short lines;
	Uchar opcount;
	Char psize;

	y = yorg + *wpt++;
	lines = *wpt;
	while (--lines >= 0)
	{
		x = xorg;
		opcount = *cpt++;
		while (opcount > 0)
		{
			x += *cpt++;
			psize = *cpt++;
			if (psize < 0)
			{
				psize = -psize;
				screen_repeat_one(s, x, y, *cpt++, psize);
				x += psize;
				opcount-=1;
			}
			else
			{
				screen_copy_seg(s, x, y, (Pixel  *)cpt, psize);
				cpt += psize;
				x += psize;
				opcount -= 1;
			}
		}
		y++;
	}
}


static void decode_delta_flc(Uchar  *data, Flic *flic, Screen *s)
	/* Flc-style delta decompression.  The data is word oriented though
	* a lot of the control info (how  to skip, how many words to
	* copy) are byte oriented still to save space. */
{
	int xorg = flic->xoff;
	int yorg = flic->yoff;
	int width = flic->head.width;
	int x,y;
	Short lp_count;
	Short opcount;
	int psize;
	union {Short  *w; Uchar  *ub; Char  *b; Pixels2  *p2;} wpt;
	int lastx;

	lastx = xorg + width - 1;
	wpt.ub = data;
	lp_count = *wpt.w++;
	y = yorg;
	goto LPACK;

SKIPLINES:	/* Advance over some lines. */
	y -= opcount;

LPACK:		/* do next line */
	if ((opcount = *wpt.w++) >= 0)
		goto DO_SS2OPS;
	if( ((Ushort)opcount) & 0x4000) /* skip lines */
		goto SKIPLINES;
	screen_put_dot(s,(Uchar)opcount,lastx,y); /* put dot at eol with low byte */
	if((opcount = *wpt.w++) == 0)
	{
		++y;
		if (--lp_count > 0)
			goto LPACK;
		goto OUT;
	}
DO_SS2OPS:
	x = xorg;

PPACK:				/* do next packet */
	x += *wpt.ub++;
	psize = *wpt.b++;
	if ((psize += psize) >= 0)
	{
		screen_copy_seg(s, x, y, (Pixel  *)wpt.ub, psize);
		x += psize;
		wpt.ub += psize;
		if (--opcount != 0)
			goto PPACK;
		++y;
		if (--lp_count > 0)
			goto LPACK;
	}
	else
	{
		psize = -psize;
		screen_repeat_two(s, x, y, *wpt.p2++, psize>>1);
		x += psize;
		if (--opcount != 0)
			goto PPACK;
		++y;
		if (--lp_count > 0)
			goto LPACK;
	}
OUT:
	return;
}

static void decode_black(Uchar  *data, Flic *flic, Screen *s)
	/* Decode a BLACK chunk.  Set frame to solid color 0 one
	* line at a time. */
{
	Pixels2 black;
	int i;
	int height = flic->head.height;
	int width = flic->head.width;
	int x = flic->xoff;
	int y = flic->yoff;

	black.pixels[0] = black.pixels[1] = 0;
	for (i=0; i<height; ++i)
	{
		screen_repeat_two(s, x, y+i, black, width/2);
		if (width & 1)	/* if odd set last pixel */
			screen_put_dot(s, x+width-1, y+i, 0);
	}
}

static void decode_literal(Uchar  *data, Flic *flic, Screen *s)
	/* Decode a LITERAL chunk.  Just copy data to screen one line at
	* a time. */
{
	int i;
	int height = flic->head.height;
	int width = flic->head.width;
	int x = flic->xoff;
	int y = flic->yoff;

	for (i=0; i<height; ++i)
	{
		screen_copy_seg(s, x, y+i, (Pixel  *)data, width);
		data += width;
	}
}

ErrCode SetupFlicAccess (Flic * flic)
{
	if (flic->usefile==TRUE)
	{
		return file_open_to_read(&flic->handle, flic->name);
	}
	else
	{
		flic->flicoffset=0;
		return Success;
	}
}

ErrCode CopyNextFlicBlock (Flic * flic, MemPtr buf, Ulong size)
{
	ErrCode err;

	if (flic->usefile==TRUE)
	{
		err = file_read_big_block(flic->handle, buf, size);
		return err;
	}
	else
	{
		memcpy(buf, flic->flicbuffer+flic->flicoffset, size);
		flic->flicoffset+=size;
		return Success;
	}
}

void	SetFlicOffset (Flic * flic, Ulong offset )
{
	if (flic->usefile==TRUE)
	{
		w_lseek(flic->handle,offset,SEEK_SET);
	}
	else
	{
		flic->flicoffset = offset;
	}
}


ErrCode flic_open(Flic *flic, char *name, MemPtr buf, Boolean usefile)
	/* Open flic file.  Read header and verify it's a flic.
	* Seek to first frame. */
{
	ErrCode err;

	ClearStruct(flic);		/* Start at a known state. */
	flic->usefile=usefile;  /* use file or buffer */
	flic->name = name;		/* Save name for future use. */
	flic->flicbuffer=buf;	/* save address of flicbuffer */

	if ((err = SetupFlicAccess (flic)) >= Success)
	{
		err = CopyNextFlicBlock (flic,
			(Uchar *)&flic->head,
			sizeof(flic->head));
		if (err >= Success)
		{
			if (flic->head.type == FLC_TYPE)
			{
				/* Seek frame 1. */
				SetFlicOffset (flic, flic->head.oframe1 );
				return Success;
			}
			if (flic->head.type == FLI_TYPE)
			{
				/* Do some conversion work here. */
				flic->head.oframe1 = sizeof(flic->head);
				flic->head.speed = flic->head.speed * 1000L / 70L;
				return Success;
			}
			else
			{
				err = ErrBadFlic;
			}
		}
	}
	flic_close(flic);	/* Close down and scrub partially opened flic. */
	return err;
}


void flic_close(Flic *flic)
	/* Close flic file and scrub flic. */
{
	if (flic->usefile==TRUE)
	{
		w_close(flic->handle);
	}
	ClearStruct(flic);		/* Discourage use after close. */
}

static ErrCode decode_frame(Flic *flic,
	FrameHead *frame, Uchar  *data, Screen *s)
	/* Decode a frame that is in memory already into screen.
	* Here we just loop through each chunk calling appropriate
	* chunk decoder.
	*/
{
	int i;
	ChunkHead  *chunk;

	for (i=0; i<frame->chunks; ++i)
	{
		chunk = (ChunkHead  *)data;
		data += chunk->size;
		switch (chunk->type)
		{
			case COLOR_256:
				decode_color_256((Uchar  *)(chunk+1), flic, s);
				break;
			case DELTA_FLC:
				decode_delta_flc((Uchar  *)(chunk+1), flic, s);
				break;
			case COLOR_64:
				decode_color_64((Uchar  *)(chunk+1), flic, s);
				break;
			case DELTA_FLI:
				decode_delta_fli((Uchar  *)(chunk+1), flic, s);
				break;
			case BLACK:
				decode_black((Uchar  *)(chunk+1), flic, s);
				break;
			case BYTE_RUN:
				decode_byte_run((Uchar  *)(chunk+1), flic, s);
				break;
			case LITERAL:
				decode_literal((Uchar  *)(chunk+1), flic, s);
				break;
			default:
				break;
		}
	}
	return Success;
}

ErrCode flic_next_frame(Flic *flic, Screen *screen)
	/* Advance to next frame of flic. */
{
	FrameHead head;
	ErrCode err;
	MemPtr bb;
	long size;

	err = CopyNextFlicBlock (flic, (Uchar *)&head, sizeof(head));
	if (err >= Success)
	{
		if (head.type == FRAME_TYPE)
		{
			size = head.size - sizeof(head);	/* Don't include head. */
			if (size > 0)
			{
				if ((err = big_alloc(&bb, size)) >= Success)
				{
					if ((err = CopyNextFlicBlock (flic, bb, size)) >= Success)
					{
						err = decode_frame(flic, &head, bb, screen);
					}
					big_free(&bb);
				}
			}
		}
		else
		{
			err = ErrBadFrame;
		}
	}
	return err;
}


static Ulong calc_end_time(Ulong millis)
	/* Little helper subroutine to find out when to start on next
	* frame. */
{
	return (GetCinematicTime() + ( (millis * CLOCKSPEED) / 4000l) );
}

static ErrCode wait_til(Ulong end_time, Machine *machine)
	/* This waits until key is hit or end_time arrives.
	* Return Success if timed out,  ErrCancel if key hit.
	* Insures keyboard will be polled at least once.
	*/
{
	do
	{
		if (CinematicAbort()!=0)
			return ErrCancel;
	}
	while (GetCinematicTime() < end_time);
	return Success;
}

ErrCode flic_play_once(Flic *flic, Machine *machine)
	/* Play a flic through once. */
{
	ErrCode err;
	int i;
	Ulong end_time;

	for (i=0; i<flic->head.frames; ++i)
	{
		end_time = calc_end_time(flic->head.speed);
		if ((err = flic_next_frame(flic, &machine->screen)) < Success)
			break;
		if ((err = wait_til(end_time, machine)) < Success)
			break;
	}
	return err;
}

static ErrCode fill_in_frame2(Flic *flic)
	/* This figures out where the second frame of the flic is
	* (useful for playing in a loop).  */
{
	FrameHead head;
	ErrCode err;

	SetFlicOffset (flic, flic->head.oframe1 );
	err = CopyNextFlicBlock (flic, (MemPtr)&head, sizeof(head));
	if (err < Success)
		return err;
	flic->head.oframe2 = flic->head.oframe1 + head.size;
	return Success;
}

ErrCode flic_play_loop(Flic *flic, Machine *machine)
	/* Play a flic until key is pressed. */
{
	int i;
	Ulong end_time;
	ErrCode err;

	if (flic->head.oframe2 == 0)
	{
		fill_in_frame2(flic);
	}
	/* Seek to first frame. */
	SetFlicOffset (flic, flic->head.oframe1 );
	/* Save time to move on. */
	end_time = calc_end_time(flic->head.speed);
	/* Display first frame. */
	if ((err = flic_next_frame(flic, &machine->screen)) < Success)
		return err;
	for (;;)
	{
		/* Seek to second frame */
		SetFlicOffset (flic, flic->head.oframe2 );
		/* Loop from 2nd frame thru ring frame*/
		for (i=0; i<flic->head.frames; ++i)
		{
			if (wait_til(end_time, machine) < Success)
				return Success;		/* Time out is a success here. */
			if ((err = flic_next_frame(flic, &machine->screen)) < Success)
				return err;
			end_time = calc_end_time(flic->head.speed);
		}
	}
}


static char *err_strings[] =
{
	"Unspecified error",
	"Not enough memory",
	"Not a flic file",
	"Bad frame in flic",
	NULL,
	NULL,
	"Couldn't open display",
	"Couldn't open keyboard",
	"User canceled action",
};

char *flic_err_string(ErrCode err)
	/* Return a string that describes an error. */
{
	if (err >= Success)
		return "Success";		/* Shouldn't happen really... */
	if (err == ErrOpen || err == ErrRead)
		return strerror(errno);	/* Get Disk IO error from DOS. */
	err = -err;
	err -= 1;
	if (err > ArrayEls(err_strings))
		return "Unknown error";
	return err_strings[err];
}


static void center_flic(Flic *flic, Screen *s)
	/* Set flic.xoff and flic.yoff so flic plays centered rather
	* than in upper left corner of display. */
{
	flic->xoff = (screen_width(s) - (signed)flic->head.width)/2;
	flic->yoff = (screen_height(s) - (signed)flic->head.height)/2;
}

void PlayFlic ( char * name, unsigned char * buffer, int usefile, int loop)
{
	ErrCode err;
	Flic flic;
	Machine machine;

	if ((err = machine_open(&machine)) >= Success)
	{
		if ((err = flic_open(&flic, name, buffer, usefile)) >= Success)
		{
			center_flic(&flic, &machine.screen);
			if (loop==0)
			{
				err = flic_play_once(&flic, &machine);
			}
			else
			{
				err = flic_play_loop(&flic, &machine);
			}
			flic_close(&flic);
		}
		machine_close(&machine);
	}
	if (err < Success && err != ErrCancel)
	{
		Error("Play Flic had troubles with %s.\n%s.\n",
			name, flic_err_string(err));
	}
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
/* pcclone.c - This file contains all the machine specific bits of the
 * flic reader.  It's job is to set up data structures and routines for
 * the Screen, Clock, and Key structures,  and the Machine structure
 * that contains them all.
 *
 * For optimum performance a flic-reader should be coded in assembler.
 * However you can get significantly greater performance merely by
 * recoding in assembler the three routines: screen_copy_seg(),
 * screen_repeat_one() and screen_repeat_two().
 *
 * Copyright (c) 1992 Jim Kent.  This file may be freely used, modified,
 * copied and distributed.  This file was first published as part of
 * an article for Dr. Dobb's Journal March 1993 issue.
 */

#include "cin_glob.h"
// #include <bios.h>
// #include <dos.h>
#include <time.h>
#include <stdlib.h>
// #include <mem.h>
#include <limits.h>
// #include <fcntl.h>
// #include <io.h>
// #include <conio.h>
#include "fli_type.h"
#include "fli_util.h"
#include "fli_def.h"
#include "fli_main.h"
//MED
// #include "memcheck.h"

static Ushort screenlookup[200];

/** Screen oriented stuff. **/

#if 0
static Boolean set_vmode(Uchar mode)
	/* Ask bios to set video mode. */
{
union REGS regs;

regs.h.ah = 0;		/* Set Video Mode request. */
regs.h.al = mode;	/* For our specific mode. */
int86(0x10, &regs, &regs);
return TRUE;
// return (regs.x.cflag == 0);	/* Carry flag clear? */
}

static Uchar get_vmode()
	/* Ask bios for current video mode. */
{
union REGS regs;

regs.h.ah = 0xF;			/* Get Video Mode request. */
int86(0x10, &regs, &regs);
return regs.h.al;
}

ErrCode screen_open(Screen *s)
	/* Put machine into graphics mode and fill out screen structure. */
{
ClearStruct(s);			/* Start in a known state... */
s->old_mode = get_vmode();
if (set_vmode(0x13))
	{
	if (get_vmode() == 0x13)
		{
      int i;

		s->is_open = TRUE;	/* Now it's open. */
		s->width = 320;
		s->height = 200;
      for (i=0;i<200;i++)
         screenlookup[i]=320*i;
      s->pixels = (unsigned char *)0xA0000;  /* Base video screen address. */
		return Success;
		}
	}
/* If got to here have failed.  Restore old video mode and return
 * failure code. */
	set_vmode(s->old_mode);
	return ErrDisplay;
}

void screen_close(Screen *s)
	/* Close screen.  Restore original display mode. */
{
if (s->is_open)		/* Don't do this twice... */
	{
//   set_vmode(s->old_mode);
	ClearStruct(s);		/* Discourage use after it's closed... */
	}
}
#endif

void *VL_SetVGA_Mode13LFB ( void );

ErrCode screen_open(Screen *s)
{
	void *scrn;
	int i;
	
	scrn=VL_SetVGA_Mode13LFB();

	s->is_open = TRUE;
	s->width = 320;
	s->height = 200;
	for (i=0; i<200; i++)
		screenlookup[i]=384*i;
	s->pixels = scrn;
	return Success;
}

void screen_close(Screen *s)
{
	if (s->is_open)		/* Don't do this twice... */
	{
		ClearStruct(s);		/* Discourage use after it's closed... */
	}
}

int screen_width(Screen *s)
	/* Return width of screen. */
{
return s->width;
}

int screen_height(Screen *s)
	/* Return height of screen. */
{
return s->height;
}

void screen_put_dot(Screen *s, int x, int y, Pixel color)
	/* Set one dot. */
{
	/* First clip it. */
if (x < 0 || y < 0 || x >= s->width || y >= s->height)
	return;

	/* Then set it. */
s->pixels[screenlookup[y] + x] = color;
}

static Boolean line_clip(Screen *s, int *px, int *py, int *pwidth)
	/* Clip a horizontal line segment so that it fits on the screen.
	 * Return FALSE if clipped out entirely. */
{
int x = *px;
int y = *py;
int width = *pwidth;
int xend = x + width;

if (y < 0 || y >= s->height || xend < 0 || x >= s->width)
	return FALSE;	/* Clipped off screen. */
if (x < 0)
	{
	*pwidth = width = width + x;		/* and shortens width. */
	*px = 0;
	}
if (xend > s->width)
	{
	*pwidth = width = width - (xend - s->width);
	}
if (width < 0)
	return FALSE;
return TRUE;
}

void screen_copy_seg(Screen *s, int x, int y, Pixel  *pixels, int count)
	/* Copy pixels from memory into screen. */
{
Pixel  *pt;
int unclipped_x = x;

	/* First let's do some clipping. */
if (!line_clip(s, &x, &y, &count))
	return;

pixels += (x - unclipped_x);   /* Clipping change in start position. */

	/* Calculate start screen address. */
pt = s->pixels + (unsigned)screenlookup[y] + (unsigned)x;

	/* Copy pixels to display. */
memcpy (pt,pixels,count);
}

void screen_repeat_one(Screen *s, int x, int y, Pixel color, int count)
	/* Draw a horizontal line of a solid color */
{
Pixel  *pt;

	/* First let's do some clipping. */
if (!line_clip(s, &x, &y, &count))
	return;

	/* Calculate start screen address. */
pt = s->pixels + (unsigned)screenlookup[y] + (unsigned)x;

	/* Repeat pixel on display. */
   memset (pt,color,count);
}

void screen_repeat_two(Screen *s, int x, int y, Pixels2 pixels2, int count)
	/* Repeat 2 pixels count times on screen. */
{
Pixels2  *pt;
int is_odd;

	/* First let's do some clipping. */
count <<= 1;		/* Convert from word to pixel count. */
if (!line_clip(s, &x, &y, &count))
	return;
is_odd = (count&1);		/* Did it turn odd after clipping?  Ack! */
count >>= 1;			/* Convert back to word count. */

	/* Calculate start screen address. */
pt = (Pixels2  *)(s->pixels + (unsigned)screenlookup[y] + (unsigned)x);

while (--count >= 0)	/* Go set screen 2 pixels at a time. */
	*pt++ = pixels2;

if (is_odd)				/* Deal with pixel at end of screen if needed. */
	{
   Pixel  *end = (Pixel  *)pt;
	*end = pixels2.pixels[0];
	}
}

void screen_put_colors(Screen *s, int start, Color  *colors, int count)
	/* Set count colors in color map starting at start.  RGB values
	 * go from 0 to 255. */
{
}

void screen_put_colors_64(Screen *s, int start, Color  *colors, int count)
	/* Set count colors in color map starting at start.  RGB values
	 * go from 0 to 64. */
{
}

#if 0
void screen_put_colors(Screen *s, int start, Color  *colors, int count)
	/* Set count colors in color map starting at start.  RGB values
	 * go from 0 to 255. */
{
int end = start + count;
int ix;

for (ix = start; ix < end; ++ix)
	{
	outportb(0x3C8, ix);
	outportb(0x3C9, colors->r>>2);
	outportb(0x3C9, colors->g>>2);
	outportb(0x3C9, colors->b>>2);
	++colors;
	}
}

void screen_put_colors_64(Screen *s, int start, Color  *colors, int count)
	/* Set count colors in color map starting at start.  RGB values
	 * go from 0 to 64. */
{
int end = start + count;
int ix;

for (ix = start; ix < end; ++ix)
	{
	outportb(0x3C8, ix);
	outportb(0x3C9, colors->r);
	outportb(0x3C9, colors->g);
	outportb(0x3C9, colors->b);
	++colors;
	}
}
#endif

#if 0
/** Clock oriented stuff. **/

#define CMODE	0x43
#define CDATA	0x40

ErrCode clock_open(Clock *c)
	/* Set up clock and store speed of clock.  */
{
c->speed = 4608;        /* Our peculiar speed.  */
outportb(CMODE, 0x34);  /* Change from divide by two to linear. */
outportb(CDATA, 0);     /* Set period to highest available. */
outportb(CDATA, 0);
return Success;
}

void clock_close(Clock *c)
	/* Return clock to normal. */
{
outportb(CMODE, 0x36);  /* Change from linear to divide by two. */
outportb(CDATA, 0);     /* Set period to highest available. */
outportb(CDATA, 0);
}

Ulong clock_ticks(Clock *c)
	/* Get current clock tick. */
{
/* This routine returns a clock with occassional spikes where time will
 * look like its running backwards 1/18th of a second.  The resolution
 * of the clock is 1/(18*256) = 1/4608 second.  The spikes are ok for
 * our purposes since the wait loop will just ignore them. */
union REGS regs;
Uchar chip_time;
Ulong time;

regs.h.ah = 0;				/* Go ask BIOS timer services */
int86(0x1A, &regs, &regs);	/* for time in 1/18ths second. */
outportb(CMODE,0);			/* Latch time at timer chip. */
inportb(CDATA);				/* Read in LSB of chip time and discard. */
chip_time = inportb(CDATA);	/* Read in MSB of chip time and save. */
chip_time = -(signed char)chip_time;
	/* We calculate the time using 3 bytes from the BIOS 18hz counter
	 * and one byte from the timer chip itself.  We discard the hi
	 * byte of the BIOS time,  shift the rest left by 8, and
	 * fill in the low byte with the MSB from the chip timer.
	 * This looks a little more complicated than this because
	 * the bios time is in various registers - cx for the hi word
	 * and dx for the low word. */
time = (Ulong)regs.h.cl << 24L;		/* Get MSB of our final time. */
time += (Ulong)regs.w.dx << 8L;     /* Fold in middle two bytes. */
time += (Ulong)chip_time;			/* Add in LSB from chip. */
return time;
}


/** Keyboard oriented stuff. **/

ErrCode key_open(Key *key)
	/* Set up keyboard. */
{
return Success;		/* Pretty easy on a PC. */
}

void key_close(Key *key)
	/* Close keyboard. */
{
return;				/* Also very easy under DOS. */
}

Boolean key_ready(Key *key)
	/* See if a key is ready. */
{
unsigned val;

if ((val = _bios_keybrd(_KEYBRD_READY)) == 0)
	return FALSE;
else
	{
	key->ascii = val;
	key->scancode = val;
	return TRUE;
	}
}

Uchar key_read(Key *key)
	/* Get next key. */
{
unsigned val;

val = _bios_keybrd(_KEYBRD_READ);
key->ascii = val;
key->scancode = val;
return key->ascii;
}

#endif

/** MemPtr stuff - to allocate and free blocks of memory > 64K. */

ErrCode big_alloc(MemPtr *bb, Ulong size)
	/* Allocate a big block. */
{
   (*bb) = SafeMalloc (size);
   return Success;
}

void big_free(MemPtr *bb)
	/* Free up a big block. */
{
   SafeFree(*bb);
}

/** Stuff for reading files - regular and over 64k blocks at a time. **/

ErrCode file_open_to_read(FileHandle *phandle, char *name)
	/* Open a binary file to read. */
{
   *phandle = SafeOpenRead(name);
	return Success;
}

ErrCode file_read_big_block(FileHandle handle, MemPtr bb, Ulong size)
	/* Read in a big block.  Could be bigger than 64K. */
{
   SafeRead (handle,bb,size);
   return Success;
}


/** Machine oriented stuff - open and close the whole banana. **/

ErrCode machine_open(Machine *machine)
	/* Open up machine: keyboard, clock, and screen. */
{
ErrCode err;

ClearStruct(machine);	/* Start it in a known state. */
//if ((err = key_open(&machine->key)) >= Success)
   {
//   if ((err = clock_open(&machine->clock)) >= Success)
		{
		if ((err = screen_open(&machine->screen)) >= Success)
			return Success;
//      clock_close(&machine->clock);
		}
//   key_close(&machine->key);
	}
return err;
}

void machine_close(Machine *machine)
	/* Close down machine. */
{
screen_close(&machine->screen);
//clock_close(&machine->clock);
//key_close(&machine->key);
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "rt_util.h"
#include "rt_view.h"
#include <math.h>
#include <dos.h>
#include <stdio.h>
#include <stdarg.h>
#include <fcntl.h>
#include <errno.h>
#include <conio.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <io.h>
#include <stdlib.h>
#include <sys\stat.h>

//MED
#include "memcheck.h"

#define PANGLES 512
#define NUMSINANGLES FINEANGLES+FINEANGLEQUAD+1

fixed  pangle[PANGLES];
long   sintable[NUMSINANGLES];
short  tantable[FINEANGLES];
byte   gammatable[GAMMAENTRIES];

extern  int      _argc;
extern  char **  _argv;

/*
=================
=
= Error
=
= For abnormal program terminations
=
=================
*/

void Error (char *error, ...)
{
	va_list	argptr;

	va_start (argptr,error);
	vprintf (error,argptr);
	va_end (argptr);
	printf ("\n");
	exit (1);
}


int SafeOpenWrite (char *filename)
{
	int	handle;

//	handle = open(filename,O_RDWR | O_BINARY | O_CREAT | O_TRUNC
//	, S_IREAD | S_IWRITE);
	handle = w_open(filename, "w+b");

	if (handle == -1)
		Error ("Error opening %s: %s",filename,strerror(errno));

	return handle;
}


void SafeWrite (int handle, void *buffer, long count)
{
	unsigned	iocount;

	while (count)
	{
		iocount = count > 0x8000 ? 0x8000 : count;
		if (w_write (handle,buffer,iocount) != iocount)
			Error ("File write failure");
		buffer = (void *)( (byte *)buffer + iocount );
		count -= iocount;
	}
}




void CalcPixelAngles ( void )
{
    int   i;
    long  intang;
    double  angle;
    double  tang;

    const   double radtoint = (double)FINEANGLES/2/PI;


    for (i=0;i<PANGLES;i++)
       {
       // start 1/2 pixel over, so viewangle bisects two middle pixels
       tang = ((((double)i*160.0)+80.0)/(FPFOCALWIDTH*(double)PANGLES));
       angle = atan(tang);
       intang = ((long)(angle*radtoint));
       pangle[i] = intang;
       }
}



void BuildSinTable (void)
{
   int   i;
   double  angle,anglestep;
   double  sinangle;
   fixed  value;

   angle = 0;
   anglestep = (double)(PI/2/FINEANGLEQUAD);
   for (i=0;i<=FINEANGLEQUAD;i++)
      {
      sinangle=sin(angle);
      value=(fixed)((double)GLOBAL1*sinangle);
      sintable[i]     =
      sintable[i+FINEANGLES]  =
      sintable[FINEANGLES/2-i] = value;
      sintable[FINEANGLES-i] = -value;
      sintable[FINEANGLES/2+i] = -value;
      angle += anglestep;
      }
}

void BuildTanTable (void)
{
   int   i;
   double  angle,anglestep;
   double  tanangle;
   fixed  value;

   angle = 0;
   anglestep = (double)(PI*2/FINEANGLES);
   for (i=0;i<FINEANGLES;i++)
      {
      tanangle=tan(angle);
      value=(fixed)((double)GLOBAL1*tanangle);
      tantable[i] =(short) (value>>1);
      angle += anglestep;
      }
}

void BuildGammaTable (void)
{
   int     l, i, inf;
   int     j;
   int     gGamma=0x100;
   j=0;
   for (l=0 ; l<NUMGAMMALEVELS ; l++,gGamma+=32)
      {
      double nGamma = (double)256 / gGamma;
      double nScale = (double)63  / pow(63, nGamma);

      for ( i = 0; i < 64; i++ )
         {
         inf = pow(i, nGamma) * nScale;
         if (inf < 0)
            inf = 0;
         if (inf > 63)
            inf = 63;
         gammatable[j++]=inf;
         }
      }
}

void main ()
{
   int handle;
   int size;

   if (_argc!=2)
      {
      printf("LOOKUPS -- Apogee Software (c) 1994\n");
      printf("\n USAGE:    lookups <name.dat>\n");
      exit(0);
      }
   handle=SafeOpenWrite (_argv[1]);
   CalcPixelAngles();
   BuildSinTable();
   BuildTanTable();
   BuildGammaTable();
   size=PANGLES;
   SafeWrite(handle,&size,sizeof(int));
   SafeWrite(handle,&pangle[0],sizeof(fixed)*size);
   size=NUMSINANGLES;
   SafeWrite(handle,&size,sizeof(int));
   SafeWrite(handle,&sintable[0],sizeof(fixed)*size);
   size=FINEANGLES;
   SafeWrite(handle,&size,sizeof(int));
   SafeWrite(handle,&tantable[0],sizeof(short)*size);
   size=GAMMAENTRIES;
   SafeWrite(handle,&size,sizeof(int));
   SafeWrite(handle,&gammatable[0],sizeof(byte)*size);
   w_close (handle);
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// #include <malloc.h>
// #include <dos.h>
#include <stdarg.h>
#include <fcntl.h>
#include <errno.h>
#include <conio.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <io.h>
#include <stdlib.h>
#include <sys\stat.h>
#include "modexlib.h"
//MED
#include "memcheck.h"



// GLOBAL VARIABLES


int    linewidth;
int    ylookup[MAXSCREENHEIGHT];
int    page1start;
int    page2start;
int    page3start;
int    screensize;
// unsigned bufferofs;
nlint bufferofs;
// unsigned displayofs;
nlint displayofs;
boolean graphicsmode=false;



/*
====================
=
= GraphicsMode
=
====================
*/
void GraphicsMode ( void )
{

#if 0
union REGS regs;

regs.w.ax = 0x13;
int386(0x10,&regs,&regs);
graphicsmode=true;
#endif

}

/*
====================
=
= TextMode
=
====================
*/
void TextMode ( void )
{

#if 0
union REGS regs;

regs.w.ax = 0x03;
int386(0x10,&regs,&regs);
graphicsmode=false;
#endif

}

/*
====================
=
= TurnOffTextCursor
=
====================
*/
void TurnOffTextCursor ( void )
{
#if 0
union REGS regs;

regs.w.ax = 0x0100;
regs.w.cx = 0x2000;
int386(0x10,&regs,&regs);
#endif
}

#if 0
/*
====================
=
= TurnOnTextCursor
=
====================
*/
void TurnOnTextCursor ( void )
{

union REGS regs;

regs.w.ax = 0x03;
int386(0x10,&regs,&regs);

}
#endif

/*
====================
=
= WaitVBL
=
====================
*/
void WaitVBL( void )
{
   unsigned char i;

   i=inp(0x03da);
   while ((i&8)==0)
      i=inp(0x03da);
   while ((i&8)==1)
      i=inp(0x03da);
}


/*
====================
=
= VL_SetLineWidth
=
= Line witdh is in WORDS, 40 words is normal width for vgaplanegr
=
====================
*/

void VL_SetLineWidth (unsigned width)
{
   int i,offset;

//
// set wide virtual screen
//
   outpw (CRTC_INDEX,CRTC_OFFSET+width*256);

//
// set up lookup tables
//
   linewidth = width*2;

   offset = 0;

   for (i=0;i<MAXSCANLINES;i++)
      {
      ylookup[i]=offset;
      offset += linewidth;
      }
}

#if 0
/*
=======================
=
= VL_SetVGAPlaneMode
=
=======================
*/

void VL_SetVGAPlaneMode ( void )
{
    GraphicsMode();
    VL_DePlaneVGA ();
    VL_SetLineWidth (48);
    screensize=208*SCREENBWIDE;
    page1start=0xa0200;
    page2start=0xa0200+screensize;
    page3start=0xa0200+(2u*screensize);
    displayofs = page1start;
    bufferofs = page2start;
    XFlipPage ();
}
#endif

#if 0
/*
=======================
=
= VL_CopyPlanarPage
=
=======================
*/
void VL_CopyPlanarPage ( byte * src, byte * dest )
{
   int plane;

   for (plane=0;plane<4;plane++)
      {
      VGAREADMAP(plane);
      VGAWRITEMAP(plane);
      memcpy(dest,src,screensize);
      }
}

/*
=======================
=
= VL_CopyPlanarPageToMemory
=
=======================
*/
void VL_CopyPlanarPageToMemory ( byte * src, byte * dest )
{
   byte * ptr;
   int plane,a,b;

   for (plane=0;plane<4;plane++)
      {
      ptr=dest+plane;
      VGAREADMAP(plane);
      for (a=0;a<200;a++)
         for (b=0;b<80;b++,ptr+=4)
            *(ptr)=*(src+(a*linewidth)+b);
      }
}

/*
=======================
=
= VL_CopyBufferToAll
=
=======================
*/
void VL_CopyBufferToAll ( unsigned buffer )
{
   int plane;

   for (plane=0;plane<4;plane++)
      {
      VGAREADMAP(plane);
      VGAWRITEMAP(plane);
      if (page1start!=buffer)
         memcpy((byte *)page1start,(byte *)buffer,screensize);
      if (page2start!=buffer)
         memcpy((byte *)page2start,(byte *)buffer,screensize);
      if (page3start!=buffer)
         memcpy((byte *)page3start,(byte *)buffer,screensize);
      }
}
#endif

/*
=======================
=
= VL_CopyDisplayToHidden
=
=======================
*/
void VL_CopyDisplayToHidden ( void )
{
   VL_CopyBufferToAll ( displayofs );
}

/*
=================
=
= VL_ClearBuffer
=
= Fill the entire video buffer with a given color
=
=================
*/

void VL_ClearBuffer (unsigned buf, byte color)
{
//  VGAMAPMASK(15);
//  memset((byte *)buf,color,screensize);
}

/*
=================
=
= VL_ClearVideo
=
= Fill the entire video buffer with a given color
=
=================
*/

void VL_ClearVideo (byte color)
{
//  VGAMAPMASK(15);
//  memset((byte *)(0xa000<<4),color,0x10000);
}

/*
=================
=
= VL_DePlaneVGA
=
=================
*/

void VL_DePlaneVGA (void)
{

//
// change CPU addressing to non linear mode
//

//
// turn off chain 4 and odd/even
//
        outp (SC_INDEX,SC_MEMMODE);
        outp (SC_DATA,(inp(SC_DATA)&~8)|4);

        outp (SC_INDEX,SC_MAPMASK);         // leave this set throughout

//
// turn off odd/even and set write mode 0
//
        outp (GC_INDEX,GC_MODE);
        outp (GC_DATA,inp(GC_DATA)&~0x13);

//
// turn off chain
//
        outp (GC_INDEX,GC_MISCELLANEOUS);
        outp (GC_DATA,inp(GC_DATA)&~2);

//
// clear the entire buffer space, because int 10h only did 16 k / plane
//
        VL_ClearVideo (0);

//
// change CRTC scanning from doubleword to byte mode, allowing >64k scans
//
        outp (CRTC_INDEX,CRTC_UNDERLINE);
        outp (CRTC_DATA,inp(CRTC_DATA)&~0x40);

        outp (CRTC_INDEX,CRTC_MODE);
        outp (CRTC_DATA,inp(CRTC_DATA)|0x40);
}


/*
=================
=
= XFlipPage
=
=================
*/

void XFlipPage ( void )
{
   displayofs=bufferofs;

//   _disable();

   outp(CRTC_INDEX,CRTC_STARTHIGH);
   outp(CRTC_DATA,((displayofs&0x0000ffff)>>8));

//   _enable();

   bufferofs += screensize;
   if (bufferofs > page3start)
      bufferofs = page1start;
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/



/*
============================================================================

													 TIMER INTERRUPT

============================================================================
*/
#include <stdlib.h>
#include <stdio.h>
#include <dos.h>
#include <mem.h>
#include <conio.h>
#include "rt_def.h"
#include "task_man.h"
#include "isr.h"
#include "_isr.h"
#include "rt_in.h"
#include "rt_util.h"
#include "profile.h"
#include "develop.h"
#include "rt_main.h"

#if (DEVELOPMENT == 1)

#include "rt_vid.h"

#endif
//MED
#include "memcheck.h"

// Global Variables

static volatile boolean ExtendedKeyFlag;

volatile int Keyboard[MAXKEYBOARDSCAN];
volatile int KeyboardQueue[KEYQMAX];
volatile int Keystate[MAXKEYBOARDSCAN];
volatile int Keyhead;
volatile int Keytail;
volatile int ticcount;
volatile int fasttics;
volatile boolean PausePressed = false;
volatile boolean PanicPressed = false;
int KeyboardStarted=false;
int  ASCIINames[] =          // Unshifted ASCII for scan codes
													 {
//       0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
		  0  ,27 ,'1','2','3','4','5','6','7','8','9','0','-','=',8  ,9  ,        // 0
		  'q','w','e','r','t','y','u','i','o','p','[',']',13 ,0  ,'a','s',        // 1
		  'd','f','g','h','j','k','l',';',39 ,'`',0  ,92 ,'z','x','c','v',        // 2
		  'b','n','m',',','.','/',0  ,'*',0  ,' ',0  ,0  ,0  ,0  ,0  ,0  ,        // 3
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,'7','8','9','-','4','5','6','+','1',        // 4
		  '2','3','0',127,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,        // 5
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,        // 6
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0           // 7
													 },
		  ShiftNames[] =              // Shifted ASCII for scan codes
													 {
//       0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
		  0  ,27 ,'!','@','#','$','%','^','&','*','(',')','_','+',8  ,9  ,        // 0
		  'Q','W','E','R','T','Y','U','I','O','P','{','}',13 ,0  ,'A','S',        // 1
		  'D','F','G','H','J','K','L',':',34 ,'~',0  ,'|','Z','X','C','V',        // 2
		  'B','N','M','<','>','?',0  ,'*',0  ,' ',0  ,0  ,0  ,0  ,0  ,0  ,        // 3
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,'7','8','9','-','4','5','6','+','1',        // 4
		  '2','3','0',127,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,        // 5
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,        // 6
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0           // 7
													 };
// Local Variables

static task * timertask;
#if (DEVELOPMENT == 1)
static task * fasttimertask;
#endif
static int TimerStarted=false;
static volatile int pausecount=0;
static struct dostime_t starttime;

void (__interrupt __far *oldtimerisr) ();
void (__interrupt __far *oldkeyboardisr) () = NULL;

static int LEDs;
static volatile int KBFlags;

/*
================
=
= I_TimerISR
=
================
*/

void __interrupt I_TimerISR (void)
{
// acknowledge the interrupt

		  OUTP(0x20,0x20);
		  ticcount++;
}

/*
================
=
= ISR_Timer
=
================
*/
#if 0
#if (DEVELOPMENT == 1)
static int time=0;
static int t1=0;
static int t2=0;
static int t3=0;
static int insettime=0;
#endif
#endif
/*
================
=
= ISR_SetTime
=
================
*/
void ISR_SetTime(int settime)
{
#if 0
#if (DEVELOPMENT == 1)
   int i;
   int t;
   int savetime;
#endif
#endif

   ticcount=settime;
#if 0
#if (DEVELOPMENT == 1)
      {
      insettime=1;
      savetime=time;
      t1=0;
      t2=0;
      t3=0;
      t=0;

      for (i=0;i<settime;i++)
         {
         t++;
         if (t==VBLCOUNTER)
            {
            t=0;
            t1++;
            if (t1==2)
               {
               t1=0;
               t2++;
               if (t2==2)
                  {
                  t2=0;
                  t3++;
                  if (t3==2)
                     t3=0;
                  }
               }
            }
         }
      time=t+(time-savetime);
      if (time>=VBLCOUNTER)
         {
         time-=VBLCOUNTER;
         t1++;
         if (t1==2)
            {
            t1=0;
            t2++;
            if (t2==2)
               {
               t2=0;
               t3++;
               if (t3==2)
                  t3=0;
               }
            }
         }
      insettime=0;
      }
#endif
#endif
}

static void ISR_Timer (task *Task)
{
//	(*(int *)(Task->data))=((*(int *)(Task->data))+1)&0xffff;
	(*(int *)(Task->data))++;

#if 0
#if (DEVELOPMENT == 1)
      {
      if (Task==timertask)
         {
         time++;
         if ((time==VBLCOUNTER) && (insettime==0))
            {
            time=0;
            VL_SetColor(0,(t1<<5)+20,(t2<<5)+20,(t3<<5)+20);
            t1++;
            if (t1==2)
               {
               t1=0;
               t2++;
               if (t2==2)
                  {
                  t2=0;
                  t3++;
                  if (t3==2)
                     t3=0;
                  }
               }
            }
         }
      }
#endif
#endif
}


/*
=====================
=
= I_SetTimer0
=
= Sets system timer 0 to the specified speed
=
=====================
*/

void I_SetTimer0(int speed)
{
	unsigned s;
		  if (!((speed > 0 && speed < 150)))
					 Error ("INT_SetTimer0: %i is a bad value",speed);
		  s=1192030U/(unsigned)speed;
		  OUTP(0x43,0x36);                            // Change timer 0
		  OUTP(0x40,s);
		  OUTP(0x40,s >> 8);
}

/*
================
=
= I_Delay
=
================
*/

void I_Delay ( int delay )
{
   int time;

   delay=(VBLCOUNTER*delay)/10;
   IN_ClearKeysDown();
   time=ticcount;
   while (ticcount<time+delay)
      {
      if (LastScan)
         break;
      }
}

/*
===============
=
= I_StartupTimer
=
===============
*/

void I_StartupTimer (void)
{
#if PROFILE
   return;
#else
   struct dostime_t cmostime;

   if (TimerStarted==true)
      return;
   TimerStarted=true;

   I_GetCMOSTime ( &cmostime );
   _dos_settime  ( &cmostime );

//      I_SetTimer0(VBLCOUNTER);
//      oldtimerisr = _dos_getvect(TIMERINT);
//      _dos_setvect (TIMERINT, I_TimerISR);

   timertask=TS_ScheduleTask( &ISR_Timer, VBLCOUNTER, 10, &ticcount);
#if (DEVELOPMENT == 1)
   fasttimertask=TS_ScheduleTask( &ISR_Timer, VBLCOUNTER*4, 10, &fasttics);
#endif
   TS_Dispatch();
   I_GetCMOSTime ( &cmostime );
   memcpy(&starttime,&cmostime,sizeof(starttime));
   ticcount=0;
   if (!quiet)
      printf("I_StartupTimer: Timer Started\n");
#endif
}

void I_ShutdownTimer (void)
{
#if PROFILE
   return;
#else
   struct dostime_t dostime;
   struct dostime_t cmostime;
#if (DEVELOPMENT == 1)
   int totaltime;
#endif

   if (TimerStarted==false)
      return;
   TimerStarted=false;

//      OUTP(0x43,0x36);                            // Change timer 0
//      OUTP(0x40,0);
//      OUTP(0x40,0);
//      _dos_setvect (TIMERINT, oldtimerisr);

   I_GetCMOSTime ( &cmostime );
   _dos_gettime  ( &dostime  );

#if (DEVELOPMENT == 1)
   SoftError("Time difference in seconds (DOS-CMOS) %ld\n",dostime.second-cmostime.second);
   SoftError("Time difference in minutes (DOS-CMOS) %ld\n",dostime.minute-cmostime.minute);
   SoftError("Time difference in hour (DOS-CMOS) %ld\n",dostime.hour-cmostime.hour);
   totaltime=( ((cmostime.hour-starttime.hour)*3600) +
               ((cmostime.minute-starttime.minute)*60) +
                (cmostime.second-starttime.second)
             );
   SoftError("Total seconds = %ld Total Tics = %ld Game Tics = %ld\n",totaltime,totaltime*VBLCOUNTER,ticcount);
#endif

   TS_Terminate( timertask );
#if (DEVELOPMENT == 1)
   TS_Terminate( fasttimertask );
#endif
   TS_Shutdown();
//   TS_Halt();
/*
   if (oldtimerisr)
      {
      OUTP(0x43,0x36);                            // Change timer 0
      OUTP(0x40,0);
      OUTP(0x40,0);
      _dos_setvect (TIMERINT, oldtimerisr);
      // Set Date and Time from CMOS

      OUTP(0x70,0);
      time.second=inp(0x71);
      OUTP(0x70,2);
      time.minute=inp(0x71);
      OUTP(0x70,4);
      time.hour=inp(0x71);
      time.second=(time.second&0x0f)+((time.second>>4)*10);
      time.minute=(time.minute&0x0f)+((time.minute>>4)*10);
      time.hour=(time.hour&0x0f)+((time.hour>>4)*10);
      _dos_settime(&time);

      OUTP(0x70,7);
      date.day=inp(0x71);
      OUTP(0x70,8);
      date.month=inp(0x71);
      OUTP(0x70,9);
      date.year=inp(0x71);
      date.day=(date.day&0x0f)+((date.day>>4)*10);
      date.month=(date.month&0x0f)+((date.month>>4)*10);
      date.year=(date.year&0x0f)+((date.year>>4)*10);
      _dos_setdate(&date);
//      }
*/
#endif
}

/*
===============
=
= I_GetCMOSTime
=
===============
*/
void I_GetCMOSTime ( struct dostime_t * cmostime )
{
   OUTP(0x70,0);
   cmostime->second=inp(0x71);
   OUTP(0x70,2);
   cmostime->minute=inp(0x71);
   OUTP(0x70,4);
   cmostime->hour=inp(0x71);
   cmostime->second=(cmostime->second&0x0f)+((cmostime->second>>4)*10);
   cmostime->minute=(cmostime->minute&0x0f)+((cmostime->minute>>4)*10);
   cmostime->hour=(cmostime->hour&0x0f)+((cmostime->hour>>4)*10);
}

/*
============================================================================

																KEYBOARD

============================================================================
*/
#define ena_kbd           0xae
#define caps_state        0x40
#define num_state         0x20
#define scroll_state      0x10

#define kb_resend         0xfe
#define kb_ack            0xfa
#define kb_pr_led         0x40
#define kb_error          0x80
#define kb_fe             0x20
#define kb_fa             0x10

#define porta             0x60
#define kb_status_port    0x64
#define input_buffer_full 0x02
#define led_cmd           0xed
#define kb_enable         0xf4
#define leds_off          0
#define caps_led_on       0x04
#define num_led_on        0x02
#define scroll_led_on     0x01

/*
================
=
= I_SendKeyboardData
=
================
*/

void I_SendKeyboardData
   (
   int val
   )

   {
   int retry;
   volatile int count;

   _disable();

   KBFlags &= ~( kb_fe | kb_fa );

   count = 0xffff;
   while( count-- )
      {
      if ( !( inp( kb_status_port ) & input_buffer_full ) )
         {
         break;
         }
      }

   outp( porta, val );

   _enable();

   retry = 3;
   while( retry-- )
      {
      count = 0x1a00;
      while( count-- )
         {
         if ( KBFlags & kb_fe )
            {
            break;
            }

         if ( KBFlags & kb_fa )
            {
            return;
            }
         }
      }

   KBFlags |= kb_error;
   }

/*
================
=
= I_SetKeyboardLEDs
=
================
*/

void I_SetKeyboardLEDs
   (
   int which,
   boolean val
   )

   {
   int mask;
   int count;

   _disable();
   KBFlags |= kb_pr_led;

   switch( which )
      {
      case scroll_lock :
         mask = scroll_led_on;
         break;

      case num_lock :
         mask = num_led_on;
         break;

      case caps_lock :
         mask = caps_led_on;
         break;

      default :
         mask = 0;
         break;
      }

   if ( val )
      {
      LEDs |= mask;
      }
   else
      {
      LEDs &= ~mask;
      }

   count = 0;
   do
      {
      if ( count > 3 )
         {
         break;
         }

      I_SendKeyboardData( led_cmd );
      _disable();
      I_SendKeyboardData( LEDs );
      _disable();
      I_SendKeyboardData( kb_enable );
      _disable();
      count++;
      }
   while( KBFlags & kb_error );

   _enable();
   KBFlags &= ~(kb_pr_led|kb_error);
   }


/*
================
=
= I_KeyboardISR
=
================
*/
void __interrupt I_KeyboardISR (void)
{
	int k;
   int temp;
   int keyon;
   int strippedkey;

   // Get the scan code
   k = inp( 0x60 );

   // Tell the XT keyboard controller to clear the key
	temp = inp( 0x61 );
	OUTP ( 0x61, temp | 0x80 );
	OUTP ( 0x61, temp );

   if ( KBFlags & kb_pr_led )
      {
      if ( k == kb_resend )
         {
         // Handle resend
         KBFlags |= kb_fe;
         }
      else if (k == kb_ack)
         {
         // Handle ack
         KBFlags |= kb_fa;
         }
      }
   else if ( pausecount )
      {
      pausecount--;
      }
   else if ( k == 0xe1 )         // Handle Pause key
      {
      PausePressed = true;
      pausecount = 5;
      }
   else if ( k == 0x46 )         // Handle Panic key (Scroll Lock)
      {
      PanicPressed = true;
      }
   else
      {
      if ( k == 0xE0 )
         {
         ExtendedKeyFlag = true;
         }
      else
         {
         keyon = k & 0x80;
         strippedkey = k & 0x7f;

         if ( ExtendedKeyFlag )
            {
            if ( ( strippedkey == sc_LShift ) ||
               ( strippedkey == sc_RShift ) )
               {
               k = sc_None;
               }
/*
            else
               {
               if ( strippedkey == sc_Alt )
                  {
                  k = sc_RightAlt | keyon;
                  }
               if ( strippedkey == sc_Control )
                  {
                  k = sc_RightCtrl | keyon;
                  }
               }
*/
            }

         if ( k != sc_None )
            {
            if ( strippedkey == sc_LShift )
               {
               k = sc_RShift | keyon;
               }

            if ( !keyon )
               {
               LastScan = k;
               }

            if (k & 0x80)        // Up event
               {
               Keystate[k&0x7f]=0;
               }
            else                 // Down event
               {
               Keystate[k]=1;
               }

            KeyboardQueue[ Keytail ] = k;
            Keytail = ( Keytail + 1 )&( KEYQMAX - 1 );
            }

         ExtendedKeyFlag = false;
         }
      }

   // acknowledge the interrupt
   OUTP ( 0x20, 0x20 );
   }


/*
===============
=
= I_StartupKeyboard
=
===============
*/

void I_StartupKeyboard (void)
{
   if (KeyboardStarted==true)
      return;
   KeyboardStarted=true;

   LEDs = 0;
   KBFlags = 0;
   ExtendedKeyFlag = false;

	oldkeyboardisr = _dos_getvect(KEYBOARDINT);
	_dos_setvect (0x8000 | KEYBOARDINT, I_KeyboardISR);

//   I_SetKeyboardLEDs( scroll_lock, 0 );

   Keyhead = Keytail = 0;
   memset(Keystate,0,sizeof(Keystate));
   if (!quiet)
      printf("I_StartupKeyboard: Keyboard Started\n");
}

void I_ShutdownKeyboard (void)
{
   if (KeyboardStarted==false)
      return;
   KeyboardStarted=false;

   // Clear LEDS
//   *( (byte *)0x417 ) &= ~0x70;

	_dos_setvect (KEYBOARDINT, oldkeyboardisr);
	*(short *)0x41c = *(short *)0x41a;      // clear bios key buffer
}



/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rottser.h"
#include "_rt_ser.h"
#include "rt_ser.h"
#include "rt_def.h"
#include <conio.h>
#include <dos.h>
#include <stdio.h>
#include <stdlib.h>
#include <mem.h>


#include <bios.h>
//MED
#include "memcheck.h"

char	localbuffer[MAXPACKET*2+2];
char  serialpacket[MAXPACKET];
int   serialpacketlength;

int   inescape;
int   newpacket;
int   uart;
int   irq;
int   baudrate;
que_t		inque, outque;

enum {UART_8250, UART_16550} uart_type;

int			modem_status = -1;
int			line_status = -1;


void (__interrupt __far *oldirqvect) () = NULL;

int			irqintnum;


void talk (void)
{
	int c;

	printf ("Talk mode...  Press ESC to return\n\n");
	while (TRUE)
	{
		/* Check for keypress */
      if (_bios_keybrd (_KEYBRD_READY))
		{
         if ((c = _bios_keybrd (_KEYBRD_READ) & 0xff) == ESC)
			{
				/* ESC key -- Exit talk mode -- Flush both sides */
            write_byte (c);
				while (read_byte () != -1)
				;
            while (_bios_keybrd (_KEYBRD_READY))
               _bios_keybrd (_KEYBRD_READ);
				printf ("\n\n");
				return;
			}
			if (c == 0x0D)		/* Change cr to crlf */
				c = 0x0A;
         write_byte (c);
         printf ("%c\n", c);
		}
		/* Check for received byte */
		if ((c = read_byte ()) != -1)
         {
         if (c==ESC)
            {
				while (read_byte () != -1)
				;
            while (_bios_keybrd (_KEYBRD_READY))
               _bios_keybrd (_KEYBRD_READ);
				printf ("\n\n");
				return;
            }
         printf ("%c\n", c);
         }
	}
}


/*
===============
=
= SetupModemGame
=
===============
*/

void SetupModemGame ( void )
{
   serialdata_t * ser;

   ser=(serialdata_t *)&rottcom->data[0];
   irq=ser->irq;
   uart=ser->uart;
   baudrate=ser->baud;
   InitPort();
//   talk();
}

/*
===============
=
= ShutdownModemGame
=
===============
*/

void ShutdownModemGame ( void )
{
   ShutdownPort();
}


/*
===============
=
= EnablePort
=
===============
*/

void EnablePort ( void )
{
   int mcr;

//
// prepare for interrupts
//
	OUTPUT( uart + INTERRUPT_ENABLE_REGISTER, 0 );	/* Turn off interrupts */

	mcr = INPUT( uart + MODEM_CONTROL_REGISTER );	/* Get modem status */
	mcr |= MCR_OUT2;											/* Set GPO 2 */
	mcr &= ~MCR_LOOPBACK;									/* Turn off loopback test */
   mcr |= MCR_DTR;                                 /* Set DTR */
   mcr |= MCR_RTS;                                 /* Set RTS */
	OUTPUT( uart + MODEM_CONTROL_REGISTER, mcr );	/* Set modem status */

	INPUT( uart );												/* Clear Rx interrupts */
	INPUT( uart + INTERRUPT_ID_REGISTER );				/* Clear Tx interrupts */


//
// hook the irq vector
//
	irqintnum = irq + 8;

   oldirqvect = _dos_getvect(irqintnum);
   _dos_setvect (irqintnum, isr_8250);

	OUTPUT( 0x20 + 1, INPUT( 0x20 + 1 ) & ~(1<<irq) );

	CLI();

// enable RX and TX interrupts at the uart
// also enable Line Status interrupts to watch for errors.

	OUTPUT( uart + INTERRUPT_ENABLE_REGISTER,
      IER_RX_DATA_READY + IER_TX_HOLDING_REGISTER_EMPTY);

// enable interrupts through the interrupt controller

	OUTPUT( 0x20, 0xc2 );

// Set DTR

	OUTPUT( uart + MODEM_CONTROL_REGISTER,
           INPUT( uart + MODEM_CONTROL_REGISTER ) | MCR_DTR );

	STI();
}

/*
===============
=
= InitPort
=
===============
*/

void InitPort ( void )
{
	int	temp;
	unsigned long divisor;

//
// init com port settings
//

   inque.head=0;
   inque.tail=0;
   inque.size=0;
   outque.head=0;
   outque.tail=0;
   outque.size=0;

//
// check for a 16550
//
	OUTPUT( uart + FIFO_CONTROL_REGISTER, FCR_FIFO_ENABLE + FCR_TRIGGER_04 );
	temp = INPUT( uart + INTERRUPT_ID_REGISTER );
	if ( ( temp & 0xf8 ) == 0xc0 )
	{
		uart_type = UART_16550;
		printf ("UART is a 16550\n");
	}
	else
	{
		uart_type = UART_8250;
		OUTPUT( uart + FIFO_CONTROL_REGISTER, 0 );
		printf ("UART is an 8250\n");
   }

   EnablePort ();
}



/*
=============
=
= ShutdownPort
=
=============
*/

void ShutdownPort ( void )
{
	OUTPUT( uart + INTERRUPT_ENABLE_REGISTER, 0 );	/* Turn off interrupts */
//   OUTPUT( uart + MODEM_CONTROL_REGISTER, 0 );     /* Clear modem status */
//   OUTPUT( uart + FIFO_CONTROL_REGISTER, 0 );      /* Clear fifo status */

	OUTPUT( 0x20 + 1, INPUT( 0x20 + 1 ) | (1<<irq) );

   _dos_setvect (irqintnum,oldirqvect);                 /* Return to orig. inter. */

}

int read_byte( void )
{
   int   c;

   if (inque.size == 0)
      return -1;

   c = inque.data[QueSpot(inque.tail++)];
   inque.size--;

   return c;
}


void write_byte( unsigned char c )
{
   outque.data[QueSpot(outque.head++)] = c;
   outque.size++;

   if ( INPUT( uart + LINE_STATUS_REGISTER ) & 0x40)
      jump_start();
}


void write_bytes( char *buf, int count )
{
   if (QueSpot(outque.head) + count >= QUESIZE)                /* About to wrap around */
   {
      while (count--)
         write_byte (*buf++);
   }
   else
   {
      memcpy(outque.data + QueSpot(outque.head), buf, count);  /* Write all at once */
      outque.head += count;
      outque.size += count;
      if ( INPUT( uart + LINE_STATUS_REGISTER ) & 0x40)
         jump_start();
   }
}


/*
================
=
= write_buffer
=
================
*/

void write_buffer( char *buffer, unsigned int count )
{
// if this would overrun the buffer, throw everything else out
	if (outque.size + count > QUESIZE)
	{
		outque.tail = outque.head;
		outque.size = 0;
	}

   write_bytes (buffer, count);

}


/*
==============
=
= isr_8250
=
==============
*/

void interrupt isr_8250(void)
{
	int c;
	int	count;

	while (1)
	{
		switch( INPUT( uart + INTERRUPT_ID_REGISTER ) & 7 )
		{
//
// receive one byte for the UART 8250,
// as many as possible for the UART 16550
//
      case IIR_RX_DATA_READY_INTERRUPT :
         do
			{
            c = INPUT( uart + RECEIVE_BUFFER_REGISTER );
            inque.data[QueSpot(inque.head++)] = c;
            inque.size++;
			} while ( uart_type == UART_16550 && INPUT( uart + LINE_STATUS_REGISTER ) & LSR_DATA_READY );
         break;

//
// transmit one byte for the UART 8250
// 16 bytes for the UART 16550
//
      case IIR_TX_HOLDING_REGISTER_INTERRUPT :
			if (outque.size != 0)
			{
            if (uart_type == UART_16550)
					count = 16;
				else
					count = 1;
				do
				{
               c = outque.data[QueSpot(outque.tail++)];
               outque.size--;
               OUTPUT( uart + TRANSMIT_HOLDING_REGISTER, c );
				} while (--count && outque.size != 0);
			}
         break;

      case IIR_MODEM_STATUS_INTERRUPT :
			modem_status = INPUT( uart + MODEM_STATUS_REGISTER );
			break;

// not enabled
		case IIR_LINE_STATUS_INTERRUPT :
			line_status = INPUT( uart + LINE_STATUS_REGISTER );
         break;

//
// done
//

		default :
         OUTPUT( 0x20, 0x20 );
			return;
		}
	}
}


/*
===============
=
= jump_start
=
= Start up the transmition interrupts by sending the first char
===============
*/

void jump_start( void )
{
	int c;

   if (outque.size != 0)
	{
      c = outque.data [QueSpot(outque.tail++)];
      outque.size--;
      OUTPUT( uart, c );
	}
}


/*
================
=
= ReadSerialPacket
=
================
*/

boolean ReadSerialPacket (void)
{
	int	c;

// if the buffer has overflowed, throw everything out


	if (inque.size > QUESIZE - 4)	// check for buffer overflow
	{
		inque.tail = inque.head;
		inque.size = 0;
		newpacket = true;
		return false;
	}

	if (newpacket)
	{
      serialpacketlength = 0;
		newpacket = 0;
	}

	do
	{
		if ((c = read_byte ()) < 0)
			return false;      // haven't read a complete packet
		if (inescape)
		{
			inescape = false;
			if (c!=FRAMECHAR)
			{
				newpacket = 1;

				return true;    // got a good packet
			}
		}
		else if (c==FRAMECHAR)
		{
			inescape = true;
			continue;			// don't know yet if it is a terminator
		}						// or a literal FRAMECHAR

      if (serialpacketlength >= MAXPACKET)
		{
			continue;			// oversize packet
		}

      serialpacket[serialpacketlength] = c;
      serialpacketlength++;
	} while (1);

}

/*
=============
=
= WriteSerialPacket
=
=============
*/

void WriteSerialPacket (char *buffer, int len)
{
	int		b;

	b = 0;
	if (len > MAXPACKET)
	{
		return;
	}

	while (len--)
	{
		if (*buffer == FRAMECHAR)
			localbuffer[b++] = FRAMECHAR;	// escape it for literal
		localbuffer[b++] = *buffer++;
	}

	localbuffer[b++] = FRAMECHAR;
	localbuffer[b++] = 0;

	write_buffer (localbuffer, b);
}


#if 0
/*
================
=
= ReadSerialPacket
=
================
*/

boolean ReadSerialPacket ( byte * packet, short * length )
{
	int	c;

// if the buffer has overflowed, throw everything out


	if (inque.size > QUESIZE - 4)	// check for buffer overflow
	{
		inque.tail = inque.head;
		inque.size = 0;
		newpacket = true;
		return false;
	}

	if (newpacket)
	{
      (*length) = 0;
		newpacket = 0;
	}

	do
	{
		if ((c = read_byte ()) < 0)
			return false;      // haven't read a complete packet
		if (inescape)
		{
			inescape = false;
			if (c!=FRAMECHAR)
			{
				newpacket = 1;

				return true;    // got a good packet
			}
		}
		else if (c==FRAMECHAR)
		{
			inescape = true;
			continue;			// don't know yet if it is a terminator
		}						// or a literal FRAMECHAR

      if ((*length) >= MAXPACKET)
		{
			continue;			// oversize packet
		}

      packet[(*length)] = c;
      (*length)++;
	} while (1);

}
#endif

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "watcom.h"
// #include "splib.h"
#include "rt_draw.h"
#include "rt_playr.h"
#include "isr.h"
// #include "mem.h"
#include "stdlib.h"
#include "rt_spbal.h"
#include "_rt_spba.h"
#include "sbconfig.h"
#include "rt_main.h"
#include "rt_map.h"

#include "rt_debug.h"
#include "rt_game.h"
#include "rt_str.h"
#include "rt_vid.h"
#include "rt_playr.h"
#include "rt_actor.h"
#include "rt_main.h"
#include "rt_util.h"
#include "rt_draw.h"
#include "rt_in.h"
#include "z_zone.h"
#include "rt_ted.h"
#include "rt_view.h"
#include "develop.h"
#include "version.h"
#include "scriplib.h"
#include <stdlib.h>
// #include <conio.h>
// #include <io.h>
// #include <fcntl.h>
// #include <dos.h>
//MED
#include "memcheck.h"

/* This file and associated .h files and Spaceball libraries:
   Copyright 1995 Spacetec IMC Corporation
*/
//static char c[]="Copyright 1995 Spacetec IMC Corporation";


#define MSGN(x)    (((x)>0)?1:-1)
#define MABS(x)    ((x<0)?(-x):(x))

#define FF(n) FLOAT_TO_FIXED(n)

#define MAX_WARPS 1  // maximum number of ranges in all warps in defaultWarps
static WarpRange defaultWarps[][MAX_WARPS]={
    {{  0, 511, FF(0.00013)}},   // Tx
    {{  0, 511, FF(0.0075 )}},   // Ty
	 {{  0, 511, FF(0.0005 )}},   // Tz
    {{150, 511, FF(0.0075 )}},   // Rx
	 {{  0, 511, FF(0.15   )}}	   // Ry
};

#undef FF


static WarpRecord defaultRecords[]={
	 {"Tx",  defaultWarps[0], 1},
	 {"Ty",  defaultWarps[1], 1},
	 {"Tz",  defaultWarps[2], 1},
	 {"Rx",  defaultWarps[3], 1},
	 {"Ry",  defaultWarps[4], 1},
};

WarpRecord *WarpTx, *WarpTy, *WarpTz, *WarpRx, *WarpRy;

static char *SpaceBallConfigName = "spwrott.cfg";
static char *ApogeePath = "APOGEECD";

#define    TURBO_LIMIT          1000000
static int turbo_increment    = 500000,
           turbo_count        = 0,
           turboFire          = false;


// sbbuttons mask: 00FE DCBA

#define BUTTON_A    0x01
#define BUTTON_B    0x02
#define BUTTON_C    0x04
#define BUTTON_D    0x08
#define BUTTON_E    0x10
#define BUTTON_F    0x20

// All possible button assignment masks (with defaults)
static
short turboFireMask      = BUTTON_A,
      attackMask         = BUTTON_B,
      useMask            = BUTTON_C,
      mapMask            = 0,
      swapWeaponMask     = BUTTON_D,
      singleAxisMask     = 0,
      planarMask         = 0,
      aimMask            = BUTTON_E,
      pauseMask          = BUTTON_F;

// Array exists just to make sure two tasks are not assigned to same button
static short *masks[6]={&turboFireMask,  &attackMask, &useMask,
                        &swapWeaponMask, &aimMask,    &pauseMask};



//******************************************************************************
//
// ShiftTowardZero ()
//
//******************************************************************************

static short
ShiftTowardZero(short n, short amount)
{
   if (MABS(n) >= amount)
      return n-((n>0)?amount:-amount);
   else
      return 0;
}


//******************************************************************************
//
// SPW_SingleAxisFilter
//
//  Zeroes all but the largest (in absolute value) element in a RawPacket
//
//   returns: nothing
//
//******************************************************************************

static void
SPW_SingleAxisFilter(SpwRawData *p)
{
    short *array   = &(p->tx),  // hope the data are in contigous locations
          *largest = array,
           newabs, large, array_length = 6;

    large = MABS( *array );
    while (--array_length > 0) {
        ++array;
        newabs = MABS(*array);
        if (newabs > large) {
            *largest = 0;
            large = newabs;
            largest = array;
        } else
            *array = 0;
    }

} /* end of SPW_SingleAxisFilter */



//******************************************************************************
//
// HandleSpaceBallMotion ()
//
//******************************************************************************

static void HandleSpaceBallMotion (SpwRawData * npacket, int controlbuf[])
{

   int    strafeAngle;
   short  tx, ty, tz, rx, ry;
   long   sbtx, sbty, sbtz, sbrx, sbry;
   static short ButtonState;

   // If they are really cranking on it, limit them to one axis at a time
   if ((MABS(npacket->tx) > 450) ||
       (MABS(npacket->ty) > 450) ||
       (MABS(npacket->tz) > 450) ||
       (MABS(npacket->rx) > 450) ||
       (MABS(npacket->ry) > 450)) SPW_SingleAxisFilter(npacket);

   // Don't want to lose the low end that the sb null_region calc is losing
   tx=ShiftTowardZero(npacket->tx,30);   // range now approximately +/- 0-480
   ty=ShiftTowardZero(npacket->ty,30);   // range now approximately +/- 0-480
   tz=ShiftTowardZero(npacket->tz,50);   // range now approximately +/- 0-460
   rx=ShiftTowardZero(npacket->rx,60);   // range now approximately +/- 0-450
   ry=ShiftTowardZero(npacket->ry,60);   // range now approximately +/- 0-450

   sbtx = SbFxConfigWarp( WarpTx, tx );
   sbty = SbFxConfigWarp( WarpTy, ty );
   sbtz = SbFxConfigWarp( WarpTz, tz );
   sbrx = SbFxConfigWarp( WarpRx, rx );
   sbry = SbFxConfigWarp( WarpRy, ry );

   strafeAngle = (player->angle - FINEANGLES/4)&(FINEANGLES-1);

   // check for turboFire
   if (turboFire)
      {
      if (MABS(turbo_count) > TURBO_LIMIT)
         turbo_increment *= -1;
      turbo_count += turbo_increment;
      sbry += turbo_increment;
      }

   controlbuf[0] += -(FixedMul (sbtz, viewcos))+
                     FixedMul (sbtx, costable[strafeAngle]);

   controlbuf[1] +=  FixedMul (sbtz, viewsin) -
                    FixedMul (sbtx, sintable[strafeAngle]);

   controlbuf[2] += sbry;



   // Handle looking up and down ^ flying

   ButtonState=npacket->buttons.cur;

   // should the user be running?
   buttonpoll[bt_run] = true; //((MABS(tx)+MABS(tz)+MABS(ry)) > 320) ? true : false ;


   // TY does flying if the user has acquired the ability to fly.
   // Currently this is ^'ed with looking up and down
   if (player->flags & FL_FLEET)
      {
      if (sbty != 0)
         {
         if (sbty > 0)
            buttonpoll[bt_lookup  ] = true;
         else
            buttonpoll[bt_lookdown] = true;
         }
      }
   else  // Lookup/down || aim up/down ?
      {
      if ( sbrx != 0 )
         {
         if (sbrx > 0)
            {
            if (ButtonState & aimMask)
               buttonpoll[bt_horizonup] = true;
            else
               buttonpoll[bt_lookup] = true;
            }
         else
            {
            if (ButtonState & aimMask)
               buttonpoll[bt_horizondown] = true;
            else
               buttonpoll[bt_lookdown] = true;
            }
         }
      }


}

//******************************************************************************
//
// PollSpaceBall ()
//
//******************************************************************************

void PollSpaceBall (void)
{
   SpwRawData rawpacket;
	short buttonsChanged;
   static short buttonState=0;
   static int reusePacketNTimes=0;
   static SpwRawData lastPacket;

   memset(&rawpacket,0,sizeof(rawpacket));
   if (SpwSimpleGet(0,&rawpacket))
      {
      lastPacket=rawpacket;
      reusePacketNTimes=6;
      }
   else if (reusePacketNTimes > 0)
      {
      rawpacket=lastPacket;
      --reusePacketNTimes;
      }
   else if (buttonState) // did not get a packet but a button is down
      rawpacket.buttons.cur=lastPacket.buttons.cur;
   else
      return;


   buttonsChanged=buttonState ^ rawpacket.buttons.cur;
   buttonState=rawpacket.buttons.cur;

   buttonpoll[bt_attack] = (turboFire = (buttonState & turboFireMask) ? true : false );

   if (buttonState & mapMask)          DoMap(player->tilex,player->tiley);
   if (buttonState & useMask)          buttonpoll[bt_use]        = true;
   if (buttonState & attackMask)       buttonpoll[bt_attack]     = true;
   if (buttonState & swapWeaponMask)   buttonpoll[bt_swapweapon] = true;
   if (buttonState & singleAxisMask)   SPW_SingleAxisFilter(&rawpacket);
   if (buttonState & planarMask)       rawpacket.ty=rawpacket.rz=rawpacket.rx=0;
   if (buttonState & pauseMask)        PausePressed=true;
   if (!PausePressed)                  HandleSpaceBallMotion(&rawpacket,controlbuf);
}


//******************************************************************************
//
// OpenSpaceBall ()
//
//******************************************************************************

void OpenSpaceBall (void)
{
   int  btn;
   char filename[ 128 ];

   if (SpwSimpleOpen(0))
      {
      SpwRawData sp;

      SpaceBallPresent = true;
      printf("Test the Spaceball by moving the ball and/or pressing buttons.\n");
      printf("Exit test by pressing any keyboard key...\n");
      while(!kbhit())
         {

         if (SpwSimpleGet(0,&sp))
            printf("\r# tx: %4d ty: %4d tz: %4d # rx: %4d ry: %4d rz: %4d # b:  %1c-%1c-%1c-%1c-%1c-%1c",
                  sp.tx, sp.ty, sp.tz,
                  sp.rx,  sp.ry,  sp.rz,
                  sp.buttons.cur &  1 ? 'A':' ', sp.buttons.cur &  2 ? 'B':' ',
                  sp.buttons.cur &  4 ? 'C':' ', sp.buttons.cur &  8 ? 'D':' ',
                  sp.buttons.cur & 16 ? 'E':' ', sp.buttons.cur & 32 ? 'F':' ');
         }

      // Check for configuration file, set defaults if none

      GetPathFromEnvironment( filename, ApogeePath, SpaceBallConfigName );

	   SbConfigParse(filename);

      // Check for warp records
   	WarpTx = SbConfigGetWarpRange("Tx");
   	WarpTy = SbConfigGetWarpRange("Ty");
   	WarpTz = SbConfigGetWarpRange("Tz");
   	WarpRx = SbConfigGetWarpRange("Rx");
   	WarpRy = SbConfigGetWarpRange("Ry");

	   if(!WarpTx) WarpTx = &defaultRecords[0];
	   if(!WarpTy) WarpTy = &defaultRecords[1];
   	if(!WarpTz) WarpTz = &defaultRecords[2];
   	if(!WarpRx) WarpRx = &defaultRecords[3];
   	if(!WarpRy) WarpRy = &defaultRecords[4];

      // Check for button assignments
	   if((btn=SbConfigGetButtonNumber("TURBO_FIRE"))!=-1)
         {
         if (masks[btn])
            *(masks[btn]) = 0; // zero out mask previously assigned to button
         masks[btn]= &turboFireMask;
		   turboFireMask=(short)(1<<btn);
         }

	   if((btn=SbConfigGetButtonNumber("ATTACK"))!=-1)
         {
         if (masks[btn])
            *masks[btn] = 0; // zero out mask previously assigned to button
         masks[btn]= &attackMask;
		   attackMask=(short)(1<<btn);
         }

	   if((btn=SbConfigGetButtonNumber("USE"))!=-1)
         {
         if (masks[btn])
            *masks[btn] = 0; // zero out mask previously assigned to button
         masks[btn]= &useMask;
		   useMask=(short)(1<<btn);
         }

	   if((btn=SbConfigGetButtonNumber("MAP"))!=-1)
         {
         if (masks[btn])
            *masks[btn] = 0; // zero out mask previously assigned to button
         masks[btn]= &mapMask;
		   mapMask=(short)(1<<btn);
         }

	   if((btn=SbConfigGetButtonNumber("SWAP_WEAPON"))!=-1)
         {
         if (masks[btn])
            *masks[btn] = 0; // zero out mask previously assigned to button
         masks[btn]= &swapWeaponMask;
		   swapWeaponMask=(short)(1<<btn);
         }

	   if((btn=SbConfigGetButtonNumber("SINGLE_AXIS_FILTER"))!=-1)
         {
         if (masks[btn])
            *masks[btn] = 0; // zero out mask previously assigned to button
         masks[btn]= &singleAxisMask;
		   singleAxisMask=(short)(1<<btn);
         }

	   if((btn=SbConfigGetButtonNumber("PLANAR_FILTER"))!=-1)
         {
         if (masks[btn])
            *masks[btn] = 0; // zero out mask previously assigned to button
         masks[btn]= &planarMask;
		   planarMask=(short)(1<<btn);
         }

	   if((btn=SbConfigGetButtonNumber("AIM"))!=-1)
         {
         if (masks[btn])
            *masks[btn] = 0; // zero out mask previously assigned to button
         masks[btn]= &aimMask;
		   aimMask=(short)(1<<btn);
         }

	   if((btn=SbConfigGetButtonNumber("PAUSE"))!=-1)
         {
         if (masks[btn])
            *masks[btn] = 0; // zero out mask previously assigned to button
         masks[btn]= &pauseMask;
		   pauseMask=(short)(1<<btn);
         }
      }
   else
      {
      SpaceBallPresent = false;
      }
}

//******************************************************************************
//
// CloseSpaceBall ()
//
//******************************************************************************

void CloseSpaceBall (void)
{
   if (SpaceBallPresent)
      {
      SpwSimpleClose(0);
      }
}

//******************************************************************************
//
// GetSpaceBallButtons ()
//
//******************************************************************************

unsigned GetSpaceBallButtons (void)
{
   SpwRawData sp;

   return ((SpwSimpleGet(0,&sp) & SPW_BUTTON_DOWN));
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
//****************************************************************************
//
// RT_SWIFT.C
//
// SWIFT services module - for CYBERMAN use in ROTT.
//
//****************************************************************************


#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include "rt_def.h"
#include "rt_swift.h"
#include "_rt_swft.h"
//MED
#include "memcheck.h"


//****************************************************************************
//
// SWIFT_Initialize ()
//
// Test for presence of SWIFT extensions and SWIFT device.
// Returns 1 (TRUE) if SWIFT features are available, 0 otherwise.
// Remember to call SWIFT_Terminate() if SWIFT_Initialize succeeds!
//
//****************************************************************************

int SWIFT_Initialize (void)
{
   SWIFT_StaticData sdBuf;
   int fSwift = 0;

   if (fActive)                     // SWIFT extensions already active
   {
#ifdef DEGUB
      SoftError( "SWIFT_Initialize: Already active.\n");
      SoftError( "SWIFT_Initialize: returns TRUE\n");
#endif
      return (1);
   }

   nAttached = SWIFT_DEV_NONE;


   if (_dos_getvect(0x33) == NULL)  // No mouse driver loaded
   {
#ifdef DBUG
      SoftError( "SWIFT_Initialize: No mouse driver loaded.\n");
      SoftError( "SWIFT_Initialize: returns FALSE\n");
#endif
      return (0);
   }


   // Reset the mouse and driver
   AX (regs) = 0;
   int386( 0x33, &regs, &regs);

   if (AX (regs) == 0)
   {                                // no mouse
#ifdef DBUG
      SoftError( "SWIFT_Initialize: No pointing device attached.\n");
      SoftError( "SWIFT_Initialize: returns FALSE\n");
#endif
      return (0);
   }

#ifdef DBUG
   AX (regs) = 36;   // Get Mouse Information
   BX (regs) = 0xffff;
   CX (regs) = 0xffff;
   DX (regs) = 0xffff;
   int386 (0x33, &regs, &regs);
   SoftError( "SWIFT_Initialize: driver version %d.%02d\n", regs.h.bh, regs.h.bl);
   SoftError( "SWIFT_Initialize: %s mouse using IRQ %d\n",
          (regs.h.ch==1) ? "bus" :
          (regs.h.ch==2) ? "serial" :
          (regs.h.ch==3) ? "inport" :
          (regs.h.ch==4) ? "PS/2" :
                           "unknown", regs.h.cl);
#endif


   // allocate a DOS real-mode buffer
   pdosmem = allocDOS(DOSMEMSIZE, &segment, &selector);
   if (!pdosmem)
   {
#ifdef DBUG
      SoftError( "SWIFT_Initialize: DOS Alloc failed!\n");
      SoftError( "SWIFT_Initialize: returns FALSE\n");
#endif
      return (0);
   }

//
// SWIFT device supported and attached
//
   if (SWIFT_GetStaticDeviceInfo (&sdBuf))
      fSwift = 1;


   if (!fSwift)
   {  // SWIFT functions not present
#ifdef DBUG
      SoftError( "SWIFT_Initialize: no SWIFT support in mouse driver.\n");
#endif
   }
   else
      if (sdBuf.deviceType == SWIFT_DEV_NONE)
      {
#ifdef DBUG
         SoftError( "SWIFT_Initialize: no SWIFT device connected.\n");
#endif
      }
      else
      {
         nAttached = sdBuf.deviceType;
#ifdef DBUG
         SoftError( "SWIFT_Initialize: ");

         switch (nAttached)
         {
            case SWIFT_DEV_CYBERMAN:
               SoftError( "CyberMan %d.%02d connected.\n",
                                sdBuf.majorVersion, sdBuf.minorVersion);
            break;

            default:
               SoftError( "Unknown SWIFT device (type %d) connected.\n",
                                nAttached);
            break;
         }
#endif
      fActive = 1;
   }

   if (!fActive)
   {                    // activation of SWIFT module failed for some reason
      if (pdosmem)
      {                 // if DOS buffer was allocated, free it
         freeDOS(selector);
         pdosmem = 0;
      }
   }

#ifdef DBUG
   SoftError( "SWIFT_Initialize: returns %s.\n", (fActive ? "TRUE" : "FALSE"));
#endif
   return fActive;
}



//****************************************************************************
//
// SWIFT_Terminate ()
//
// Free resources required for SWIFT support.  If SWIFT_Initialize has
// not been called, or returned FALSE, this function does nothing.
// SWIFT_Terminate should always be called at some time after a call to
// SWIFT_Initialize has returned TRUE.
//
//****************************************************************************

void SWIFT_Terminate (void)
{
#ifdef DBUG
   SoftError( "SWIFT_Terminate called.\n");
#endif

   if (fActive)
   {
     // free DOS buffer
      if (pdosmem)
      {
         freeDOS(selector);
         pdosmem = 0;
      }

      fActive = 0;
   }
}


//****************************************************************************
//
// SWIFT_GetAttachedDevice ()
//
// Returns the device-type code for the attached SWIFT device, if any.
//
//****************************************************************************

int SWIFT_GetAttachedDevice (void)
{
   return (nAttached);
}



//****************************************************************************
//
// SWIFT_GetStaticDeviceInfo ()
//
// Reads static device data.
//
//****************************************************************************

int SWIFT_GetStaticDeviceInfo (SWIFT_StaticData far *psd)
{
   memset (&RMI, 0, sizeof (RMI));
   RMI.ax = 0x53C1;                       // SWIFT: Get Static Device Data
   RMI.es = segment;                      // DOS buffer real-mode segment
   RMI.dx = 0;                            //  "    "      "   "   offset
   MouseInt (&RMI);                       // get data into DOS buffer

   *psd = *(SWIFT_StaticData *)pdosmem;   // then copy into caller's buffer
   return (RMI.ax == 1);                  // return success
}



//****************************************************************************
//
// SWIFT_Get3DStatus ()
//
// Read the current input state of the device.
//
//****************************************************************************


void SWIFT_Get3DStatus (SWIFT_3DStatus far *pstat)
{
#ifdef DBUG
   if (!fActive)
   {
      SoftError( "SWIFT_Get3DStatus: SWIFT module not active!\n");
   }
#endif

   memset (&RMI, 0, sizeof (RMI));
   RMI.ax = 0x5301;
   RMI.es = segment;
   RMI.dx = 0;
   MouseInt(&RMI);
   *pstat = *(SWIFT_3DStatus *)pdosmem;
}




//****************************************************************************
//
// SWIFT_TactileFeedback ()
//
// Generates tactile feedback to user.
// d   = duration of tactile burst, in milliseconds.
// on  = motor on-time per cycle, in milliseconds.
// off = motor off-time per cycle, in milliseconds.
//
//****************************************************************************

void SWIFT_TactileFeedback (int d, int on, int off)
{
  // Use DPMI call 300h to issue mouse interrupt
   memset (&RMI, 0, sizeof(RMI));
   RMI.ax = 0x5330;                    // SWIFT: Get Position & Buttons
   RMI.bx = (on / 5) << 8 + (off / 5);
   RMI.cx = d / 40;
   MouseInt (&RMI);

#ifdef DBUG
   SoftError( "SWIFT_TactileFeedback (dur=%d ms, on=%d ms, off=%d ms)\n",
                   d / 40 * 40, on/5*5, off/5*5);
#endif
}



//****************************************************************************
//
// SWIFT_GetDynamicDeviceData ()
//
// Returns Dynamic Device Data word - see SDD_* above
//
//****************************************************************************

unsigned SWIFT_GetDynamicDeviceData (void)
{
   memset (&RMI, 0, sizeof(RMI));
   RMI.ax = 0x53C2;                       // SWIFT: Get Dynamic Device Data
   MouseInt (&RMI);
   return ((unsigned)RMI.ax);
}


//****************************************************************************
//
// MouseInt ()
//
// Generate a call to the mouse driver (interrupt 33h) in real mode,
// using the DPMI function 'Simulate Real-Mode Interrupt'.
//
//****************************************************************************

void MouseInt (struct rminfo *prmi)
{
   memset (&sregs, 0, sizeof (sregs));
   AX (regs) = 0x0300;                    // DPMI: simulate interrupt
   BX (regs) = MOUSE_INT;
   CX (regs) = 0;
   DI (regs) = FP_OFF (prmi);
   sregs.es = FP_SEG (prmi);
   int386x( DPMI_INT, &regs, &regs, &sregs );
}


//****************************************************************************
//
// freeDOS ()
//
// Release real-mode DOS memory block via DPMI
//
//****************************************************************************

void freeDOS (short sel)
{
   AX(regs) = 0x0101;      // DPMI free DOS memory
   DX(regs) = sel;

   int386( DPMI_INT, &regs, &regs);
}


//****************************************************************************
//
// allocDOS ()
//
// Allocate a real-mode DOS memory block via DPMI
//
//****************************************************************************

void far *allocDOS (unsigned nbytes, short *pseg, short *psel)
{
   unsigned npara = (nbytes + 15) / 16;
   void far *pprot;
   pprot = NULL;
   *pseg = 0;        // assume will fail
   *psel = 0;

   // DPMI call 100h allocates DOS memory
   segread (&sregs);
   AX (regs) = 0x0100;        // DPMI: Allocate DOS Memory
   BX (regs) = npara;         // number of paragraphs to alloc
   int386( DPMI_INT, &regs, &regs);

   if (regs.w.cflag == 0)
   {
      *pseg = AX (regs);      // the real-mode segment
      *psel = DX (regs);      // equivalent protected-mode selector
      // pprot is the protected mode address of the same allocated block.
      // The Rational extender maps the 1 MB physical DOS memory into
      // the bottom of our virtual address space.
      pprot = (void far *) ((unsigned)*pseg << 4);
   }
   return pprot;
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
/* Copyright 1995 Spacetec IMC Corporation */

#if defined(__BORLANDC__)
#  pragma inline
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <dos.h>

typedef long fixed;

#include "develop.h"
#include "sbconfig.h"
//MED
#include "memcheck.h"

/* ----------------------------------------------------------------------- */

#define DEFAULT_CONFIG_FILENAME  "sbconfig.dat"

#define NUM_ELEMENTS(x) (sizeof(x)/sizeof(x[0]))
#define SIGN(x) ((x<0)?-1:1)

/* ----------------------------------------------------------------------- */

#if defined(__BORLANDC__)

fixed FIXED_MUL(fixed a, fixed b)
{

   fixed ret_code;

   asm {

      mov  eax,a
      mov  edx,b
      imul edx
      shrd eax,edx,16
      mov  ret_code,eax
   }

   return ret_code;
}

#elif defined(_MSC_VER)

/* Microsoft C7.0 can not be done with inline assembler because it
   can not handle 32-bit instructions
*/
fixed FIXED_MUL(fixed a,fixed b)
{
   fixed sgn,ah,al,bh,bl;

   sgn = (SIGN(a) ^ SIGN(b)) ? -1 : 1 ;
   ah = (a >> 16) & 0xffff ;
   al = (a        & 0xffff);
   bh = (b >> 16) & 0xffff ;
   bl = (b        & 0xffff);

   return sgn * ( ((al*bl)>>16) + (ah*bl) + (al*bh) + ((ah*bh)<<16) );
}

#elif defined(__WATCOMC__)

fixed FIXED_MUL(fixed a, fixed b);

#pragma aux FIXED_MUL =     \
   "imul    edx"            \
   "shrd    eax,edx,16"     \
   parm     [eax] [edx]     \
   value    [eax]           \
   modify   exact [eax]     ;

#endif /* definition of inline FIXED_MUL */


static
fixed StrToFx1616(char *string, char **ret_string)
{
	long  whole;
	long  fract;
	fixed result;
	int   sign;

	/* Skip whitespace */
	while((*string==' ')||(*string=='\t')||(*string=='\n')) string++;

	/* Accept numbers in the form: [+-]?[0-9]+(.[0-9]*)
	*/

	sign=1;
	if(*string=='-')
		{
			string++;
			sign=-1;
		}
	else if(*string=='+')
		{
			string++;
			sign=1;
		}

	/* Read in the whole part */
	whole=0;
	while((*string>='0')&&(*string<='9'))
		whole=whole*10+(*string++)-'0';

	/* Read the optional fraction part */
	fract=0;
	if(*string=='.')
		{
			long place=1;
			string++;
			while((*string>='0')&&(*string<='9'))
				{
					fract=fract*10+(*string++)-'0';
					place*=10;
				}
			/* Convert to fixed point */
			fract=(fract<<16)/place;
		}

	if(ret_string) *ret_string=string;

	if(sign==1)
		result= (whole<<16) + fract;
	else
		result=-(whole<<16) + fract;

	return result;
}

/* ----------------------------------------------------------------------- */

static char *SbButtonNames[]={
	"BUTTON_A",
	"BUTTON_B",
	"BUTTON_C",
	"BUTTON_D",
	"BUTTON_E",
	"BUTTON_F"};

static int         cfgFileVersion=0;
static char        cfgButtons[NUM_ELEMENTS(SbButtonNames)][MAX_STRING_LENGTH];
static WarpRecord *pCfgWarps;
static int         nCfgWarps=0;

/*-------------------------------------------------------------------------*/

/* Read a string in the form: "{#, #, #}"
 * and return a pointer to the character AFTER the '}'
 * or NULL if error
 */
static char *GetWarpLevels(char *string, WarpRange *pw)
{
	short value;
   fixed fxvalue;

	if((*string++)!='{')
  		return NULL;

	if(!*string)
  		return NULL;

	/* Expecting the first number - low */
	value=(short)strtol(string, &string, 0);
	if(pw) pw->low=value;

	/* Skip any whitespace */
	while(isspace(*string)) string++;

	if(*string++!=',')
  		return NULL;

	/* Expecting the second number - high */
	value=(short)strtol(string, &string, 0);
	if(pw) pw->high=value;

	/* Skip any whitespace */
	while(isspace(*string)) string++;

	if(*string++!=',')
  		return NULL;

	/* Expecting the third number - multiplier */
	fxvalue=StrToFx1616(string, &string);
	if(pw) pw->mult=fxvalue;

	/* Skip any whitespace */
	while(isspace(*string)) string++;

	if(*string!='}')
		return NULL;

	return string+1;
}



static int GetWarp(char *string, WarpRecord *pRecord)
{
	int        nWarp;
	WarpRange *pWarp;

	/* Only update the field if we successfully read the entire line */
	nWarp=0;
	pWarp=NULL;

	/* Skip whitespace */
	while(isspace(*string)) string++;

	if(*string++!='{') return 0;

	while(string && *string)
		{
			switch(*string)
				{
				case ' ':
				case '\t':
				case '\n':
					string++;
					break;

				case ',':
					string++;
					break;

				case '{':
					if(nWarp++==0)
						pWarp=malloc(sizeof(WarpRange));
					else
						pWarp=realloc(pWarp, nWarp*sizeof(WarpRange));

					string=GetWarpLevels(string, pWarp+nWarp-1);
					break;

				case '}':
					pRecord->nWarp=nWarp;
					pRecord->pWarp=pWarp;
					return 1;
				}
		}

	/* Early EOL (didn't get closing '}') */
	if(nWarp) free(pWarp);
	return 0;
}
	

/*-------------------------------------------------------------------------*/

int SbConfigParse(char *filename)
{
	int             i;
	FILE           *file;
	char           *pc;
	char            buffer[128];

   if(!filename) filename=DEFAULT_CONFIG_FILENAME;

	if(!(file=fopen(filename, "r")))
      {
			printf("Config file: %s, not found\n", filename);
			return 0;
      }

	while(fgets(buffer, sizeof(buffer), file))
		{
			int lineParsed=0;

			/* each line in config file starts with either a ;, VERSION or an
	      ** element of GameButtonNames or WarpNames
			*/
	      pc=strtok(buffer, " \t\n,");

	      if(*pc==';')									/* commented out line? */
				continue;

			/* VERSION?  The version will be used in the future to allow fx1616
			**           values in the config file
			*/
			if(!stricmp(pc,"VERSION"))
				{
					pc=strtok(NULL, " \t\n,");
					cfgFileVersion=atoi(pc);
				}

			/* Check if first token is an element of SbButtonNames */
			for(i=0; i<NUM_ELEMENTS(SbButtonNames); i++)
				if(!stricmp(pc, SbButtonNames[i]))
					{
						lineParsed=1;

						/* Save the next token in the appropriate slot */
						pc=strtok(NULL," \t\n,");

						strncpy(cfgButtons[i], pc, MAX_STRING_LENGTH-1);
						cfgButtons[i][MAX_STRING_LENGTH-1]=0;
					}

			/* If the first token is not from GameButtonNames,
			** it must be a WarpName
			*/
			if(!lineParsed)
				{
					char *name;

					name=pc;
					pc=pc+strlen(pc)+1;			/* Skip this token */
					while(isspace(*pc)) pc++;	/* Skip any whitespace */

					if(*pc=='{')
						{
							WarpRecord warpRec;

							strcpy(warpRec.name, name);
							warpRec.pWarp=NULL;
							warpRec.nWarp=0;

							if(GetWarp(pc, &warpRec))
								{
									if(nCfgWarps++==0)
										pCfgWarps=(WarpRecord *)malloc(sizeof(WarpRecord));
									else
										pCfgWarps=(WarpRecord *)realloc(pCfgWarps, nCfgWarps*sizeof(WarpRecord));
									pCfgWarps[nCfgWarps-1]=warpRec;
								}
						}
				}
		} /* end of while getting lines from config file */

	fclose(file);
   return 1;
}

/*-------------------------------------------------------------------------*/

char *SbConfigGetButton(char *btnName)
{
	int i;
	for(i=0; i<NUM_ELEMENTS(SbButtonNames); i++)
		{
			if(!stricmp(btnName, SbButtonNames[i]))
				if(cfgButtons[i][0])
					return cfgButtons[i];
				else
					return NULL;	/* Empty slot */

			if(!stricmp(btnName, cfgButtons[i]))
				return SbButtonNames[i];
		}

	/* Unknown button name */
	return NULL;
}



int SbConfigGetButtonNumber(char *btnName)
{
	int i;
	for(i=0; i<NUM_ELEMENTS(SbButtonNames); i++)
		{
			if(!stricmp(btnName, cfgButtons[i]))
				return i;
		}

	/* Unknown button name */
	return -1;
}

/*-------------------------------------------------------------------------*/

WarpRecord *SbConfigGetWarpRange(char *rngName)
{
	int i;
	for(i=0; i<nCfgWarps; i++)
		if(!stricmp(rngName, pCfgWarps[i].name))
			return &pCfgWarps[i];

	return NULL;
}

/*-------------------------------------------------------------------------*/

fixed SbFxConfigWarp(WarpRecord *warp, short value)
{
	int  i;
	short absValue;
	fixed accum;
	int   sign;

	if(!warp) return INT_TO_FIXED(value);
	
	absValue=value;
	sign=1;
	if(absValue<0)
		{
			absValue= (short)-absValue;
			sign=-1;
		}

	accum=INT_TO_FIXED(0);

	for(i=0; i<warp->nWarp; i++)
		{
      if(absValue<=warp->pWarp[i].low)
		      ;	/* Ignore it if below this range (if required, will have
					**	been caught by the previous warp)
					*/
			else if((absValue>warp->pWarp[i].low) && (absValue<=warp->pWarp[i].high))
				{
					fixed diff;
					fixed partial;
					diff=INT_TO_FIXED((long)absValue-(long)warp->pWarp[i].low);
               partial=FIXED_MUL(diff, warp->pWarp[i].mult);
					accum=FIXED_ADD(accum, partial);
					break;	/* Exit the for loop */
				}
			else	/* Accumulate if greater than this range */
				{
					fixed partial;
					partial=FIXED_MUL(INT_TO_FIXED((long)warp->pWarp[i].high-(long)warp->pWarp[i].low),
										   warp->pWarp[i].mult);
					accum=FIXED_ADD(accum, partial);
				}
		}

	if(sign==1)
		return  accum;
	else
		return -accum;

#if 0	/* Old technique */
		if((absValue>=warp->pWarp[i].low) && (absValue<=warp->pWarp[i].high))
			if(warp->pWarp[i].shift>=0)
				value=accum+((absValue-warp->pWarp[i].low)<<warp->pWarp[i].shift);
			else
				value=accum+((absValue-warp->pWarp[i].low)>>abs(warp->pWarp[i].shift));
		else
			if(warp->pWarp[i].shift>=0)
				accum+=(warp->pWarp[i].high-warp->pWarp[i].low)<<warp->pWarp[i].shift;
			else
				accum+=(warp->pWarp[i].high-warp->pWarp[i].low)>>abs(warp->pWarp[i].shift);

	if(absValue>warp->pWarp[warp->nWarp-1].high)
		value=accum;

	return sign*value;
#endif
}


/*-------------------------------------------------------------------------*/

long SbConfigWarp(WarpRecord *warp, short value)
{
   /* An apparent bug in the msc70 compiler, trashes r
      if it is on the stack.  Leave in unitialized global segment.
   */
   static fixed r;

   r = SbFxConfigWarp(warp,value);

   return r >> 16 ;
}


/*-------------------------------------------------------------------------*/

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
/**********************************************************************
   module: USRHOOKS.C

   author: James R. Dose
   phone:  (214)-271-1365
   date:   July 26, 1994

   This module contains cover functions for operations the library
   needs that may be restricted by the calling program.  This code
   is left public for you to modify.
**********************************************************************/

#include <stdlib.h>
#include "usrhooks.h"
#include "z_zone.h"
//MED
// #include "memcheck.h"


/*---------------------------------------------------------------------
   Function: USRHOOKS_GetMem

   Allocates the requested amount of memory and returns a pointer to
   its location, or NULL if an error occurs.  NOTE: pointer is assumed
   to be dword aligned.
---------------------------------------------------------------------*/

int USRHOOKS_GetMem
   (
   void **ptr,
   unsigned long size
   )

   {
   *ptr = Z_Malloc( size, PU_STATIC, NULL );
   if ( *ptr == NULL )
      {
      return( USRHOOKS_Error );
      }

   return( USRHOOKS_Ok );
   }


/*---------------------------------------------------------------------
   Function: USRHOOKS_FreeMem

   Deallocates the memory associated with the specified pointer.
---------------------------------------------------------------------*/

int USRHOOKS_FreeMem
   (
   void *ptr
   )

   {
   if ( ptr == NULL )
      {
      return( USRHOOKS_Error );
      }

   Z_Free( ptr );

   return( USRHOOKS_Ok );
   }
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include <string.h>
#include <stdlib.h>
#include "rt_def.h"
#include "rt_sound.h"
#include "rt_door.h"
#include "rt_ted.h"
#include "rt_draw.h"
#include "watcom.h"
#include "z_zone.h"
#include "w_wad.h"
#include "lumpy.h"
#include "gmove.h"
#include "states.h"
#include "rt_sqrt.h"
#include "rt_stat.h"
#include "sprites.h"
#include "rt_actor.h"
#include "rt_game.h"
#include "rt_main.h"
#include "rt_playr.h"
#include "rt_util.h"
#include "rt_rand.h"
#include "rt_menu.h"
//#include "rt_swift.h"
#include "_rt_acto.h"
#include "rt_cfg.h"
#include "rt_floor.h"
#include "engine.h"
#include "develop.h"
#include "rt_view.h"
#include "isr.h"
#include "rt_com.h"
#include "rt_scale.h"
#include "modexlib.h"
#include "rt_net.h"
#include "rt_msg.h"
//MED
// #include "memcheck.h"

#define SGN(x)  (((x) > 0)?(1):(-1))

#define WILEYBLITZCHANCE  20
#define GIBSOUND		SD_GIBSPLASHSND
#define ACTORTHUDSND	SD_BODYLANDSND
#define ACTORLANDSND	SD_PLAYERLANDSND

//========================== Global Variables ===================================================

#define SHP(difficulty,ob)  (starthitpoints[difficulty][ob->obclass])

#define CAP_OSCUROS_HITPOINTS(ob)								\
{																\
	if (ob->hitpoints > (SHP(gamestate.difficulty,ob)<<1))		\
		ob->hitpoints = (SHP(gamestate.difficulty,ob)<<1);		\
}

boolean			ludicrousgibs=false;

short				colheight[15];

byte				deathshapeoffset[8] = {0,7,7,8,8,9,8,7};

// unsigned			MAXFUNCTION,MINFUNCTION,MAXSTATE,MINSTATE;
nlint			MAXFUNCTION,MINFUNCTION,MAXSTATE,MINSTATE;

objtype			*PLAYER0MISSILE;
objtype			*SCREENEYE;
objtype			*FIRSTACTOR,*LASTACTOR;

objtype			*FIRSTFREE,*LASTFREE;
objtype			*lastactive,*firstactive,**objlist;
objtype			*firstareaactor[NUMAREAS+1],*lastareaactor[NUMAREAS+1];
int					objcount;

byte				RANDOMACTORTYPE[10];

#if (SHAREWARE == 0)
_2Dpoint			SNAKEPATH[512];
#endif
misc_stuff		mstruct,*MISCVARS = &mstruct;
int					angletodir[ANGLES];
objtype			*new;

void				*actorat[MAPSIZE][MAPSIZE];
#if (DEVELOPMENT == 1)
FILE *				williamdebug;
#endif
exit_t				playstate;

void				T_SlideDownScreen(objtype*);

basic_actor_sounds  BAS[NUMCLASSES+3] =
		{{0,0,0,0,0},
			{0,0,0,0,0},
			{0,SD_LOWGUARD1SEESND,SD_LOWGUARDFIRESND,SD_LOWGUARDOUCHSND,SD_LOWGUARD1DIESND},
			{0,SD_HIGHGUARD1SEESND,SD_HIGHGUARDFIRESND,SD_HIGHGUARDOUCHSND,SD_HIGHGUARDDIESND},
			{0,SD_OVERP1SEESND,SD_OVERPFIRESND,SD_OVERPOUCHSND,SD_OVERPDIESND},
			{0,SD_STRIKE1SEESND,SD_STRIKEFIRESND,SD_STRIKEOUCHSND,SD_STRIKEDIESND},
			{0,SD_BLITZ1SEESND,SD_BLITZFIRESND,SD_BLITZOUCHSND,SD_BLITZDIESND},
			{0,SD_ENFORCERSEESND,SD_ENFORCERFIRESND,SD_ENFORCEROUCHSND,SD_ENFORCERDIESND} ,
			{0,SD_MONKSEESND,SD_MONKGRABSND,SD_MONKOUCHSND,SD_MONKDIESND},
			{0,SD_FIREMONKSEESND,SD_FIREMONKFIRESND,SD_FIREMONKOUCHSND,SD_FIREMONKDIESND},
			{0,SD_ROBOTSEESND,SD_ROBOTFIRESND,0,SD_ROBOTDIESND},

			//bosses
			{SD_DARIANSAY1,SD_DARIANSEESND,SD_DARIANFIRESND,0,SD_DARIANDIESND},
			{SD_KRISTSAY1,SD_KRISTSEESND,SD_KRISTFIRESND,0,SD_KRISTDIESND},
			{0,SD_NMESEESND,SD_NMEFIRE1SND,0,SD_NMEDIESND},
			{SD_DARKMONKSAY1,SD_DARKMONKSEESND,SD_DARKMONKFIRE1SND,0,SD_DARKMONKDIESND},
			{SD_SNAKESAY1,SD_SNAKESEESND,SD_SNAKESPITSND,0,SD_SNAKEDIESND},

			//specials
			{0,SD_EMPLACEMENTSEESND,SD_EMPLACEMENTFIRESND,0,0},
			{0,SD_ROBOTSEESND,SD_ROBOTFIRESND,0,SD_ROBOTDIESND}, //wallop
			{0,0,0,0,0}, //pillar
			{SD_FIREJETSND,0,0,0,0}, //firejet
			{SD_BLADESPINSND,0,0,0,0}, //blade
			{SD_CYLINDERMOVESND,0,0,0,0}, //crushcol
			{SD_BOULDERROLLSND,0,0,SD_BOULDERHITSND,0}, //boulder
			{SD_SPEARSTABSND,0,0,0,0}, //spear
			{0,0,0,0,0}, //gasgrate
			{SD_SPRINGBOARDSND,0,0,0,0}, //spring
			{0,0,0,0,0}, //shuriken
			{SD_FIREBALLSND,0,0,SD_FIREBALLHITSND,0}, //wallfire
			{0,0,0,0,0}, //net
			{SD_KRISTMINEBEEPSND,0,0,0,0}, //h_mine
			{0,0,0,0,0}, //grenade
			{0,0,0,0,0}, //fireball
			{0,0,0,0,0}, //dmfball
			{0,0,0,0,0}, //bigshuriken
			{0,0,0,0,0}, //missile
			{0,0,0,0,0}, //NMEsaucer
			{0,0,0,0,0}, //dm_weapon
			{0,0,0,0,0}, //dm_heatseek
			{0,0,0,0,0}, //dm_spit
			{SD_MISSILEFLYSND,0,SD_BAZOOKAFIRESND,SD_MISSILEHITSND,0},
			{SD_MISSILEFLYSND,0,SD_FIREBOMBFIRESND,SD_MISSILEHITSND,0},
			{SD_MISSILEFLYSND,0,SD_HEATSEEKFIRESND,SD_MISSILEHITSND,0},
			{SD_MISSILEFLYSND,0,SD_DRUNKFIRESND,SD_MISSILEHITSND,0},
			{SD_FLAMEWALLSND,0,SD_FLAMEWALLFIRESND,SD_FIREHITSND,0},
			{SD_MISSILEFLYSND,0,SD_SPLITFIRESND,SD_MISSILEHITSND,0},
			{SD_GRAVSND,0,SD_GRAVFIRESND,SD_GRAVHITSND,0},
			{SD_GRAVSND,0,SD_GODMODEFIRESND,SD_GRAVHITSND,0}

		};

//========================== Local Variables ==================================================

extern boolean dopefish;

boolean Masterdisk;

static objtype	*SNAKEHEAD,*SNAKEEND,*PARTICLE_GENERATOR,*EXPLOSIONS;
#if (SHAREWARE == 0)
	static int		OLDTILEX,OLDTILEY;
#endif

static char *debugstr[] =
{
	"inerttype",
	"player",
	"lowguard",
	"highguard",
	"overpatrol",
	"strikeguard",
	"blitzguard",
	"triadenforcer",
	"deathmonk",
	"dfiremonk",
	"roboguard",
	"b_darian",
	"b_heinrich",
	"b_darkmonk",
	"b_roboboss",
	"b_darksnake",
	"patrolgun",
	"wallop",
	"pillar",
	"firejet",
	"blade",
	"crushcol",
	"boulder",
	"spear",
	"gasgrate",
	"spring",
	"shuriken",
	"wallfire",
	"net",
	"h_mine",
	"grenade",
	"fireball",
	"dmfball",
	"bigshuriken",
	"missile",
	"NMEsaucer",
	"dm_weapon",
	"dm_heatseek",
	"dm_spit",
	"p_bazooka",
	"p_firebomb",
	"p_heatseek",
	"p_drunkmissile",
	"p_firewall",
	"p_splitmissile",
	"p_kes",
	"p_godball",
	"collectorobj"
};

static int		starthitpoints[4][NUMENEMIES+2] = {
	{0,0,30,35,50,40,45,425,200,200,100,1500,2500,3000,3000,-1,200,2},
	{0,0,40,50,55,50,50,475,250,250,125,2300,3400,4500,3600,-1,250,2},
	{0,0,50,65,60,60,60,525,275,300,150,2400,3600,5000,4500,-1,300,2},
	{0,0,60,80,70,70,75,525,300,350,175,2800,3800,5900,4800,-1,350,2}
};

static statobj_t  *touchsprite;

static byte dirdiff[8][8] = {
	{0,1,2,3,4,3,2,1},{1,0,1,2,3,4,3,2},
	{2,1,0,1,2,3,4,3},{3,2,1,0,1,2,3,4},
	{4,3,2,1,0,1,2,3},{3,4,3,2,1,0,1,2},
	{2,3,4,3,2,1,0,1},{1,2,3,4,3,2,1,0}
};

static byte dirorder[8][2] = {
	{southeast,northeast},{east,north},
	{northeast,northwest},{north,west},
	{northwest,southwest},{west,south},
	{southwest,southeast},{south,east}
};

#if (SHAREWARE == 0)

static byte dirdiff16[16][16] = {
	{0,1,2,3,4,5,6,7,8,7,6,5,4,3,2,1},
	{1,0,1,2,3,4,5,6,7,8,7,6,5,4,3,2},
	{2,1,0,1,2,3,4,5,6,7,8,7,6,5,4,3},
	{3,2,1,0,1,2,3,4,5,6,7,8,7,6,5,4},
	{4,3,2,1,0,1,2,3,4,5,6,7,8,7,6,5},
	{5,4,3,2,1,0,1,2,3,4,5,6,7,8,7,6},
	{6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,7},
	{7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8},
	{8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7},
	{7,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6},
	{6,7,8,7,6,5,4,3,2,1,0,1,2,3,4,5},
	{5,6,7,8,7,6,5,4,3,2,1,0,1,2,3,4},
	{4,5,6,7,8,7,6,5,4,3,2,1,0,1,2,3},
	{3,4,5,6,7,8,7,6,5,4,3,2,1,0,1,2},
	{2,3,4,5,6,7,8,7,6,5,4,3,2,1,0,1},
	{1,2,3,4,5,6,7,8,7,6,5,4,3,2,1,0}
};
#endif

static byte dirorder16[16][2] = {
	{15,1}  ,	{0,2},	{1,3},	{2,4},
	{3,5}  ,	{4,6},	{5,7},	{6,8},
	{7,9}  ,  {8,10},  {9,11}, {10,12},
	{11,13}, {12,14}, {13,15},  {14,0}
};

//static byte opposite16[16] = {8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7};

#if (SHAREWARE == 0)

static statetype * UPDATE_STATES[NUMSTATES][NUMENEMIES] = {
	{&s_lowgrdstand,&s_highgrdstand,&s_opstand,&s_strikestand,
	&s_blitzstand,&s_enforcerstand,&s_dmonkstand,&s_firemonkstand,
	&s_robogrdstand,&s_darianstand,&s_heinrichstand,NULL,
	&s_darkmonkstand,NULL,&s_gunstand,&s_wallstand},

	{&s_lowgrdpath1,&s_highgrdpath1,&s_oppath1,&s_strikepath1,
	&s_blitzpath1,&s_enforcerpath1,&s_dmonkpath1,&s_firemonkpath1,
	&s_robogrdpath1,NULL,NULL,NULL,
	NULL,NULL,NULL,&s_wallpath},

	{&s_lowgrdcollide,&s_highgrdcollide,&s_opcollide,&s_strikecollide,
	&s_blitzcollide,&s_enforcercollide,&s_dmonkcollide,&s_firemonkcollide,
	&s_robogrdcollide,&s_dariancollide,NULL,NULL,
	NULL,NULL,NULL,&s_wallcollide},

	{&s_lowgrdcollide2,&s_highgrdcollide2,&s_opcollide2,&s_strikecollide2,
	&s_blitzcollide2,&s_enforcercollide2,&s_dmonkcollide2,&s_firemonkcollide2,
	&s_robogrdcollide2,&s_dariancollide2,NULL,NULL,
	NULL,NULL,NULL,&s_wallcollide},

	{&s_lowgrdchase1,&s_highgrdchase1,&s_opchase1,&s_strikechase1,
	&s_blitzchase1,&s_enforcerchase1,&s_dmonkchase1,&s_firemonkchase1,
	NULL/*se1*/,&s_darianchase1,&s_heinrichchase,&s_NMEchase,
	&s_darkmonkchase1,NULL,&s_gunstand,&s_wallpath},

	/*
	{&s_lowgrduse1,&s_highgrduse1,&s_opuse1,&s_strikeuse1,
	&s_blitzuse,&s_enforceruse1,NULL,NULL,
	NULL,&s_darianuse1,NULL,NULL,
	NULL,NULL,NULL,NULL},*/
	{0},

	{&s_lowgrdshoot1,&s_highgrdshoot1,&s_opshoot1,&s_strikeshoot1,
	&s_blitzshoot1,&s_enforcershoot1,NULL,&s_firemonkcast1,
	&s_robogrdshoot1,&s_darianshoot1,&s_heinrichshoot1,NULL,
	NULL,NULL,&s_gunfire1,&s_wallshoot},

	{&s_lowgrddie1,&s_highgrddie1,&s_opdie1,&s_strikedie1,
	&s_blitzdie1,&s_enforcerdie1,&s_dmonkdie1,&s_firemonkdie1,
	&s_robogrddie1,&s_dariandie1,&s_heinrichdie1,&s_NMEdie,
	&s_darkmonkdie1,NULL,&s_gundie1,NULL},

	{0},

	{NULL,NULL,NULL,&s_strikewait,
	&s_blitzstand,&s_enforcerdie1,&s_dmonkdie1,&s_firemonkdie1,
	&s_robogrddie1,&s_dariandie1,&s_heinrichdie1,NULL,
	&s_darkmonkdie1,NULL,NULL,NULL},

	{&s_lowgrdcrushed1,&s_highgrdcrushed1,&s_opcrushed1,&s_strikecrushed1,
	&s_blitzcrushed1,&s_enforcercrushed1,&s_dmonkcrushed1,&s_firemonkcrushed1,
	&s_robogrddie1,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL}

};

#else

static statetype * UPDATE_STATES[NUMSTATES][NUMENEMIES] = { 
	{&s_lowgrdstand,&s_highgrdstand,NULL,&s_strikestand,
	&s_blitzstand,&s_enforcerstand,NULL,NULL,
	&s_robogrdstand,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL},

	{&s_lowgrdpath1,&s_highgrdpath1,NULL,&s_strikepath1,
	&s_blitzpath1,&s_enforcerpath1,NULL,NULL,
	&s_robogrdpath1,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL},

	{&s_lowgrdcollide,&s_highgrdcollide,NULL,&s_strikecollide,
	&s_blitzcollide,&s_enforcercollide,NULL,NULL,
	NULL,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL},

	{&s_lowgrdcollide2,&s_highgrdcollide2,NULL,&s_strikecollide2,
	&s_blitzcollide2,&s_enforcercollide2,NULL,NULL,
	&s_robogrdcollide2,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL},

	{&s_lowgrdchase1,&s_highgrdchase1,NULL,&s_strikechase1,
	&s_blitzchase1,&s_enforcerchase1,NULL,NULL,
	NULL,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL},

	/*
	{&s_lowgrduse1,&s_highgrduse1,&s_opuse1,&s_strikeuse1,
	&s_blitzuse,&s_enforceruse1,NULL,NULL,
	NULL,&s_darianuse1,NULL,NULL,
	NULL,NULL,NULL,NULL},*/
	{0},

	{&s_lowgrdshoot1,&s_highgrdshoot1,NULL,&s_strikeshoot1,
	&s_blitzshoot1,&s_enforcershoot1,NULL,NULL,
	&s_robogrdshoot1,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL},

	{&s_lowgrddie1,&s_highgrddie1,NULL,&s_strikedie1,
	&s_blitzdie1,&s_enforcerdie1,NULL,NULL,
	&s_robogrddie1,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL},

	{0},

	{NULL,NULL,NULL,&s_strikewait,
	&s_blitzstand,&s_enforcerdie1,NULL,NULL,
	&s_robogrddie1,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL},

	{&s_lowgrdcrushed1,&s_highgrdcrushed1,NULL,&s_strikecrushed1,
	&s_blitzcrushed1,&s_enforcercrushed1,NULL,NULL,
	&s_robogrddie1,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL}

};

#endif

#define TABLE_ACTOR(ob)  ((ob->obclass >= lowguardobj) && (ob->obclass <= wallopobj))

void T_Reset(objtype*ob);

static int	STOPSPEED			=	0x200;
static int	PLAYERFRICTION	=	0xe000;
static int	ACTORFRICTION	=	0xf000;
static int	DIAGADJUST		=	0xb504;
static boolean MissileSound		=	true;

boolean FirstExplosionState(statetype *state)
{
	if (DoPanicMapping())
	{
		if (state == &s_altexplosion1)
			return true;
		else
			return false;
	}
	else
	{
		if ((state == &s_explosion1) ||
			(state == &s_grexplosion1) ||
			(state == &s_staticexplosion1)
			)
			return true;
		else
			return false;
	}

}

void SetGibSpeed(int speed)
{
	MISCVARS->gibspeed = speed;
}

void ResetGibSpeed(void)
{
	MISCVARS->gibspeed = NORMALGIBSPEED;
}

int ValidAreanumber (int areanumber)
{
	if ((areanumber >=0) && (areanumber <= NUMAREAS))
		return 1;
	return 0;
}

int GetIndexForState (statetype * state)
{
	int i;

	if (state == NULL)
		return -1;

	for (i=0;i<MAXSTATES;i++)
	{
		if (statetable[i]==state)
			return i;
	}
	Error("Cannot find the state in 'GetIndexForState', "
		"state->shapenum = %d\n",
		state->shapenum);
	return -1;
}

statetype * GetStateForIndex (int index)
{
	if (index == -1)
		return NULL;

	return statetable[index];
}

statobj_t *GetStaticForIndex(int index)
{
	statobj_t* temp;

	for(temp=FIRSTSTAT;temp;temp=temp->statnext)
		if (index == temp->whichstat)
			return temp;

	Error("Cannot find the static in 'GetStaticForIndex', "
		"statindex %d\n",
		index);
	return NULL;
}

void SaveActors(byte **buffer,int*size)
{
	objtype *temp, *tact;
	saved_actor_type dummy;
	byte *tptr;
	int actorcount;

	for(actorcount=0,temp=FIRSTACTOR;temp;temp=temp->next)
		temp->whichactor = actorcount++;

	*size = sizeof(int) + sizeof(numplayers) + sizeof(misc_stuff) + 
		objcount*sizeof(saved_actor_type);
	*buffer = (byte*)SafeMalloc(*size);
	tptr = *buffer;

	memcpy(tptr,MISCVARS,sizeof(misc_stuff));
	tptr += sizeof(misc_stuff);

	memcpy(tptr,&numplayers,sizeof(numplayers));
	tptr += sizeof(numplayers);

	memcpy(tptr,&consoleplayer,sizeof(consoleplayer));
	tptr += sizeof(consoleplayer);

	for(temp=FIRSTACTOR;temp;temp=temp->next)
	{
		dummy.x = temp->x;
		dummy.y = temp->y;
		dummy.z = temp->z;
		dummy.flags = temp->flags;
		dummy.areanumber = temp->areanumber;
		//dummy.whichactor = temp->whichactor;
		dummy.hitpoints = temp->hitpoints;
		dummy.ticcount = temp->ticcount;
		dummy.obclass = (byte)(temp->obclass);
		dummy.stateindex = GetIndexForState(temp->state);
		dummy.shapeoffset = temp->shapeoffset;
		dummy.dirchoosetime = temp->dirchoosetime;
		dummy.door_to_open = temp->door_to_open;
		dummy.targetx = temp->targettilex;
		dummy.targety = temp->targettiley;
		dummy.dir = (signed char)temp->dir;
		dummy.angle = temp->angle;
		dummy.yzangle = temp->yzangle;
		dummy.speed = temp->speed;
		dummy.momentumx = temp->momentumx;
		dummy.momentumy = temp->momentumy;
		dummy.momentumz = temp->momentumz;

		dummy.temp1 = temp->temp1;
		dummy.temp2 = temp->temp2;
		dummy.temp3 = temp->temp3;
		if (temp->whatever)
		{
			/*if ((temp->flags & FL_USE) && (temp!=player))
			{dummy.whateverindex = (GetIndexForState((statetype*)(temp->whatever))|SG_PSTATE);
				if ((dummy.whateverindex < 0) && (dummy.whateverindex != -1))
				Error("Bad actor whatever save value of %d\n",dummy.whateverindex);
			}
			else*/
			{
				tact = (objtype*)(temp->whatever);
				if (tact->which == ACTOR)
					dummy.whateverindex = tact->whichactor;
				else
				{
					statobj_t *tstat;

					tstat = (statobj_t*)(temp->whatever);
					dummy.whateverindex = (tstat->whichstat|SG_PSTAT);
				}
			}
		}
		else
			dummy.whateverindex = -1;

		if (temp->target)
		{
			tact = (objtype*)(temp->target);
			if (tact->which == ACTOR)
			{
				dummy.targetindex = tact->whichactor;
				Debug("\nsave actor %d, type %d has target %d",
					temp->whichactor,temp->obclass,tact->whichactor);
			}
			else if (tact->which == SPRITE)
			{
				statobj_t *tstat;
				tstat = (statobj_t*)(temp->target);
				dummy.targetindex = (tstat->whichstat|SG_PSTAT);
			}
			else // It must be a push wall, and we don't save that
			dummy.targetindex=-1;
		}
		else
			dummy.targetindex = -1;

		memcpy(tptr,&(dummy.x),sizeof(saved_actor_type));
		tptr += sizeof(saved_actor_type);
	}
}

void LoadActors(byte *buffer,int size)
{
	int numactors,i,playerindex;
	saved_actor_type dummy;
	objtype *temp;
	short *targetindices,*whateverindices;

	InitActorList();

	memcpy(MISCVARS,buffer,sizeof(misc_stuff));
	buffer += sizeof(misc_stuff);

	memcpy(&numplayers,buffer,sizeof(numplayers));
	buffer += sizeof(numplayers);

	memcpy(&playerindex,buffer,sizeof(playerindex));
	buffer += sizeof(playerindex);

	size -= (sizeof(misc_stuff)+sizeof(numplayers)+sizeof(playerindex));
	numactors = size/sizeof(saved_actor_type);

	objlist = (objtype**)SafeMalloc(numactors*sizeof(objtype*));
	targetindices = (short*)SafeMalloc(numactors*sizeof(short));
	whateverindices = (short*)SafeMalloc(numactors*sizeof(short));

	for(i=0;i<numactors;i++)
	{
		targetindices[i] = 0;
		whateverindices[i] = 0;
		objlist[i] = NULL;
	}

	for(i=0;i<numactors;i++)
	{
		GetNewActor();
		objlist[i] = new;
		if (i < numplayers)
		{
			PLAYER[i]=new;
			if (i==playerindex)
				player=new;
		}

		memcpy(&(dummy.x),buffer,sizeof(saved_actor_type));

		//new->x = dummy.x;
		//new->y = dummy.y;
		SetFinePosition(new,dummy.x,dummy.y);
		SetVisiblePosition(new,dummy.x,dummy.y);
		new->z = dummy.z;
		new->flags = dummy.flags;
		new->hitpoints = dummy.hitpoints;
		new->ticcount = dummy.ticcount;
		new->shapeoffset = dummy.shapeoffset;
		new->obclass = (classtype)(dummy.obclass);

		new->state = GetStateForIndex(dummy.stateindex);
		if (new->state == &s_superparticles)
			PARTICLE_GENERATOR = new;
		else if
			(new->state->think == T_SlideDownScreen)
			SCREENEYE = new;
		new->dirchoosetime = dummy.dirchoosetime;
		new->door_to_open = dummy.door_to_open;
		new->targettilex = dummy.targetx;
		new->targettiley = dummy.targety;
		new->dir = (dirtype)(dummy.dir);
		new->angle = dummy.angle;
		new->yzangle = dummy.yzangle;
		new->speed = dummy.speed;
		new->momentumx = dummy.momentumx;
		new->momentumy = dummy.momentumy;
		new->momentumz = dummy.momentumz;
		new->temp1 = dummy.temp1;
		new->temp2 = dummy.temp2;
		new->temp3 = dummy.temp3;
		if (dummy.whateverindex == -1)
			new->whatever = NULL;

		else if (dummy.whateverindex & SG_PSTAT)
			new->whatever = GetStaticForIndex(dummy.whateverindex & ~SG_PSTAT);
		else
			whateverindices[i] = dummy.whateverindex+1;

		if (dummy.targetindex == -1)
			new->target = NULL;
		else if (dummy.targetindex & SG_PSTAT)
			new->target = GetStaticForIndex(dummy.targetindex & ~SG_PSTAT);
		else
		{
			targetindices[i] = dummy.targetindex+1;
			Debug("\nload actor %d, type %d has target %d",
				i,new->obclass,dummy.targetindex);
		}

		new->areanumber = dummy.areanumber;
		new->shapenum = new->state->shapenum + new->shapeoffset;
		new->which = ACTOR;
		if (new->flags & FL_ABP)
			MakeActive(new);
		if (new->obclass != inertobj)
			MakeLastInArea(new);

		if (!(new->flags & (FL_NEVERMARK|FL_NONMARK)))
			actorat[new->tilex][new->tiley] = new;

		PreCacheActor(new->obclass,-1);
		buffer += sizeof(saved_actor_type);
	}

	// find unique links between actors,
	// searching list AFTER all have been spawned

	for(i=0;i<numactors;i++)
	{
		temp=objlist[i];
		if (whateverindices[i])
			temp->whatever = objlist[whateverindices[i]-1];
		if (targetindices[i])
			temp->target = objlist[targetindices[i]-1];
	}

	for(temp=FIRSTACTOR;temp;temp=temp->next)
	{
		if (temp->obclass == b_darksnakeobj)
			{if (!SNAKEHEAD)
				SNAKEHEAD = temp;
			else if (!temp->whatever)
				SNAKEEND = temp;
			}

	}

	if (SNAKEHEAD)
		for(temp=FIRSTACTOR;temp;temp=temp->next)
	{
		if (temp->state == &s_megaexplosions)
			EXPLOSIONS = temp;
	}

	//SafeFree(objlist);
	SafeFree(targetindices);
	SafeFree(whateverindices);

}

int RandomSign(void)
{
	if (GameRandomNumber("random sign",0) < 128)
		return -1;
	return 1;
}

void AddToFreeList(objtype*ob)
{
	if (!FIRSTFREE)
	{
		FIRSTFREE = ob;
		LASTFREE = ob;
	}
	else
	{
		ob->prev = LASTFREE;
		LASTFREE->next = ob;
		LASTFREE = ob;
	}
}

void RemoveFromFreeList(objtype*ob)
{
	if (ob == LASTFREE)
	{
		LASTFREE = ob->prev;
		if(LASTFREE)
			LASTFREE->next=NULL;
	}
	else if(ob->next)
	{
		ob->next->prev = ob->prev;
	}

	if (ob == FIRSTFREE)
	{
		FIRSTFREE = ob->next;
		if(FIRSTFREE)
			FIRSTFREE->prev=NULL;
	}
	else if(ob->prev)
	{
		ob->prev->next = ob->next;
	}

	ob->prev = NULL;
	ob->next = NULL;

}

void MakeActive(objtype *ob)
{
	if ((ob == firstactive) || (ob->prevactive) || (ob->nextactive))
	{
		SoftError("\ndouble make active try");
		//AddEndGameCommand ();
		return;
	}

	if (!firstactive)
	{
		firstactive = ob;
		lastactive = ob;
	}
	else
	{
		ob->prevactive = lastactive;
		lastactive->nextactive = ob;
		lastactive = ob;
	}

#if ((DEVELOPMENT == 1))
#if ((LOADSAVETEST == 1))
	if (!lastactive)
		Debug("\nlastactive = NULL !");
	else
		Debug("\nlastactive = %8x",lastactive);
#endif
#endif
}

extern boolean player_noclip;

void MakeLastInArea(objtype *ob)
{
#if 0
	if((ob->obclass == playerobj) && player_noclip)
	{
		if (!ValidAreanumber(ob->areanumber))
		{
		}
	}
#endif

	if (!ValidAreanumber(ob->areanumber))
	{	
		Error("\n ob type %s at %d,%d has illegal areanumber of %d",
			debugstr[ob->obclass], ob->tilex, ob->tiley,
			ob->areanumber);
	}

	if (	(ob == firstareaactor[ob->areanumber]) ||
			(ob->previnarea) || (ob->nextinarea)	)
	{
		SoftError("\ndouble make last in area try");
		//AddEndGameCommand ();
		return;
	}

	if (!firstareaactor[ob->areanumber])
	{
		firstareaactor[ob->areanumber]	= ob;
		lastareaactor[ob->areanumber] = ob;
	}
	else
	{
		ob->previnarea = lastareaactor[ob->areanumber];
		lastareaactor[ob->areanumber]->nextinarea = ob;
		lastareaactor[ob->areanumber] = ob;
	}
}

void RemoveFromArea(objtype *ob)
{
	objtype *ob_tmp;

	if (!((ob == firstareaactor[ob->areanumber]) ||
		(ob->previnarea) || (ob->nextinarea)))
	{
		SoftError("\ndouble remove from area try");
		//AddEndGameCommand ();
		return;
	}

	if (ob == lastareaactor[ob->areanumber])	// remove from master list
	{
		ob_tmp = ob->previnarea;
		lastareaactor[ob->areanumber] = ob_tmp;
		if(ob_tmp)
			ob_tmp->nextinarea = NULL;
	}
	else if(ob->nextinarea)
	{
		ob->nextinarea->previnarea = ob->previnarea;
	}

	if (ob == firstareaactor[ob->areanumber])
	{
		ob_tmp = ob->nextinarea;
		firstareaactor[ob->areanumber] = ob_tmp;
		if(ob_tmp)
			ob_tmp->previnarea = NULL;
	}
	else if(ob->previnarea)
	{
		ob->previnarea->nextinarea = ob->nextinarea;
	}

	ob->previnarea = NULL;
	ob->nextinarea = NULL;
}

void MakeInactive(objtype *ob)
{
	if (!ACTIVE(ob))
//  if (!((ob == firstactive) || (ob->prevactive) || (ob->nextactive)))
	{
		SoftError("\n trying to remove inactive object");
		//AddEndGameCommand ();
		return;
	}

	//if (ob->flags & FL_ABP)
	{
		if (ob == lastactive)	// remove from master list
		{
			lastactive = ob->prevactive;
			if(lastactive)
				lastactive->nextactive=NULL;
		}
		else if(ob->nextactive)
		{
			ob->nextactive->prevactive = ob->prevactive;
		}

		if (ob == firstactive)
		{
			firstactive = ob->nextactive;
			if(firstactive)
				firstactive->prevactive=NULL;
		}
		else if(ob->prevactive)
		{
			ob->prevactive->nextactive = ob->nextactive;
		}

		ob->prevactive = NULL;
		ob->nextactive = NULL;
	}
}

void A_Steal(objtype*ob)
{
	int dx,dy,dz;

	ActorMovement(ob);

	dx = abs(ob->x - PLAYER[0]->x);
	dy = abs(ob->y - PLAYER[0]->y);
	dz = abs(ob->z - PLAYER[0]->z);

	if ((dx > TOUCHDIST) || (dy > TOUCHDIST) || (dz > (TOUCHDIST >> 10)))
	{
		NewState(ob,&s_blitzchase1);
		return;
	}

	if (ob->ticcount)
		return;

	SD_PlaySoundRTP(SD_BLITZSTEALSND,ob->x,ob->y);
	if (PLAYER[0]->flags & FL_GASMASK)
	{
		PLAYER[0]->flags &= ~FL_GASMASK;
		PLAYERSTATE[0].protectiontime = 1;
		ob->temp3 = stat_gasmask;
		GM_UpdateBonus (PLAYERSTATE[0].poweruptime, true);

	}
	else if(PLAYER[0]->flags & FL_BPV)
	{
		PLAYER[0]->flags &= ~FL_BPV;
		PLAYERSTATE[0].protectiontime = 1;
		ob->temp3 = stat_bulletproof;
		GM_UpdateBonus (PLAYERSTATE[0].poweruptime, true);
	}
	else if(PLAYER[0]->flags & FL_AV)
	{
		PLAYER[0]->flags &= ~FL_AV;
		PLAYERSTATE[0].protectiontime = 1;
		ob->temp3 = stat_asbesto;
		GM_UpdateBonus (PLAYERSTATE[0].poweruptime, true);
	}
	else if (PLAYERSTATE[0].missileweapon != -1)
	{
		NewState(PLAYER[0],&s_player);
		PLAYERSTATE[0].attackframe = PLAYERSTATE[0].weaponframe = 0;
		PLAYERSTATE[0].new_weapon = PLAYERSTATE[0].bulletweapon;
		ob->temp3 = GetItemForWeapon(PLAYERSTATE[0].missileweapon);
		ob->temp2 = PLAYERSTATE[0].ammo;
		//ob->temp1 = oldpolltime;
		PLAYERSTATE[0].ammo = -1;

		if (PLAYERSTATE[0].weapon == PLAYERSTATE[0].missileweapon)
			PLAYERSTATE[0].weapondowntics = WEAPONS[PLAYERSTATE[0].weapon].screenheight/GMOVE;
		PLAYERSTATE[0].missileweapon = -1;

		if ( SHOW_BOTTOM_STATUS_BAR() )
			DrawBarAmmo (false);
	}
}

void FindAddresses(void)
{
	int i;
	nlint tstate,tfunct;

// MINFUNCTION = 0xffffffff;
	MINFUNCTION = 0x7fffffffffffffffULL;
// MAXFUNCTION = 0x00000000;
	MAXFUNCTION = 0x0000000000000000ULL;
// MINSTATE = 0xffffffff;
	MINSTATE = 0x7fffffffffffffffULL;
// MAXSTATE = 0x00000000;
	MAXSTATE = 0x0000000000000000ULL;

	for(i=0;i<MAXSTATES;i++)
	{
	tstate = (nlint)(statetable[i]);
	if (tstate < MINSTATE)
		MINSTATE = tstate;

	if (tstate > MAXSTATE)
		MAXSTATE = tstate;
	if (statetable[i]!=NULL)
		{
		tfunct = (nlint)(statetable[i]->think);
		if (tfunct < MINFUNCTION)
			MINFUNCTION = tfunct;

		if (tfunct > MAXFUNCTION)
			MAXFUNCTION = tfunct;
		}
	}
}

void CheckBounds(objtype *ob)
{
	nlint tstate,tfunct;

	tstate = (nlint)(ob->state);
	tfunct = (nlint)(ob->state->think);

	if ((tfunct < MINFUNCTION) || (tfunct > MAXFUNCTION) ||
		(tstate < MINSTATE) || (tstate > MAXSTATE))
	{
		if (tfunct < MINFUNCTION)
			Error("%s has thinking function less than MINFUNCTION",
				debugstr[ob->obclass]);
		else if (tfunct > MAXFUNCTION)
			Error("%s has thinking function greater than MAXFUNCTION",
				debugstr[ob->obclass]);
		if (tstate < MINSTATE)
			Error("%s has state less than MINSTATE",
				debugstr[ob->obclass]);
		else if (tstate > MAXSTATE)
			Error("%s has state greater than MAXSTATE",
				debugstr[ob->obclass]);
	}
}

/*************************************************************/

/*
=====================
=
= DoActor
=
=====================
*/
void main ( void );

void DoActor (objtype *ob)
{
	void (*think)(objtype *);
	int door;

//  for(i=0;i<tics;i++)
//	{

	ApplyGravity(ob);
	M_CheckDoor(ob);
	M_CheckBossSounds(ob);
	if ((ob->obclass >= b_darianobj) &&
		(ob->obclass < b_darksnakeobj) &&
		MISCVARS->REDTIME
		)
	{
		MISCVARS->REDTIME --;
		MISCVARS->redindex = (MISCVARS->REDTIME  & 15);
	}

	if (ob->obclass == playerobj)
		ControlPlayerObj(ob);

	if(!ob->state)
	{
		RemoveObj (ob);
		return;
	}

	think = ob->state->think;
	if (think)
	{
		//CheckBounds(ob);
		think (ob);

		if (!ob->state)
		{
			RemoveObj (ob);
			return;
		}
	}

	if (ob->ticcount)
		ob->ticcount --;

	else
	{
		if (!(ob->state->next))
		{
			RemoveObj (ob);
			return;
		}
		else
			NewState(ob,ob->state->next);
	}

	if (ob->flags&FL_NEVERMARK)
		return;

	if ((ob->flags&FL_NONMARK) && actorat[ob->tilex][ob->tiley])
		return;

	actorat[ob->tilex][ob->tiley] = ob;
}

void ApplyGravity(objtype *ob)
{
	int oldmomentumz;

	if (((ob->momentumz) || (ob->z != nominalheight)) &&
		(ob->obclass > playerobj) &&
		((ob->obclass <= roboguardobj) || (ob->obclass == collectorobj) ||
		(ob->obclass == b_heinrichobj)) &&
		(ob->state->think != T_Stand)
		)
	{
		ob->z += (ob->momentumz>>16);
		ob->momentumz += GRAVITY;
		if (ob->z >= nominalheight)
		{
			ob->z = nominalheight;
			oldmomentumz = ob->momentumz;
			ob->momentumz = 0;
			if (oldmomentumz > 2*GRAVITY)
			{
				if (ob->flags & FL_DYING)
					SD_PlaySoundRTP(ACTORTHUDSND,ob->x,ob->y);
				else
				{
					int oldviolence = gamestate.violence;

					SD_PlaySoundRTP(ACTORLANDSND,ob->x,ob->y);
					gamestate.violence = vl_low;
					BeginEnemyHurt(ob);
					gamestate.violence = oldviolence;
				}
			}
			if (ob->flags&FL_FALLINGOBJECT)
			{
				RemoveObj(ob);
				return;
			}
		}
	}
}

/*
===================
=
= NewState
=
= Changes ob to a new state, setting ticcount to the max for that state
=
===================
*/

void NewState (objtype *ob, statetype *newstate)
{
	if (DoPanicMapping() &&
		((newstate == &s_explosion1) ||
		(newstate == &s_grexplosion1) ||
		(newstate == &s_staticexplosion1)
		)
		)
		ob->state = &s_altexplosion1;
	else
		ob->state = newstate;

	SetVisiblePosition(ob,ob->x,ob->y);
	ob->ticcount = (ob->state->tictime>>1);
	ob->shapenum = ob->state->shapenum + ob->shapeoffset;
}

/*
=========================
=
= InitActorList
=
= Call to clear out the actor object lists returning them all to the free
= list.  Allocates a special spot for the player.
=
=========================
*/

void InitActorList (void)
{
	int i;

	//====== NETWORK STUFF =======================================
	memset(&DEADPLAYER[0],0,sizeof(DEADPLAYER));
	NUMDEAD = 0;

	//======= NULLIFY GLOBAL POINTERS ============================

	LASTACTOR=FIRSTACTOR=NULL;
	FIRSTFREE = LASTFREE = NULL;
	firstactive = lastactive = NULL;
	memset(firstareaactor,0,sizeof(firstareaactor));
	memset(lastareaactor,0,sizeof(lastareaactor));
	NUMSPAWNLOCATIONS = 0;

	PARTICLE_GENERATOR = NULL;
	EXPLOSIONS = NULL;
	SNAKEEND=SNAKEHEAD=NULL;
	SCREENEYE = NULL;
	PLAYER0MISSILE = NULL;

	//============================================================

	objcount = 0;
	memset(MISCVARS,0,sizeof(misc_stuff));
	MISCVARS->gibgravity = -1;
	MISCVARS->gibspeed = NORMALGIBSPEED;

	memset(&RANDOMACTORTYPE[0],0,sizeof(RANDOMACTORTYPE));
	FindAddresses();
	MissileSound = true;
	Masterdisk = false;
	
	T_InitSwizzle();
}

//===========================================================================

/*
=========================
=
= GetNewActor
=
= Sets the global variable new to point to a free spot in objlist.
= The free spot is inserted at the end of the liked list
=
= When the object list is full, the caller can either have it bomb out ot
= return a dummy object pointer that will never get used
=
=========================
*/

void GetNewActor (void)
{
	objtype *temp;

	if (!FIRSTFREE)
	{
		temp = (objtype*)Z_LevelMalloc(sizeof(objtype),PU_LEVELSTRUCT,NULL);
		//SoftError("\nMalloc-ing actor");
		//if (insetupgame)
		//  SoftError("in setup");
	}
	else
	{
		temp = LASTFREE;
		//SoftError("\nfree actor available");
		RemoveFromFreeList(LASTFREE);
	}

	if (temp)
	{
		new = temp;
		memset(new,0,sizeof(*new));

		if (FIRSTACTOR)
		{
			new->prev = LASTACTOR;
			LASTACTOR->next = new;
			LASTACTOR = new;
		}
		else
		{
			FIRSTACTOR = new;
			LASTACTOR = new;
		}

		new->door_to_open = -1;
		new->soundhandle = -1;
		objcount ++;
	}
	else
		Error("Z_LevelMalloc failed in GetNewActor");
}

//===========================================================================

/*
=========================
=
= RemoveObj
=
= Add the given object back into the free list, and unlink it from it's
= neighbors
=
=========================
*/

void RemoveObj (objtype *gone)
{
	if (gone == PLAYER[0])
		Error ("RemoveObj: Tried to remove the player!");

	gone->state=NULL;

	MakeInactive(gone);

	if (gone->obclass!=inertobj)
	{
		if (ValidAreanumber(gone->areanumber))
			RemoveFromArea(gone);
		else
			Error("tried to remove an instance of %s with "
					"invalid areanumber %d",
				debugstr[gone->obclass],gone->areanumber);
	}

	if (gone == LASTACTOR)
	{
		LASTACTOR = gone->prev;
		if(LASTACTOR)
			LASTACTOR->next = NULL;
	}else if(gone->next)
	{
		gone->next->prev = gone->prev;
	}

	if (gone == FIRSTACTOR)
	{
		FIRSTACTOR = gone->next;
		if(FIRSTACTOR)
			FIRSTACTOR->prev = NULL;
	}
	else if(gone->prev)
	{
		gone->prev->next = gone->next;
	}

	if (gone == EXPLOSIONS)
		EXPLOSIONS = NULL;

	gone->next = NULL;
	gone->prev = NULL;

//	SoftError("\nremoving instance of %s",debugstr[gone->obclass]);
	if (actorat[gone->tilex][gone->tiley] == (void*)gone)
		actorat[gone->tilex][gone->tiley] = NULL;

	gone->flags |= FL_NEVERMARK;

	if (gone->flags & FL_TARGET)
		UnTargetActor(gone);

	//Add_To_Delete_Array(gone);
	//Z_Free(gone);
	AddToFreeList(gone);

	objcount--;
}

//============== World Physics Model Functions =========================

void ParseMomentum(objtype *ob,int angle)
{
	ob->momentumx += FixedMul(ob->speed,costable[angle]);
	ob->momentumy -= FixedMul(ob->speed,sintable[angle]);
}

void Set_3D_Momenta(objtype *ob, int speed, int theta, int phi)
{
	int _2Ddiag;

	ob->momentumz = -FixedMul(speed,sintable[phi]);
	_2Ddiag = FixedMul(speed,costable[phi]);
	ob->momentumx = FixedMul(_2Ddiag,costable[theta]);
	ob->momentumy = -FixedMul(_2Ddiag,sintable[theta]);
}

int AngleBetween(objtype *source,objtype*target)
{
	int dx,dy;

	dx = target->x - source->x;
	dy = source->y - target->y;
	return (atan2_appx(dx,dy));
}

void GetMomenta(
	objtype *target, objtype *source, int *newmomx,
	int *newmomy, int *newmomz, int magnitude
	)
{
	int angle,dx,dy,dz,yzangle,xydist,_2Ddiag;

	dx = target->x - source->x;
	dy = source->y - target->y;
	dz = source->z - target->z;
	xydist = FindDistance(dx,dy);
	angle = atan2_appx(dx,dy);
	yzangle = atan2_appx(xydist,(dz<<10));
	_2Ddiag = FixedMul(magnitude,costable[yzangle]);

	*newmomz = -FixedMul(magnitude,sintable[yzangle]);
	*newmomx = FixedMul(_2Ddiag,costable[angle]);
	*newmomy = -FixedMul(_2Ddiag,sintable[angle]);
}

//=======================================================================

void SpawnNewObj (int tilex, int tiley, statetype *state, classtype which)
{
	int newarea;

	tilex &= MAPSIZE-1;
	tiley &= MAPSIZE-1;

	GetNewActor ();
	new->obclass = which;
	SetTilePosition(new,tilex,tiley);
	SetVisiblePosition(new,new->x,new->y);
	new->dir = nodir;
	new->which = ACTOR;
	if (FirstExplosionState(state))
		new->flags |= (FL_NEVERMARK|FL_NOFRICTION);

	if ((which != inertobj) && (which != diskobj))
		actorat[tilex][tiley] = new;

	newarea = AREANUMBER(tilex,tiley);
	
	if(newarea==-1)
		newarea=0;
	
	if ((which <= springobj) && (which != inertobj))
	{
		if (ValidAreanumber(newarea))
			new->areanumber = newarea;
		else
			Error("illegal initial areanumber of %d for actor type %s"
				"trying to spawn at %d, %d",
				newarea,debugstr[which],tilex,tiley);
	}
	else
		new->areanumber = newarea;

	if ((which != inertobj) && (!Masterdisk))
		MakeLastInArea(new);
	NewState(new,state);
	new->z = nominalheight;
	if (which==springobj)
		new->z+=2;
}

//====================================================================

void ConsiderAlternateActor(objtype *ob,classtype which)
{
	if (((which >= lowguardobj) && (which <= blitzguardobj)) ||
		(which == dfiremonkobj))
	{
		if (GameRandomNumber("SpawnStand",which) < 128)
		{
			switch(which)
			{
			case lowguardobj:
				ob->shapeoffset =  W_GetNumForName("MARSHOO1") -
										W_GetNumForName("LWGSHOO1");
				break;
			case highguardobj:
				ob->shapeoffset =  W_GetNumForName("HIGSHOO1") -
										W_GetNumForName("HG2SHOO1");
				break;
			case overpatrolobj:
				ob->shapeoffset =  W_GetNumForName("PATSHOO1") -
										W_GetNumForName("OBPSHOO1");
				break;
			case strikeguardobj:
				ob->shapeoffset =  W_GetNumForName("XYGSHOO1") -
										W_GetNumForName("ANGSHOO1");
				break;
			/*case blitzguardobj:
				altstartlabel = "WIGSHOO1";
				new->shapeoffset = 80;
				break;*/
			case dfiremonkobj:
				ob->shapeoffset =  W_GetNumForName("MRKKSH1") -
										W_GetNumForName("ALLKSH1");
				break;
			}
		}
	}

	//if (new->shapeoffset)
	//  {if (W_CheckNumForName(altstartlabel) == -1)
	//	new->shapeoffset = 0;
	//  }

}

/*
===================
=
= StandardEnemyInit
=
===================
*/

void StandardEnemyInit(objtype *ob,int dir)
{
	int zoffset;

	if ((ob->obclass == deathmonkobj) || (ob->obclass == dfiremonkobj))
		ob->temp2 = DRAINTIME;

	else if ((ob->obclass == highguardobj) ||
			(ob->obclass == triadenforcerobj))
		ob->flags |= FL_HASAUTO;

	ob->hitpoints = starthitpoints[gamestate.difficulty][ob->obclass];
	ob->dir = dir*2;
	ob->flags |= (FL_SHOOTABLE|FL_BLOCK);
	ob->speed = ENEMYRUNSPEED;
	ob->dirchoosetime = 0;
	ob->door_to_open = -1;

	if(rott_iswolf)
	{
		if((ob->obclass == deathmonkobj) ||
			(ob->obclass == dfiremonkobj))
		{
			ob->hitpoints = 15;
			ob->speed = ENEMYRUNSPEED*3;
		}
	}

	zoffset = MAPSPOT(ob->tilex, ob->tiley, 2);
	if ((zoffset&0xff00)==0xb000)
		Set_NewZ_to_MapValue( &(ob->z), zoffset,
			"standard enemy", ob->tilex, ob->tiley);
	else
		ob->z = PlatformHeight(ob->tilex, ob->tiley);

}

void ConsiderOutfittingBlitzguard(objtype *ob)
{
	if(rott_iswolf)
		return;

	if ((GameRandomNumber("wiley blitzguard",0) < WILEYBLITZCHANCE) &&
		(gamestate.difficulty >= gd_medium)		)
	{
		ob->temp3 = stat_bazooka;
		ob->temp2 = 3;
	}
}

/*
===============
=
= SpawnStand
=
===============
*/

void SpawnStand (classtype which, int tilex, int tiley, int dir, int ambush)
{
	statetype *temp;

	tilex &= MAPSIZE-1;
	tiley &= MAPSIZE-1;

#if (SHAREWARE == 1)
	switch(which)
	{
	case overpatrolobj:
	case wallopobj:
	case deathmonkobj:
	case dfiremonkobj:
	case b_darianobj:
	case b_heinrichobj:
	case b_darkmonkobj:
		Error("\n%s actor at %d,%d not allowed in shareware !",
			debugstr[which],tilex,tiley);
		break;
	}
#endif

	if ((which == lowguardobj) &&
		(GameRandomNumber("SpawnStand",which) < 128) && (!rott_iswolf))
			which = blitzguardobj;

	if ((temp = UPDATE_STATES[STAND][which-lowguardobj]) != NULL)
	{
		SpawnNewObj(tilex,tiley,temp,which);
		if (!loadedgame)
			gamestate.killtotal++;

		if (ambush)
			new->flags |= FL_AMBUSH;

		#if 0
		#if (SUPERROTT == 1)
		ConsiderAlternateActor(new,which);
		#endif
		#endif

		StandardEnemyInit(new,dir);

		if (which == b_darkmonkobj)
		{
			new->flags |= (FL_NOFRICTION);//|FL_INVULNERABLE);
			new->speed = ENEMYRUNSPEED*2;
		}

		if (which == blitzguardobj)
			ConsiderOutfittingBlitzguard(new);

		if ((new->obclass >= lowguardobj) && (new->obclass <= dfiremonkobj))
			RANDOMACTORTYPE[new->obclass]++;

		if (MAPSPOT(tilex,tiley,2) == 0xdead)
		{
			new->flags |= FL_KEYACTOR;
			MISCVARS->KEYACTORSLEFT++;
		}

		PreCacheActor(which,0);
	}
	//else
	//Error("NULL initialization error");
}

/*
===============
=
= SpawnPatrol
=
===============
*/

void SpawnPatrol (classtype which, int tilex, int tiley, int dir)
{
	statetype *temp;
	int path=PATH;
#if 0
#if (SUPERROTT == 1)
	char *altstartlabel;
#endif
#endif

	tilex &= MAPSIZE-1;
	tiley &= MAPSIZE-1;

	#if (SHAREWARE==1)
	switch(which)
	{
	case overpatrolobj:
	case wallopobj:
	case deathmonkobj:
	case dfiremonkobj:
	case b_darianobj:
	case b_heinrichobj:
	case b_darkmonkobj:
		Error("\n%s actor at %d,%d not allowed in shareware !",
			debugstr[which],tilex,tiley);
		break;
	}
	#endif

	if ((which == lowguardobj) &&
		(GameRandomNumber("SpawnStand",which) < 128) && !rott_iswolf)
			which = blitzguardobj;

	if ((temp= UPDATE_STATES[path][(int)(which-lowguardobj)]) != NULL)
	{
		SpawnNewObj(tilex,tiley,temp,which);

		if (!loadedgame)
			gamestate.killtotal++;

		#if 0
		#if (SUPERROTT == 1)
		ConsiderAlternateActor(new,which);
		#endif
		#endif

		StandardEnemyInit(new,dir);

		if ((which == wallopobj) || (which == roboguardobj))
		{
			new->flags |= FL_NOFRICTION;
			//new->flags &= ~FL_SHOOTABLE;
			new->dir <<= 1;
			ParseMomentum(new,dirangle16[new->dir]);
		}
		else
			ParseMomentum(new,dirangle8[new->dir]);

		if (which == blitzguardobj)
			ConsiderOutfittingBlitzguard(new);

		if (MAPSPOT(tilex,tiley,2) == 0xdead)
		{
			new->flags |= FL_KEYACTOR;
			MISCVARS->KEYACTORSLEFT++;
		}

		PreCacheActor(which,0);
	}
}

//==========================================================================

void SpawnDisk(int tilex, int tiley, int type, boolean master)
{
	int zoffset;

	tilex &= MAPSIZE-1;
	tiley &= MAPSIZE-1;

	if (master == true)
	{
		Masterdisk = true;
		SpawnNewObj(tilex,tiley,&s_diskmaster,diskobj);
		Masterdisk = false;
		new->flags |= FL_MASTER;
		new->momentumz = -(DISKMOMZ << 16);
		new->flags |= FL_SYNCED;
		new->flags |= FL_NEVERMARK;
		new->temp1 = 1;
		//RemoveFromArea(new);
	}

	else
	{
		if (!type)
		{
			SpawnNewObj(tilex,tiley,&s_elevdisk,diskobj);
			new->momentumz = -(DISKMOMZ << 16);
			//new->flags |= FL_SYNCED;
			zoffset = MAPSPOT(tilex,tiley,2);
			if ((zoffset&0xff00)==0xb000)
			{
				Set_NewZ_to_MapValue(
					(fixed*)(&(new->temp2)),
					zoffset,"elev disk",tilex,tiley);
			}
			else
				new->temp2 = 32;
			new->temp1 = 1;
		}
		else
		{
			SpawnNewObj(tilex,tiley,&s_pathdisk,diskobj);
			zoffset = MAPSPOT(tilex,tiley,2);
			if ((zoffset&0xff00)==0xb000)
				Set_NewZ_to_MapValue(
					(fixed*)(&(new->z)),zoffset,
					"path disk",tilex,tiley);

			new->dir = (type-1) << 1;
			new->speed = 0x1000;

			//ParseMomentum(new,dirangle8[new->dir]);
		}
		actorat[tilex][tiley] = NULL;
		new->flags |= FL_BLOCK;
		new->flags |= (FL_NOFRICTION|FL_ACTIVE|FL_NEVERMARK);
	}
}

objtype	*DiskAt(int tilex,int tiley)
{
	int area;
	objtype *temp;
	statobj_t *tstat;

	area = AREANUMBER(tilex, tiley);
	
	if((area<0) || (area>=NUMAREAS))		//BGB: debug
		return NULL;
	
	for(temp = firstareaactor[area]; temp; temp = temp->nextinarea)
	{
		if ((temp->tilex != tilex) || (temp->tiley != tiley) ||
			(temp->obclass != diskobj))
			continue;
		return temp;
	}

	for(tstat = firstactivestat; tstat; tstat = tstat->nextactive)
	{
		if ((tstat->tilex != tilex) || (tstat->tiley != tiley) ||
			(tstat->itemnumber != stat_disk))
				continue;
		return (objtype*)tstat;
	}

	return NULL;
}

void SetElevatorDiskVariables(
	objtype *ob, int newz, int newmomentumz,
	int newtemp1, int newtemp3, int newdirchoose)
{
	ob->z = newz;
	ob->momentumz = newmomentumz;
	ob->temp1 = newtemp1;
	ob->temp3 = newtemp3;
	ob->dirchoosetime = newdirchoose;
}

void T_ElevDisk(objtype*ob)
{
	objtype *temp;
	objtype *master;

	temp = (objtype*)(actorat[ob->tilex][ob->tiley]);

	if (ob->flags & FL_MASTER)
		goto masterlabel;

	master = (objtype*)(ob->target);
	if (!master)
		Error("disk without master !");

	//SoftError("\n ob->z:%d %s, master z:%d",ob->z,
	//		(ob->flags & FL_SYNCED)?("SYNCED"):("UNSYNCED"),master->z);

	if (M_ISACTOR(temp) && (temp != ob) && (!(temp->flags & FL_DYING)))
	{
		int dz = abs(ob->z - temp->z),
			dx = abs(ob->x - temp->x),
			dy = abs(ob->y - temp->y);

		if ((dx < 0x7000) && (dy < 0x7000) && (dz < 68) && (temp->z > ob->z))
		{
			ob->flags &= ~FL_SYNCED;
			return;
		}
	}

	if (master && (!(ob->flags & FL_SYNCED)))
	{
		int dz;

		dz = abs(master->z - ob->z);
		if ((dz > 0) && (dz < 8))
		{
			SetElevatorDiskVariables(ob,
				master->z, master->momentumz,
				master->temp1, master->temp3,
				master->dirchoosetime);
			ob->flags |= FL_SYNCED;
			//return;
		}
		return;
	}

	masterlabel:

	if (ob->dirchoosetime)
	{
		ob->dirchoosetime --;
		return;
	}

	if (ob->temp1) // moving
	{
		ob->z += (ob->momentumz >> 16);
		if (ob->momentumz > 0) // down
		{
			if (ob->z >= nominalheight + 40 + DISKMOMZ)
				SetElevatorDiskVariables(
					ob, ob->z - (ob->momentumz>>16),0,0,0,35);
		}
		else
		{
			if (ob->z < ob->temp2) // temp2 has max height
				SetElevatorDiskVariables(
					ob, ob->z - (ob->momentumz>>16),0,0,1,35);
		}
	}
	else
	{
		if (ob->temp3)
			ob->momentumz = (DISKMOMZ << 16);
		else
			ob->momentumz = -(DISKMOMZ << 16);
		ob->temp1 = 1;
	}
}

void SpawnInertActor(int newx,int newy, int newz)
{
	GetNewActor ();
	MakeActive(new);

	new->obclass = inertobj;
	new->which = ACTOR;
	SetFinePosition(new,newx,newy);
	SetVisiblePosition(new,new->x,new->y);
	new->z = newz;
	new->dir = 0;
	new->speed = 0;
	new->flags = (FL_NEVERMARK|FL_ABP);
}

#if (SHAREWARE == 0)
void SpawnGroundExplosion(int x, int y, int z)
{
	SpawnInertActor(x,y,z);
	NewState(new,&s_grexplosion1);
	new->temp2 = GameRandomNumber("SpawnGroundExplosion",0)>>2;

}
#endif

void SpawnSlowParticles(int which, int numgibs, int x,int y,int z)
{
	objtype *prevlast,*temp;
	int tilex,tiley;

	tilex = x>>16;
	tiley = y>>16;
	
	tilex &= (MAPSIZE-1);	//BGB: Debug
	tiley &= (MAPSIZE-1);	//BGB: Debug

	SpawnNewObj(tilex,tiley,&s_gibs1,inertobj);
	SetFinePosition(new,x,y);
	SetVisiblePosition(new,x,y);
	prevlast = new;
	prevlast->flags |= FL_ABP;
	MakeActive(prevlast);
	SpawnParticles(new,which,numgibs);

	for(temp = prevlast->next; temp; temp=temp->next)
	{
		temp->z = z;
		temp->momentumx >>= 1;
		temp->momentumy >>= 1;
		temp->momentumz >>= 1;
	}
	RemoveObj(prevlast);
}

void ResolveDoorSpace(int tilex,int tiley)
{
	statobj_t *tstat, *temp;

	for(tstat = firstactivestat;tstat;)
	{
		temp = tstat->nextactive;

		if (tstat->flags & FL_DEADBODY)
		{
			if ((tstat->tilex == tilex) && (tstat->tiley == tiley))
			{
				if ((tstat->flags & FL_DEADBODY) && (tstat->linked_to != -1))
					DEADPLAYER[tstat->linked_to] = NULL;
				RemoveStatic(tstat);
				if (tstat->flags & FL_DEADBODY)
					SpawnSlowParticles(GUTS,8,tstat->x,tstat->y,tstat->z);
				else
					SpawnSlowParticles(gt_sparks,8,tstat->x,tstat->y,tstat->z);
				SD_PlaySoundRTP(SD_ACTORSQUISHSND,tstat->x,tstat->y);
			}
		}
		tstat = temp;
	}
}

void SpawnSpear(int tilex,int tiley,int up)
{
	int count,i;
	statetype *tstate;

	if (BATTLEMODE && (!gamestate.BattleOptions.SpawnDangers))
		return;

	if (!up)
	{
#if (SHAREWARE == 1)
		Error("\ndownspear at %d,%d in shareware!",tilex,tiley);
#else
		SpawnNewObj(tilex,tiley,&s_speardown1,spearobj);
		new->z = 0;
#endif
	}
	else
		SpawnNewObj(tilex,tiley,&s_spearup1,spearobj);

	count = (int)(GameRandomNumber("Spawn Spear",0) % 16);

	for(i=0, tstate = new->state; i<count; i++, tstate=tstate->next);
	
	NewState(new,tstate);

	PreCacheActor(spearobj,up);
	new->flags |= (FL_ABP);//|FL_INVULNERABLE);
	MakeActive(new);
}

void SpawnSpring(int tilex,int tiley)
{
	int iconvalue;

	tilex &= MAPSIZE-1;
	tiley &= MAPSIZE-1;

	iconvalue = MAPSPOT(tilex,tiley,2);
	if (iconvalue == 3)
	{
		SpawnNewObj(tilex,tiley,&s_autospring1,springobj);
		new->ticcount = (GameRandomNumber("Spawn Spring",0) %
			new->ticcount)+1;
		new->temp1 = iconvalue;
	}
	else
	{
		SpawnNewObj(tilex,tiley,&s_spring1,springobj);
		if (iconvalue == 2)
			new->temp1 = iconvalue;
	}

	PreCacheActor(springobj,0);
	new->flags &= ~(FL_SHOOTABLE|FL_BLOCK);
}

void T_Spring(objtype*ob)
{
	objtype *temp;
	int op,dx,dy,dz;

	if ((ob->state->condition & SF_DOWN) && (ob->temp1))
	{
		if (ob->ticcount)
			return;
		ob->shapenum++;
		TurnActorIntoSprite(ob);
		return;
	}

	for(temp=firstareaactor[ob->areanumber];temp;temp=temp->nextinarea)
	{
		if (temp == ob)
			continue;

		if (temp->obclass >= roboguardobj)
			continue;

		dx = abs(ob->x-temp->x);
		dy = abs(ob->y-temp->y);
		dz = abs(ob->z-temp->z);
		if ((dx > ACTORSIZE+0x2800) || (dy > ACTORSIZE+0x2800) || (dz > 40))
			continue;
		if (!temp->momentumz)
		{
			op = FixedMul(GRAVITY,(temp->z-5)<<16) << 1;
			temp->momentumz = -FixedSqrtHP(op);
			SD_PlaySoundRTP(SD_SPRINGBOARDSND,ob->x,ob->y);
		}
	}
}

objtype		*swiz_objtype_list[4096];
short		swiz_objtype_chn[4096];
short		swiz_objtype_hash[64];
int			swiz_objtype_cnt;

statobj_t	*swiz_statobj_list[4096];
short		swiz_statobj_chn[4096];
short		swiz_statobj_hash[64];
int			swiz_statobj_cnt;

int T_InitSwizzle()
{
	int i;

	for(i=0; i<64; i++)
	{
		swiz_objtype_hash[i]=-1;
		swiz_statobj_hash[i]=-1;
	}
	swiz_objtype_cnt = 0;
	swiz_statobj_cnt = 0;
	
	return(0);
}

int T_SwizzleObjtypeToInt(objtype *ob)
{
	nlint a;
	int i, h;
	
	a=(nlint)ob;
	h=((a*65521)>>16)&63;
	
	i=swiz_objtype_hash[h];
	while(i>=0)
	{
		if(swiz_objtype_list[i]==ob)
			return(i);
		i=swiz_objtype_chn[i];
	}
	
	i = swiz_objtype_cnt++;
	swiz_objtype_list[i] = ob;
	swiz_objtype_chn[i] = swiz_objtype_hash[h];
	swiz_objtype_hash[h] = i;
	return(i);
	
//	__debugbreak();
}

int T_SwizzleStatObjToInt(statobj_t *ob)
{
	nlint a;
	int i, h;
	
	a=(nlint)ob;
	h=((a*65521)>>16)&63;
	
	i=swiz_statobj_hash[h];
	while(i>=0)
	{
		if(swiz_statobj_list[i]==ob)
			return(i);
		i=swiz_statobj_chn[i];
	}
	
	i = swiz_statobj_cnt++;
	swiz_statobj_list[i] = ob;
	swiz_statobj_chn[i] = swiz_statobj_hash[h];
	swiz_statobj_hash[h] = i;
	return(i);

//	__debugbreak();
}

objtype *T_SwizzleObjtypeFromInt(int obj)
{
	return(swiz_objtype_list[obj]);
//	__debugbreak();
}

statobj_t *T_SwizzleStatObjFromInt(int obj)
{
	return(swiz_statobj_list[obj]);
}

void T_Count(objtype*ob)
{
	int index;
	wall_t* tswitch;
	touchplatetype *temp;
	objtype* tempactor;

	if (ob->dirchoosetime)
		{
		ob->dirchoosetime --;
		if (ob->dirchoosetime>980)
			MISCVARS->gasindex=((1050-ob->dirchoosetime)<<4)/70;
		else if (ob->dirchoosetime<35)
			MISCVARS->gasindex=(ob->dirchoosetime<<4)/35;
		if (ob->temp3)
			{
			ob->temp3 --;
			if (ob->temp3 & 1)
				SD_PlaySoundRTP(SD_GASHISSSND,ob->x,ob->y);
			}
		else
			{
			ob->temp3 = 105;
			for(tempactor=firstareaactor[ob->areanumber];tempactor;tempactor=tempactor->nextinarea)
				{
				if (tempactor == ob)
					continue;
				if (!(tempactor->flags & FL_SHOOTABLE))
					continue;
				if (tempactor->obclass != playerobj)
					{
					if ((tempactor->obclass >= lowguardobj) &&
						(tempactor->obclass <= dfiremonkobj))
						{
						int oldviolence = gamestate.violence;

						gamestate.violence = vl_low;
						DamageThing(tempactor,EnvironmentDamage(ob));
						Collision(tempactor,ob,-(tempactor->momentumx),-(tempactor->momentumy));
						gamestate.violence = oldviolence;

						}
					}
				else if (!(tempactor->flags & FL_GASMASK))
					{
					DamageThing(tempactor,EnvironmentDamage(ob));
					Collision(tempactor,ob,0,0);
					M_CheckPlayerKilled(tempactor);
					}
				}
			}
		}

	else
	{
		int i;
		playertype *pstate;

		for(i=0;i<numplayers;i++)
		{
			M_LINKSTATE(PLAYER[i],pstate);
			PLAYER[i]->flags &= ~FL_GASMASK;
			pstate->protectiontime = 1;
		}

		NewState(ob,&s_gas1);
		SD_PlaySoundRTP(SD_GASENDSND,ob->x,ob->y);
		ob->flags &= ~FL_ACTIVE;
		MISCVARS->gasindex=0;
		MU_StartSong(song_level);
		MU_RestoreSongPosition();
		MISCVARS->GASON = 0;

		index = touchindices[ob->temp1][ob->temp2]-1;
		TRIGGER[index] = 0;
		for(temp = touchplate[index];temp;temp = temp->nextaction)
			if (temp->action == EnableObject)
		{
//			tempactor = (objtype*)(temp->whichobj);
			tempactor = T_SwizzleObjtypeFromInt(temp->whichobj);
			tempactor->flags &= ~FL_ACTIVE;
		}

		tswitch = (wall_t*)actorat[ob->temp1][ob->temp2];
		/*
		if (tswitch && (tswitch->which != ACTOR))
			{
			tilemap[ob->temp1][ob->temp2]--;
			tswitch->flags &= ~FL_ON;
			}
		*/

	}
}

void SpawnBlade(int tilex, int tiley,int dir,int upordown,int moving)
{
	int count,i;
	statetype *nstate;

	tilex &= MAPSIZE-1;
	tiley &= MAPSIZE-1;

	#if (SHAREWARE == 1)
	if (!upordown)
	Error("\ndown spinblade at %d,%d not allowed in shareware !",tilex,tiley);
	if (moving)
	Error("\nupdown spinblade at %d,%d not allowed in shareware !",tilex,tiley);

	#endif

	if (BATTLEMODE && (!gamestate.BattleOptions.SpawnDangers))
	return;

	if (moving)
	{
#if (SHAREWARE == 0)
		if (upordown)
			SpawnNewObj(tilex,tiley,&s_spinupblade1,bladeobj);
		else
		{
			SpawnNewObj(tilex,tiley,&s_spindownblade1,bladeobj);
			new->z = 0;
		}
#endif
	}
	else
	{
		if (upordown)
		{
			SpawnNewObj(tilex,tiley,&s_upblade1,bladeobj);
		}
#if (SHAREWARE == 0)
		else
		{
			SpawnNewObj(tilex,tiley,&s_downblade1,bladeobj);
			new->z = 0;
		}
#endif
	}

	count = (int)(GameRandomNumber("SpawnBlade",0) % 16);
	for(nstate=new->state,i=0;i<count;nstate = nstate->next,i++);
	NewState(new,nstate);

	new->flags |= (FL_BLOCK);
	new->flags &= ~FL_SHOOTABLE;
	new->dir = dir;

	if (dir != nodir)
	{
		new->flags |= FL_NOFRICTION;
		new->speed = ENEMYRUNSPEED;
	}

	if (!MAPSPOT(tilex,tiley,2))
	{
		new->flags |= FL_ACTIVE;
		ParseMomentum(new,dirangle8[new->dir]);
	}

	PreCacheActor(bladeobj,(moving<<1)+upordown);
}

void SpawnCrushingColumn(int tilex, int tiley, int upordown)
{
	int i,count;
	statetype * nstate;

	tilex &= MAPSIZE-1;
	tiley &= MAPSIZE-1;

	#if (SHAREWARE == 1)
	if (!upordown)
		Error("\ncrush-up column at %d,%d not allowed in shareware!",
			tilex,tiley);
	#endif

	if (BATTLEMODE && (!gamestate.BattleOptions.SpawnDangers))
		return;
#if (SHAREWARE == 0)
	if (!upordown)
	{
		SpawnNewObj(tilex,tiley,&s_columnupup1,crushcolobj);
	}
	else
#endif
	{
		SpawnNewObj(tilex,tiley,&s_columndowndown1,crushcolobj);
		new->z = 0;
	}

	count = (int)(GameRandomNumber("SpawnCrushingColumn",0) % 8);
	for(nstate=new->state,i=0;i<count;nstate = nstate->next,i++)
	{if ((!upordown) && (nstate->condition & SF_UP))
		new->temp1 += (((nstate->tictime>>1) + 1)<<2);

	}
	NewState(new,nstate);
	new->flags |= (FL_BLOCK);

	new->flags &= ~FL_SHOOTABLE;
	PreCacheActor(crushcolobj,upordown);
}

void SpawnFirejet(int tilex, int tiley, int dir, int upordown)
{
	int statecount,i;
	statetype *tstate;

	statecount = (int)(GameRandomNumber("SpawnFirejet",0) % 22);

	if (upordown)
	{
		for(i=0,tstate=&s_firejetup1;i<statecount;i++,tstate=tstate->next);
		SpawnNewObj(tilex,tiley,tstate,firejetobj);
	}
	else
	{
#if (SHAREWARE == 1)
		Error("\ndown firejet at %d,%d not allowed in shareware",tilex,tiley);
#else
		for(i=0,tstate=&s_firejetdown1;i<statecount;i++,tstate=tstate->next);
		SpawnNewObj(tilex,tiley,tstate,firejetobj);
		new->z = 0;
#endif
	}

	PreCacheActor(firejetobj,upordown);

	new->flags &= ~FL_SHOOTABLE;

	if (dir != nodir)
		{
		new->dir = dir*2;
		new->flags |= FL_NOFRICTION;
		new->speed = ENEMYRUNSPEED;
		ParseMomentum(new,dirangle8[new->dir]);
		}
	else
		new->dir = dir;
}

void SpawnFirebomb(objtype*ob,int damage,int which)
{
	int i,low,high,doorat;
	wall_t *tempwall;
	doorobj_t*tempdoor;

	if (which == 0)
	{
		low = (ob->dir>>1);
		high = low;
	}
	else
	{
		low = 0;
		high = which-1;

		if ((FindDistance((ob->x-player->x), (ob->y-player->y))<0x120000) &&
			(player->z==nominalheight)
			)
			SHAKETICS = 35;
	}

	for (i=low;i<=high;i++)
		{
		MissileSound = false;
		/*
		if (((which == 0) && ((low == 5) || (low == 6))) ||
			((which == 6) && ((i==4) || (i==5)))
			)
			{

			if (((which == 0) && (low == 5)) ||
				((which == 6) && (i == 4))
				)
				{
				newz = ob->z + 64;
				if (newz > maxheight)
					continue;
				SpawnMissile(ob,p_firebombobj,0,0,&s_grexplosion1,0);
				new->z = newz;
				new->dir = 10;

				}
			else
				{
				newz = ob->z - 64;
				if ((sky == 0) && (newz < 0))
					continue;
				SpawnMissile(ob,p_firebombobj,0,0,&s_grexplosion1,0);
				new->z = newz;
				new->dir = 12;

				}

			}
		else */
		{
			SpawnMissile(ob,p_firebombobj,0,
				dirangle8[2*i],&s_grexplosion1,0x10000);
			new->z = ob->z;
			new->dir = (i<<1);

		}

		MissileSound = true;

		SD_PlaySoundRTP(SD_EXPLODEFLOORSND,ob->x,ob->y);
		new->temp2 = FixedMul(damage,DIAGADJUST);

		tempwall = (wall_t*)actorat[new->tilex][new->tiley];
		doorat= 0;
		if (M_ISDOOR(new->tilex,new->tiley))
		{
			tempdoor = doorobjlist[tilemap[new->tilex][new->tiley]&0x3ff];
			if (tempdoor->position<0x8000)
				doorat = 1;
		}

		if ((tempwall && M_ISWALL(tempwall)) || doorat ||
			(new->tilex <=0) || (new->tilex > MAPSIZE-1) ||
			(new->tiley <=0) || (new->tiley > MAPSIZE-1)
			)
		{
			new->z = ob->z;
			SetFinePosition(new,ob->x,ob->y);
			SetVisiblePosition(new,ob->x,ob->y);
		}
		new->whatever = ob->whatever;
		new->temp3 = ob->temp3 - 1;
	}
}

void MissileHitActor(objtype *owner, objtype *missile, objtype *victim,
							int damage, int hitmomx, int hitmomy
						)
{
	int tcl = victim->obclass;
	int ocl = missile->obclass;

	if (
			(victim->flags & FL_DYING) || // hey, they're dying already;
			(victim->flags & FL_HEAD)  || // don't hurt overrobot's head, wheels
			(tcl == wallopobj)				|| // bcraft is invulnerable
			(tcl == b_darkmonkobj)		|| // darkmonk is invulnerable
			(!(victim->flags & FL_SHOOTABLE)) || // don't hurt environment dangers, dead guys
			((tcl == b_darksnakeobj) &&
			((SNAKELEVEL != 3) || (!victim->temp3))// return for non-red snake
			)
		)
		return;

	if ((tcl == playerobj) || (tcl == b_heinrichobj))
		victim->target = owner;

	if (tcl == NMEsaucerobj)  // can shoot over's saucer
	{
		NewState(victim,&s_explosion1);
		victim->flags &= ~FL_SHOOTABLE;
		victim->temp2 = damage;
		return;
	}

	else if (tcl == roboguardobj)		// check roboguard
	{
		DamageThing(victim,damage);
		Collision(victim,owner,0,0);
	}

	else if (tcl == collectorobj)
	{
		if (gamestate.SpawnEluder)
			return;

		DamageThing(victim,damage);
		Collision(victim,owner,0,0);
	}

	else if (tcl == patrolgunobj)
		{
		DamageThing(victim,damage);
		if (victim->hitpoints <= 0)
			{
			victim->momentumx = victim->momentumy = victim->momentumz = 0;
			victim->flags |= FL_DYING;
			if (victim->temp1 == -1)  // this is 4-way gun
				NewState(victim,&s_robogrddie1);
#if (SHAREWARE == 0)
			else								// this is normal
				NewState(victim,&s_gundie1);
#endif
			}
		}

// bosses are "special" ==========================

	else if ((tcl >= b_darianobj) && (tcl < b_darkmonkobj))

		{
		DamageThing(victim,damage);
		if (!(victim->flags & FL_ATTACKMODE))
			FirstSighting (victim);	// put into combat mode
		if (victim->hitpoints <= 0)
			{
			victim->momentumx = victim->momentumy = victim->momentumz = 0;
			victim->flags |= FL_DYING;
			NewState(victim,UPDATE_STATES[DIE][victim->obclass-lowguardobj]);
			switch (victim->obclass)
				{
				case b_darianobj:
					AddMessage("Darian defeated!",MSG_CHEAT);
					break;

				case b_heinrichobj:
					AddMessage("Krist defeated!",MSG_CHEAT);
					break;

				case b_robobossobj:
					AddMessage("NME defeated!",MSG_CHEAT);
					break;
				}
			MU_StartSong(song_bossdie);
			}
#if (SHAREWARE == 0)
		else
			{
			MISCVARS->REDTIME = (damage >> 1);
			if (victim->obclass == b_heinrichobj)
				{
				NewState(victim,&s_heinrichdefend);
				if (Near(victim,PLAYER[0],3))
					{
					MISCVARS->HRAMMING = 1;
					MISCVARS->HMINING = 0;
					victim->dirchoosetime = 0;
					}
				else
					{
					MISCVARS->HMINING = 1;
					MISCVARS->HRAMMING = 0;
					victim->dirchoosetime = 5;//10;
					}
				victim->targettilex = victim->targettiley = 0;
				victim->target = NULL;
				}
			}
#endif
		}

#if (SHAREWARE == 0)
	else if ((tcl == b_darksnakeobj) && (victim->temp3)) // red snake
	{
		DamageThing(SNAKEEND,damage);
		if (victim->state->think == T_DarkSnakeChase)
			NewState(victim,&s_redheadhit);
		else
			NewState(victim,&s_redlinkhit);
		victim->temp3 = 0;
	}
#endif

//===============================================
	else // all other actors
	{
		if ((tcl == playerobj) &&
			(victim->flags & FL_AV) &&
			(ocl != p_godballobj)
			)
		{
			playertype *pstate;

			M_LINKSTATE(victim,pstate);
			pstate->protectiontime -= ((damage<<1) + damage);
			if (pstate->protectiontime < 1)
				pstate->protectiontime = 1;
			if (victim==player)
				GM_UpdateBonus (pstate->protectiontime, false);

			return;  // asbestos vest prevents victim damage
		}

		DamageThing(victim,damage);

		if ((tcl < roboguardobj) && (victim->hitpoints <= 0))
		{
			if (ocl != p_godballobj)
				victim->flags |= FL_HBM;
			else
				victim->flags |= (FL_GODSTRUCK | FL_FULLLIGHT);
		}

		if (tcl == playerobj)
			{
			playertype *pstate;

			M_LINKSTATE(victim,pstate);
			if (pstate->health <= 0)
				{
				if (ocl != p_godballobj)
					victim->flags |= FL_HBM;
				else
					victim->flags |= (FL_GODSTRUCK | FL_FULLLIGHT);

				if (M_ISACTOR(owner))
					{
					if (owner->obclass == playerobj)
						{
						if (!victim->momentumz)
							BATTLE_PlayerKilledPlayer(battle_kill_with_missile,owner->dirchoosetime,victim->dirchoosetime);
						else
							BATTLE_PlayerKilledPlayer(battle_kill_with_missile_in_air,owner->dirchoosetime,victim->dirchoosetime);
						}
					else
						BATTLE_CheckGameStatus(battle_player_killed,missile->dirchoosetime);
					}
				else
						BATTLE_CheckGameStatus(battle_player_killed,missile->dirchoosetime);
				}
			}

		if ((owner->obclass == playerobj) && (victim->flags & FL_HBM))
		{
				MISCVARS->supergibflag = true;
			//GivePoints(starthitpoints[gamestate.difficulty][victim->obclass]*5);
		}

		Collision(victim,owner,hitmomx,hitmomy);
		MISCVARS->supergibflag = false;
		if ((tcl == blitzguardobj) && (owner->obclass == playerobj))
			victim->flags |= FL_TARGET;

	}
}

void MissileHit (objtype *ob,void *hitwhat)
{
	int damage=0, random,tcl=0,ocl,fireweapon=0,sound,hitmomx,hitmomy;
	objtype* tempactor=NULL,*owner;

	if (ob==missobj)
		missobj=NULL;

	if (ob == PLAYER0MISSILE)
		PLAYER0MISSILE = NULL;

	ob->momentumz = 0;
	hitmomx = ob->momentumx;
	hitmomy = ob->momentumy;
	if (ob->soundhandle != -1)
		SD_StopSound(ob->soundhandle);

	ob->flags &= ~FL_SHOOTABLE;
	if (FirstExplosionState(ob->state))
		return;

	/*
	if ((ob->z < -28) || (IsWindow(ob->tilex,ob->tiley)))
		{
		NewState(ob,&s_megaremove);
		return;
		}
	*/

	tempactor = (objtype*)hitwhat;
	owner = (objtype*)(ob->whatever);

	random = GameRandomNumber("MissileHit",0);
	ocl = ob->obclass;
	if (tempactor)
		{
		if (tempactor->which == ACTOR)
			tcl = tempactor->obclass;
		else if (tempactor->which == SPRITE)
			tcl = -1;
		}

	if ((!tcl) && (ob->z < -30))
		{
		if (ob->soundhandle != -1)
			SD_StopSound(ob->soundhandle);

		NewState(ob,&s_megaremove);
		return;

		}

	if (((ocl != p_kesobj) && (ocl != p_godballobj)) || (!tcl))
		ZEROMOM;

	if (tcl == b_darianobj)
		MISCVARS->ESAU_SHOOTING  = false;

	switch(ocl)
		{

		case p_bazookaobj:
			NewState(ob,&s_explosion1);
			if (M_ISACTOR(owner) && (owner->obclass == blitzguardobj))
				damage = 30 + (random >> 4);
			else
				damage = 2*((random>>3)+80);
			break;

		case p_heatseekobj:
			NewState(ob,&s_explosion1);
			damage = 2*((random>>3)+50);
			break;

		case p_drunkmissileobj:
			NewState(ob,&s_explosion1);
			damage = ((random>>3)+25);
			break;

		case p_firebombobj:
			NewState(ob,&s_explosion1);
			damage = 2*((random>>3)+90);
			ob->temp3 = 4;
			SpawnFirebomb(ob,damage,4);
			break;

		case p_firewallobj:

			if (tcl == playerobj)
				gamestate.DOGROUNDZEROBONUS = true;
			NewState(ob,&s_explosion1);
			damage = 2*((random>>3)+50);
			break;

		case p_godballobj:
			if ((tcl >= pillarobj) || (!tcl) || ((tcl == -1) && (!(tempactor->flags & FL_SHOOTABLE))))
				NewState(ob,&s_explosion1);
			ob->target = NULL;
			damage = 500;
			break;

		case shurikenobj:
			NewState(ob,&s_explosion1);
			damage = ((random >>3) + 30)>>2;
			break;

		case grenadeobj:
			NewState(ob,&s_explosion1);
			damage = (random >>3) + 20;
			break;

		case fireballobj:
			NewState(ob,&s_explosion1);
			damage = (random >> 3) + 10;
			fireweapon = 1;
			break;

		case missileobj:
			NewState(ob,&s_explosion1);
			if (M_ISACTOR(owner) && (owner->obclass == wallopobj))
				damage = (random >> 5);
			else
				damage = (random >>3) + 30;
			if (tcl && (tcl != b_heinrichobj))
				damage = 3*damage>>3;
			break;

		case wallfireobj:
			if ((!tempactor) ||
				(tempactor->which == ACTOR) ||
				(tempactor->which == SPRITE)
				)
				NewState(ob,&s_explosion1);
			else if (M_ISWALL(tempactor) || (tempactor->which == DOOR))
				NewState(ob,&s_crossdone1);
			damage = EnvironmentDamage(ob);
			fireweapon = 1;
			break;

		case inertobj:
			ob->state = NULL;
			return;
			break;

#if (SHAREWARE == 0)

		case p_splitmissileobj:
			NewState(ob,&s_explosion1);
			damage = 2*((random>>3)+50);
			break;

		case p_kesobj:
			if ((tcl >= pillarobj) ||
				(!tcl) ||
				((tcl == -1) && (!(tempactor->flags & FL_SHOOTABLE)))
				)
				NewState(ob,&s_explosion1);
			damage = 2*((random>>3)+140);
			break;

		case netobj:
			ob->state=NULL;
			MISCVARS->NET_IN_FLIGHT = false;
			if (tempactor == PLAYER[0])
				{
				if ((tempactor->flags & FL_GODMODE) ||
					(tempactor->flags & FL_DOGMODE) ||
					godmode
					)
					damage = 0;
				else
					{
					damage = (random >>4) + 5;
					PLAYERSTATE[0].NETCAPTURED = -1;
					PLAYERSTATE[0].weapondowntics = WEAPONS[PLAYERSTATE[0].weapon].screenheight/GMOVE;
					NewState(PLAYER[0],&s_player);
					PLAYERSTATE[0].attackframe = PLAYERSTATE[0].weaponframe = 0;
					PLAYERSTATE[0].batblast = 0;
					if (PLAYERSTATE[0].HASKNIFE == false)
						AddMessage("Wiggle left and right to get out of net!",
									MSG_GAME);
					}
				}
			break;

		case bigshurikenobj:
			NewState(ob,&s_oshurikenhit1);
			if (owner->obclass == wallopobj)
				damage = (random >> 5);
			else
				damage = 4*((random >>3) + 30)/10;

			break;

		case dm_spitobj:
			NewState(ob,&s_spithit1);
			damage = 30;
			if (gamestate.difficulty == gd_hard)
				damage += 15;
			break;

		case dm_weaponobj:
			damage = 20;
			NewState(ob,&s_explosion1);
			break;

		case dm_heatseekobj:
			damage = 20;
			NewState(ob,&s_explosion1);
			break;

		case dmfballobj:
			NewState(ob,&s_explosion1);
			damage = (random >>3) + 20;
			fireweapon = 1;
			break;

		case h_mineobj:
			NewState(ob,&s_explosion1);
			damage = (random >>3) + 20;
			break;

		case NMEsaucerobj:
			NewState(ob,&s_explosion1);
			damage = 2*((random>>3)+30);
			break;

#endif

	//default:
		//Error("Unknown ob %d called MissileHit",ob->obclass);
		}

	//if (!ob->state)
	//return;
	if ((sound = BAS[ob->obclass].hit)!=0)
		SD_PlaySoundRTP(sound,ob->x,ob->y);

	if (FirstExplosionState(ob->state))
		SD_PlaySoundRTP(SD_EXPLODESND,ob->x,ob->y);

	if (tcl>0) // actors
		{
		MissileHitActor(owner,ob,tempactor,damage,hitmomx,hitmomy);
		if ((ocl == p_kesobj) && (tcl < roboguardobj))
			{
			tempactor->momentumx = hitmomx; // kes gives wus targets its momentum
			tempactor->momentumy = hitmomy;
			//missile->flags |= FL_NOFRICTION;
			}
		}

	else if (tcl < 0)  // static
	{
		DamageThing(hitwhat,damage);
		if (FirstExplosionState(new->state))
			new->whatever = ob->whatever;
	}
}

void T_Spears(objtype*ob)
{
	int dx,dy,dz,i;

	for(i=0;i<numplayers;i++)
	{
		if (PLAYER[i]->flags & FL_DYING)
			continue;

		dx = abs(PLAYER[i]->x - ob->x);
		dy = abs(PLAYER[i]->y - ob->y);
		dz = abs(PLAYER[i]->z - ob->z);

		if ((!ob->ticcount)&&(ob->state->condition&SF_SOUND) &&
			areabyplayer[ob->areanumber])
			SD_PlaySoundRTP(BAS[ob->obclass].operate,ob->x,ob->y);

		if ((dx < STANDDIST) && (dy < STANDDIST) && (dz < 20))
		{
			ob->flags &= ~FL_BLOCK;
			if ((!ob->ticcount) && (ob->state->condition & SF_CRUSH))
			{
				DamageThing(PLAYER[i],EnvironmentDamage(ob));
				Collision(PLAYER[i],ob,0,0);
				M_CheckPlayerKilled(PLAYER[i]);
				return;
			}
		}
		else
		{
			if (ob->state->condition & SF_DOWN)
				ob->flags &= ~FL_BLOCK;
			else
				ob->flags |= FL_BLOCK;
		}
	}
}

void T_CrushUp(objtype*ob)
{
	int dx, dy,dist,dz,i,playeron;

	if ((!ob->ticcount) && (ob->state->condition & SF_SOUND) &&
		areabyplayer[ob->areanumber])
	{
		SD_PlaySoundRTP(BAS[ob->obclass].operate,ob->x,ob->y);
	}

	dist = ACTORSIZE+0x2000;
	if (ob->state->condition & SF_UP)
	{
		ob->temp1 += 4;
	//	Debug("\ncol momz = 4");
	}
	else if (ob->state->condition & SF_DOWN)
	{
		ob->temp1 -= 4;
	//		Debug("\ncol mom z = -4");
	}
	else
	{
		//ob->momentumz = 0;
		//	Debug("\ncol mom z = 0");
	}

	ob->temp2 = maxheight - ob->temp1 + 32;

	playeron = 0;
	for(i=0; i<numplayers; i++)
	{
		dx = abs(PLAYER[i]->x - ob->x);
		dy = abs(PLAYER[i]->y - ob->y);
		dz = abs(ob->temp2-PLAYER[i]->z);

		if ((dx < dist) && (dy < dist) && (dz < 65))
		{
			ob->flags &= ~FL_BLOCK;
			//player->temp2 = 0;
			playeron  = 1;
			if ((!ob->ticcount) && (ob->state->condition & SF_CRUSH) &&
				(levelheight<2) && (!(ob->flags & FL_DYING)))
			{
				DamageThing(PLAYER[i], EnvironmentDamage(ob));
				if (PLAYER[i]->hitpoints <= 0)
					PLAYER[i]->flags |= FL_HBM;
				Collision(PLAYER[i],ob,0,0);
				M_CheckPlayerKilled(PLAYER[i]);
				//NewState(ob,ob->state); //reset ticcount
				return;
			}
			if (ob->state->condition & SF_UP)
			{
				PLAYER[i]->momentumz = -(4<<16);
				if (PLAYER[i]->z < -30)
					PLAYER[i]->z = -30;
			}
			else if (ob->state->condition & SF_DOWN)
			{
				PLAYER[i]->momentumz = (4<<16);
				if (PLAYER[i]->z >= nominalheight)
					PLAYER[i]->z = nominalheight;
			}
			else
				PLAYER[i]->momentumz = 0;
			PLAYER[i]->whatever = ob;
			ob->whatever = PLAYER[i];
			//PLAYER[i]->flags |= FL_RIDING;
		}
	}

	//if (!playeron)
	{
		if (ob->state->condition & SF_BLOCK)
			ob->flags |= FL_BLOCK;
		else
			ob->flags &= ~FL_BLOCK;
	}
}

void T_CrushDown(objtype*ob)
{
	int dx,dy,dz,i,playeron;

	if ((!ob->ticcount) && (ob->state->condition & SF_SOUND)&&
		areabyplayer[ob->areanumber])
	{
		SD_PlaySoundRTP(BAS[ob->obclass].operate,ob->x,ob->y);
	}

	ob->temp2 = ob->z;
	playeron = 0;
	for(i=0;i<numplayers;i++)
	{
		dx = abs(PLAYER[i]->x - ob->x);
		dy = abs(PLAYER[i]->y - ob->y);
		dz = abs(PLAYER[i]->z - ob->z);

		if ((dx < STANDDIST) && (dy < STANDDIST) && (dz < 20))
		{
			//PLAYER[i]->temp2 = 0;
			playeron = 1;
			ob->flags &= ~FL_BLOCK;
			if ((!ob->ticcount) && (ob->state->condition & SF_CRUSH) &&
					(!(ob->flags & FL_DYING)))
			{
				DamageThing(PLAYER[i],EnvironmentDamage(ob));
				if (PLAYER[i]->hitpoints <= 0)
					PLAYER[i]->flags |= FL_HBM;
				Collision(PLAYER[i],ob,0,0);
				M_CheckPlayerKilled(PLAYER[i]);
				//NewState(ob,ob->state); //reset ticcount
				return;
			}
			if ((ob->state->condition & SF_DOWN) &&
					((ob->state != &s_columndowndown1) &&
					(ob->state != s_columndowndown1.next)))
			{
				PLAYER[i]->temp2 = COLUMNCRUSH;
				PLAYER[i]->whatever = ob;
			}
		}
	}

	//if (!playeron)
	{
		if (ob->state->condition & SF_BLOCK)
			ob->flags |= FL_BLOCK;
		else
			ob->flags &= ~FL_BLOCK;
	}
}

void T_Explosion(objtype* ob)
{
	int momx,momy,momz;
	int dx,dy,dz;
	int pdamage,dist,blastradius=0x20000,
		fatalradius=0x9000,impulse,damage,
		scalefactor;

	statobj_t* checkstat;
	objtype* check,*owner;

	if (ob->ticcount)
		return;

	damage = EXPLOSION_DAMAGE;
	owner = (objtype*)(ob->whatever);
	if ((ob->temp3) && (ob->obclass == p_firebombobj))
	{
		SpawnFirebomb(ob,damage,0);
		ob->temp3 = 0;
	}
	//================== check surrounding actors ============================//

	for(check = firstactive; check; check=check->nextactive)
	{
		if (check == ob)
			continue;

//	if (check == owner)
//		continue;

		dx = abs(check->x - ob->x);
		if (dx > blastradius)
			continue;

		dy = abs(ob->y - check->y);
		if (dy > blastradius)
			continue;

		dz = ((abs(ob->z - check->z))<<10);
		if (dz > blastradius)
			continue;

		if (check->flags & FL_HEAD)
			continue;

		if (check->flags & FL_DYING)
			continue;

		if (!(check->flags & FL_SHOOTABLE))
			continue;

		if ((check->obclass >= roboguardobj) && (check->obclass != b_darkmonkobj))
			//(check->obclass <= wallopobj))
			continue;

		if (!CheckLine(ob,check,SIGHT))
			continue;

		if (check->obclass == NMEsaucerobj)
		{
			NewState(check,&s_explosion1);
			check->flags &= ~FL_SHOOTABLE;
			return;
		}
#if 0
		dist = FindDistance(dx,dy);
		scalefactor = (blastradius-dist)>>4;
		if (scalefactor > 0xffff)
			scalefactor = 0xffff;
		pdamage = FixedMul(damage,scalefactor);
#endif
//#if 0
	//magdx = abs(dx);
	//magdy = abs(dy);

		dist = Find_3D_Distance(dx,dy,dz);
		SoftError("\ndist: %x\n",dist);

		//if (dist < 0x10000)
		// dist = 0x10000;

		scalefactor = FixedDiv2(1<<16,FixedMul(dist,dist));
	//scalefactor = FixedDiv2(1<<16,dist);

		if (scalefactor > 0x12000)
			scalefactor = 0x12000;
		pdamage = FixedMul(damage,scalefactor);
		SoftError("\ndamage: %d, scalefactor: %x\n",pdamage,scalefactor);
//#endif
		impulse = FixedMul(EXPLOSION_IMPULSE,scalefactor);
		if (check->obclass == playerobj)
		{
			check->target = owner;
			if (check->flags & FL_AV)
				pdamage = 0;
		}

		if (check->obclass < roboguardobj)
		{
			SoftError("\nhitpoints before: %d",check->hitpoints);
			DamageThing(check,pdamage);
			SoftError("\nhitpoints after: %d",check->hitpoints);
			if ((check->hitpoints <= 0) && (gamestate.violence == vl_excessive) &&
				((ob->obclass == p_firebombobj) ||
				((dx < fatalradius) && (dy < fatalradius) && (dz < 20)))
				)
				check->flags |= FL_HBM;

			GetMomenta(check,ob,&momx,&momy,&momz,impulse);
				//Debug("\nhitmomx = %d, hitmomy = %d",momx,momy);

		/*if (M_ISACTOR(owner) &&
				(owner->obclass == playerobj) &&
				(check->hitpoints <=0)
			)
			GivePoints(starthitpoints[gamestate.difficulty][check->obclass]*5);
		*/
			Collision(check,owner,momx,momy);
			check->momentumz += (momz<<6);
			if ((check->obclass == playerobj) && (check->flags & FL_DYING) &&
				M_ISACTOR(owner))
			{
				if (owner->obclass == playerobj)
				{
					if (check->z != nominalheight)
						BATTLE_PlayerKilledPlayer(battle_kill_with_missile_in_air,owner->dirchoosetime,check->dirchoosetime);
					else
						BATTLE_PlayerKilledPlayer(battle_kill_with_missile,owner->dirchoosetime,check->dirchoosetime);
				}
				else
					BATTLE_CheckGameStatus(battle_player_killed,check->dirchoosetime);
			}
		}
		else
		{
			if (check->obclass != b_darkmonkobj)
				SoftError("non-darkmonk actor %d being helped by explosion",check->obclass);
			check->hitpoints += pdamage;
		}
	}

	//======================== check surrounding statics ================

	for(checkstat = firstactivestat;
		checkstat;
		checkstat=checkstat->nextactive)
	{

		if ((!(checkstat->flags & FL_SHOOTABLE)) && (checkstat->itemnumber != stat_priestporridge))
			continue;

		if ((checkstat->itemnumber >= stat_lifeitem1) &&
			(checkstat->itemnumber <= stat_lifeitem4))
			continue;

		dx = abs(checkstat->x - ob->x);
		dy = abs(checkstat->y - ob->y);
		dz = ((abs(checkstat->z - ob->z))<<10);

		if ((dx < blastradius) && (dy < blastradius) && (dz < blastradius))
		{
			dist = Find_3D_Distance(dx,dy,dz)+0xc00;

			if (dist < 0x10000)
				dist = 0x10000;

			scalefactor = FixedDiv2(1<<16,FixedMul(dist,dist));
			pdamage = FixedMul(damage,scalefactor);

			if (checkstat->itemnumber != stat_priestporridge)
				DamageThing(checkstat,pdamage);
			else if (!(checkstat->flags & FL_ACTIVE))
			{
				checkstat->flags |= FL_ACTIVE;
				checkstat->count = 1;
				//checkstat->numanims = 6;
				SD_PlaySoundRTP(SD_COOKHEALTHSND,ob->x,ob->y);
			}
		}
	}

	//======================== check surrounding walls ================
	{
		int tilexlow,tilexhigh;
		int tileylow,tileyhigh;
		int radius =0x10000;
		int x,y;

		tilexlow = (int)((ob->x-radius) >>TILESHIFT);
		tileylow = (int)((ob->y-radius) >>TILESHIFT);

		tilexhigh = (int)((ob->x+radius) >>TILESHIFT);
		tileyhigh = (int)((ob->y+radius) >>TILESHIFT);

		tilexlow &= (MAPSIZE-1);	//BGB: Debug
		tileylow &= (MAPSIZE-1);	//BGB: Debug
		tilexhigh &= (MAPSIZE-1);	//BGB: Debug
		tileyhigh &= (MAPSIZE-1);	//BGB: Debug

		for (y=tileylow;y<=tileyhigh;y++)
		{
			for (x=tilexlow;x<=tilexhigh;x++)
			{
				if(		(tilemap[x][y]&0x8000) &&
						(tilemap[x][y]&0x4000) &&
						(abs(ob->z - nominalheight) < 32)	)
				{
					maskedwallobj_t		*mw;

					mw=maskobjlist[tilemap[x][y]&0x3ff];
					if (mw->flags&MW_SHOOTABLE)
						UpdateMaskedWall(tilemap[x][y]&0x3ff);
				}
			}
		}
	}
}

void SpawnScreenEye(objtype *ob)
{
	SpawnNewObj(ob->tilex,ob->tiley,&s_eye1,inertobj);
	new->targettiley = 0;
	new->targettilex = GameRandomNumber("eye position",0) + 20;
	SCREENEYE = new;
	//RemoveFromArea(new);
	new->flags |= FL_ABP;
	MakeActive(new);
}

void SpawnSuperFatalityGibs(objtype *ob,objtype *attacker)
{
	int crazygibs = (GameRandomNumber("crazy gibs",0) % 6) + 4;
	int i;

	if ((MISCVARS->supergibflag == true) &&
		((crazygibs == 9) || (ludicrousgibs == true))
		)

		{
		int olddirect = MISCVARS->directgibs;

		MISCVARS->directgibs = false;
		if (ludicrousgibs == false)
			{
			if (attacker == player)
				{
				AddMessage("Ludicrous Gibs!",MSG_GAME);
				if (!(attacker->flags&FL_DOGMODE))
					SD_Play(PlayerSnds[locplayerstate->player]);
				}
			}
		else
			{
			MISCVARS->randgibspeed = true;
//			SpawnParticles(ob,GUTS,75);
//MED
			SpawnParticles(ob,GUTS,150);
			MISCVARS->randgibspeed = false;
			}
		SpawnParticles(ob,GUTS,40);
		MISCVARS->directgibs = olddirect;

		}

	for (i=gt_head;i<=crazygibs;i++)
	{
		if (((ob->obclass == dfiremonkobj) ||
			(ob->obclass == deathmonkobj)) &&
				(i == gt_leg)	)
			SpawnParticles(ob,gt_arm,1);
		else
			SpawnParticles(ob,i,1);
	}
}

boolean Vicious_Annihilation(objtype *ob, objtype *attacker)
	{
	if ((ob->flags & FL_HBM) && (gamestate.violence >= vl_high))
		{
		ob->shapeoffset = 0;
		ob->flags &= ~FL_FULLLIGHT;
		NewState(ob,(ob->obclass == playerobj)?(&s_remoteguts1):(&s_guts1));
		SD_PlaySoundRTP(SD_ACTORSQUISHSND,ob->x,ob->y);
		if (gamestate.violence == vl_excessive)
			{
			int numgibs;
			objtype *prevlast;

			numgibs = (GameRandomNumber("excessive guts",0) & 7) + 4;
			//SoftError("\nnumgibs = %d,gamestate.difficulty = %d",numgibs,gamestate.difficulty);
			prevlast = LASTACTOR;
			MISCVARS->fulllightgibs = true;
			SpawnParticles(ob,GUTS,numgibs);
			MISCVARS->fulllightgibs = false;
			for(prevlast = prevlast->next;prevlast;prevlast = prevlast->next)
				prevlast->momentumz += (prevlast->momentumz >> 1);

			if ((GameRandomNumber("super gib chance",0) < 100) ||
				(ludicrousgibs == true)
				)
				{
				MISCVARS->directgibs = true;
//MED
				MISCVARS->gibgravity = GRAVITY/2;
//				MISCVARS->gibgravity = GRAVITY*2;
				MISCVARS->fulllightgibs = true;
				SpawnSuperFatalityGibs(ob,attacker);
				MISCVARS->fulllightgibs = false;
				MISCVARS->gibgravity = -1;
				MISCVARS->directgibs = false;
				}
			}
		return true;

		}

	if (ob->flags & FL_GODSTRUCK)
		{
		ob->shapeoffset = 0;
		ob->flags |= (FL_FULLLIGHT);
		ob->flags &= ~FL_COLORED;
		ob->momentumx = ob->momentumy = ob->momentumz = 0;
		KillActor(ob);
		NewState(ob,&s_vaporized1);
		return true;
		}

	if (ob->flags & FL_SKELETON)
		{
		KillActor(ob);
		ob->shapeoffset = 0;
		ob->flags &= ~FL_COLORED;
		ob->momentumx = ob->momentumy = ob->momentumz = 0;
		NewState(ob,&s_skeleton1);
		SD_PlaySoundRTP(SD_ACTORBURNEDSND,ob->x,ob->y);
		return true;
		}

	return false;

	}

/*
========================
=
= BeginEnemyFatality
=
========================
*/

void BeginEnemyFatality(objtype *ob,objtype *attacker)
{
	if ((attacker == player) && (ob->obclass < (NUMENEMIES + 2)))
	{
		GivePoints(starthitpoints[gamestate.difficulty][ob->obclass]*5);
		if (timelimitenabled)
			timelimit+=VBLCOUNTER;
	}

	ob->flags |= FL_DYING;
	ob->soundhandle = -1;

#if 0
	if ((ob->obclass == blitzguardobj) &&
		(ob->state->condition & SF_DOWN)
		)

		SD_Play(PlayerSnds[locplayerstate->player]);
#endif

	if (Vicious_Annihilation(ob,attacker))
		return;

	if ((ob->obclass == patrolgunobj) && (ob->temp1 == -1))
		NewState(ob,&s_robogrddie1);
	else if (ob->obclass == collectorobj)
	{
		if ((!M_ISACTOR(attacker)) || (attacker->obclass != playerobj))
			RespawnEluder();
		else
			BATTLE_CheckGameStatus(battle_shot_deluder,attacker->dirchoosetime);

		NewState(ob,&s_explosion1);
		MISCVARS->gibgravity = GRAVITY/2;
		MISCVARS->fulllightgibs = true;
		SpawnParticles(ob,gt_sparks,100);
		MISCVARS->fulllightgibs = false;
		MISCVARS->gibgravity = -1;
	}
	else
	{
		statetype *temp;

		if ((ob->obclass == blitzguardobj) &&
				(ob->state->condition & SF_FAKING)
			)
		{
			NewState(ob,&s_blitzstruggledie1);
			ob->flags &= ~FL_FULLLIGHT;
		}
		else if
			((ob->obclass == blitzguardobj) &&
				(ob->state->condition & SF_DOWN)
			)
		{
			NewState(ob,&s_blitzplead7);
			ob->flags &= ~FL_FULLLIGHT;
		}

		else if
			((temp= M_S(DIE)) != NULL)
			{
			if (LOW_VIOLENCE_DEATH_SHOULD_BE_SET(ob))
				SET_DEATH_SHAPEOFFSET(ob);
			NewState(ob,temp);
			ob->flags &= ~FL_FULLLIGHT;
			}
		else
			Error("Null dead state called in Collision, obclass %d",ob->obclass);
	}
}

/*
========================
=
= BeginPlayerFatality
=
========================
*/

void BeginPlayerFatality(objtype *ob,objtype *attacker)
{
	playertype *pstate;
	M_LINKSTATE(ob,pstate);

	ob->flags &= ~(FL_ELASTO|FL_GODMODE|FL_DOGMODE|FL_NOFRICTION|FL_RIDING);

	ob->flags |= FL_DYING;
	pstate->weapon = -1;

	if (BATTLEMODE)
		SD_PlaySoundRTP (SD_PLAYERTCDEATHSND+(pstate->player),ob->x,ob->y);

	if (Vicious_Annihilation(ob,attacker) == false)
	{
		if (LOW_VIOLENCE_DEATH_SHOULD_BE_SET(ob))
			SET_DEATH_SHAPEOFFSET(ob);

		NewState(ob,&s_remotedie1);
		ob->flags &= ~FL_FULLLIGHT;
	}
}

/*
========================
=
= BeginEnemyHurt
=
========================
*/

void BeginEnemyHurt(objtype *ob)
{
	statetype *temp;

	if ((temp= M_S(COLLIDE1)) != NULL)
	{
		if ((ob->obclass == blitzguardobj) &&
				(ob->state->condition & SF_FAKING)
			)
		{
			ob->temp1 = 1;
			ob->dirchoosetime = 0;
			T_PlayDead(ob);

		}
		else
		{
			if ((ob->obclass == triadenforcerobj) &&
				(GameRandomNumber("george pain chance",0) <
				(50 + (gamestate.difficulty<<6))
				)
				)
			{
				ob->flags &= ~FL_FULLLIGHT;
				return;
			}

			if (LOW_VIOLENCE_PAIN_SHOULD_BE_SET(ob))
				SET_PAIN_SHAPEOFFSET(ob);

			if (GameRandomNumber("Collision",0) < 128)
				NewState(ob,temp);
			else
				NewState(ob,M_S(COLLIDE2));
		}

		ob->flags &= ~FL_FULLLIGHT;
		ob->ticcount = PAINTIME;
		if (ob->obclass == strikeguardobj)
			ob->ticcount >>= 1;
	}
}

void  Collision(
	objtype *ob, objtype *attacker,
	int hitmomentumx, int hitmomentumy)
{
	int ocl;

	if ((!(ob->flags & FL_SHOOTABLE)) || (ob->flags & FL_DYING))
		return;

	ocl = ob->obclass;

	ob->momentumx += hitmomentumx;
	ob->momentumy += hitmomentumy;

	if ((ocl == playerobj) && (gamestate.battlemode == battle_Eluder))
		return;

	//insertion 5

	if (ocl != playerobj)
	{
		if ((!(ob->flags & FL_ATTACKMODE)) && (TABLE_ACTOR(ob)))
			ActivateEnemy(ob);

		if (ob->hitpoints <= 0)
			BeginEnemyFatality(ob,attacker);

		else if (ocl != roboguardobj)// && (ob->state->think != T_Collide))
			BeginEnemyHurt(ob);
	}
	else
	{
		playertype *pstate;

		if ((ob->flags & FL_GODMODE) || (ob->flags & FL_DOGMODE) || godmode)
			return;

		M_LINKSTATE(ob,pstate);
		if (pstate->health<=0)
			BeginPlayerFatality(ob,attacker);
		else
			ob->flags |= FL_PAIN;
	}
}

void T_BossExplosions(objtype*ob)
{
	if (ob->temp1)
	{
		if (ob->dirchoosetime)
		{
			ob->dirchoosetime --;
		}
		else
		{
			int randtime,randangle,randdist,sound;
			statetype *nstate;

			ob->temp1 --;
			randtime = GameRandomNumber("Boss Explosion Time",0);
			ob->dirchoosetime = 10;
			if (randtime < 128)
				ob->dirchoosetime >>= 1;
			randangle = (GameRandomNumber("Boss Explosion Angle",0) << 3);
			randdist = (GameRandomNumber("Boss Explosion Distance",0) << 7)+0x4000;
			sound = SD_EXPLODEFLOORSND;
			if (randtime < 128)
				{nstate = &s_explosion1;
				sound++;
				}
#if (SHAREWARE == 0)
			else
				nstate = &s_grexplosion1;
#endif

			SpawnMissile(ob,inertobj,0,randangle,nstate,randdist);
			SD_PlaySoundRTP(sound,new->x,new->y);
		}
	}
}

gib_t RandomGutsType(void)
{
	int rand = GameRandomNumber("gut random",0);

	if (rand < 128)
		return gt_organ;

	//if (rand < 160)
		return gt_rib;

	//return gt_pinkorgan;
}

//MED
void SpawnParticles(objtype*ob,int which,int numparticles)
{
	int randphi,randtheta,i,nspeed;
	boolean eyespawned = false;
	int gibtype;
	int randadj;

	if ((ob->z <= -64) && (sky == 0)) //shouldn't happen
		return;

	if (((which == GUTS) || (which == RANDOM)) && (gamestate.violence < vl_high))
		which = gt_sparks;

	gibtype = which;

	for(i=0;i<numparticles;i++)
		{
		randphi = (GameRandomNumber("particle generate phi",0) << 3);
		randadj = RandomSign() *
					(GameRandomNumber("rand gib adjust",0) >> 4);

		if (ob->z > (nominalheight - 32))
			randphi &= ((ANGLES/2) - 1);

		randtheta = (GameRandomNumber("particle generate theta",0) << 3);
		nspeed = MISCVARS->gibspeed;

		if (which == RANDOM)
			{
			if (GameRandomNumber("random gib",0) < 128)
				gibtype = RandomGutsType();
			else
				gibtype = gt_sparks;

			}

		if ((which == GUTS) || (which == DISEMBOWEL))
			{

			gibtype = RandomGutsType();
			if (which == DISEMBOWEL)
				{
				randphi>>=2;
				randtheta=ob->temp1+(randtheta>>3)-(randtheta>>4);
				}

			}

		if (lowmemory && (gibtype >= gt_rib) && (gibtype <= gt_limb))
			gibtype = gt_organ;

		if
			(
		// (gibtype >= gt_organ) && (gibtype <= gt_limb) &&
			(MISCVARS->numgibs >= MAXGIBS)
			)
			return;

		if (gibtype == gt_lsoul)
			{
			SpawnNewObj(ob->tilex,ob->tiley,&s_littlesoul,inertobj);
			randphi = 0;
			}

	#if (SHAREWARE == 0)
		else if (gibtype == gt_spit)

			SpawnNewObj(ob->tilex,ob->tiley,&s_slop1,inertobj);
	#endif
		else
			{
			SpawnNewObj(ob->tilex,ob->tiley,&s_gibs1,inertobj);
			new->shapeoffset = gibtype*12;
			NewState(new,new->state);
			}

		if (MISCVARS->directgibs == true)
			{
			int dx,dy,dz;

			dx = PLAYER[0]->x - ob->x;
			dy = ob->y - PLAYER[0]->y;
			randtheta = AngleBetween(ob,PLAYER[0]) +
							(randadj<<4);
			dz = 100 + (randadj<<3);

//MED
//			nspeed = 0x2800 + (randadj<<7);
			nspeed = 0x2800;
			randphi = atan2_appx(FindDistance(dx,dy),dz<<10);
			}

		if ((eyespawned == false) && (which == GUTS) &&
				(ob->obclass != playerobj)
			)
			{
			eyespawned = true;
			new->flags |= FL_EYEBALL;
			}

		if ((gibtype >= gt_organ) && (gibtype <= gt_limb))
			{
			new->dirchoosetime = GIBVALUE;
			MISCVARS->numgibs ++;
			}
		new->temp2 = gibtype;
		new->temp3 = (MISCVARS->gibgravity == -1)?(GRAVITY):(MISCVARS->gibgravity);

		new->speed = nspeed>>1;
//		if (MISCVARS->randgibspeed == true)
//			new->speed += (randadj << 11);
			//if (ob->state == &s_snakefireworks)
		new->z = ob->z;
		Fix(randphi);
		Fix(randtheta);

		Set_3D_Momenta(new,new->speed,randtheta,randphi);
		new->momentumz <<= 6;
		new->flags |= (FL_NOFRICTION|FL_CRAZY|FL_ABP|FL_NEVERMARK);
		if (MISCVARS->fulllightgibs == true)
			new->flags |= FL_FULLLIGHT;
		new->dir = west;
		new->whatever = ob;
		MakeActive(new);
		}
}

void T_SlideDownScreen(objtype *ob)
{
	ob->targettiley += 12;
	if (ob->targettiley > 300)
	{
		NewState(ob,&s_megaremove);
		SCREENEYE = NULL;
	}

}

void T_SpawnSoul(objtype*ob)
{
	if (ob->ticcount)
		return;

	SpawnNewObj(ob->tilex,ob->tiley,&s_bigsoul,inertobj);
	new->momentumz = -4000;
	new->flags |= (FL_NOFRICTION|FL_CRAZY|FL_ABP|FL_NEVERMARK);
	new->z = ob->z;
	new->dir = west;
	MakeActive(new);

	SpawnParticles(ob,gt_lsoul,6);
}

void BloodDrip(objtype *ob,int tilex,int tiley)
{
	int dx,dy,x,y,scale;

	dx = ob->tilex - tilex;
	dy = ob->tiley - tiley;

	if (!dy)
	{
		scale = (ob->momentumx)?(FixedDiv2(ob->momentumy,ob->momentumx)):(0);
		x = (dx < 0)?(tilex << 16):((tilex+1) << 16);
		y = FixedMul(x - ob->x,scale) + ob->y;
	}

	else if (!dx)
	{
		scale = (ob->momentumy)?(FixedDiv2(ob->momentumx,ob->momentumy)):(0);
		y = (dy < 0)?(tiley << 16):((tiley+1) << 16);
		x = FixedMul(y - ob->y,scale) + ob->x;
	}

	ob->temp2 = (GameRandomNumber("BloodDrip",0) << 9) + 0xc000;
	ob->temp1 = (ob->z<<16);
	SetFinePosition(ob,x,y);
	ob->shapeoffset = 0;
	NewState(ob,&s_blooddrip1);
}

void T_BloodFall(objtype*ob)
{
	ob->temp1 += ob->temp2;
	ob->z = (ob->temp1 >> 16);
	if (ob->z >= maxheight)
	{
		ob->shapeoffset = 12;
		MISCVARS->numgibs--;
		NewState(ob,&s_gibsdone1);
		ob->z = nominalheight;
	}
}

void T_Xylophone(objtype*ob)
{
	if (!ob->ticcount)
		SD_PlaySoundRTP(SD_ACTORSKELETONSND,ob->x,ob->y);
}

void T_ParticleGenerate(objtype*ob)
{
	if (ob->dirchoosetime)
	{
		ob->dirchoosetime--;
	}
	else
	{
		SetGibSpeed(0x3000);
		SpawnParticles(ob, gt_sparks,
			(GameRandomNumber("particle count",0) % 10) + 7);
		ResetGibSpeed();
		ob->dirchoosetime = 10;
		if (GameRandomNumber("particle generator choose time",0) < 128)
			ob->dirchoosetime >>= 1;
	}
}

void T_Particle(objtype*ob)
{
	int dx,dy,dz;

	ob->z += (ob->momentumz>>16);

	if ((ob->z >= nominalheight) || (!ob->momentumz))
	{
		if (ob->z >= nominalheight)
			ob->z = nominalheight;
	//done:
		if (ob->temp2 == gt_spit)
			ob->state = NULL;
		else
		{
			if (ob->dirchoosetime == GIBVALUE)
			{
				MISCVARS->numgibs--;
				SD_PlaySoundRTP(GIBSOUND,ob->x,ob->y);
			}
			NewState(ob,&s_gibsdone1);
		}
		return;
	}
	else if ((ob->z < -64) && (sky == 0))
	{
		ob->momentumz = 1; //any positive value will do
		ob->z = -64;

	}

	ob->momentumz += ob->temp3;
	ActorMovement(ob);

	if (!BATTLEMODE)
	{
		dx = abs(ob->x - PLAYER[0]->x);
		dy = abs(ob->y - PLAYER[0]->y);
		dz = abs(ob->z - PLAYER[0]->z);

	#if (SHAREWARE==0)
		if ((ob->flags & FL_EYEBALL) && (dx < 0x20000) && (dy < 0x20000) &&
			(dz < 64) && (GameRandomNumber("eye chance",0) < 15) &&
			(SCREENEYE == NULL) && (locplayerstate->weapon != wp_dog)
			)
	#else
		if ((ob->flags & FL_EYEBALL) && (dx < 0x20000) && (dy < 0x20000) &&
			(dz < 64) && (GameRandomNumber("eye chance",0) < 15) &&
			(SCREENEYE == NULL)
			)
	#endif
				SpawnScreenEye(ob);
	}

	//MoveActor(ob);
	//if ((!ob->momentumx) && (!ob->momentumy))
	//goto done;
}

void DropItemInEmptyTile(int item,int tilex,int tiley)
{
	int stilex = tilex;
	int stiley = tiley;

	FindEmptyTile(&stilex,&stiley);
	SpawnStatic(stilex,stiley,item,9);
	LASTSTAT->flags |= FL_ABP;
	MakeStatActive(LASTSTAT);
}

void KillActor(objtype *ob)
{
	int ocl;

	ocl = ob->obclass;

	ob->flags &= ~FL_BLOCK;

	//GivePoints(starthitpoints[gamestate.difficulty][ob->obclass]*5);
	if ((ocl == highguardobj) &&
		(GameRandomNumber("Drop mp40 chance",0) < 25))
	{
		DropItemInEmptyTile(stat_mp40,ob->tilex,ob->tiley);
	}
	else if ((ocl == blitzguardobj) && (ob->temp3))
	{
		DropItemInEmptyTile(ob->temp3,ob->tilex,ob->tiley);
		LASTSTAT->ammo = ob->temp2;
	}

	if (actorat[ob->tilex][ob->tiley] == (void*)ob)
		actorat[ob->tilex][ob->tiley] = NULL;

	gamestate.killcount++;
	ob->flags &= ~FL_SHOOTABLE;
	ob->flags &= ~FL_BLOCK;
	ob->flags |= FL_NEVERMARK;
#if (SHAREWARE == 0)
	if (ocl == b_darksnakeobj)
	{
		if (ob == SNAKEHEAD)
		{
			SpawnNewObj(ob->tilex,ob->tiley,&s_megaexplosions,inertobj);
			new->temp1 = 7000;
			new->flags |= FL_ABP;
			EXPLOSIONS = new;
			NewState(ob,&s_darkmonkheaddie1);
			MakeActive(new);
			ob->dirchoosetime = 0;
		}
		else
		{
			objtype *temp;

			SNAKEEND = (objtype*)(ob->target);
			SNAKEEND->whatever = NULL;
			NewState(ob,&s_explosion1);
			for(temp=SNAKEHEAD;temp;temp = (objtype*)(temp->whatever))
				temp->speed += 0x500;
		}
	}
	else
#endif
	{
		ob->whatever = NULL;
		if (ob->obclass!=playerobj)
			ob->target	= NULL;
	}

	if (	(ob->flags & FL_KEYACTOR) &&
			(ocl!=playerobj) &&
			(ocl != blitzguardobj))
	{
		MISCVARS->KEYACTORSLEFT --;
		if (!MISCVARS->KEYACTORSLEFT)
		{
			SpawnNewObj(ob->tilex,ob->tiley,&s_timekeeper,inertobj);
			new->flags |= FL_ABP;
			MakeActive(new);
		}
	}
//	ob->flags &= ~FL_BLOCK;

}

void T_End(objtype *ob)
{
	if (ob->ticcount)
		return;

	if (MAPSPOT(0,5,2) == LASTLEVELVALUE)
	playstate = ex_gameover;
	else
	playstate = ex_bossdied;
}

void T_Convert(objtype*ob)
{
	if (ob->ticcount)
		return;

	if (ob->obclass == playerobj)
	{
		if (ob->state == &s_vaporized8)
		{
			T_SpawnSoul(ob);
			NewState(ob,&s_voidwait);
		}
		else if (ob->state == &s_skeleton48)
		{
			playertype *pstate;

			M_LINKSTATE(ob,pstate);
			if ((pstate->falling == true) ||
				(!ob->momentumz)	)
				NewState(ob,&s_ashwait);
			else
				CheckPlayerSpecials(ob);
		}
	}
	else
	{
		if (ob->state == &s_vaporized8)
			T_SpawnSoul(ob);
		else if (ob->state == &s_skeleton48)
			TurnActorIntoSprite(ob);
	}
}

void TurnActorIntoSprite(objtype *ob)
{
	statobj_t	*temp;
	objtype		*tactor;

	if (!firstemptystat)
	{
		temp = (statobj_t*)Z_LevelMalloc(
			sizeof(statobj_t),PU_LEVELSTRUCT,NULL);
	}
	else
	{
		temp = lastemptystat;
		//SoftError("\nfree actor available");
		RemoveFromFreeStaticList(lastemptystat);
	}

//	ob->flags &= ~FL_BLOCK;		//BGB Debug

	if (temp)
	{
		if ((ob->obclass == blitzguardobj) &&
			((ob->flags & FL_PLEADING) || (ob->flags & FL_UNDEAD))
			)
		{
			MISCVARS->NUMBEGGINGKEVINS = 0;
		}

		if (ob->obclass == roboguardobj)
		{
			for(	tactor=firstareaactor[ob->areanumber];
					tactor;
					tactor=tactor->nextinarea)
			{
				if (tactor == ob)
					continue;
				if (tactor->obclass != ob->obclass)
					continue;

				if (tactor->flags & FL_DYING)
					continue;
				if (!tactor->state->think)
					NewState(tactor,
						UPDATE_STATES[PATH][tactor->obclass-lowguardobj]);

			}
		}

		memset(temp,0,sizeof(*temp));
		temp->shapenum = ob->shapenum;
		temp->linked_to = -1;
		temp->whichstat = statcount ++;
		SetFinePosition(temp,ob->x,ob->y);
		temp->areanumber = MAPSPOT(temp->tilex,temp->tiley,0)-AREATILE;
	//	if ((temp->areanumbers<=0) || (temp->areanumber>NUMAREAS))
		//		Error ("Sprite at x=%ld y=%ld type=%ld has an illegal areanumber\n",tilex,tiley,mtype);

		temp->visspot = &spotvis[temp->tilex][temp->tiley];
		temp->which = SPRITE;
		temp->itemnumber = -1;
		temp->flags = FL_DEADBODY;
		if (ob->flags & FL_COLORED)
		{
			playertype *pstate;
			M_LINKSTATE(ob,pstate);
			temp->flags |= FL_COLORED;
			temp->hitpoints = pstate->uniformcolor;
		}
		temp->z = ob->z;
		AddStatic(temp);
	//	sprites[temp->tilex][temp->tiley] = temp;

		if (areabyplayer[temp->areanumber])
		{
			temp->flags |= FL_ABP;
			MakeStatActive(temp);
		}
		if (ob->state != &s_guts12)
			actorat[ob->tilex][ob->tiley] = temp;
		ob->state = NULL; // say goodbye actor
	}
	else
	{
		Error("Z_LevelMalloc failed in TurnActorIntoSprite!");
	}
}

void T_Blood(objtype*ob)
{
	if (ob->dirchoosetime)
	{
		ob->dirchoosetime --;
		return;
	}

	ob->dirchoosetime = 35 + (GameRandomNumber("blood time",0) % 20);
	NewState(ob,&s_deadblood1);
}

void ActorDeath(objtype*ob)
{
	ob->flags &= ~FL_BLOCK;		//BGB Debug

#if (SHAREWARE == 0)
	if (ob->obclass == b_heinrichobj)
	{
		KillActor(ob);
		ob->temp1 = ob->dirchoosetime = 5;//10; // init. spin counter for heinrich
		ob->temp3 = 7; //number of times to stay at fast spin
		ob->temp2 = ob->dir; //temp2 holds orig. dir.
	}
	else if (ob->obclass == b_robobossobj)
	{
		objtype *wheels,*head;

		head = (objtype*)(ob->whatever);
		wheels = (objtype*)(ob->target);
		head->flags &= ~(FL_HEAD|FL_SHOOTABLE|FL_BLOCK);
		head->temp2 = 5;
		head->flags |= (FL_NOFRICTION|FL_CRAZY);
//		head->obclass = inertobj;
		//RemoveObj(wheels);	// remove wheels
		KillActor(ob);
		ob->whatever = head;
		ob->target = wheels;
		//ob->temp1 = 25;
		//ob->shapeoffset = 0;
		SpawnNewObj(ob->tilex,ob->tiley,&s_megaexplosions,inertobj);
		new->temp1 = 18;
		new->flags |= FL_ABP;
		MakeActive(new);
		//ob->state = NULL;
		NewState(ob,&s_NMEdeathbuildup);
	}
	else
#endif
		if ((ob->state == ob->state->next) &&
			(ob->flags & FL_DYING)
			)
	{
		KillActor(ob);
		TurnActorIntoSprite(ob);
		if (LASTSTAT->z < nominalheight)
		{
			if ((!IsPlatform(LASTSTAT->tilex,LASTSTAT->tiley)) &&
				(DiskAt(LASTSTAT->tilex,LASTSTAT->tiley) == NULL)
				)
			{
				SpawnParticles(ob,GUTS,10 + gamestate.difficulty);
				RemoveStatic(LASTSTAT);
			}
		}
		/*
		else if ((GameRandomNumber("blood spray",0) < 300) && areabyplayer[ob->areanumber])
			{ob->shapeoffset = 0;
			ob->temp2 = ob->temp3 = 0;
			ob->temp1 = 10;
			NewState(ob,&s_deadblood1);
			return;
			}
			*/
	}
}

void BeginPostPainAction(objtype *ob)
{
	if ((ob->obclass == strikeguardobj) &&
		(ob->target == (void*)PLAYER[0])
		)
	{
		//ob->target = NULL;
		if (LOW_VIOLENCE_DEATH_IS_SET(ob))
			RESET_DEATH_SHAPEOFFSET(ob);

		if (GameRandomNumber("T_Collide",0) < 128)
			NewState(ob,&s_strikerollright1);
		else
			NewState(ob,&s_strikerollleft1);

		SelectRollDir(ob);

		if (ob->dirchoosetime)
		{
			SD_PlaySoundRTP(SD_STRIKEROLLSND,ob->x,ob->y);
			return;
		}
	}

	if (LOW_VIOLENCE_PAIN_IS_SET(ob))
		RESET_PAIN_SHAPEOFFSET(ob);

	if (ob->obclass < roboguardobj)
		ob->flags &= ~FL_NOFRICTION;

	if (
		(ob->obclass == blitzguardobj) &&
		(gamestate.violence == vl_excessive) &&
		(GameRandomNumber("blitzplead",0) < 128) &&
		(MISCVARS->NUMBEGGINGKEVINS == 0) &&
		(ob->flags & FL_TARGET) &&

		(ob->hitpoints < (starthitpoints[gamestate.difficulty][ob->obclass] >> 1)) &&
		(ob->momentumz == 0) &&
		(!(ob->flags & FL_UNDEAD))
		)
	{
		NewState(ob,&s_blitzplead1);
		MISCVARS->NUMBEGGINGKEVINS = 1;
		ob->momentumx = ob->momentumy = 0;
		ob->flags |= FL_PLEADING;
		ob->flags &= ~FL_TARGET;
		ob->dirchoosetime = 165;
		ob->hitpoints = 1;
	}
	else
	{
		NewState(ob,M_S(CHASE));
		ob->targettilex = ob->targettiley = 0;
		ob->dirchoosetime = 0;
	}
}

void T_Collide(objtype *ob)
{
	if (!(ob->flags & FL_SHOOTABLE))
		return;

	ActorMovement(ob);

	if (ob->state == NULL)
		return;

	if (ob->ticcount)
		return;

	if (ob->hitpoints <= 0)
	{

		if ((ob->soundhandle == -1) &&
			(!ob->ticcount) &&
			(ob->state->next->tictime == 0)
			)
		{
			ob->soundhandle = SD_PlaySoundRTP(ACTORTHUDSND,ob->x,ob->y);
		}

		if (ob->momentumx || ob->momentumy || ob->momentumz)
			return;

		ActorDeath(ob);
		return;
	}

	BeginPostPainAction(ob);
}

/*
=========================================================================
=
=					Special Blitzguard Functions
=
=========================================================================
*/

/*
=================
=
=	T_Plead
=
=================
*/

void T_Plead(objtype*ob)
{
	int handle;

	ActorMovement(ob);
	if (ob->dirchoosetime)
	{
		if (!(ob->dirchoosetime & 31))
		{
			int random = GameRandomNumber("blitz plead sound",0);
			if (random < 80)
				SD_PlaySoundRTP(SD_BLITZPLEADSND,ob->x,ob->y);
			else if (random < 160)
				SD_PlaySoundRTP(SD_BLITZPLEAD1SND,ob->x,ob->y);
			else
				SD_PlaySoundRTP(SD_BLITZPLEAD2SND,ob->x,ob->y);
		}
		ob->dirchoosetime --;
		return;
	}

	ob->hitpoints = (starthitpoints[gamestate.difficulty][blitzguardobj]>>1);
	//ob->flags |= FL_DYING;
	ob->flags |= FL_UNDEAD;
	SET_DEATH_SHAPEOFFSET(ob);
	NewState(ob,&s_blitzfakedie1);
	ob->flags &= ~FL_PLEADING;
	ob->dirchoosetime = (GameRandomNumber("blitz fake time",0) >> 2) + 70;
	handle = SD_PlaySoundRTP(SD_BLITZOUCHSND,ob->x,ob->y);
	SD_SetSoundPitch (handle,-500);
	ob->temp1 = 0;
	ob->temp1 = (GameRandomNumber("blitz visible rise",0) < 60);
}

/*
=================
=
=	T_ReallyDead
=
=================
*/

void T_ReallyDead(objtype *ob)
{
	ActorMovement(ob);
	if ((!ob->ticcount) && (LOW_VIOLENCE_DEATH_SHOULD_BE_SET(ob)))
		SET_DEATH_SHAPEOFFSET(ob);
}

/*
=================
=
=	T_PlayDead
=
=================
*/

void T_PlayDead(objtype *ob)
{
	int dangle;

	ob->flags &= ~FL_DYING;

	ActorMovement(ob);
	if (ob->dirchoosetime)
	{
		ob->dirchoosetime--;
		return;
	}

	dangle = abs(player->angle - AngleBetween(player,ob));
	if (dangle > ANGLES/2)
		dangle = ANGLES - dangle;

	if (ob->temp1 || (dangle > ANGLES/4))
	{
		if (LOW_VIOLENCE_DEATH_IS_SET(ob))
			RESET_DEATH_SHAPEOFFSET(ob);
		ob->temp1 = 0;

		NewState(ob,&s_blitzrise2);
	}
}

void AdjustAngle(int maxadjust, short int *currangle,int targetangle)
{
	int dangle,i,magangle;

	for(i=0;i<maxadjust;i++)
	{
		dangle = *currangle - targetangle;

		if (dangle)
		{
			magangle = abs(dangle);
			if (magangle > (ANGLES/2))
			{
				if (dangle > 0)
					(*currangle) ++;
				else
					(*currangle) --;
			}
			else
			{
				if (dangle > 0)
					(*currangle) --;
				else
					(*currangle) ++;
			}
			Fix(*currangle);
		}
	}
}

void ResolveMinimumDistance(
	objtype *heatseeker,
	objtype *potential_target,
	int *currmin)
{
	int currdist,angle,magangle;

	currdist = FindDistance((heatseeker->x-potential_target->x),
									(heatseeker->y-potential_target->y));
	angle = AngleBetween(heatseeker,potential_target);

	if (heatseeker->obclass != p_godballobj)
	{
		magangle = abs(heatseeker->angle - angle);
		if (magangle > VANG180)
			magangle = ANGLES - magangle;
		if (magangle > ANGLESDIV8)
			return;
	}

	if (currdist > LOOKAHEAD)
		return;

	if (currdist < (*currmin))
	{
		*currmin = currdist;
		heatseeker->target = potential_target;
	}
}

void HeatSeek(objtype*ob)
{
	int			xydist;
	int			mindist;
	objtype		*tactor;
	objtype		*owner;
	statobj_t	*tstat;
	int			angle,dz,yzangle,adjust;
	int			dx,dy;

	owner=(objtype *)ob->whatever;

	if (ob->dirchoosetime)
	{
		ob->dirchoosetime --;
	}
	else
	{
		if (!ob->target)
		{
			mindist = 0x7fffffff;

			for (tactor=firstactive;tactor;tactor=tactor->nextactive)
			{
				if (tactor == owner)
					continue;

				if (tactor->flags & FL_HEAD)
					continue;

				if ((tactor == ob) ||
					(!(tactor->flags & FL_SHOOTABLE)) ||
					(tactor->flags & FL_DYING))
					continue;

				if (!CheckLine(ob,tactor,SIGHT))
					continue;

				if ((tactor->obclass == bladeobj) || (tactor->obclass == NMEsaucerobj))
					continue;

				ResolveMinimumDistance(ob,tactor,&mindist);

			}

			if (ob->obclass != p_godballobj)
			{
				for(tstat=firstactivestat;tstat;tstat=tstat->nextactive)
				{
					if (!(tstat->flags & FL_HEAT))
						continue;

					if (!CheckLine(ob,tstat,SHOOT))
						continue;

					ResolveMinimumDistance(ob,(objtype*)tstat,&mindist);
				}
			}

			if (!ob->target)
				ob->dirchoosetime = 5;
		}
		else //if (ob->target != owner)
		{
			tactor = (objtype*)ob->target;

			if ((!tactor->nextactive) && (!tactor->prevactive))
			{
				ob->target = NULL;
				return;
			}

			dx = tactor->x - ob->x;
			dy = ob->y - tactor->y;
			dz = ob->z - tactor->z;
			//xydist = FixedSqrtHP((FixedMul(dx,dx) + FixedMul(dy,dy))>>16);
			xydist = FindDistance(dx,dy);
			angle = atan2_appx(dx,dy);
			adjust = (ob->obclass == p_godballobj)?(GODHAPT):(HAAPT);
			AdjustAngle(adjust,&(ob->angle),angle);
			ob->dir = angletodir[ob->angle];
			ob->momentumx = FixedMul(ob->speed,costable[ob->angle]);
			ob->momentumy = -FixedMul(ob->speed,sintable[ob->angle]);

			yzangle = atan2_appx(xydist,(dz<<10));
			adjust = (ob->obclass == p_godballobj)?(GODVAPT):(VAAPT);
			AdjustAngle(adjust,&(ob->yzangle),yzangle);
			ob->momentumz = -(FixedMul(ob->speed,sintable[ob->yzangle]));
		}
	}
}

void Stagger(objtype*ob)
{
	int randadj;

	randadj = (int)(GameRandomNumber("Stagger",1) >> 3);

	if (!ob->dirchoosetime)
	{
		ob->momentumz = ob->temp1 + (RandomSign() << 12);
		ob->dirchoosetime = 6;
	}
	else
		ob->dirchoosetime --;

	if ((ob->z + (ob->momentumz >> 10)) > (maxheight-12))
		ob->momentumz = -ob->momentumz;
	else if ((ob->z < 5) && (!sky))
		ob->z = 5;

	ob->angle += (RandomSign()*randadj);
	Fix(ob->angle);
	ob->momentumx = FixedMul(ob->speed,costable[ob->angle]);
	ob->momentumy = -FixedMul(ob->speed,sintable[ob->angle]);
	ob->dir = angletodir[ob->angle];
}

void SpawnSplit(objtype *ob,int angle)
{
	Fix(angle);
	SpawnMissile(ob,p_heatseekobj,ob->speed,angle,&s_p_bazooka1,0x4000);
	new->momentumz = ob->momentumz;
	new->whatever = ob->whatever;
}

void SplitMissile(objtype*ob)
{
	SD_PlaySoundRTP(SD_SPLITSND,ob->x,ob->y);
	if (ob->soundhandle != -1)
		SD_StopSound(ob->soundhandle);

	SpawnSplit(ob,ob->angle + ANGLES/12);
	SpawnSplit(ob,ob->angle - ANGLES/12);

	if (missobj == ob)
		{
		if (GameRandomNumber("split misscam",0)<128)
			missobj = LASTACTOR;
		else
			missobj = LASTACTOR->prev;
		}

	ob->state=NULL; // get rid of current missile
}

void SpawnMissileSmoke(objtype *ob)
{
	if (!ValidAreanumber(AREANUMBER(ob->tilex,ob->tiley)))
		return;

	SpawnStatic(ob->tilex,ob->tiley,stat_missmoke,-1);
	LASTSTAT->flags |= FL_ABP;
	MakeStatActive(LASTSTAT);
	SetFinePosition(LASTSTAT,ob->x,ob->y);
	LASTSTAT->z = ob->z+3;
}

void T_Projectile (objtype *ob)
{
	objtype *owner;
	playertype * pstate;

	owner = (objtype*)(ob->whatever);

	if (owner->obclass == playerobj)
		M_LINKSTATE(owner,pstate);

	if ((ob->soundhandle != -1) &&
		(!(oldpolltime & 7))
		)
		SD_PanRTP(ob->soundhandle,ob->x,ob->y);
#if (SHAREWARE == 0)
	if (ob->obclass == h_mineobj)
		{
		if (!ob->dirchoosetime)
			{
			NewState(ob,&s_grexplosion1);
			SD_PlaySoundRTP(SD_KRISTMINEHITSND,ob->x,ob->y);
			}
		else
			ob->dirchoosetime --;
		if (
			(ob->state == &s_mine1) &&
			(!ob->ticcount)
			)
			SD_PlaySoundRTP(BAS[ob->obclass].operate,ob->x,ob->y);

		}
#endif

	if (!ob->ticcount)
		{
		if (ob->state == &s_p_grenade)
			ob->momentumz += (GRAVITY>>6);
		else if
			(ob->state == &s_grenade_fall6)
			{
			NewState(ob,&s_explosion1);
			return;
			}
		}

	if (ob->obclass == p_drunkmissileobj)
		{
		if (ob->temp3 > 0)
			{
			ob->temp3 --;
			Stagger(ob);
			}
		else
			{
			if (ob->target == NULL)
				Stagger(ob);
			HeatSeek(ob);
			}

		}

	else if (ob->temp1 == NME_DRUNKTYPE)

		Stagger(ob);

	else if ((ob->obclass == p_heatseekobj) ||
		(ob->obclass == dm_heatseekobj) ||
		(ob->temp1 == NME_HEATSEEKINGTYPE) ||
		(ob->obclass == p_godballobj)
		)
		HeatSeek(ob);

	else if
		((ob->obclass == p_splitmissileobj) &&
		(!pstate->buttonstate[bt_attack])
		)
		{
		SplitMissile(ob);
		return;
		}

	if ((!BATTLEMODE) &&
		(!(ob->ticcount & 7)) &&
		(ob->obclass != p_firewallobj) &&
		(ob->obclass != p_kesobj) &&
		(ob->obclass != p_godballobj) &&
		((ob->obclass >= p_bazookaobj) ||  (ob->obclass == missileobj))
		)// &&

		SpawnMissileSmoke(ob);

	MissileMovement(ob);

	if (ob->obclass == grenadeobj)

		{
		if (ob->temp1 > 0)
			ob->temp1 -= ob->speed;
		else if (!(ob->flags & FL_DONE))
			{
			NewState(ob,&s_grenade_fall1);
			ob->flags |= FL_DONE;
			}
		}
}

void StartFirewall(objtype*ob, int newz)
{
	objtype *owner = (objtype*)(ob->whatever);

	MISCVARS->firespawned = 0;
	owner->temp1 = 0;
	SpawnFirewall(ob,2,newz);
	if (missobj == ob)
		missobj = LASTACTOR;
	NewState(ob,&s_megaremove);
}

void MissileMovement(objtype*ob)
{
	int tryx, tryy,tryz;
	tryx = ob->x + ob->momentumx;
	tryy = ob->y + ob->momentumy;
	tryz = ob->z + (ob->momentumz >> 10);

	if (!MissileTryMove (ob, tryx, tryy, tryz))
		return;
	ob->z += (ob->momentumz >> 10);
	MoveActor(ob);
}

#define DetonateMissile(x,y) \
{MissileHit(x,y);				\
	return false;					\
}										\

#define QuietDetonate(ob)				\
	{											\
	if (ob->soundhandle != -1)		\
		SD_StopSound(ob->soundhandle); \
	if (ob == missobj)					\
		missobj = NULL;					\
	NewState(ob,&s_megaremove);		\
	return false;							\
	}

boolean MissileTryMove(objtype*ob,int tryx,int tryy,int tryz)
{
	int				tilexlow,tileylow,tilexhigh,tileyhigh,x,y,
					trytilex,trytiley,dx,dy,dzt,dztp1,radius,
					sprrad,actrad,tcl,ocl,oldsrad,area,zdist,
					wall;

	objtype			*temp;
	wall_t			*tempwall;
	doorobj_t		*tempdoor;
	int				doorn;
	statobj_t		*tempstat;
	boolean			areatried[NUMAREAS] = {0};

	sprrad = 0x4500;
	actrad = ACTORSIZE+0x2800;
	ocl = ob->obclass;
	radius = PROJSIZE-0x2200;
	if (ocl==wallfireobj)
		radius-=0x3000;
	trytilex = (tryx >> TILESHIFT);
	trytiley = (tryy >> TILESHIFT);

	trytilex &= MAPSIZE-1;
	trytiley &= MAPSIZE-1;

	if (IsWindow(trytilex,trytiley) || (!InMapBounds((tryx>>16),(tryy>>16))))
	{
		QuietDetonate(ob);
	}

	/*
	*/
	//==== ceiling/floor clipping =================//

	if (tryz < -30)
	{
		if ((sky==0) || (ocl == inertobj))
		{
			DetonateMissile(ob,NULL);
		}
	/*
	else
		return true;
		*/
	/*
	else
		{
		NewState(ob,&s_megaremove);
		if (missobj == ob)
			missobj = NULL;

		return false;
		}
		*/
	}

	if (tryz > (maxheight-10))
	{
		if ((ocl == p_firewallobj) && (!(ob->flags & FL_ISFIRE)))
			StartFirewall(ob,nominalheight);
		else
			MissileHit(ob,NULL);
		return false;
	}

	//=============================================//

	sprrad = PROJSIZE+0x1000;

	tilexlow = (int)((tryx-radius) >>TILESHIFT);
	tileylow = (int)((tryy-radius) >>TILESHIFT);
	tilexhigh = (int)((tryx+radius) >>TILESHIFT);
	tileyhigh = (int)((tryy+radius) >>TILESHIFT);

	tilexlow &= (MAPSIZE-1);		//BGB Debug
	tileylow &= (MAPSIZE-1);		//BGB Debug
	tilexhigh &= (MAPSIZE-1);		//BGB Debug
	tileyhigh &= (MAPSIZE-1);		//BGB Debug

	oldsrad = sprrad;

	if (ocl == inertobj)
		goto walls;

	area = ob->areanumber;
	areatried[area] = true;
actors:
	for(temp=firstareaactor[area];temp;temp=temp->nextinarea)
	{
		if (temp == ob)
			continue;

		dx = abs(tryx - temp->x);
		dy = abs(tryy - temp->y);
		if ((dx > actrad) || (dy > actrad))
			continue;

		if (temp->flags & FL_HEAD)
			continue;

		if ((!(temp->flags & FL_BLOCK)) || (temp->flags & FL_DYING))
			continue;

		tcl = temp->obclass;

		zdist = 32;
		dzt = abs(tryz - temp->z);

		if ((tcl == playerobj) && (temp->flags & FL_DOGMODE))
			{
			dzt = abs(tryz - (temp->z + 30));
			zdist = 10;
			}
		else if (tcl == diskobj)
			{
			zdist = 50;
			}

		if (dzt > zdist)
			continue;

		//if ((ocl==wallfireobj) && (tcl==playerobj) && (temp->flags&FL_DOGMODE) && (dz>15))
			// continue;

		//if ((ocl==playerobj) &&
			//  (ob->whatever == (void*)temp))
			//continue;

		if (ob->whatever && (ob->whatever == temp->whatever))// &&
	//		(ocl == tcl))// missiles with same owner
																			// go through each other
			continue;

		if (!(ob->flags & FL_ISFIRE))
				{

				int random;

				if (tcl != b_darkmonkobj)
					{
					MissileHit(ob,temp);
					ob->target = NULL;
					if (tcl == wallfireobj)
						MissileHit(temp,NULL);
					if (((ocl == p_kesobj) || (ocl == p_godballobj)) && (tcl < pillarobj))
						continue;
					else
						return false;
					}
				random = GameRandomNumber("empower darkmonk",0);
#if (SHAREWARE == 0)

				if (ocl == p_kesobj)
					{
					NewState(ob,&s_megaremove);
					//ob->state = NULL;
					temp->hitpoints += (((random>>3)+140)<<1);
					CAP_OSCUROS_HITPOINTS(temp);
					}
				else if (ocl == p_firebombobj)
					{
					NewState(ob,&s_explosion1);
					temp->hitpoints += (((random>>3)+70)<<1);
					CAP_OSCUROS_HITPOINTS(temp);

					ob->target = NULL;
					}
				else
					{
					NewState(ob,&s_explosion1);
					temp->hitpoints += (((random>>3)+50)<<1);
					CAP_OSCUROS_HITPOINTS(temp);

					ob->target = NULL;
					}
				temp->temp3 = ocl;
				temp->speed = 5*SPDPATROL;
				NewState(temp,&s_darkmonkreact);
#endif
				return false;
				}

		else if (tcl < roboguardobj)
			{if ((temp->z == nominalheight) &&
				(!((tcl == playerobj) && ((temp->flags & FL_GODMODE) || (temp->flags & FL_DOGMODE) || godmode))))
				{
				if (tcl == playerobj)
					{
					playertype *pstate;
					objtype *owner = (objtype*)(ob->whatever);

					M_LINKSTATE(temp,pstate);
					if (temp->flags & FL_AV)
						{pstate->protectiontime = 1;
						if (temp==player)
							GM_UpdateBonus (pstate->protectiontime, false);
						continue;
						}

					//temp->flags &= ~FL_COLORED;
					pstate->health = 0;
					pstate->weapon = -1;
					if (owner->obclass == playerobj)
						BATTLE_PlayerKilledPlayer(battle_kill_with_missile,owner->dirchoosetime,temp->dirchoosetime);

					}

				temp->flags |= FL_SKELETON;
				temp->hitpoints = 0;
				Collision(temp,ob->whatever,-temp->momentumx,-temp->momentumy);
				}
			continue;
			}

		else
			{
			NewState(ob,&s_megaremove);
			ob->target = NULL;
#if (SHAREWARE == 0)
			if (tcl == b_darkmonkobj)
				NewState(temp,&s_darkmonkfspark1);
#endif
			}

		return false;

	}

	for (y=tileylow;y<=tileyhigh;y++)
		for (x=tilexlow;x<=tilexhigh;x++)
	{
		area = AREANUMBER(x,y);
		if (ValidAreanumber(area) && (areatried[area]==false))
		{
			areatried[area] = true;
			goto actors;
		}
	}

/******************* WALLS/PWALLS *****************************************/

	walls:

	for (y=tileylow; y<=tileyhigh; y++)
	for (x=tilexlow; x<=tilexhigh; x++)
	{
		tempwall = (wall_t*)actorat[x][y];
		wall=tilemap[x][y];

		if (tempwall && M_ISWALL(tempwall) && (tempwall->which!=MWALL))
		{
			if (ocl == h_mineobj)
			{
				if (WallCheck(ob->x-ob->momentumx, tryy))
				{
					ob->momentumx = -ob->momentumx;
					continue;
				}
				else if (WallCheck(tryx, ob->y-ob->momentumy))
				{
					ob->momentumy = -ob->momentumy;
					continue;
				}
			}

			DetonateMissile(ob,tempwall);
			//MissileHit(ob,tempwall);
			//return false;
		}

		tempstat = sprites[x][y];
		sprrad = oldsrad;

		if (tempstat &&
				((tempstat->flags & FL_SHOOTABLE) || (tempstat->flags & FL_BLOCK)))
		{

			if ((tempstat->itemnumber >= stat_bcolumn) &&
					(tempstat->itemnumber <= stat_icolumn))
				sprrad += 0x5000;

			dx = tryx - tempstat->x;
			if ((dx < -sprrad) || (dx > sprrad))
				continue;

			dy = tryy - tempstat->y;
			if ((dy < -sprrad) || (dy > sprrad))
				continue;

	//#define MINSTATZDIFF 60

			dzt = abs(ob->z - tempstat->z);
			dztp1 = abs(tryz - tempstat->z);
			/*
			if (ocl == p_firewallobj)// && (dztp1 <= MINSTATZDIFF))
				{
				if (ob->flags & FL_ISFIRE)
					{
					int cz = (ob->z - tempstat->z + MINSTATZDIFF);

					if ((cz >= -MAXSTEPHEIGHT) && (cz <= 0))
						{
						ob->z = tempstat->z - MINSTATZDIFF;
						tryz = ob->z + (ob->momentumz >> 16);
						dzt = MINSTATZDIFF;
						}
					}

				if ((dztp1 >= MINSTATZDIFF) || (dzt >= MINSTATZDIFF))
					continue;

				if (!(ob->flags & FL_ISFIRE))
					{
					StartFirewall(ob,tempstat->z - MINSTATZDIFF);
					return false;
					}
				}

			else*/
			{
				if (dztp1 > 50)
					continue;

				DetonateMissile(ob,tempstat);
			}
			//MissileHit(ob,tempstat);
			//return false;
		}
	}

//mwalls:

	if (M_ISMWALL(trytilex,trytiley))
	{
		maskedwallobj_t * mw;

		wall=tilemap[trytilex][trytiley];
		//tempwall = (wall_t*)actorat[trytilex][trytiley];

		mw=maskobjlist[wall&0x3ff];

		if (!(mw->flags&MW_BLOCKING))
		{

			if ((levelheight > 1) &&
				(((!(mw->flags & MW_ABOVEPASSABLE)) && (tryz <= 32)) ||
				((!(mw->flags & MW_MIDDLEPASSABLE)) && (tryz > 25) && (tryz < nominalheight-32)) ||
				((!(mw->flags & MW_BOTTOMPASSABLE)) && (tryz > maxheight - 74))
					)	)
			{
				DetonateMissile(ob,NULL);
			}
		}

		else if (mw->flags&MW_SHOOTABLE)
			{
			if (ob->z >= maxheight-64)
				{
				UpdateMaskedWall(tilemap[trytilex][trytiley]&0x3ff);
				}
			else
				DetonateMissile(ob,NULL);

			}

		else
			DetonateMissile(ob,NULL);
		//MissileHit(ob,tempwall);
		//return false;
	}

/******************* DOOR STUFF ******************************************/

	else if (M_ISDOOR(trytilex,trytiley))
	{
		doorn = tilemap[trytilex][trytiley];
		tempdoor = doorobjlist[doorn&0x3ff];
		if (tempdoor->position>=0x8000)
		{
		if (ob->z>maxheight-64)
			return true;
		}
		DetonateMissile(ob,tempdoor);
	}

	return true;
}

void SpawnFirewall(objtype*ob,int which,int newz)
{
	int i,j,count,newx,newy;
	objtype* owner;
	wall_t*tempwall;
	statetype* frame;
	int offset;

	owner = (objtype*)(ob->whatever);

	if ((owner->temp1 < 2) && (MISCVARS->firespawned < 14))
	{
		for(i=0;i<=which;i++)
		{
			GetNewActor ();
			MakeActive(new);
			MISCVARS->firespawned ++;
			new->obclass = p_firewallobj;
			new->which = ACTOR;
			new->areanumber = ob->areanumber;
			MakeLastInArea(new);
			offset = 0x6000;
			if (!which)
				new->temp1 = ob->temp1;
			else if (i==1)
				new->temp1 = ob->angle + ANGLES/4;
			else if (i==2)
				new->temp1 = ob->angle - ANGLES/4;
			else
			{
				new->temp1 = 0;
				offset = 0;
				new->flags |= FL_DONE;
			}

			Fix(new->temp1);

			new->speed = 0x8000;
			new->angle = ob->angle;
			ParseMomentum(new,new->angle);
			newx = ob->x + FixedMul(offset,costable[new->temp1]);
			newy = ob->y - FixedMul(offset,sintable[new->temp1]);
			SetFinePosition(new,newx,newy);
			SetVisiblePosition(new,newx,newy);
			new->whatever = ob->whatever;
			new->dirchoosetime = 2;
			new->flags |= (FL_NEVERMARK|FL_ABP|FL_NOFRICTION);
			count = (int)(GameRandomNumber("SpawFireWall",0) & 15);

			for(frame = &s_fireunit1,j=0;j<count;frame = frame->next,j++);

			NewState(new,frame);
			new->flags |= FL_ISFIRE;
				//SD_Play(SD_EXPL);
			tempwall = (wall_t*)actorat[new->tilex][new->tiley];
			new->z = newz;
			if (tempwall && M_ISWALL(tempwall))
			{
				SetFinePosition(new,ob->x,ob->y);
				SetVisiblePosition(new,ob->x,ob->y);
				owner->temp1++;
			}
		}
	}
}

void T_Firethink(objtype*ob)
{
	if (ob->dirchoosetime)
		ob->dirchoosetime--;
	else if (!(ob->flags & FL_DONE))
	{
		SpawnFirewall(ob,0,ob->z);
		ob->flags |= FL_DONE;
	}

	MissileMovement(ob);
}

void ResolveRide(objtype *ob)
{
	objtype *ride = (objtype*)(ob->whatever);

	if (M_ISACTOR(ride) && (ob->obclass != playerobj))
	{
		if (ob->flags & FL_RIDING)
		{
			int dx,dy;

			dx = ob->x - ride->x;
			dy = ob->y - ride->y;
			if ((dx < -MINACTORDIST) || (dx > MINACTORDIST) ||
				(dy < -MINACTORDIST) || (dy > MINACTORDIST) )
			{
				ride->whatever = NULL;
				ob->whatever = NULL;
				ob->flags &= ~FL_RIDING;
			}
		}
	}
}

void MoveActor(objtype*ob)
{
	int linked,oldarea,newarea,
		tilex,tiley,oldtilex,oldtiley;

	linked = 0;

	ResolveRide(ob);

	oldtilex = ob->tilex;
	oldtiley = ob->tiley;

	SetFinePosition(ob,ob->x+ob->momentumx,ob->y+ob->momentumy);
	/*
	if (ob->state == &s_explosion1)
	Error("moving explosion"); */

	if ((ob->obclass == playerobj) || (ob->flags & FL_NOFRICTION) || (ob->state->think == T_Collide) ||
		(ob->obclass == b_heinrichobj) || (ob->obclass == h_mineobj))

	SetVisiblePosition(ob,ob->x,ob->y);

	if (ob->obclass == inertobj)
		return;

	if ((ob->obclass == b_darksnakeobj) && (ob != SNAKEHEAD))
	{
		oldarea = ob->areanumber;
		newarea = SNAKEHEAD->areanumber;
		if (oldarea != newarea)
		{
			RemoveFromArea(ob);
			ob->areanumber = newarea;
			MakeLastInArea(ob);
		}
		return;
	}

	oldarea = ob->areanumber;
	newarea = AREANUMBER(ob->tilex,ob->tiley);
	if (!(ob->flags & (FL_NONMARK|FL_NEVERMARK)))
	{
		if ((oldtilex != ob->tilex) || (oldtiley != ob->tiley))
		{
			if (actorat[oldtilex][oldtiley] == (void*)ob)
				actorat[oldtilex][oldtiley] = NULL;
			if (actorat[ob->tilex][ob->tiley])
			{
				objtype* temp;

				temp = (objtype*)actorat[ob->tilex][ob->tiley];
				if (temp->which != SPRITE)
					actorat[ob->tilex][ob->tiley] = ob;
			}
			else
				actorat[ob->tilex][ob->tiley] = ob;
		}
	}

#define CheckAdjacentArea(x,y)		\
	{											\
	if (InMapBounds(x,y))				\
		{										\
		temparea = AREANUMBER(x,y);	\
		if (ValidAreanumber(temparea))  \
			newarea = temparea;			\
		}										\
	}

	if (!ValidAreanumber(newarea)) //find empty tile
	{
		int temparea;
		tilex = ob->tilex;
		tiley = ob->tiley;

		CheckAdjacentArea(tilex+1,tiley);
		CheckAdjacentArea(tilex-1,tiley);
		CheckAdjacentArea(tilex,tiley+1);
		CheckAdjacentArea(tilex,tiley-1);
	}
	//Error("new area invalid for actor %d, class %d",
		//	ob-&objlist[0],ob->obclass);

	if (!ValidAreanumber(newarea))		//BGB: debug
		newarea = oldarea;

//======================  swap in linked lists =====================
	if (oldarea != newarea)
	{
		RemoveFromArea(ob);
		ob->areanumber = newarea;
		MakeLastInArea(ob);
	}
}

void SpawnPushColumn(int tilex,int tiley,int which,int dir, int linked)
{
	if (which==0)
	{
		SpawnNewObj(tilex,tiley,&s_pushcolumn1,pillarobj);
//		for (i=0;i<(levelheight-1);i++)
//			SpawnStatic(tilex,tiley,stat_bcolumn,-(i<<6));
	}
	else if (which==1)
	{
		SpawnNewObj(tilex,tiley,&s_pushcolumn2,pillarobj);
//		for (i=0;i<(levelheight-1);i++)
//			SpawnStatic(tilex,tiley,stat_gcolumn,-(i<<6));
	}
	else
	{
		SpawnNewObj(tilex,tiley,&s_pushcolumn3,pillarobj);
//		for (i=0;i<(levelheight-1);i++)
//			SpawnStatic(tilex,tiley,stat_icolumn,-(i<<6));
	}
	PreCacheActor(pillarobj,which);

	gamestate.secrettotal++;
	new->speed = PILLARMOM;
	new->temp1 = 0x20000;
	new->temp2 = linked;
	new->flags |= (FL_BLOCK|FL_NOFRICTION);
	new->flags &= ~FL_SHOOTABLE;
	new->flags |= FL_HEIGHTFLIPPABLE;
	new->dir = dir;
	if (dir != nodir)
	ParseMomentum(new,dirangle8[new->dir]);
}

void SpawnWallfire(int tilex, int tiley, int dir)
{
	int offx,offy;

	GetNewActor();
	new->speed = 0x2000;
	SetTilePosition(new,tilex,tiley);
	SetVisiblePosition(new,new->x,new->y);
	new->obclass = wallfireobj;
	new->dir = dir*2;
	new->flags |= (FL_BLOCK|FL_NOFRICTION|FL_NEVERMARK);
	new->flags &= ~FL_SHOOTABLE;
	new->which = ACTOR;
	new->angle = dirangle8[new->dir];
	offx = FixedMul(0x10000,costable[new->angle])>>TILESHIFT;
	offy = -(FixedMul(0x10000,sintable[new->angle])>>TILESHIFT);

	new->areanumber = MAPSPOT(new->tilex+offx,new->tiley+offy,0)-AREATILE;
	MakeLastInArea(new);

	NewState(new,&s_wallfireball);
}

void SpawnSneaky(int tilex,int tiley)
{

	SpawnNewObj(tilex,tiley,&s_sneakydown,lowguardobj);
	new->temp3 = SNEAKY;
	if (!loadedgame)
		gamestate.killtotal++;
	StandardEnemyInit(new,north>>1);

	PreCacheActor(lowguardobj,0);
}

void RespawnEluder(void)
{
	int rand,count;
	int nx,ny;

	rand = (GameRandomNumber("eluder respawn",0) % NUMSPAWNLOCATIONS);

	for(count=0;count < NUMSPAWNLOCATIONS;count++)
	{
		if (!actorat[SPAWNLOC[rand].x][SPAWNLOC[rand].y])
		{
			SpawnCollector(SPAWNLOC[rand].x,SPAWNLOC[rand].y);
			return;
		}
		rand= ((rand + 1) % NUMSPAWNLOCATIONS);
	}

//MED
	nx = SPAWNLOC[rand].x;
	ny = SPAWNLOC[rand].y;
	FindEmptyTile(&nx,&ny);
	SpawnCollector(nx,ny);
}

//****************************************************************************
//
//
//
//****************************************************************************

void SpawnCollector(int tilex, int tiley)
{
	#if (SHAREWARE == 0)
	if ( dopefish==true )
	{
		SpawnNewObj(tilex,tiley,&s_scottwander1,collectorobj);
	}
	else
	#endif
	{
		SpawnNewObj(tilex,tiley,&s_collectorwander1,collectorobj);
	}

	new->flags |= (FL_SHOOTABLE|FL_BLOCK|FL_NOFRICTION|FL_FULLLIGHT);
	new->hitpoints = 500;
	new->speed = 0x3000;
	new->dir = north;
	new->dirchoosetime = 175;
	new->z = PlatformHeight(tilex,tiley);
	if (new->z == -10)
	new->z = 0;

	if (areabyplayer[new->areanumber])
	{
		new->flags |= FL_ABP;
		MakeActive(new);
	}

}

void SelectDoorDir(objtype*ob)
{
	int dx,dy,actrad;
	dirtype dtry1,dtry2,tdir,olddir;

	dx= ob->targettilex - ob->x;
	dy= ob->y - ob->targettiley;
	olddir = ob->dir;
	if ((abs(dx) < 0x4000) && (abs(dy) < 0x4000))
	{ZEROMOM;
	SetFinePosition(ob,ob->targettilex,ob->targettiley);
	SetVisiblePosition(ob,ob->x,ob->y);
	ParseMomentum(ob,dirangle8[ob->temp2]);
	ActorMovement(ob);
	ob->temp2 = 0;
	ob->temp1 = 20;
	#if (SHAREWARE == 0)
	if ( dopefish==true )
		{
		NewState(ob,&s_scottwander1);
		}
	else
	#endif
		{
		NewState(ob,&s_collectorwander1);
		}
	ob->targettilex = ob->targettiley = 0;
	ob->dirchoosetime = 165;
	return;
	}

	ZEROMOM;

	ParseMomentum(ob,atan2_appx(dx,dy));
	ActorMovement(ob);
	if (ob->momentumx || ob->momentumy)
	return;
	actrad = ACTORSIZE;
	dtry1=nodir;
	dtry2=nodir;

	if (dx> actrad)
	dtry1= east;
	else if (dx< -actrad)
	dtry1= west;
	if (dy> actrad)
	dtry2= north;
	else if (dy < -actrad)
	dtry2= south;

	if (abs(dy)>abs(dx))
	{tdir=dtry1;
	dtry1=dtry2;
	dtry2=tdir;
	}

	if (dtry1 != nodir)
	M_CHECKDIR(ob,dtry1);

	if (dtry2 != nodir)
	M_CHECKDIR(ob,dtry2);

	if (dtry1 != nodir)
	M_CHECKDIR(ob,dirorder[dtry1][NEXT]);

	if (dtry2 != nodir)
	M_CHECKDIR(ob,dirorder[dtry2][NEXT]);

	for(tdir = dirorder[olddir][NEXT];tdir != olddir;tdir = dirorder[tdir][NEXT])
	M_CHECKDIR(ob,tdir);
	ob->dir = olddir;

}

int M_ABS(int a)
{
	if(a<0)
		return(-a);
	return(a);
}

boolean EluderCaught(objtype *ob)
{
	objtype *temp;
	int dx,dy,dz;
	playertype *pstate;
	int dist = 0xc000;

	for(	temp = PLAYER[0];
			temp != PLAYER[numplayers-1]->next;
			temp = temp->next	)
	{
#if (SHAREWARE == 0)
		if (temp->state != &s_doguse)
			continue;
#endif

		dx = M_ABS(temp->x - ob->x);
		if (dx > dist)
			continue;

		dy = M_ABS(temp->y - ob->y);
		if (dy > dist)
			continue;

		dz = M_ABS(temp->z - ob->z);
		if (dz > (dist>>10))
			continue;

		M_LINKSTATE(temp,pstate);
//		if (DOGSCRATCH.attackinfo[pstate->attackframe].attack
//			== at_pulltrigger)
		{
			BATTLE_CheckGameStatus(battle_caught_eluder,temp->dirchoosetime);
			SpawnNewObj(ob->tilex,ob->tiley,&s_itemspawn1,inertobj);
			new->flags |= FL_ABP;
			SetFinePosition(new,ob->x,ob->y);
			SetVisiblePosition(new,ob->x,ob->y);
			new->z = ob->z;
			SD_PlaySoundRTP(SD_GETBONUSSND,ob->x,ob->y);
			MakeActive(new);
			NewState(ob,&s_megaremove);
			return true;
		}
	}

	return false;
}

void T_CollectorFindDoor(objtype*ob)
{
	if (EluderCaught(ob))
		return;

	if (!(gamestate.TimeCount % 17))
		SD_PlaySoundRTP(SD_MONKGRABSND,ob->x,ob->y);

	if ((ob->z != nominalheight) && (!IsPlatform(ob->tilex,ob->tiley)))
		ZEROMOM;

	if (ob->dirchoosetime)
		ob->dirchoosetime --;
	else
	{
#if (SHAREWARE == 0)
		if ( dopefish==true )
		{
			NewState(ob,&s_scottwander1);
		}
		else
#endif
		{
			NewState(ob,&s_collectorwander1);
		}

		ob->dirchoosetime = 165;
		ob->targettilex = ob->targettiley = 0;
		return;
	}

	if (ob->temp1)
	{
		int dx,dy;

		ob->temp1 --;
		ActorMovement(ob);
		dx = ob->targettilex-ob->x;
		dy = ob->targettiley-ob->y;
		if ((abs(dx) < 0x4000) && (abs(dy) < 0x4000))
		{
			ZEROMOM;
			SetFinePosition(ob,ob->targettilex,ob->targettiley);
			SetVisiblePosition(ob,ob->x,ob->y);

			ParseMomentum(ob,dirangle8[ob->temp2]);
			ActorMovement(ob);
			ob->temp2 = 0;
			ob->temp1 = 35;
			#if (SHAREWARE == 0)
			if ( dopefish==true )
			{
				NewState(ob,&s_scottwander1);
			}
			else
			#endif
			{
				NewState(ob,&s_collectorwander1);
			}
			ob->targettilex = ob->targettiley = 0;
			ob->dirchoosetime = 165;
			return;
		}

		if (NOMOM)
			ob->temp1 = 0;
		return;
	}

	ob->temp1 = 5;

	if (ob->targettilex || ob->targettiley)
		SelectDoorDir(ob);

	else
	{
		int i;
		doorobj_t* dptr;

//==========================================================================
#define SetCollectorTarget(xoffset,yoffset,newdir)								\
	{																							\
	ob->targettilex = ((dptr->tilex + (xoffset)) << TILESHIFT) + HALFGLOBAL1; \
	ob->targettiley = ((dptr->tiley + (yoffset)) << TILESHIFT) + HALFGLOBAL1; \
	ob->temp2 = newdir;																	\
	if (GameRandomNumber("collector door search",0) < 100)						\
		return;																				\
	}
//==========================================================================

	for(i=0;i<doornum;i++)
	{
		dptr = doorobjlist[i];

		if (dptr->vertical)
		{
			int area1 = AREANUMBER(dptr->tilex-1,dptr->tiley),
					area2 = AREANUMBER(dptr->tilex+1,dptr->tiley);

			if (area1 == ob->areanumber)
				SetCollectorTarget(-1,0,east)

			else if (area2 == ob->areanumber)
				SetCollectorTarget(1,0,west);
		}
		else
		{
			int area1 = AREANUMBER(dptr->tilex,dptr->tiley-1),
					area2 = AREANUMBER(dptr->tilex,dptr->tiley+1);

			if (area1 == ob->areanumber)
				SetCollectorTarget(0,-1,south)

			else if (area2 == ob->areanumber)
				SetCollectorTarget(0,1,north);

		}
	}
	}

}

void T_CollectorWander(objtype*ob)
{
	int newtilex,newtiley;

	if (EluderCaught(ob))
		return;

	if ((ob->z != nominalheight) && (!IsPlatform(ob->tilex,ob->tiley)))
		ZEROMOM;

	if (!(gamestate.TimeCount & 15))//%17
		SD_PlaySoundRTP(SD_MONKGRABSND,ob->x,ob->y);

	if (ob->dirchoosetime)
		{
		if (doornum > 0)
			ob->dirchoosetime --;
		}

	else
		{
		#if (SHAREWARE == 0)
		if ( dopefish==true )
			{
			NewState(ob,&s_scottwanderdoor1);
			}
		else
		#endif
			{
			NewState(ob,&s_collectorfdoor1);
			}
		ob->temp1 = 0;
		ob->dirchoosetime = 165;
		ob->targettilex = ob->targettiley = 0;
		return;
		}

	if (ob->temp1) // temp1 holds direction time
		ob->temp1 --;
	else
		{
		dirtype bestdir,tempdir;

		bestdir = angletodir[GameRandomNumber("collector theta",0) << 3];

		for(tempdir = bestdir;tempdir != dirorder[bestdir][PREV];tempdir = dirorder[tempdir][NEXT])
			{
			ParseMomentum(ob,dirangle8[tempdir]);
			newtilex = ((ob->x + ob->momentumx)>>16);
			newtiley = ((ob->y + ob->momentumy)>>16);
			if (IsWindow(newtilex,newtiley))
				continue;
			ActorMovement(ob);
			if (ob->momentumx || ob->momentumy)
				{
				ob->temp1 = (GameRandomNumber("collector choose time",0) >> 2);
				return;
				}
			}

		}

	newtilex = ((ob->x + ob->momentumx)>>16);
	newtiley = ((ob->y + ob->momentumy)>>16);

	if (IsWindow(newtilex,newtiley))
		{
		ob->temp1 = 0;
		return;
		}

	ActorMovement(ob);

	if (NOMOM)
		ob->temp1 = 0;
	}

boolean CheckDoor(objtype *ob,doorobj_t * door,int trytilex,int trytiley)
{boolean doorok=false;

	switch(ob->dir)
	{case north:
	if ((ob->tiley == (door->tiley + 1)) && (trytilex == ob->tilex))
		doorok = true;
	break;

	case east:
	if ((ob->tilex == (door->tilex - 1)) &&	(trytiley == ob->tiley))
		doorok = true;
	break;

	case south:
	if ((ob->tiley == (door->tiley - 1)) &&	(trytilex == ob->tilex))
		doorok = true;
	break;

	case west:
	if ((ob->tilex == (door->tilex + 1)) &&	(trytiley == ob->tiley))
		doorok = true;
	break;
	}

	if (doorok)
	{SetTilePosition(ob,ob->tilex,ob->tiley);
	SetVisiblePosition(ob,ob->x,ob->y);
	return true;
	}
	return false;
}

boolean WallCheck(int tryx,int tryy)
{
	int tilexlow,tilexhigh,tileylow,tileyhigh,y,x;

	tilexlow = (int)((tryx -PLAYERSIZE) >>TILESHIFT);
	tileylow = (int)((tryy -PLAYERSIZE) >>TILESHIFT);

	tilexhigh = (int)((tryx + PLAYERSIZE) >>TILESHIFT);
	tileyhigh = (int)((tryy + PLAYERSIZE) >>TILESHIFT);

	tilexlow &= MAPSIZE-1;
	tileylow &= MAPSIZE-1;
	tilexhigh &= MAPSIZE-1;
	tileyhigh &= MAPSIZE-1;

	for (y=tileylow;y<=tileyhigh;y++)
		for (x=tilexlow;x<=tilexhigh;x++)
	{
		//tempwall = (wall_t*)actorat[x][y];
		//if (tempwall && M_ISWALL(tempwall))
		if (tilemap[x][y])
			return false;
	}

	return true;
}

boolean QuickSpaceCheck(objtype *ob, int tryx, int tryy)
{
	int xlow,xhigh,ylow,yhigh,x,y,dx,dy;
	objtype* temp;

	xlow = (int)((tryx-ACTORSIZE) >>TILESHIFT);
	ylow = (int)((tryy-ACTORSIZE) >>TILESHIFT);

	xhigh = (int)((tryx+ACTORSIZE) >>TILESHIFT);
	yhigh = (int)((tryy+ACTORSIZE) >>TILESHIFT);
	
	xlow &= MAPSIZE-1;
	ylow &= MAPSIZE-1;
	xhigh &= MAPSIZE-1;
	yhigh &= MAPSIZE-1;
	
/******************* WALLS/PWALLS *****************************************/

	for (y=ylow;y<=yhigh;y++)
	for (x=xlow;x<=xhigh;x++)
	{temp = (objtype*)actorat[x][y];
	if ((temp && (temp->which != ACTOR)) ||
		(sprites[x][y] && (sprites[x][y]->flags & FL_BLOCK))

			|| tilemap[x][y])
		return false;
	}

	for(temp=firstareaactor[ob->areanumber];temp;temp=temp->nextinarea)
	{
		if (temp == ob)
			continue;
		if ((temp->flags & FL_NONMARK) || (temp->flags & FL_NEVERMARK))
		continue;
		dx = tryx - temp->x;
		if ((dx < -MINACTORDIST) || (dx > MINACTORDIST))
			continue;
		dy = tryy - temp->y;
		if ((dy < -MINACTORDIST) || (dy > MINACTORDIST))
			continue;
		if (ob->whatever == (void*)temp)
			continue;
		if (temp->whatever == ob->whatever)
			continue;
		return false;
	}

	return true;
}

//=========================================================================
//
//						ACTOR TRY MOVE MADNESS
//
//=========================================================================

typedef enum
{
	NO_MOVEMENT,
	Z_MOVEMENT_ONLY,
	OK_TO_CONTINUE

}movement_status;

//==================== Some ActorTryMove macros ==============================

#define CheckProximitySpecials(ob,temp)									\
{																						\
	if (ocl == b_heinrichobj)													\
		{																				\
		if (tcl == playerobj)													\
			{																			\
			playertype *pstate;												\
																							\
			M_LINKSTATE(temp,pstate);										\
			DamageThing(temp,5);												\
			temp->whatever = ob;												\
			temp->temp2 = COLUMNCRUSH;										\
			pstate->heightoffset += 4;										\
			if (pstate->heightoffset >= 30)								\
				pstate->heightoffset = 30;									\
			pstate->oldheightoffset = pstate->heightoffset;			\
			}																			\
		else																			\
			{																			\
			temp->momentumx = temp->momentumy = temp->momentumz = 0; \
			temp->hitpoints = 0;												\
			}																			\
		if (temp->hitpoints <= 0)												\
			temp->flags |= FL_HBM;												\
		Collision(temp,ob,0,0);												\
		continue;																	\
		}																				\
																						\
	else if ((ocl == b_darksnakeobj) && (tcl == playerobj)) \
		{																	\
		DamageThing(temp,1);												\
		Collision(temp,ob,0,0);	\
		M_CheckPlayerKilled(temp);											\
		} \
		\
	if ((ocl == boulderobj) && (tcl >= lowguardobj) && (tcl < roboguardobj))\
		{temp->momentumx = temp->momentumy = temp->momentumz = 0;	\
		temp->hitpoints = 0;													\
		temp->flags |= FL_HBM;													\
		Collision(temp,ob,0,0);												\
		SD_PlaySoundRTP(SD_ACTORSQUISHSND,temp->x,temp->y);			\
		continue;																	\
		}																				\
																						\
	if (pusher && (ocl != tcl) && (!(temp->flags & FL_DYING))  &&	\
		(tcl < roboguardobj)													\
		)																				\
		{if ((!ob->ticcount) && (ocl != collectorobj) && (ocl != diskobj))\
			DamageThing(temp,5);												\
																						\
		if (tcl == playerobj)													\
			temp->flags |= FL_PUSHED;											\
		Collision(temp,ob,ob->momentumx-temp->momentumx,ob->momentumy-temp->momentumy);\
		M_CheckPlayerKilled(temp);											\
		continue;																	\
		}																				\
																						\
	if (bouncer)																	\
		{ob->momentumx = -ob->momentumx;										\
		continue;																	\
		}																				\
	}

#define CheckStepping(ob,step,minzdiff)								\
{																					\
	int cz = (ob->z - step->z + minzdiff);								\
																					\
	if ((cz >= -MAXSTEPHEIGHT) && (cz <= MAXSTEPHEIGHT))			\
		{if ((ob->obclass == playerobj) && (ob->temp2 == 0) &&	\
			(ob->z != (step->z - minzdiff))							\
			)																	\
			{																		\
			playertype *pstate;												\
																					\
			M_LINKSTATE(ob,pstate);										\
																					\
			pstate->heightoffset = pstate->oldheightoffset + cz;	\
			ob->temp2 = (cz >= 0)?(STEPUP):(STEPDOWN);				\
			}																		\
		ob->z = step->z - minzdiff;										\
		tryz = ob->z + (ob->momentumz >> 16);							\
		dzt = minzdiff;														\
		}																			\
}																					\

//============ Players crushing other players =====================

void BattleCrushCheck(objtype *ob,objtype *listrover)
{
	if ((ob->obclass == playerobj) && (listrover->obclass == playerobj))
	{
		playertype * pstate;

		M_LINKSTATE(listrover,pstate);
		if (pstate->health <= 0)
			BATTLE_PlayerKilledPlayer(
				battle_kill_by_crushing,ob->dirchoosetime,
				listrover->dirchoosetime);
	}
}

//=================================================================

movement_status CheckOtherActors(objtype*ob,int tryx,int tryy,int tryz)
{
	objtype *listrover;
	int area;
	int op;
	int areatried[NUMAREAS]={0};
	int tilexlow,tilexhigh,tileylow,tileyhigh;
	int radius,actrad,oldrad;
	boolean bouncer,pusher,thinkingactor,zstoppable,ACTORSTOP;
	int dzt,dztp1,checkz;
	int x,y,dx,dy;
	int ocl,tcl;
	int ISPLAYER = 0;
	int hoffset;

	ocl = ob->obclass;

	actrad = MINACTORDIST;//ACTORSIZE+0x2800;
	pusher =  ((ocl == wallopobj) || (ocl == pillarobj) ||
				(ocl == roboguardobj) || (ocl == collectorobj) ||
				(ocl == boulderobj) || (ocl == diskobj)
				);

	thinkingactor = ((ocl != playerobj) && (ob->state->think != T_Collide) &&
						(ocl < roboguardobj)
						);

	zstoppable = (!(ob->flags & FL_DYING));
	bouncer = ((ocl == playerobj) && (ob->flags & FL_ELASTO));
	radius = ACTORSIZE;

	if (ocl != playerobj)
	{
		//actrad = MINACTORDIST;
		//if ((ob->dir == nodir) && (ocl != b_robobossobj) &&
		//	(ocl != wallopobj) && (ocl != roboguardobj) && (ocl != diskobj)
		// )
		// Error("ob called with nodir");
		if (ocl == boulderobj)
			radius += (ACTORSIZE/4);
		else if (ocl == b_darksnakeobj)
			radius -= 6000;
		else if (ocl == inertobj)
			radius -= 0x2000;
	}

	else
	{
		ISPLAYER = 1;
		if (ob->flags & FL_DOGMODE)
			hoffset = 10;
	}

	tilexlow = (int)((tryx-radius) >>TILESHIFT);
	tileylow = (int)((tryy-radius) >>TILESHIFT);

	tilexhigh = (int)((tryx+radius) >>TILESHIFT);
	tileyhigh = (int)((tryy+radius) >>TILESHIFT);

	tilexlow &= (MAPSIZE-1);
	tileylow &= (MAPSIZE-1);
	tilexhigh &= (MAPSIZE-1);
	tileyhigh &= (MAPSIZE-1);

	area = ob->areanumber;
	areatried[area] = 1;
	ACTORSTOP = false;
	oldrad = actrad;

actors:
	for(	listrover=firstareaactor[area];
			listrover;
			listrover=listrover->nextinarea	)
	{
		actrad = oldrad;

		if (listrover == ob)
			continue;

		tcl = listrover->obclass;

		if ((tcl == b_darksnakeobj) && (listrover != SNAKEHEAD))
			continue;

		if (((tcl == bladeobj) || (tcl == firejetobj)) && thinkingactor)
			actrad += 0x3000;

		dx = tryx - listrover->x;
		if ((dx < -actrad) || (dx > actrad))
			continue;

		dy = tryy - listrover->y;
		if ((dy < -actrad) || (dy > actrad))
			continue;

		if ((ocl == b_darksnakeobj) && (tcl == ocl))
			continue;

		if ((tcl == springobj) && (listrover->state->condition & SF_UP) &&
			(listrover->temp1!=3) && (levelheight > 1) &&
			(abs(listrover->z - ob->z) < 5) && (!ob->momentumz)
			)
		{
			{
				op = (FixedMul((int)GRAVITY,(int)((ob->z-10)<<16))<<1);
				ob->momentumz = -FixedSqrtHP(op);
			}
			SD_PlaySoundRTP(SD_SPRINGBOARDSND,listrover->x,listrover->y);
			NewState(listrover,&s_spring2);

		}

		if ((tcl == firejetobj) && (ob->z < listrover->z))
			continue;

		// if not blocking
		// and actor not avoiding
		// env. danger
//		if ((!(listrover->flags & FL_BLOCK)) && (actrad == oldrad))
		if (!(listrover->flags & FL_BLOCK))	//BGB: Debug
			continue;

		if (listrover->flags & FL_DYING)	//BGB: Debug
			continue;
		if (listrover->flags & FL_DEADBODY)	//BGB: Debug
			continue;

		if (tcl == crushcolobj)
			checkz = listrover->temp2;
		else
			checkz = listrover->z;

	#define  MINACTORZDIFF 58

		dzt = abs(checkz - ob->z);
		dztp1 = abs(checkz - tryz);

		if ((tcl == diskobj) && (dztp1 <= MINACTORZDIFF) && zstoppable &&
			(ocl != b_heinrichobj)
			)
			CheckStepping(ob,listrover,MINACTORZDIFF);

		dztp1 = abs(checkz - tryz);

		if ((dzt > (MINACTORZDIFF - 25)) && (dzt < MINACTORZDIFF) &&
			(dztp1 < MINACTORZDIFF) && (tcl < roboguardobj) &&
			(ocl < roboguardobj)
			)
			{
			int rdx,rdy;

			rdx = abs(ob->x - listrover->x);
			rdy = abs(ob->y - listrover->y);
			if ((rdx < actrad) && (rdy < actrad))
				{
				if (ob->z > listrover->z)
					listrover->z = ob->z - MINACTORZDIFF;
				else
					ob->z = listrover->z - MINACTORZDIFF;

				dzt = dztp1 = MINACTORZDIFF;
				}

			}

		if ((dztp1 >= MINACTORZDIFF) || (dzt >= MINACTORZDIFF))
		{
			if ((dzt >= MINACTORZDIFF) && (dztp1 <= MINACTORZDIFF) &&
				zstoppable
				)
			{
				//ob->momentumz = 0;
				if (ob->z < listrover->z)
				{
					ob->z = listrover->z - MINACTORZDIFF;
					ob->momentumz = 0;
				}
				else
					ob->momentumz = 2*GRAVITY;
				if ((listrover->z > ob->z) && (tcl < roboguardobj) && (ocl < roboguardobj) &&
						(!(listrover->flags & FL_DYING))
					)
				{
					DamageThing(listrover,5);
					BattleCrushCheck(ob,listrover);
					Collision(listrover,ob,listrover->momentumx,listrover->momentumy);
					/*
					if ((ocl == playerobj) && (listrover->flags & FL_DYING))
						GivePoints(starthitpoints[gamestate.difficulty][tcl]);
					*/
				}

				if (((tcl == bladeobj) || (tcl == diskobj)) && (ob->z < listrover->z))
				{
					ob->whatever = listrover;
					if (listrover->flags & FL_ACTIVE)
						ob->flags |= FL_RIDING;
					listrover->whatever = ob;
				}

				//Debug("\nplayerz %d, tryz %d momz zeroed at %d, clearances %d and %d",
					//	ob->z,tryz,listrover->z-64 + (listrover->momentumz >> 16),dzt,dztp1);

			}

			continue;
		}
		
//		printf("Collide Check: %X\n", listrover->flags);

		CheckProximitySpecials(ob, listrover);

		ACTORSTOP = true;
		if (!ob->momentumz)
			return NO_MOVEMENT;

	}

	for (y=tileylow; y<=tileyhigh; y++)
		for (x=tilexlow; x<=tilexhigh; x++)
	{
		area = AREANUMBER(x,y);
		if (ValidAreanumber(area) && (areatried[area]==0))
		{
			areatried[area] = 1;
			goto actors;
		}
	}

	if (ACTORSTOP==true)
		return Z_MOVEMENT_ONLY;
	return OK_TO_CONTINUE;
}

movement_status CheckRegularWalls(objtype *ob,int tryx,int tryy,int tryz)
{
	int tilexlow,tilexhigh,tileylow,tileyhigh,x,y,radius;
	classtype ocl;
	boolean WALLSTOP,ISPLAYER=false;

	ocl = ob->obclass;
	tryz=tryz;

	if (ocl != playerobj)
	{
		radius = ACTORSIZE - 0x1000;
		//actrad = MINACTORDIST;
		//if ((ob->dir == nodir) && (ocl != b_robobossobj) &&
		//	(ocl != wallopobj) && (ocl != roboguardobj) && (ocl != diskobj)
		//  )
		// Error("ob called with nodir");
		if (ocl == boulderobj)
			radius += (ACTORSIZE/4);
		else if (ocl == b_darksnakeobj)
			radius -= 6000;
		else if (ocl == inertobj)
			radius -= 0x2000;
	}

	else
	{
		radius = PLAYERSIZE;
		ISPLAYER = true;
	}

	tilexlow = (int)((tryx-radius) >>TILESHIFT);
	tileylow = (int)((tryy-radius) >>TILESHIFT);

	tilexhigh = (int)((tryx+radius) >>TILESHIFT);
	tileyhigh = (int)((tryy+radius) >>TILESHIFT);

	tilexlow &= (MAPSIZE-1);	//BGB: Debug
	tileylow &= (MAPSIZE-1);
	tilexhigh &= (MAPSIZE-1);	//BGB: Debug
	tileyhigh &= (MAPSIZE-1);

	WALLSTOP = false;

	for (y=tileylow;y<=tileyhigh;y++)
		for (x=tilexlow;x<=tilexhigh;x++)
			{
			wall_t			*tempwall;
			int				wall;

			tempwall = (wall_t*)actorat[x][y];
			wall=tilemap[x][y];
			if (tempwall)
				{
				if (tempwall->which==WALL)// && IsWindow(x,y)==false)
					{
					if (ocl == boulderobj)
						{
#if (SHAREWARE == 0)
						NewState(ob,&s_bouldersink1);
#endif
						SD_PlaySoundRTP(SD_BOULDERHITSND,ob->x,ob->y);
						}
					else if (ISPLAYER && (!(ob->flags & FL_DYING)) &&
							(!(ob->flags & FL_AV)) &&
							(tempwall->flags & FL_W_DAMAGE))
						{
						DamageThing(ob,5);
						Collision(ob,(objtype*)tempwall,0,0);
						M_CheckPlayerKilled(ob);
						SD_PlaySoundRTP(SD_PLAYERBURNEDSND,ob->x,ob->y);
						}

					//return false;
					WALLSTOP = true;
					if ((ocl == inertobj) &&
						(ob->dirchoosetime == GIBVALUE) &&

						(((ob->tilex - x) == 0) != ((ob->tiley - y) == 0)) &&
						(ob->z > -28)

						)
						{
	//					SoftError ("Blood Dripping oldpolltime=%ld\n",oldpolltime);
						BloodDrip(ob,x,y);
						return NO_MOVEMENT;
						}

					if (!ob->momentumz)
						return NO_MOVEMENT;
					else// if (ocl != inertobj)
						return Z_MOVEMENT_ONLY;
					//else
					//goto doors;
					}

				else if (tempwall->which==PWALL)
						{
						pwallobj_t*pw;
						int dx,dy;

						pw=(pwallobj_t *)tempwall;
						dx = abs(pw->x - tryx);
						if (dx > PWALLRAD+0x5000)
							continue;

						dy = abs(pw->y - tryy);
						if (dy > PWALLRAD+0x5000)
							continue;

						return NO_MOVEMENT;
						}

				}
			}

	return OK_TO_CONTINUE;

	}

movement_status CheckStaticObjects(objtype *ob,int tryx,int tryy,int tryz)
{
	int dx,dy,dzt,dztp1,x,y;
	statobj_t*tempstat;
	int sprrad,oldsrad,sprtrad;
	boolean specialstat=false,widestat=false,zstoppable;
	int sprxlow,sprxhigh,sprylow,spryhigh;
	boolean SPRSTOP;
	classtype ocl;

//	return OK_TO_CONTINUE;		//BGB: Debug

	ocl = ob->obclass;

	if (ocl != playerobj)
		sprtrad = ACTORSIZE - 0x1000;
	else
		sprtrad = ACTORSIZE - 0x1000 + 0x10000;

	sprxlow = (int)((tryx-sprtrad) >>TILESHIFT);
	sprylow = (int)((tryy-sprtrad) >>TILESHIFT);

	sprxhigh = (int)((tryx+sprtrad) >>TILESHIFT);
	spryhigh = (int)((tryy+sprtrad) >>TILESHIFT);

	if (sprxlow < 0)
		sprxlow = 0;

	if (sprxhigh > (MAPSIZE-1))
		sprxhigh = MAPSIZE-1;

	if (sprylow < 0)
		sprylow = 0;

	if (spryhigh > (MAPSIZE-1))
		spryhigh = MAPSIZE-1;

	SPRSTOP = false;
	sprrad = 0x4500;
	zstoppable = (!(ob->flags & FL_DYING));
	oldsrad = sprrad;

	for (y=sprylow;y<=spryhigh;y++)
		for (x=sprxlow;x<=sprxhigh;x++)
	{
		tempstat = sprites[x][y];
		sprrad = oldsrad;

		if (tempstat)
		{
			specialstat = ((tempstat->itemnumber == stat_heatgrate) ||
								(tempstat->itemnumber == stat_pit)
							);

			widestat = (((tempstat->itemnumber >= stat_bcolumn) &&
							(tempstat->itemnumber <= stat_icolumn)) ||
							(tempstat->itemnumber == stat_disk)
						);

			if ((tempstat->flags & FL_BLOCK) || (specialstat==true))
			{
				if ((specialstat==true) && (ocl !=playerobj) &&
					(ob->state->think != T_Collide)
					)
					sprrad += 0x5000;

				if (widestat==true)
					sprrad += 0x3b00;

				if ((tempstat->itemnumber == stat_ironbarrel) ||
						(tempstat->itemnumber == stat_bonusbarrel))
					sprrad += 0x5000;

				dx = abs(tryx - tempstat->x);
				if (dx > sprrad)
					continue;
				dy = abs(tryy - tempstat->y);
				if (dy > sprrad)
					continue;

	#define MINSTATZDIFF 58

				dzt = abs(ob->z - tempstat->z);
				dztp1 = abs(tryz - tempstat->z);

				if (widestat && (dztp1 <= MINSTATZDIFF) && zstoppable &&
					(ocl != b_heinrichobj)
					)
					CheckStepping(ob,tempstat,MINSTATZDIFF);

				dztp1 = abs(tryz - tempstat->z);

#if (SHAREWARE == 0)
				if ((ocl == b_darksnakeobj) && (tempstat->itemnumber == stat_heatgrate))
					{
					if (ob->state->think == T_DarkSnakeChase)
						NewState(ob,&s_darkmonkredhead);
					else
						NewState(ob,&s_darkmonkredlink);
					ob->temp3 ++; // make shootable
					}
#endif

				if (specialstat==true)
					continue;

				if ((dztp1 >= MINSTATZDIFF) || (dzt >= MINSTATZDIFF))
					{if ((dzt >= MINSTATZDIFF) && (dztp1 <= MINSTATZDIFF) && zstoppable)
						{//ob->momentumz = 0;
						if (ob->z <= tempstat->z)
							{
							ob->z = tempstat->z - MINSTATZDIFF;
							ob->momentumz = 0;
							}
						else
							ob->momentumz = 2*GRAVITY; // ((2*GRAVITY + GRAVITY) >> 16) = 1
						}
					continue;
					}

				if (ocl == boulderobj)
					{if ((tempstat->itemnumber < stat_bcolumn) ||
						(tempstat->itemnumber > stat_icolumn)
						)
						{
						tempstat->flags |= FL_SHOOTABLE;
						DamageThing(tempstat,tempstat->hitpoints);
						continue;
						}
#if (SHAREWARE == 0)
					else
						NewState(ob,&s_bouldersink1);
#endif
					}
				//ob->momentumz=0;
				//return false;
				SPRSTOP=true;
				if (!ob->momentumz)
					return NO_MOVEMENT;
			}
		}
	}

	if (SPRSTOP == true)
		return Z_MOVEMENT_ONLY;
	return OK_TO_CONTINUE;
}

//============== Platform craziness ======================================

#define ClipHeight(ob,clipz)										\
{  ob->momentumz = 0;													\
																				\
	if (ISPLAYER && (ob->z != (clipz)) && (ob->temp2 == 0))	\
		{playertype *pstate;											\
		int dz = ob->z - (clipz);										\
																				\
		M_LINKSTATE(ob,pstate);										\
																				\
		pstate->heightoffset = pstate->oldheightoffset + dz; \
		ob->temp2 = (dz >= 0)?(STEPUP):(STEPDOWN);			\
		}																	\
																				\
	ob->z = (clipz);														\
}

//======================

#define CheckSpecialGibMovement(blocker)				\
	{																\
	int centerx = ((trytilex<<16) + 0x8000);			\
	int centery = ((trytiley<<16) + 0x8000);			\
																	\
	if (blocker->vertical==false)						\
		{															\
		int dyt = centery - ob->y;						\
		int dytp1 = centery - tryy;						\
																	\
		if ((abs(dytp1) > abs(dyt)) &&					\
			(SGN(dyt) == SGN(dytp1))						\
			)														\
			return OK_TO_CONTINUE;							\
																	\
		}															\
	else															\
		{															\
		int dxt = centerx - ob->x;						\
		int dxtp1 = centerx - tryx;						\
																	\
		if ((abs(dxtp1) > abs(dxt)) &&					\
			(SGN(dxt) == SGN(dxtp1))						\
			)														\
			return OK_TO_CONTINUE;							\
																	\
		}															\
	}

movement_status CheckMaskedWalls(objtype *ob,int tryx,int tryy,int tryz)
{
	int trytilex,trytiley;
	boolean MWALLSTOP;
	int ISPLAYER = (ob->obclass == playerobj);
	classtype ocl = ob->obclass;

	trytilex = (tryx >> TILESHIFT);
	trytiley = (tryy >> TILESHIFT);
	MWALLSTOP = false;
	//for (y=tileylow;y<=tileyhigh;y++)
	// for (x=tilexlow;x<=tilexhigh;x++)

	if (M_ISMWALL(trytilex,trytiley))
		{
		int wall = tilemap[trytilex][trytiley];
		maskedwallobj_t * mw;

		mw=maskobjlist[wall&0x3ff];

		if (ocl == inertobj)
			CheckSpecialGibMovement(mw);

		if (!(mw->flags&MW_BLOCKING))
			{
			if (mw->flags&MW_NONDOGBLOCKING)
				{
				if ((ocl==playerobj)&&(ob->flags&FL_DOGMODE))
					{
					if (ob->z < nominalheight)
						{
						MWALLSTOP = true;
						if (!ob->momentumz)
							return NO_MOVEMENT;
						}
					}
				else
					{
					MWALLSTOP = true;
					if (!ob->momentumz)
						return NO_MOVEMENT;
					}
				}

			else
				{
					if (mw->flags & MW_ABOVEPASSABLE)
						{if (mw->flags & MW_MIDDLEPASSABLE) // ==> not bottom
							{if (ob->z > LOWFALLCLIPZ+MAXSTEPHEIGHT)
								MWALLSTOP = true;
							else if (tryz >= LOWFALLCLIPZ)
								ClipHeight(ob,LOWFALLCLIPZ);
							}
						else if (mw->flags & MW_BOTTOMPASSABLE)
							{if ((ob->z > HIGHFALLCLIPZ+MAXSTEPHEIGHT) && (ob->z < LOWRISECLIPZ))
								MWALLSTOP = true;
							else if (ob->z <= HIGHFALLCLIPZ+MAXSTEPHEIGHT)
								{if (tryz >= HIGHFALLCLIPZ)
									ClipHeight(ob,HIGHFALLCLIPZ);
								}
							else if (tryz <= LOWRISECLIPZ)
								ob->momentumz = 0;

							}
						else // ==> above only
							{if (ob->z > HIGHFALLCLIPZ+MAXSTEPHEIGHT)
								MWALLSTOP = true;
							else if (tryz >= HIGHFALLCLIPZ)
								ClipHeight(ob,HIGHFALLCLIPZ);
							}

						}
					else if (mw->flags & MW_MIDDLEPASSABLE)
						{if (mw->flags & MW_BOTTOMPASSABLE) //==> not above passable
							{if (ob->z >= HIGHRISECLIPZ)
								{if (tryz <= HIGHRISECLIPZ)
									ob->momentumz = 0;
								}
							else if (tryz <= HIGHRISECLIPZ)
								MWALLSTOP = true;
							}

						else  //==> middle only
							{if (ob->z > LOWFALLCLIPZ+MAXSTEPHEIGHT)
								MWALLSTOP = true;
							else if (tryz >= LOWFALLCLIPZ)
								ClipHeight(ob,LOWFALLCLIPZ)
							else
								{if (ob->z >= HIGHRISECLIPZ)
								{if (tryz <= HIGHRISECLIPZ)
									ob->momentumz = 0;
								}
								else if (tryz <= HIGHRISECLIPZ)
									MWALLSTOP = true;
								}
							}

						}
					else // ==> bottompassable only
						{if (ob->z < LOWRISECLIPZ)
								MWALLSTOP = true;
						else if (tryz < LOWRISECLIPZ)
							ob->momentumz = 0;
						}

				}
			}
		else
			{
			if ( (mw->flags&MW_SHOOTABLE) &&
					(mw->flags&MW_BLOCKINGCHANGES) &&
					(ob->z >= nominalheight)

				)
				{
				int speed=FindDistance(ob->momentumx,ob->momentumy);
				if ((speed>0x2800) && (!(ob->flags & FL_DYING)))
					{
					if (ob->obclass == playerobj)
						{
						DamageThing(ob,10);
						Collision(ob,(objtype*)mw,0,0);
						}
					UpdateMaskedWall(wall&0x3ff);
					if (tryz < nominalheight)
						ob->momentumz = 0;
					}
				else
					{
					MWALLSTOP = true;
					if (!ob->momentumz)
						return NO_MOVEMENT;
					}
				}
			else
				{
				MWALLSTOP = true;
				if (!ob->momentumz)
					return NO_MOVEMENT;
				}
			}
		}

	if (MWALLSTOP == true)
		return Z_MOVEMENT_ONLY;
	return OK_TO_CONTINUE;
}

movement_status CheckDoors(objtype *ob,int tryx,int tryy,int tryz)
{
	int trytilex,trytiley;
	int ocl;

	trytilex = (tryx >> TILESHIFT);
	trytiley = (tryy >> TILESHIFT);
	
	trytilex &= MAPSIZE-1;
	trytiley &= MAPSIZE-1;
	
	ocl = ob->obclass;

	if (M_ISDOOR(trytilex,trytiley))
	{
		doorobj_t*tempdoor;
		int doorn;

		doorn = tilemap[trytilex][trytiley];

		tempdoor = doorobjlist[doorn&0x3ff];
		if (tempdoor->action == dr_open)
		{
			if (ob->z >= nominalheight)
			{
				if (tryz < nominalheight)
					ob->momentumz = 0;
				return OK_TO_CONTINUE;
			}
		}
		if (ocl == inertobj)
		{
			CheckSpecialGibMovement(tempdoor);
		}
		else if ((ocl == playerobj) || (ocl > b_darksnakeobj))
			return NO_MOVEMENT;
		else if (ob->state->think != T_Collide)
		{

#define DOOR_LOCKED(door)												\
			(((door->flags & DF_ELEVLOCKED) || (door->lock)) && \
				(ob->obclass != b_darianobj)							\
			)
#define GAS_DOOR(x,y) (MISCVARS->GASON && (MAPSPOT(x,y,1) == GASVALUE))

			if ((!DOOR_LOCKED(tempdoor)) &&
				(!GAS_DOOR(trytilex,trytiley))
				)
				//)
			{
				ob->door_to_open = doorn&0x3ff;
				LinkedOpenDoor(ob->door_to_open);
				if (tempdoor->eindex != -1)
					OperateElevatorDoor(doorn&0x3ff);
			}

			//if ((nstate = M_S(USE)) != NULL)
			//{ob->whatever = ob->state;
			//	NewState(ob,nstate);
			//	ob->flags |= FL_USE;
			// }
			return NO_MOVEMENT;
		}
		else
			return NO_MOVEMENT;
	}

	return OK_TO_CONTINUE;
}

boolean ActorTryMove(objtype*ob,int tryx, int tryy, int tryz)
{
	movement_status (*reduced_movement_check[3])(objtype*,int,int,int)=
						{
						CheckRegularWalls,
						CheckMaskedWalls,
						CheckDoors,
						};

	movement_status (*complete_movement_check[5])(objtype*,int,int,int)=
						{
						CheckOtherActors,
						CheckRegularWalls,
						CheckStaticObjects,
						CheckMaskedWalls,
						CheckDoors,
						};

	movement_status (**movement_function)(objtype*,int,int,int);
	movement_status movement_check_result;
	int				numcheckfunctions;
	int				i;
	boolean			xyblocked;

	if ((tryz < -30) && (sky==0) && (ob->obclass != inertobj))
		{
		ob->z = -28;
		ob->momentumz = 0;
		return false;
		}

	if ((!InMapBounds(tryx>>16,tryy>>16)) ||
		((ob->obclass != playerobj) && (IsWindow((tryx>>16),(tryy>>16))))
		)
		return false;

	switch(ob->obclass)
	{
	case inertobj:
	case bladeobj:
	case firejetobj:
		movement_function = &reduced_movement_check[0];
		numcheckfunctions = 3;
		break;

	default:
		movement_function = &complete_movement_check[0];
		numcheckfunctions = 5;
		break;
	}

	for(xyblocked=false,i=0;i<numcheckfunctions;i++)
	{
		movement_check_result = movement_function[i](ob,tryx,tryy,tryz);
		if (movement_check_result == Z_MOVEMENT_ONLY)
			xyblocked = true;

		else if (movement_check_result == NO_MOVEMENT)
			return false;
	}

	if (xyblocked == true)
		return false;

	return true;
}

void PushWallMove(int num)
{
	int				tcl;
	pwallobj_t		*pwall;
	int				dx,dy;
	int				actrad;
	objtype			*temp;
	boolean			pushem;
	int				tryx,tryy,areanumber,trytilex,trytiley;

	pwall=pwallobjlist[num];

	actrad = PWALLRAD + 0x5000;
	tryx = (pwall->x + pwall->momentumx);
	tryy = (pwall->y + pwall->momentumy);
	trytilex = (tryx >> 16);
	trytiley = (tryy >> 16);

	trytilex &= MAPSIZE-1;
	trytiley &= MAPSIZE-1;

	areanumber = AREANUMBER(trytilex,trytiley);

	for(temp=firstareaactor[areanumber];temp;temp=temp->nextinarea)
	{
		tcl = temp->obclass;

		if (temp->flags & FL_HEAD)  //ignore NME's head and wheels
			continue;

		if ((temp->flags & FL_DYING) || (!(temp->flags & FL_SHOOTABLE)))
			continue;

		if (tcl > b_darianobj)
			continue;

		dx = abs(tryx - temp->x);
		if (dx > actrad)
			continue;

		dy = abs(tryy - temp->y);
		if (dy > actrad)
			continue;

		if (pwall->flags&PW_DAMAGE)
			{if (!((tcl == playerobj) && (temp->flags & FL_AV)))
				DamageThing(temp,5);

			Collision(temp,(objtype*)pwall,0,0);
			M_CheckPlayerKilled(temp);
			if (temp->flags & FL_DYING)
				return;

			}

		pushem=false;
		switch (pwall->dir)
		{

#define PWALLTOL (0xc000)

			case north:
				if ((temp->y<pwall->y) && (dx<PWALLTOL))
					pushem=true;
				break;
			case east:
				if ((temp->x>pwall->x) && (dy<PWALLTOL))
					pushem=true;
				break;
			case northeast:
				if ((temp->y<pwall->y) && (dx<PWALLTOL))
					pushem=true;
				else if ((temp->x>pwall->x) && (dy<PWALLTOL))
					pushem=true;
				break;
			case northwest:
				if ((temp->y<pwall->y) && (dx<PWALLTOL))
					pushem=true;
				else if ((temp->x<pwall->x) && (dy<PWALLTOL))
					pushem=true;
				break;
			case south:
				if ((temp->y>pwall->y) && (dx<PWALLTOL))
					pushem=true;
				break;
			case west:
				if ((temp->x<pwall->x) && (dy<PWALLTOL))
					pushem=true;
				break;
			case southeast:
				if ((temp->y>pwall->y) && (dx<PWALLTOL))
					pushem=true;
				else if ((temp->x>pwall->x) && (dy<PWALLTOL))
					pushem=true;
				break;
			case southwest:
				if ((temp->y>pwall->y) && (dx<PWALLTOL))
					pushem=true;
				else if ((temp->x<pwall->x) && (dy<PWALLTOL))
					pushem=true;
				break;
			default:
				//Error ("Pushwall #%d has an illegal direction %d \n",num,pwall->dir);
				break;
		}

		//if (!pushem)
			//continue;

		//temp->momentumx = temp->momentumy = 0;
		if (temp->obclass==playerobj)
				temp->flags|=FL_PUSHED;

		if (!pushem)
		{
			Collision(temp,(objtype*)pwall,-temp->momentumx,-temp->momentumy);
			continue;
		}

		if ((temp->obclass >= lowguardobj) && (temp->obclass < roboguardobj))
		{
			temp->momentumx = temp->momentumy = temp->momentumz = 0;
			temp->hitpoints = 0;

			if (gamestate.violence >= vl_high)
				temp->flags |= FL_HBM;

			Collision(temp,(objtype*)pwall,0,0);
			/*
					if (gamestate.violence < vl_high)
						{if ((tstate = UPDATE_STATES[CRUSH][temp->obclass - lowguardobj])!=NULL)
							NewState(temp,tstate);

						else
							Error("\n\Null low-violence crush state in push wall crush, instance of %s",debugstr[temp->obclass]);
						}
					else
						{temp->shapeoffset = 0;
						//tactor->flags|=FL_HBM;
						NewState(temp,&s_guts1);
						//KillActor(temp);
						}*/

			SD_PlaySoundRTP(SD_ACTORSQUISHSND,temp->x,temp->y);
		}
		else
		{
			if (!ActorTryMove(
				temp,temp->x + temp->momentumx,
				temp->y + temp->momentumy,
				temp->z + (temp->momentumz >> 16))	)
			{
				DamageThing(temp,30);
				if ((temp->obclass==playerobj) && (temp->hitpoints <= 0))
					temp->target = (objtype *)pwall;
			}

			Collision(temp,(objtype*)pwall,pwall->momentumx-temp->momentumx,pwall->momentumy-temp->momentumy);
			M_CheckPlayerKilled(temp);
		}
	}
}

void ActorMovement (objtype *ob)
{
	int tryx,tryy,tryz,limitok,max,friction,ocl;

	if ((ob->obclass == strikeguardobj) &&
		(!(ob->flags & FL_DYING)) &&
		(gamestate.difficulty > gd_easy)	)
	{
		AvoidPlayerMissile(ob);
		ob->flags &= ~FL_FULLLIGHT;
	}

	if ((!ob->momentumx) && (!ob->momentumy) && (!ob->momentumz))
	{
		if (ob->flags & FL_RIDING)
			goto ride;
		else
			return;
	}

	limitok = 1;

	friction = ACTORFRICTION;
	if (!(ob->flags & FL_DYING))
		friction >>= 1;
	ocl = ob->obclass;

	if (ocl == playerobj)
	{
		playertype *pstate;

		M_LINKSTATE(ob,pstate);
		max = pstate->topspeed;
		friction = PLAYERFRICTION;
		if ((ob->temp2 == PITFALL) || (ob->temp2 == PITRISE))
			friction >>= 4;
	}
	else
//	if (/*(ob->state->think != T_Collide) &&*/ (ocl != b_robobossobj) &&
	if ((ocl != b_robobossobj) &&
		(ocl != boulderobj) &&
		(ocl != b_darkmonkobj) &&
		(ocl != b_darksnakeobj) &&
		(ocl != inertobj) &&
		(ocl != collectorobj))
	{
		max = MAXMOVE;
	}
	else
	{
		limitok = 0;
	}

	if (limitok)
	{
		if (ocl == playerobj)
		{
			int dist,scale;

			dist = FindDistance(ob->momentumx,ob->momentumy);
			if (dist > max)
			{
				scale = FixedDiv2(max,dist);
				ob->momentumx = FixedMul(ob->momentumx,scale);
				ob->momentumy = FixedMul(ob->momentumy,scale);
			}
		}
		else
		{
			if (ob->momentumx > max)
				ob->momentumx = max;
			else if (ob->momentumx < -max)
				ob->momentumx = -max;
			if (ob->momentumy > max)
				ob->momentumy = max;
			else if (ob->momentumy < -max)
				ob->momentumy = -max;
		}
	}

	tryx = ob->x + ob->momentumx;
	tryy = ob->y + ob->momentumy;
	tryz = ob->z + (ob->momentumz >> 16);

	if (ocl != playerobj)
		ob->flags &= ~FL_STUCK;

	if (!ActorTryMove (ob, tryx, tryy, tryz))
	{
		if (ocl == playerobj)
		{
			if (!(ob->flags & FL_ELASTO))
				PlayerSlideMove (ob);
			else
			{
				if (ActorTryMove(ob,tryx, ob->y-ob->momentumy,tryz))
					ob->momentumy = -(ob->momentumy);
				else if (ActorTryMove(ob,ob->x-ob->momentumx,tryy,tryz))
					ob->momentumx = -(ob->momentumx);
				else
					ZEROMOM;
			}
		}
		else
		{
			ZEROMOM;
			ob->flags |= FL_STUCK;
			return;
		}
	}

	MoveActor(ob);

	ride:

	if (ob->flags & FL_RIDING)
	{
		objtype *ride = (objtype*)(ob->whatever);

		ob->z += (ride->momentumz >> 16);

		if ((ride->momentumx || ride->momentumy) &&
			ActorTryMove(ob,ob->x+ride->momentumx,ob->y+ride->momentumy,tryz)
			)
			SetFinePosition(ob,ob->x+ride->momentumx,ob->y+ride->momentumy);
	}

#define SLIDER(ob)  ((ob->flags & FL_NOFRICTION) && \
	(ob->state->think != T_Collide))
#define AIRBORNE(ob) ((ob->obclass != playerobj) && \
	(ob->z != nominalheight) && \
							(!IsPlatform(ob->tilex,ob->tiley)) && \
							(DiskAt(ob->tilex,ob->tiley) == NULL) \
							)

	if (SLIDER(ob) || AIRBORNE(ob))
		return;

	if ( (abs(ob->momentumx) < STOPSPEED) &&
		(abs(ob->momentumy) < STOPSPEED)
	)
	{
		ZEROMOM;
	}

	else if ((ob->flags & FL_DYING) && (ob->state == ob->state->next))
	{
		ob->momentumx = FixedMul (ob->momentumx, DEADFRICTION);
		ob->momentumy = FixedMul (ob->momentumy, DEADFRICTION);
	}
	else
	{
		ob->momentumx = FixedMul (ob->momentumx, friction);
		ob->momentumy = FixedMul (ob->momentumy, friction);
	}
}

void T_Guts(objtype*ob)
{
	if (ob->ticcount)
		return;
	SpawnParticles(ob, GUTS, 50);
}

void T_Special(objtype*ob)
{
	if (ob->ticcount)
		return;

#if (SHAREWARE == 0)
	if (ob->state == &s_NMEheadexplosion)
	{
		ob->z -= 42;
		SetGibSpeed(0x4000);
		SpawnParticles(ob,gt_sparks,100);
		ResetGibSpeed();
		SD_PlaySoundRTP(SD_EXPLODESND,ob->x,ob->y);
		return;
	}
#endif

	if (ob->obclass != b_robobossobj)
		return;

	NewState(ob,&s_bossdeath);
}

void SpawnBoulder(int tilex,int tiley,int dir)
{
#if (SHAREWARE == 1)
	tilex = tilex;
	tiley = tiley;
	dir = dir;
	Error("Boulders aren't allowed in shareware!");
#endif
#if (SHAREWARE == 0)
	SpawnNewObj(tilex,tiley,&s_boulderspawn,inertobj);
	new->z = 0;
	PreCacheActor(boulderobj,0);
	new->dir = 2*dir;
#endif

}

#define InitSprayPart(newflags)														\
	{																							\
	new->hitpoints = starthitpoints[gamestate.difficulty][b_robobossobj]; \
	new->dir = dir*4;																	\
	new->speed = 7*SPDPATROL;															\
	new->door_to_open = -1;															\
	new->flags |= (newflags);															\
	}																							\

void SpawnMultiSpriteActor(classtype actorclass, int tilex,int tiley,int dir)
{

#if (SHAREWARE==1)

		actorclass = actorclass;
		tilex = tilex;
		tiley = tiley;
		dir  = dir;
		Error("\nSPRAY not allowed in shareware !");

#else

	{
	objtype *temp;

	gamestate.killtotal++;

	SpawnNewObj(tilex,tiley,&s_NMEstand,actorclass);
	InitSprayPart(FL_BLOCK|FL_NOFRICTION|FL_SHOOTABLE);

	new->temp1 = -1; // temp1 used as one-event queue for directions when chasing
						// -1 when isn't waiting to try new dir, dirnumber when waiting
	temp = new;

	SpawnNewObj(tilex,tiley,&s_NMEhead1,actorclass);
	InitSprayPart(FL_NOFRICTION|FL_SHOOTABLE|FL_HEAD|FL_NEVERMARK);

	//new->whatever = temp;  // head points to body

	temp->whatever = new;  // body points to head

	SpawnNewObj(tilex,tiley,&s_NMEwheels2,actorclass);
	InitSprayPart(FL_NOFRICTION|FL_SHOOTABLE|FL_HEAD|FL_NEVERMARK);

	//new->whatever = temp;  // head points to body
	temp->target = new;	// body also points to wheels
	actorat[tilex][tiley] = NULL;
	PreCacheActor(b_robobossobj,0);
	}
#endif
}

void SpawnSnake(int tilex,int tiley)
{
#if (SHAREWARE == 1)
	tilex = tilex;
	tiley = tiley;
	Error("snake not allowed in shareware!");
#else

	GetNewActor();
	MakeActive(new);
	new->flags |= (FL_DONE|FL_ABP|FL_NEVERMARK);
	SetTilePosition(new,tilex,tiley);
	SetVisiblePosition(new,new->x,new->y);
	new->obclass = b_darkmonkobj;
	new->which = ACTOR;
	new->z = nominalheight;
	if (SNAKELEVEL == 2)
	NewState(new,&s_darkmonkfastspawn);
	else
	NewState(new,&s_darkmonkhspawn);
#endif

}

void SpawnGunThingy(classtype which, int tilex, int tiley, int dir)
{
#if (SHAREWARE == 1)
	which = which;
	tilex = tilex;
	tiley = tiley;
	dir  = dir;

	Error("no emplacements allowed in shareware!");
#else
	SpawnNewObj(tilex,tiley,&s_gunstand,which);

	if (!loadedgame)
		gamestate.killtotal++;

	PreCacheActor(patrolgunobj,0);

	new->hitpoints = starthitpoints[gamestate.difficulty][which];
	new->dir = dir*2;
//  new->speed = 0x500;
//  ParseMomentum(new,dirangle8[new->dir]);
	new->flags |= (FL_BLOCK|FL_SHOOTABLE);
#endif
}

void SpawnFourWayGun(int tilex, int tiley)
{
#if (SHAREWARE == 1)
	tilex = tilex;
	tiley = tiley;
	Error("no 4-way emplacements allowed in shareware!");
#else

	SpawnNewObj(tilex,tiley,&s_4waygun,patrolgunobj);
	if (!loadedgame)
	gamestate.killtotal++;

	PreCacheActor(patrolgunobj,0);
	new->temp1 = -1;
	new->hitpoints = starthitpoints[gamestate.difficulty][patrolgunobj]*3;
	new->flags |= (FL_BLOCK|FL_SHOOTABLE);
#endif
}

/*
=======================================================================
=
=								NON-SHAREWARE CODE
=
=======================================================================
*/

#if (SHAREWARE == 0)

void T_BoulderSpawn(objtype*ob)
{
	objtype *tactor;
	int dx,dy,cl;

	if (!(ob->flags & FL_ACTIVE))
		return;

	else if (!ob->ticcount)
	{
		for(	tactor = firstareaactor[ob->areanumber];
				tactor;
				tactor = tactor->nextinarea)
		{
			cl = tactor->obclass;

			if (tactor == ob)
				continue;

			if (!(tactor->flags & FL_SHOOTABLE))
				continue;
			dx = abs(tactor->x - ob->x);
			if (dx > MINACTORDIST)
				continue;
			dy = abs(tactor->y - ob->y);
			if (dy > MINACTORDIST)
				continue;
			if ((cl == b_heinrichobj) || (cl== b_darkmonkobj) ||
					(cl == b_darianobj) || (cl == b_robobossobj) ||
					(cl == pillarobj) || (cl == wallopobj) ||
					(cl == boulderobj))
				return;
			else
				break;
		}

		SpawnNewObj(ob->tilex,ob->tiley,&s_boulderdrop1,boulderobj);
		new->z = 0;
		new->dir = ob->dir;
		//new->angle = dirangle8[new->dir];
		new->speed = 0x4000;
		ParseMomentum(new,dirangle8[new->dir]);
		new->flags |= (FL_BLOCK|FL_NOFRICTION);
		new->flags &= ~FL_SHOOTABLE;
		new->whatever = ob;
		if (tactor)
		new->target = tactor;
		MakeActive(new);
		new->flags |= FL_ABP;
	}

}

void T_BoulderDrop(objtype*ob)
{
	int dx,dy,dz;
	objtype * tactor;
	statetype *tstate;

	if (ob->state == &s_boulderdrop12)
	{
		if (ob->z == nominalheight)
			NewState(ob,&s_boulderroll1);
		else if (ob->momentumz)
		{
			ob->z += (ob->momentumz>>16);
			ob->momentumz += (GRAVITY<<1);
			if (ob->z > nominalheight)
			{
				ob->z = nominalheight;
				ob->momentumz = 0;
				//ob->flags &= ~FL_NOFRICTION;
			}
		}
		else if (!ob->temp1)
		{
			ob->momentumz = (GRAVITY<<6);
			ob->temp1  = 1;
		}

	}

	if (ob->ticcount)
		return;
	if (ob->state->condition & SF_SOUND)
		SD_PlaySoundRTP(SD_BOULDERFALLSND,ob->x,ob->y);

	tactor = (objtype*)(ob->target);

	if (tactor && (!(tactor->flags & FL_DYING)))
	{
		dx = tactor->x - ob->x;
		dy = tactor->y - ob->y;
		dz = tactor->z - ob->z;
		if ((abs(dx) < MINACTORDIST) && (abs(dy) < MINACTORDIST) &&
			(abs(dz) < 50))
		{
			if (tactor->obclass != playerobj)
			{
				tactor->momentumx = tactor->momentumy = tactor->momentumz = 0;
				tactor->flags |= FL_DYING;
				tactor->hitpoints = 0;
				if (gamestate.violence < vl_high)
				{
					if ((tstate = UPDATE_STATES[CRUSH]
							[tactor->obclass - lowguardobj])!=NULL)
						NewState(tactor,tstate);

					//else
					//Error("\n\Null low-violence crush state in boulder drop, instance of %s",debugstr[tactor->obclass]);
				}
				else
				{
					tactor->shapeoffset = 0;
					//tactor->flags|=FL_HBM;
					NewState(tactor,&s_guts1);
				}
			}
			else
			{
				DamageThing(tactor,200);
				Collision(tactor,ob,0,0);
				M_CheckPlayerKilled(tactor);
			}
			SD_PlaySoundRTP(SD_ACTORSQUISHSND,tactor->x,tactor->y);
			ob->target = NULL;
		}
	}
}

void CheckCrush(objtype*ob)
{
	objtype *temp;
	int dx,dy,dz;

	for(	temp = PLAYER[0];
			temp != PLAYER[numplayers-1]->next;
			temp=temp->next)
	{
		if (ob->flags & FL_DYING)
			continue;

		dx = abs(temp->x - ob->x);
		if (dx > MINACTORDIST)
			continue;

		dy = abs(temp->y - ob->y);
		if (dy > MINACTORDIST)
			continue;

		dz = abs(temp->z - ob->z);
		if (dz > (MINACTORDIST>>10))
			continue;

		if (!ob->ticcount)
			DamageThing(temp,EnvironmentDamage(ob));

		Collision(temp,ob,
			ob->momentumx-temp->momentumx,
			ob->momentumy-temp->momentumy);

		M_CheckPlayerKilled(temp);
	}
}

void T_BoulderMove(objtype*ob)
{
	if (MAPSPOT(ob->tilex, ob->tiley, 1) == 395)
	{
		NewState(ob,&s_bouldersink1);
		return;
	}
	if (NOMOM)
		ParseMomentum(ob,dirangle8[ob->dir]);
	if ((!ob->ticcount) && (ob->state->condition & SF_SOUND) &&
		areabyplayer[ob->areanumber])
			SD_PlaySoundRTP(BAS[ob->obclass].operate,ob->x,ob->y);

	SelectPathDir(ob);
}

/*
=========================================================================
=
=									Boss Functions
=
=========================================================================
*/

//***************************** Esau ************************************

// static
enum {
	ESAU_USING_HOLES=1,
	ESAU_LEAVING_CONTROL_ROOM,
	ESAU_USING_TOUCH_PEDASTALS,
	ESAU_CHASING_PLAYER
};

void T_EsauWait(objtype*ob)
{
	int dist;

	dist = FindDistance(ob->tilex-PLAYER[0]->tilex,ob->tiley-PLAYER[0]->tiley);
	MISCVARS->ESAU_SHOOTING = false;

	if (ob->dirchoosetime)
		ob->dirchoosetime --;

	if ((dist>81) || (dist<36))
	{
		if (CheckLine(ob,PLAYER[0],MISSILE))
		{
			NewState(ob,&s_darianshoot1);
			ob->momentumx = ob->momentumy = 0;
		}
		return;
	}
	else if ((!ob->dirchoosetime) && (CheckLine(ob,PLAYER[0],SHOOT)))
	{
		NewState(ob,&s_dariandefend1);
		ob->dirchoosetime = (GameRandomNumber("T_EsauWait",0) % 35) + 17;//35;
		return;
	}
}

void T_EsauRise(objtype*ob)
{
	int newarea,oldarea;

	// if (gamestate.victoryflag)
	// return;

	if (!ob->ticcount)
	{
		//Debug("\n tx before: %d, ty before: %d",
		//			ob->targettilex,ob->targettiley);

		SelectTouchDir(ob);
		if (ob->targettilex || ob->targettiley)
		{
			//Debug("\n ob->tilex: %d, ob->tiley: %d, targettilex: %d, targettiley: %d",
				//			ob->tilex, ob->tiley, ob->targettilex, ob->targettiley);

			SetTilePosition(ob,ob->targettilex,ob->targettiley);
			SetVisiblePosition(ob,ob->x,ob->y);
			oldarea = ob->areanumber;
			newarea = AREANUMBER(ob->tilex,ob->tiley);
			if (oldarea != newarea)
			{
				RemoveFromArea(ob);
				ob->areanumber = newarea;
				MakeLastInArea(ob);
			}
		}
		else
			MISCVARS->EPOP[ob->temp3].x = MISCVARS->EPOP[ob->temp3].y = 0;

		ob->dirchoosetime= (GameRandomNumber("T_EsauRise",0) % 35) + 17;
		MISCVARS->ESAU_HIDING = false;
		MISCVARS->ESAU_SHOOTING = true;
		ob->flags |= FL_SHOOTABLE;
	}
}

void T_EsauChase(objtype*ob)
	{
	int dx,dy,chance,dist;
	statetype *temp;

	if ((ob->tilex == ob->targettilex) && (ob->tiley == ob->targettiley))
		{
		if (MISCVARS->DSTATE == ESAU_USING_HOLES)
			{
			MISCVARS->ESAU_HIDING = true;
			MISCVARS->ESAU_SHOOTING = false;
			SD_PlaySoundRTP(SD_DARIANHIDESND,ob->x,ob->y);
			NewState(ob,&s_dariansink1);
			ob->flags &= ~FL_SHOOTABLE;
			return;
			}
		else if (MISCVARS->DSTATE == ESAU_LEAVING_CONTROL_ROOM)
			{
			if (!MISCVARS->doorcount)
				{
				SetTilePosition(ob,ob->tilex,ob->tiley);
				SetVisiblePosition(ob,ob->x,ob->y);
				}
			MISCVARS->doorcount ++;
			if (MISCVARS->doorcount == 4)
				MISCVARS->DSTATE = ESAU_USING_HOLES;
			else // hack to FORCE esau to walk through door
				{
				switch (ob->temp1)
					{
					case east:
						ob->targettilex ++;
						break;
					case west:
						ob->targettilex --;
						break;
					case north:
						ob->targettiley --;
						break;
					case south:
						ob->targettiley ++;
						break;
					}
				}
			SelectTouchDir(ob);
			return;
			}
		}

	if (touchsprite && (touchsprite->itemnumber == stats[stat_dariantouch].type))
		{
		dx = touchsprite->x - ob->x;
		dy = touchsprite->y - ob->y;

		if (((dx > -0x5000) && (dx < 0x5000)) &&
			((dy > -0x5000) && (dy < 0x5000)))
			{
			SD_PlaySoundRTP(SD_DARIANGONNAUSESND,ob->x,ob->y);
			NewState(ob,&s_darianuse1);
			return;
			}
		}

	if (ob->dirchoosetime)
		ob->dirchoosetime --;

	if (NOMOM || (!ob->dirchoosetime))
		{
		SelectTouchDir(ob);
		ob->dirchoosetime = M_CHOOSETIME(ob);
		}
	else
		ActorMovement(ob);

	if (!ob->ticcount)
		{
		if (CheckLine(ob,PLAYER[0],MISSILE))	// got a shot at player?
			{
			if (Near(ob,PLAYER[0],1))
				chance = 300;
			else
				{
				dx = abs(PLAYER[0]->tilex-ob->tilex);
				dy = abs(PLAYER[0]->tiley-ob->tiley);
				dist = (dx>dy)?dx:dy;
				chance = 400/dist;
				}
			if (GameRandomNumber("T_EsauChase",0) <chance)
				{
				if ((temp=M_S(AIM)) != NULL)
					{
					NewState(ob,temp);
					ob->dirchoosetime = 0;
					ob->momentumx = ob->momentumy = 0;
					SetVisiblePosition(ob,ob->x,ob->y);
					return;
					}
				}
			if (MISCVARS->ESAU_SHOOTING)
				{
				SetVisiblePosition(ob,ob->x,ob->y);
				return;
				}
			}
		}
	}

void T_EsauSpears(objtype*ob)
{
	if (ob->ticcount == (ob->state->tictime>>1)-1)
	{
		OLDTILEX = PLAYER[0]->tilex;
		OLDTILEY = PLAYER[0]->tiley;
	}

	else if (!ob->ticcount)
	{
		SpawnNewObj(OLDTILEX,OLDTILEY,&s_speardown1,spearobj);
		new->flags |= FL_ABP;
		MakeActive(new);
	}
}

void FindDoor(objtype*ob)
{
	int i,area1,area2,min,curr,
		dest1x,dest1y,dest2x,dest2y,
		d1,d2;

	dirtype tdir1,tdir2;
	doorobj_t*dr;

	min = 0x7fffffff;
	for(i=0;i<doornum;i++)
	{
		dr = doorobjlist[i];
		if (dr->vertical)
		{
			area1 = MAPSPOT(dr->tilex-1,dr->tiley,0)-AREATILE;
			dest1x = dr->tilex-1;
			dest1y = dr->tiley;
			tdir1 = east;
			area2 = MAPSPOT(dr->tilex+1,dr->tiley,0)-AREATILE;
			dest2x = dr->tilex+1;
			dest2y = dr->tiley;
			tdir2 = west;
		}
		else
		{
			area1 = MAPSPOT(dr->tilex,dr->tiley-1,0)-AREATILE;
			dest1x = dr->tilex;
			dest1y = dr->tiley-1;
			tdir1 = south;
			area2 = MAPSPOT(dr->tilex,dr->tiley+1,0)-AREATILE;
			dest2x = dr->tilex;
			dest2y = dr->tiley+1;
			tdir2 = north;
		}

//============================================================
#define CheckMinDist(destx,desty,dir)						\
	{																	\
		curr = FindDistance(destx-ob->tilex,desty-ob->tiley); \
		if (curr < min)													\
		{																\
			min = curr;													\
			ob->targettilex = destx;									\
			ob->targettiley = desty;									\
			ob->temp1 = dir;											\
		}																\
	}
//============================================================

		if (area1 == ob->areanumber)
		{
			if (area1 == area2)
			{
				d1 = FindDistance(dest1x-ob->tilex,dest1y-ob->tiley);
				d2 = FindDistance(dest2x-ob->tilex,dest2y-ob->tiley);
				if (d2 < d1) //swap areas
				{
					CheckMinDist(dest2x,dest2y,tdir2);
					continue;
				}
			}
			CheckMinDist(dest1x,dest1y,tdir1);
		}
		else if (area2 == ob->areanumber)
			CheckMinDist(dest2x,dest2y,tdir2);
	}
}

int FindTouch(objtype *ob)
{
	int i,curr,min,tx,ty,noneleft;
	statobj_t* tempstat;

	min = 0x7fffffff;
	noneleft = 1;
	for(i=0;i<MISCVARS->nexttouch;i++)
	{
		if (MISCVARS->ETOUCH[i].x || MISCVARS->ETOUCH[i].y)
		{
			noneleft = 0;
			tx = MISCVARS->ETOUCH[i].x;
			ty = MISCVARS->ETOUCH[i].y;
			tempstat = sprites[tx][ty];
			curr = FindDistance(tx-ob->tilex,ty-ob->tiley);

			if (curr < min)
			{
				min = curr;
				ob->targettilex = tx;
				ob->targettiley = ty;
				touchsprite = tempstat;
			}
		}
	}
	return (!noneleft);
}

typedef enum
{
	down_in_a_hole=-1,
	no_holes_available=0,
	holes_unreachable=1,
	hole_targetted=2
}hiding_status;

hiding_status HoleStatus(objtype*ob)
{
	int i,tx,ty,dist,noneleft,invisible,curr,min;
	tpoint dummy,*dptr = &dummy;
	objtype *tactor;
	_2Dpoint *tdptr;

	min = 0x7fffffff;
	noneleft = 1;

	for(i=0;i<MISCVARS->nextpop;i++)
		{
		tdptr = &(MISCVARS->EPOP[i]);

		if (tdptr->x || tdptr->y)
			{
			tactor = (objtype*)actorat[tdptr->x][tdptr->y];
			if (tactor && (tactor->obclass == pillarobj))
				{
				tdptr->x = 0;
				tdptr->y = 0;
				MISCVARS->popsleft --;
				}
			}
		}

	if (MISCVARS->popsleft > 1)
		{
		for(i=0;i<MISCVARS->nextpop;i++)
			{
			tdptr = &(MISCVARS->EPOP[i]);

			if (tdptr->x || tdptr->y)
				{
				tx = tdptr->x;
				ty = tdptr->y;

				if ((PLAYER[0]->tilex == tx) || (PLAYER[0]->tiley == ty))
					continue;

				if (MISCVARS->ESAU_HIDING)
					{
					dist = FindDistance(PLAYER[0]->tilex-tx,PLAYER[0]->tiley-ty);
					if ((ob->tilex == tx) && (ob->tiley == ty) && (MISCVARS->popsleft != 1))
						continue;
					noneleft = 0;
					if ((MAPSPOT(tx,ty,0)-AREATILE) == ob->areanumber)
						{
						ob->targettilex = tx;
						ob->targettiley = ty;
						ob->temp3 = i;
						if ((dist < 81) && (dist > 36))
							return down_in_a_hole;
						}
					}

				else if (!MISCVARS->ESAU_SHOOTING)
					{
					curr = FindDistance(tx-ob->tilex,ty-ob->tiley);
					if (curr < min)
						{
						min = curr;
						noneleft = 0;
						dptr->which = ACTOR;
						SetTilePosition(dptr,tx,ty);
						//dptr->x = (tx << TILESHIFT) + TILEGLOBAL/2;
						//dptr->y = (ty << TILESHIFT) + TILEGLOBAL/2;
						dptr->z = ob->z;
						invisible = 0;
						if ((!CheckLine(ob,dptr,SHOOT)) && (MISCVARS->DSTATE != ESAU_USING_HOLES))
							{
							invisible = 1;
							MISCVARS->DSTATE = ESAU_LEAVING_CONTROL_ROOM;
							}
						else
							MISCVARS->DSTATE = ESAU_USING_HOLES;
						ob->targettilex = tx;
						ob->targettiley = ty;
						}
					}
				}
			}
		}

	if (MISCVARS->ESAU_HIDING)
		return down_in_a_hole;

	if (noneleft)
	{
		MISCVARS->DSTATE = ESAU_CHASING_PLAYER;
		return  no_holes_available;
	}

	if (invisible) //leave present room
		return holes_unreachable;

	return hole_targetted;
}

void SelectTouchDir (objtype *ob)
	{
	int dx,dy,noneleft,invisible;
	hiding_status hole;

	dirtype d[3];
	dirtype tdir, olddir, turnaround;

	olddir=ob->dir;
	turnaround= opposite[olddir];

	invisible = 0;
	noneleft = 1;

	if (!MISCVARS->notouch)
		{
		if (!FindTouch(ob))
			MISCVARS->notouch = 1;
		else
			MISCVARS->DSTATE = ESAU_USING_TOUCH_PEDASTALS;
		}

	else if ((!MISCVARS->noholes) && (MISCVARS->DSTATE != ESAU_LEAVING_CONTROL_ROOM))
		{
		hole = HoleStatus(ob);

		switch(hole)
			{
			case down_in_a_hole:
				return;

			case no_holes_available:
				MISCVARS->noholes = 1;
				break;

			case holes_unreachable:
				FindDoor(ob);
				break;

			}
		}

	else if (MISCVARS->DSTATE == ESAU_CHASING_PLAYER)

	// only gets here if all gimmicks (touch tables,
						// holes) are inoperative
		{
		ob->flags |= FL_SHOOTABLE;
		ob->targettilex = PLAYER[0]->tilex;
		ob->targettiley = PLAYER[0]->tiley;
		}
	/*
	if (DSTATE == SDOOR)
	{dx = ((ob->targettilex<<16)+TILEGLOBAL/2) - ob->x;
		dy = ob->y - ((ob->targettiley<<16)+TILEGLOBAL/2);
		angle = atan2_appx(dx,dy);
		ZEROMOM;
		ParseMomentum(ob,angle);
		ActorMovement(ob);
		if (ob->momentumx || ob->momentumy)
		{ob->angle = angle;
		ob->dir = angletodir[ob->angle];
		return;
		}
	}
	else */
	dx = ob->targettilex - ob->tilex;
	dy = ob->tiley - ob->targettiley;

	d[1]=nodir;
	d[2]=nodir;

	if (dx>0)
		d[1]= east;
	else if (dx<0)
		d[1]= west;
	if (dy>0)
		d[2]=north;
	else if (dy<0)
		d[2]=south;

	if (GameRandomNumber("SelectTouchDir",0)<128)
	{
		tdir=d[1];
		d[1]=d[2];
		d[2]=tdir;
	}

	ZEROMOM;

	if (d[1]!=nodir)
		M_CHECKDIR(ob,d[1]);

	if (d[2]!=nodir)
		M_CHECKDIR(ob,d[2]);

	if (GameRandomNumber("SelectTouchDir",ob->obclass)>128)	//randomly determine direction of search
	{
		for (tdir=north;tdir<=west;tdir++)
		{
			if (tdir!=turnaround)
				M_CHECKDIR(ob,tdir);
		}
	}
	else
	{
		for (tdir=west;tdir>=north;tdir--)
		{
			if (tdir!=turnaround)
				M_CHECKDIR(ob,tdir);
		}
	}

	if (turnaround !=  nodir)
		M_CHECKDIR(ob,turnaround);

	if (olddir!=nodir)
		M_CHECKDIR(ob,olddir);
}

//************** Krist ****************************************************

void CheckRunover(objtype*ob)
{
	int dx,dy,dz;

	dx = abs(PLAYER[0]->x - ob->x);
	if (dx > MINACTORDIST)
		return;

	dy = abs(PLAYER[0]->y - ob->y);
	if (dy > MINACTORDIST)
		return;

	dz = abs(PLAYER[0]->z - ob->z);
	if (dz > 10)
		return;

	locplayerstate->heightoffset = 18 + locplayerstate->playerheight;
	locplayerstate->oldheightoffset = locplayerstate->heightoffset;
	PLAYER[0]->temp2 = RENORMALIZE;
	DamageThing(PLAYER[0],30);
	Collision(PLAYER[0],ob,0,0);
	M_CheckPlayerKilled(PLAYER[0]);
}

void T_HeinrichChase(objtype*ob)
{
	int	dx,dy,dist,chance,perpangle;
// statetype *temp;
	boolean doorok;

	CheckRunover(ob);

	//	ob->flags &= ~FL_DODGE;
	if (CheckLine(ob,PLAYER[0],SIGHT))
	{
		ob->targettilex = PLAYER[0]->x;
		ob->targettiley = PLAYER[0]->y;
	}

	if (!ob->ticcount)
	{
	//	if (gamestate.victoryflag)
	//		return;

		if (CheckLine(ob,PLAYER[0],SHOOT))	// got a shot at PLAYER[0]?
		{
			dx = abs(ob->tilex - PLAYER[0]->tilex);
			dy = abs(ob->tiley - PLAYER[0]->tiley);
			dist = dx>dy ? dx : dy;
			if (!dist || dist==1)
					chance = 300;
			else
				chance = 2400/dist;

			if (GameRandomNumber("T_HeinrichChase",0) <chance)
			{
				tpoint dummy,*dptr=&dummy;

				if (Near(ob,PLAYER[0],2))
					goto cdoor;

				perpangle = AngleBetween(ob,PLAYER[0]) + ANGLES/4;
				Fix(perpangle);
				dptr->which = ACTOR;
				dptr->x = ob->x + FixedMul(0x10000l,costable[perpangle]);
				dptr->y = ob->y - FixedMul(0x10000l,sintable[perpangle]);

				dptr->z = ob->z;
				if (!CheckLine(dptr,PLAYER[0],SHOOT))
					goto cdoor;

				ob->target = PLAYER[0];
				NewState(ob,M_S(AIM));
				ob->dirchoosetime = 0;
				return;
			}
		}
	}

cdoor:
	doorok = NextToDoor(ob);

	if (ob->dirchoosetime)
	ob->dirchoosetime--;

	if ((ob->flags & FL_STUCK) || (!ob->dirchoosetime) || doorok)
	{
		/*if ((ob->flags & FL_DODGE) && (!doorok))
		SelectKristDodgeDir (ob);
		else */
		SD_PlaySoundRTP(SD_KRISTMOTORSND,ob->x,ob->y);
		SelectKristChaseDir(ob);

		ob->dirchoosetime = 4*M_CHOOSETIME(ob);
	}

	else
	{
		if (NOMOM)
			ParseMomentum(ob,dirangle8[ob->dir]);
		ActorMovement(ob);
	}
}

void T_Heinrich_Defend (objtype*ob)
{
	CheckRunover(ob);

	if (ob->dirchoosetime)
	ob->dirchoosetime--;

	if (MISCVARS->HRAMMING)
	ParseMomentum(ob,dirangle8[ob->dir]);

	if ((ob->flags & FL_STUCK) || (!ob->dirchoosetime))
	{
		if (MISCVARS->HRAMMING)
		{
			if (!Near(ob,PLAYER[0],3))
			{
				NewState(ob,M_S(CHASE));
				ob->dirchoosetime = 0;
				return;
			}
			SelectKristChaseDir(ob);
		}
		else if (MISCVARS->HMINING)
		{
			SelectMineDir(ob);
			if (!MISCVARS->HMINING)
				goto hchase;
			ob->dirchoosetime = 5;	//10;
			return;
		}
		else
		{
		hchase:
			NewState(ob,M_S(CHASE));
			ob->dirchoosetime = 0;
		}
	}
	else
	{
		if (NOMOM)
			ParseMomentum(ob,dirangle8[ob->dir]);
		ActorMovement(ob);
	}
}

void T_Heinrich_Out_of_Control(objtype*ob)
{
	if (ob->dirchoosetime)
		ob->dirchoosetime --;
	else
		{
		if (!ob->temp1)
			{
			SetGibSpeed(0x4000);
			SpawnParticles(ob,RANDOM,120);
			ResetGibSpeed();

			NewState(ob,&s_dexplosion1);
			SD_PlaySoundRTP(SD_EXPLODESND,ob->x,ob->y);
			}
		else
			{
			ob->dir = dirorder[ob->dir][PREV];
			ob->angle = dirangle8[ob->dir];
			if (ob->dir == ob->temp2)
				{
				if (ob->temp1 > 1)
					ob->temp1--;
				else
					{
					if (ob->temp3 == 7)
						{
						SpawnNewObj(ob->tilex,ob->tiley,&s_megaexplosions,inertobj);
						new->temp1 = 25;
						new->flags |= FL_ABP;
						MakeActive(new);
						SpawnNewObj(ob->tilex,ob->tiley,&s_superparticles,inertobj);
						new->flags |= FL_ABP;
						PARTICLE_GENERATOR = new;
						MakeActive(new);
						}
					if (ob->temp3)
						ob->temp3 --;
					else
						ob->temp1 --;
					}
				}

			if (ob->temp1)
				ob->dirchoosetime = ob->temp1;
			else
				{
				ob->dirchoosetime = 70; // end of spin wait for megaexplosion
				if (PARTICLE_GENERATOR)
					{
					NewState(PARTICLE_GENERATOR,&s_megaremove);
					PARTICLE_GENERATOR = NULL;
					}
				}
			}
		}
	}

void SelectKristChaseDir(objtype*ob)
{
	int dx,dy,tx,ty,angle;
	dirtype dtry1,dtry2,tdir,olddir,next,prev,straight;
	//tpoint dummy,*dptr=&dummy;

	olddir=ob->dir;

	//dptr->which = ACTOR;
	//dptr->z = ob->z;
	if (ob->targettilex || ob->targettiley)
	{tx = ob->targettilex;
	ty = ob->targettiley;
	dx= tx - ob->x;
	dy= ob->y - ty;
	// SetFinePosition(dptr,tx,ty);
	if ( ((dx < 0x20000) && (dx > -0x20000)) &&
			((dy < 0x20000) && (dy > -0x20000)))
		{
		dx= PLAYER[0]->x-ob->x;
		dy= ob->y-PLAYER[0]->y;
	// SetFinePosition(dptr,PLAYER[0]->x,PLAYER[0]->y);
		}
	}
	else
	{
	dx= PLAYER[0]->x-ob->x;
	dy= ob->y-PLAYER[0]->y;
	//SetFinePosition(dptr,PLAYER[0]->x,PLAYER[0]->y);

	}

	angle = atan2_appx(dx,dy);
	straight = angletodir[angle];
	/*
	if (ob->areanumber == PLAYER[0]->areanumber)
	{//tpoint newpos1,newpos2;
		//dirtype leftdir;
		//int leftangle1,leftangle2;

		if (CheckLine(ob,&dummy,DIRCHECK))
		{//Debug("\ntrying straight dir %d",straight);
			M_CHECKTURN(ob,straight);
			//Debug("\nstraight dir %d failed",straight);
		}
		//leftdir = dirorder[straight][PREV];
		//leftangle1 = dirangle8[leftdir];
		//newpos1.which = ACTOR;
		//rightangle = dirangle[dirorder[straight][NEXT]];
		//newpos1.x = ob->x + FixedMul(0x10000,costable[leftangle1]);
		//newpos1.y = ob->y - FixedMul(0x10000,sintable[leftangle1]);
		//newpos1.z = ob->z;

		//leftangle2 = dirangle8[dirorder[leftdir][PREV]];
		//newpos2.which = ACTOR;
		//rightangle = dirangle[dirorder[straight][NEXT]];
		//newpos2.x = ob->x + FixedMul(0x10000,costable[leftangle2]);
		//newpos2.y = ob->y - FixedMul(0x10000,sintable[leftangle2]);
		//newpos2.z = ob->z;
		//if (CheckLine(&newpos1,&dummy,SHOOT))// || CheckLine(&newpos2,&dummy,SHOOT))
			{for(tdir = dirorder[straight][PREV];tdir != dirorder[straight][NEXT];tdir = dirorder[tdir][PREV])
				{//Debug("\ntried left-hand rule dir %d",tdir);
				M_CHECKTURN(ob,tdir);
				}
			}
		//else
		//{for(tdir = dirorder[straight][NEXT];tdir != dirorder[straight][PREV];tdir = dirorder[tdir][NEXT])
			// {//Debug("\ntrying right-hand rule dir %d",tdir);
			//	M_CHECKTURN(ob,tdir);
				//Debug("\nright-hand rule dir %d failed\n",tdir);
		//	}
		// }
	}
	else*/
	{dtry1=nodir;
	dtry2=nodir;

	if (dx> ACTORSIZE)
		dtry1= east;
	else if (dx< -ACTORSIZE)
		dtry1= west;
	if (dy> ACTORSIZE)
		dtry2=north;
	else if (dy < -ACTORSIZE)
		dtry2= south;

	if (abs(dy)>abs(dx))
		{tdir=dtry1;
		dtry1=dtry2;
		dtry2=tdir;
		}

	//	ZEROMOM;
	ob->momentumx = FixedMul (ob->momentumx, DEADFRICTION>>gamestate.difficulty);
	ob->momentumy = FixedMul (ob->momentumy, DEADFRICTION>>gamestate.difficulty);

	M_CHECKTURN(ob,straight);

	if (dtry1 != nodir)
		M_CHECKTURN(ob,dtry1);

	if (dtry2 != nodir)
		M_CHECKTURN(ob,dtry2);

	if (dtry1 != nodir)
		{M_CHECKTURN(ob,dirorder[dtry1][NEXT]);
			M_CHECKTURN(ob,dirorder[dtry1][PREV]);
		}

	for(tdir = dirorder[olddir][NEXT];tdir != olddir;tdir = dirorder[tdir][NEXT])
		M_CHECKTURN(ob,tdir);

	ob->dir = olddir;
	}

}

void T_KristLeft(objtype*ob)
{
	CheckRunover(ob);
	ActorMovement(ob);
	if (!ob->ticcount)
	{
		SD_PlaySoundRTP(SD_KRISTTURNSND,ob->x,ob->y);
		if (ob->dir != ob->temp1)
			ob->dir = dirorder[ob->dir][NEXT];
		else
		{
			ob->temp1 = 0;
			NewState(ob,&s_heinrichchase);
		}
	}
}

void T_KristRight(objtype*ob)
{CheckRunover(ob);
	ActorMovement(ob);
	if (!ob->ticcount)
	{SD_PlaySoundRTP(SD_KRISTTURNSND,ob->x,ob->y);
	if (ob->dir != ob->temp1)
	ob->dir = dirorder[ob->dir][PREV];
	else
	{ob->temp1 = 0;
	NewState(ob,&s_heinrichchase);
	}
	}
}

void T_KristCheckFire(objtype*ob)
{int perpangle,angle;
	tpoint dummy;

	if (!ob->ticcount)
	{angle = AngleBetween(ob,PLAYER[0]);

	if (ob->state == &s_heinrichshoot1)
	perpangle = angle + ANGLES/4;
	else
	perpangle = angle - ANGLES/4;

	Fix(perpangle);

	dummy.which = ACTOR;
	dummy.x = ob->x + FixedMul(0x4000,costable[angle]) + FixedMul(0x4000l,costable[perpangle]) +
				FixedMul(PROJSIZE,costable[perpangle]); // offset ahead plus
				// offset for left/right missile plus offset for missile
				// radius (will missile reach player without hitting wall,etc.)

	dummy.y = ob->y - FixedMul(0x4000,sintable[angle]) - FixedMul(0x4000l,sintable[perpangle]) -
				FixedMul(PROJSIZE,sintable[perpangle]);

	dummy.x -= (FixedMul(PROJSIZE,costable[perpangle])<<1);

	dummy.y += (FixedMul(PROJSIZE,sintable[perpangle])<<1);
	dummy.z = ob->z;

	if (!CheckLine(&dummy,PLAYER[0],SHOOT))
	{NewState(ob,&s_heinrichchase);
	return;
	}

	}
}

void SelectMineDir(objtype*ob)
{int angle,missangle;
	dirtype olddir,tdir,next,prev,destdir;
	static nummines=0;

	if (!CheckLine(ob,PLAYER[0],SIGHT))
	{NewState(ob,M_S(CHASE));
	MISCVARS->HMINING = 0;
	return;
	}

	olddir = ob->dir;

	angle = AngleBetween(ob,PLAYER[0]);
	tdir = angletodir[angle];
	destdir = opposite[tdir];

	if (destdir != olddir)
	{next = dirorder[olddir][NEXT];
	prev = dirorder[olddir][PREV];
	if (dirdiff[destdir][next] < dirdiff[destdir][prev])
	ob->dir = next;
	else
	ob->dir = prev;
	return;
	}

	nummines ++;
	missangle  = angle;
	if (nummines == 2)
	missangle -= (ANGLES/36);
	else if (nummines == 3)
	missangle += (ANGLES/36);

	Fix(missangle);
// if (missangle > (ANGLES - 1))
//  missangle -= ANGLES;
// else if (missangle < 0)
//  missangle += ANGLES;

	SpawnMissile(ob,h_mineobj,0x2000,missangle,&s_mine1,0xa000);
	new->dirchoosetime = 140;
	SD_PlaySoundRTP(SD_KRISTDROPSND,ob->x,ob->y);

	if (nummines == 3)
	{MISCVARS->HMINING = 0;
	nummines = 0;
	}
}

void  A_HeinrichShoot(objtype* ob)
{int angle,perpangle;

	if (!ob->ticcount)
	{angle = AngleBetween(ob,PLAYER[0]);
	if (ob->state == &s_heinrichshoot4)
	perpangle = angle + ANGLES/4;
	else
	perpangle = angle - ANGLES/4;

	Fix(perpangle);

	SpawnMissile(ob,missileobj,0x4000,angle,&s_missile1,0x8000);
	SD_PlaySoundRTP(BAS[ob->obclass].fire,ob->x,ob->y);

	SetFinePosition(new,new->x + FixedMul(0x4000l,costable[perpangle]),
							new->y - FixedMul(0x4000l,sintable[perpangle]));
	SetVisiblePosition(new,new->x,new->y);
	}

}

//***************************///////**************************************
//***************************/ NME /**************************************
//***************************///////**************************************

void UpdateNMELinkedActors(objtype*ob)
	{
	objtype *head,*wheels;
	int oldarea;

	head = (objtype*)(ob->whatever);
	wheels = (objtype*)(ob->target);

	oldarea = head->areanumber;

	SetFinePosition(head,ob->x,ob->y);
	SetFinePosition(wheels,ob->x,ob->y);
	SetVisiblePosition(head,ob->x,ob->y);
	SetVisiblePosition(wheels,ob->x,ob->y);

	if (oldarea != ob->areanumber)
		{
		RemoveFromArea(head);
		head->areanumber = ob->areanumber;
		MakeLastInArea(head);
		RemoveFromArea(wheels);
		wheels->areanumber = ob->areanumber;
		MakeLastInArea(wheels);
		}

	}

void T_OrobotChase(objtype*ob)
	{
	int dx,dy;

	if (CheckLine(ob,PLAYER[0],SIGHT))
		{

		ob->targettilex = PLAYER[0]->tilex;
		ob->targettiley = PLAYER[0]->tiley;
		}

	if (!ob->ticcount)
		{
		if (NMEspincheck(ob))
			return;

		dx = PLAYER[0]->x - ob->x;
		dy = ob->y - PLAYER[0]->y;
		/*
		if ((dx > -0x18000) && (dx < 0x18000) && (dy > -0x18000) && (dy < 0x18000))
			{NewState(ob,&s_NMEavoid);
			return;
			}
		*/

		if (CheckLine(ob,PLAYER[0],SIGHT))
			{
			int inrange;

			switch(gamestate.difficulty)
				{
				case gd_baby: inrange = Near(ob,PLAYER[0],6);break;
				case gd_easy: inrange = Near(ob,PLAYER[0],9);break;
				case gd_medium: inrange = Near(ob,PLAYER[0],12);break;
				case gd_hard: inrange = 1;break;
				}

			if ((!Near(ob,PLAYER[0],3)) && inrange)
				{
				SD_PlaySoundRTP(SD_NMEREADYSND,ob->x,ob->y);
				if ((ob->hitpoints < 2000) && (GameRandomNumber("NME special attack",0) < 120))
					{
					int next,prev;

					next = dirorder16[ob->dir][NEXT];
					prev = dirorder16[ob->dir][PREV];
					ob->targettilex = (angletodir[atan2_appx(dx,dy)]<<1);

					if (dirdiff16[prev][ob->targettilex] < dirdiff16[next][ob->targettiley])
						ob->temp3 = PREV;
					else
						ob->temp3 = NEXT;
					NewState(ob,&s_NMEspinfire);
					}
				else
					{
					NewState(ob,&s_NMEwindup);
					ob->temp3 = 0;
					}
			//NewState((objtype*)(ob->target),&s_NMEwheelspin);

				NewState((objtype*)(ob->target),&s_NMEwheels120);
				return;
				}
			}
		}

	if (ob->dirchoosetime)
		ob->dirchoosetime --;

	if ((ob->flags & FL_STUCK) || (!ob->dirchoosetime))
		{
		SelectOrobotChaseDir(ob);
		ob->dirchoosetime = 4;//8;
		}

	else
		{
		ActorMovement(ob);
		UpdateNMELinkedActors(ob);
		}
	}

void T_Saucer(objtype*ob)
{int angle,dangle;

	if (!ob->ticcount)  // if on track at end of each state, accelerate
							// towards PLAYER[0]
	{if (ob->state->condition & SF_SOUND)
	SD_PlaySoundRTP(SD_NMEREADYSND,ob->x,ob->y);
	angle = AngleBetween(ob,PLAYER[0]);
	dangle = ob->angle - angle;
	if ((dangle > -(ANGLES/72)) && (dangle < (ANGLES/72)))
	{if (ob->speed < 0x10000)
		{ob->speed += 0x200;
		ZEROMOM;
		ParseMomentum(ob,ob->angle);
		}
	}
	else // off track; zero mom. and select new dir.
	{ob->speed = 0x1000;
	ZEROMOM;
	ob->angle = angle;
	ParseMomentum(ob,ob->angle);
	}
	}
	MissileMovement(ob);

}

void T_NME_WindUp(objtype*ob)
{objtype *head,*wheels;

	head = (objtype*)(ob->whatever);
	wheels = (objtype*)(ob->target);

	if (ob->dirchoosetime)
	{ob->dirchoosetime--;
	return;
	}

	ob->dirchoosetime = 0;//3;

	if (MISCVARS->NMErotate < 3)
	{head->dir = dirorder16[head->dir][NEXT];
	MISCVARS->NMErotate ++;
	}
	else if (MISCVARS->NMErotate < 6)
	{head->dir = dirorder16[head->dir][PREV];
	MISCVARS->NMErotate ++;
	}
	else if (MISCVARS->NMErotate < 9)
	{ob->dir = dirorder16[ob->dir][NEXT];
	wheels->dir = ob->dir;
	MISCVARS->NMErotate++;
	}
	else if (MISCVARS->NMErotate < 12)
	{ob->dir = dirorder16[ob->dir][PREV];
	wheels->dir = ob->dir;
	MISCVARS->NMErotate ++;
	}
	else
	{MISCVARS->NMErotate = 0;

	NewState(ob,&s_NMEattack);
	ob->dirchoosetime = 0;
	//ob->dirchoosetime = 50 - (ob->shapeoffset >> 2) - (gamestate.difficulty << 2);//70;
	if (!ob->temp2)
	NewState((objtype*)(ob->whatever),&s_NMEhead1rl);
	else
	NewState((objtype*)(ob->whatever),&s_NMEhead2rl);
	NewState(wheels,&s_NMEwheels2);
	}

}

#define SPRAYDIST 0x12000

void SelectOrobotChaseDir(objtype*ob)	// this code is for head
	{
	int dx,dy,angle,tx,ty;
	int tdir,olddir,nextdir,prevdir;
	objtype* head,*wheels;

	head = (objtype*)(ob->whatever);
	wheels = (objtype*)(ob->target);
	olddir=head->dir;

findplayer:
	if (ob->temp1 == -1)
		{
		if (ob->targettilex || ob->targettiley)
			{
			tx = (int)((ob->targettilex << TILESHIFT) + HALFGLOBAL1);
			ty = (int)((ob->targettiley << TILESHIFT) + HALFGLOBAL1);
			dx= tx - ob->x;
			dy= ob->y - ty;
			if (((dx <SPRAYDIST ) && (dx > -SPRAYDIST)) &&
				((dy <SPRAYDIST ) && (dy > -SPRAYDIST)))
				{
				dx= PLAYER[0]->x-ob->x;
				dy= ob->y - PLAYER[0]->y;
				}
			}
		else
			{
			dx= PLAYER[0]->x - ob->x;
			dy= ob->y - PLAYER[0]->y;
			}

		angle = atan2_appx(dx,dy);

		tdir = (((angletodir[angle])<<1) & 0xf);
		}
	else
		{
		tdir = (ob->temp1 & 0xf);

		if ((head->dir == tdir) && (ob->dir == tdir)) // increment
		// tried dir if robot will attempt to move at tdir =>
		// head and body are at move try dir
			{//Debug("\ntrying next queue dir %d",tdir);
			MISCVARS->NMEdirstried ++;
			if (MISCVARS->NMEdirstried == MISCVARS->NMEqueuesize) //gone through all queue entries
				{//Debug("\nqueue exhausted");
				ob->temp1 = -1;
				MISCVARS->NMEdirstried = 0;
				goto findplayer;
				}
			}
		}

	if (tdir != olddir) //rotate head to new chase direction
		{
		nextdir = dirorder16[olddir][NEXT];
		prevdir = dirorder16[olddir][PREV];
		if (dirdiff16[tdir][nextdir] < dirdiff16[tdir][prevdir])
			head->dir = nextdir;
		else
			head->dir = prevdir;
		return;
		}
	//Debug("\nhead aligned to dir %d",tdir);

	//oddir = ob->dir;
	if (ob->dir != head->dir)	// align body and wheels with head
		{
		ZEROMOM;
		NewState(wheels,&s_NMEwheels120);  //rotate wheels for spinning
		nextdir = dirorder16[ob->dir][NEXT];
		prevdir = dirorder16[ob->dir][PREV];
		if (dirdiff16[head->dir][nextdir] < dirdiff16[head->dir][prevdir])
			ob->dir = nextdir;
		else
			ob->dir = prevdir;
		wheels->dir = ob->dir;
		return;
		}

	// Debug("\nbody aligned to head at dir %d",ob->dir);

	ZEROMOM;
	ParseMomentum(ob,dirangle16[head->dir]);
	// Debug("\ntrying to move at dir %d",head->dir);
	ActorMovement(ob);
	UpdateNMELinkedActors(ob);

	if (ob->momentumx || ob->momentumy)
		{
		NewState(wheels,&s_NMEwheels2); // align wheels for movement
		//Debug("\nmove at dir %d succesful, resetting queue",head->dir);
		ob->temp1 = -1; //clear direction queue
		return;
		}
	else if (ob->temp1 == -1) // if queue is empty
									//make a queue of directions (byte packed)
		{
		//Debug("\nmove at dir %d failed and queue empty",head->dir);
		ob->temp1 = 0;
		MISCVARS->NMEdirstried = 0;
		MISCVARS->NMEqueuesize = 0;

		nextdir = ((tdir + 6) & 0xf);
		prevdir = ((tdir - 6) & 0xf);

		for(; MISCVARS->NMEqueuesize < 6;MISCVARS->NMEqueuesize += 2)
			{
			ob->temp1 <<= 4;
			ob->temp1 += nextdir;
			ob->temp1 <<= 4;
			ob->temp1 += prevdir;
			nextdir = ((nextdir-2) & 0xf);
			prevdir = ((prevdir+2) & 0xf);

			}
	#if 0
		SoftError("\n straight dir: %d\n queue dirs ",tdir);
		for(count = 0;count < MISCVARS->NMEqueuesize;count++)
			{
			SoftError("\n dir %d: %d",MISCVARS->NMEqueuesize-count,
						((ob->temp1 >> (4*count)) &0xf)
						);

			}
	#endif
		}
	else				// else goto next queue dir;
		{
		ob->temp1 >>= 4;
		}

	}

void T_NME_Explode(objtype*ob)
{

	if (ob->ticcount == 35)
	{objtype*head;
	int op;

	head = (objtype*)(ob->whatever);

	op = FixedMul(GRAVITY,(head->z-25)<<16) << 1;
	head->momentumz = -FixedSqrtHP(op);
	head->momentumx = (GameRandomNumber("NME head momx",0) << 2);
	head->momentumy = (GameRandomNumber("NME head momy",0) << 2);
	head->hitpoints = 0;
	head->flags |= FL_DYING;
	NewState(head,&s_shootinghead);

			//RemoveObj((objtype*)(ob->whatever)); // remove head
	}
	else if (!ob->ticcount)
	{ob->shapeoffset = 0;
	NewState(ob,&s_explosion1);
	SetGibSpeed(0x4000);
	SpawnParticles(ob,gt_sparks,200);
	ResetGibSpeed();
	RemoveObj((objtype*)(ob->target));
	}

}

void T_NME_HeadShoot(objtype*ob)
{//int randtheta,i,offx,offy;

	ob->z += (ob->momentumz>>16);

	/*if (ob->momentumz < 0)
	{for(i=0;i<3;i++)
	{randtheta = (GameRandomNumber("NME spark drop",0) << 3);
	SpawnNewObj(ob->tilex,ob->tiley,&s_particle1,inertobj);
	new->temp2 = 1;
	offx = FixedMul(0x400,costable[randtheta]);
	offy = -FixedMul(0x400,sintable[randtheta]);
	new->x = new->drawx = ob->x + offx;
	new->y = new->drawy = ob->y + offy;
	new->z = ob->z-15;
	new->flags |= (FL_NOFRICTION|FL_CRAZY|FL_ABP);
	new->dir = west;
	MakeActive(new);
	}
	}*/

	ob->momentumz += GRAVITY;
	if (ob->z >= (nominalheight+45))
	{ob->z = nominalheight+45;
	if (ob->temp2)
	{ob->momentumz = -30000*ob->temp2;
	ob->temp2--;
	}
	else
	{ob->momentumx = ob->momentumy = ob->momentumz = 0;
	ob->shapeoffset = 0;
	NewState(ob,&s_NMEheadexplosion);

	return;
	}
	}
	ActorMovement(ob);

}

boolean NMEspincheck(objtype*ob)
	{
	int dx,dy,dz;

	dx = abs(PLAYER[0]->x - ob->x);
	dy = abs(PLAYER[0]->y - ob->y);
	dz = abs(PLAYER[0]->z - ob->z);
	if ((dx < 0x10000) && (dy < 0x10000) && (dz < 32))
		{
		NewState(ob,&s_NMEspinattack);
		NewState((objtype*)(ob->target),&s_NMEwheelspin);
		if (!ob->temp2)
			NewState((objtype*)(ob->whatever),&s_NMEhead1);
		else
			NewState((objtype*)(ob->whatever),&s_NMEhead2);
		ob->dirchoosetime = 1;
		return true;
		}
	return false;
	}

void T_NME_SpinAttack(objtype* ob)
{int mx,my,mz;
	objtype*head,*wheels;

	if (ob->ticcount == 30)  // knock player back
	{GetMomenta(PLAYER[0],ob,&mx,&my,&mz,0x4000);
	DamageThing(PLAYER[0],20);
	Collision(PLAYER[0],ob,mx,my);
	M_CheckPlayerKilled(PLAYER[0]);
	}
	if (ob->dirchoosetime)
	ob->dirchoosetime --;
	else
	{head = (objtype*)(ob->whatever);
	wheels = (objtype*)(ob->target);
	wheels->dir = head->dir = ob->dir = dirorder16[dirorder16[ob->dir][NEXT]][NEXT];

	ob->dirchoosetime = 1;
	}

}

void T_NME_SpinFire(objtype*ob)
{
	int randtheta,oldyzangle,dx,dy,xydist,dz;
	objtype *head,*wheels;

	head = (objtype*)(ob->whatever);
	wheels = (objtype*)(ob->target);

	if (ob->dir != ob->targettilex)
	{ob->dir = head->dir = wheels->dir = dirorder16[ob->dir][ob->temp3];
	return;
	}

	if (ob->dirchoosetime)
	{ob->dirchoosetime --;
	return;
	}

	if (ob->temp3 < 20)
	{//randphi = (GameRandomNumber("NME generate phi",0) << 3) & ((ANGLES/2) -1);
	if (GameRandomNumber("NME generate theta",0) < 128)
		randtheta = (GameRandomNumber("NME generate theta",0)>>4);
	else
		randtheta = -(GameRandomNumber("NME generate theta",0)>>4);
	dx = PLAYER[0]->x-ob->x;
	dy = ob->y-PLAYER[0]->y;
	if (GameRandomNumber("bcraft shoot up/down",0) < 128)
	dz = 5;
	else
	dz = -5;
	xydist = FindDistance(dx,dy);
	randtheta += atan2_appx(dx,dy);
	Fix(randtheta);
	oldyzangle = ob->yzangle;
	ob->yzangle = atan2_appx(xydist,dz<<10);
	//ob->yzangle = randphi;
	SD_PlaySoundRTP(BAS[ob->obclass].fire+1,ob->x,ob->y);
	//wheels->dir = head->dir = ob->dir = dirorder16[dirorder16[ob->dir][NEXT]][NEXT];
	SpawnMissile(ob,fireballobj,0x6000,randtheta,&s_NMEminiball1,0x10000);
	ob->dirchoosetime = 1;
	ob->yzangle = oldyzangle;
	ob->temp3 ++;
	}
	else
	{ob->temp3 = 0;
	NewState(ob,&s_NMEchase);
	NewState((objtype*)(ob->target),&s_NMEwheels2);
	if (!ob->temp2)
		NewState((objtype*)(ob->whatever),&s_NMEhead1);
	else
		NewState((objtype*)(ob->whatever),&s_NMEhead2);

	}

}

void T_NME_Attack(objtype*ob)
{int angle,perpangle,i;

	if (NMEspincheck(ob))
	{//ob->temp3 = 0;
	return;
	}
	if (ob->dirchoosetime)
	{ob->dirchoosetime --;
		return;
	}

	if (!CheckLine(ob,PLAYER[0],SIGHT))
	{//ob->temp3 = 0;
	//#if ((DEVELOPMENT == 1))
	//Debug("\nCheckLine failed in NME Attack");
	//#endif
	NewState(ob,&s_NMEchase);
	NewState((objtype*)(ob->target),&s_NMEwheels2);
	if (!ob->temp2)
		NewState((objtype*)(ob->whatever),&s_NMEhead1);
	else
		NewState((objtype*)(ob->whatever),&s_NMEhead2);
	return;
	}
	//sound = BAS[ob->obclass].fire;
	angle = AngleBetween(ob,PLAYER[0]);

	if ((ob->temp3 == 0) || (ob->temp3 == 1)) //heatseek

		{SD_PlaySoundRTP(BAS[ob->obclass].fire+2,ob->x,ob->y);
		angle = AngleBetween(ob,PLAYER[0]);
		SpawnMissile(ob,missileobj,0x6000,angle,&s_missile1,0x8000);
		if (ob->temp3 == 3)
			perpangle = angle + ANGLES/4;
		else
			perpangle = angle - ANGLES/4;
		Fix(perpangle);

		new->temp1 = NME_HEATSEEKINGTYPE;
		SetFinePosition(new,new->x + FixedMul(0x8000l,costable[perpangle]),
									new->y - FixedMul(0x8000l,sintable[perpangle]));
		SetVisiblePosition(new,new->x,new->y);
		if (!ob->temp3)
			ob->dirchoosetime = 20;
		else
			{ob->dirchoosetime = 35 - (ob->shapeoffset >> 2) - (gamestate.difficulty << 2);//70;
			if (!ob->temp2)
				NewState((objtype*)(ob->whatever),&s_NMEhead1);
			else
				NewState((objtype*)(ob->whatever),&s_NMEhead2);
			}
		ob->temp3 ++;

		}

	else if (ob->temp3 == 2)			// saucer
	{ SpawnMissile(ob,NMEsaucerobj,0x1000,angle,&s_NMEsaucer1,0xc000);
		new->flags |= FL_SHOOTABLE;
		ob->temp3++;
		ob->dirchoosetime = 35 - (ob->shapeoffset >> 2) - (gamestate.difficulty << 2);//70;
		if (!ob->temp2)
			NewState((objtype*)(ob->whatever),&s_NMEhead1rl);
		else
			NewState((objtype*)(ob->whatever),&s_NMEhead2rl);
	}

	else if ((ob->temp3 == 3) || (ob->temp3 == 4))	// drunk
		{SD_PlaySoundRTP(BAS[ob->obclass].fire+2,ob->x,ob->y);
		if (!ob->temp3)
		perpangle = angle + ANGLES/4;
		else
		perpangle = angle - ANGLES/4;
		Fix(perpangle);
		for(i=0;i<(2+gamestate.difficulty);i++)
			{
			SpawnMissile(ob,missileobj,0x6000,angle,&s_missile1,0x8000);
			new->temp1 = NME_DRUNKTYPE;
			SetFinePosition(new,new->x + FixedMul(0x8000l,costable[perpangle]),
										new->y - FixedMul(0x8000l,sintable[perpangle]));
			SetVisiblePosition(new,new->x,new->y);
			}

		if (ob->temp3 == 3)
			ob->dirchoosetime = 20;
		else
			{ob->temp3 = 0;
			NewState(ob,&s_NMEchase);
			if (!ob->temp2)
				NewState((objtype*)(ob->whatever),&s_NMEhead1);
			else
				NewState((objtype*)(ob->whatever),&s_NMEhead2);
			}

		ob->temp3 ++;

		}

}

//================== Tom/Snake ============================================

void T_DarkSnakeSpawn(objtype*ob)
	{
	objtype * linkinfront;

	if (((ob->state == &s_darkmonkhspawn) && (!(ob->ticcount%8))) ||
		((ob->state == &s_darkmonkfastspawn) && (!(ob->ticcount%4))))
		{
		GetNewActor();
		MakeActive(new);
		SetFinePosition(new,ob->x,ob->y);
		SetVisiblePosition(new,ob->x,ob->y);
		new->z = nominalheight;
		new->areanumber = MAPSPOT(new->tilex,new->tiley,0)-AREATILE;
		MakeLastInArea(new);
		new->obclass = b_darksnakeobj;
		new->which = ACTOR;
		new->angle = AngleBetween(ob,PLAYER[0]);
		new->dir = angletodir[new->angle];
		if (SNAKELEVEL == 1)
			new->speed = 0x5000;
		else if (SNAKELEVEL == 2)
			new->speed = 0x5800;
		else
			new->speed = 0x2000;

		new->hitpoints = 1000;
		new->dirchoosetime = 0;
		new->door_to_open = -1;

		new->flags |= (FL_ABP|FL_NOFRICTION|FL_SHOOTABLE|FL_BLOCK);

		if (ob->whatever)
			{
			linkinfront = (objtype*)(ob->whatever);
			linkinfront->whatever = new;
			new->target = linkinfront;
			new->targettilex = linkinfront->x;
			new->targettiley = linkinfront->y;
			new->angle = AngleBetween(new,linkinfront);
			new->dir = angletodir[new->angle];
			new->flags |= FL_NEVERMARK;
			ParseMomentum(new,new->angle);
			NewState(new,&s_darkmonksnakelink);
			}

		else
			{
			SNAKEHEAD = new;
			if (SNAKELEVEL == 3)
				NewState(new,&s_darkmonkhead);
			else if (SNAKELEVEL == 1)
				{
				NewState(new,&s_snakefindpath);
				new->flags |= FL_ATTACKMODE;
				}
			else if (SNAKELEVEL == 2)
				{
				NewState(new,&s_snakepath);
				new->angle = 3*ANGLES/4;
				new->dir = angletodir[new->angle];
				new->flags |= FL_ATTACKMODE;

				}
			ob->targettilex = ob->targettiley = 0;
			ParseMomentum(new,new->angle);
			}

		if (!ob->ticcount)
			SNAKEEND = new;

		ob->whatever = new;

		}
	}

void T_GenericMove(objtype*ob)
{int dx,dy;

	if (ob->temp3 == -1)
	return;

	if (!(SNAKEHEAD->flags & FL_ATTACKMODE))
	return;

	if (ob->hitpoints <= 0)
	{KillActor(ob);
	ob->temp3 = 0;
	return;
	}

	if (!ob->ticcount)
	{if (ob->state == &s_darkmonkredlink)
	ob->temp3 = 0;
	else if ((ob!=SNAKEEND) && (ob->state == &s_redlinkhit))
	NewState((objtype*)(ob->whatever),&s_redlinkhit);
	}

	dx = ob->targettilex-ob->x;
	dy = ob->y-ob->targettiley;
	if ((dx > -0xa000) && (dx < 0xa000) && (dy > -0xa000) && (dy < 0xa000))
	{if (ob->temp1 && ob->temp2)
		{dx = ob->temp1 - ob->x;
		dy = ob->y - ob->temp2;
		ZEROMOM;
		/*
		if ((ob->targettilex == ob->temp1) && (ob->targettiley == ob->temp2))
			return; */
		//ob->x = ob->drawx = ob->targettilex;
		//ob->y = ob->drawy = ob->targettiley;
		//ob->tilex = ob->x >> TILESHIFT;
		//ob->tiley = ob->y >> TILESHIFT;
		//#if ((DEVELOPMENT == 1))
		//	Debug("\nfollower %d being moved to targetx %4x and targety %4x",
		//	ob-SNAKEHEAD,ob->x,ob->y);
		// #endif
		ob->targettilex = ob->temp1;
		ob->targettiley = ob->temp2;
		#if (0)
			Debug("\nfollower %d's new targetx %4x, targety %4x",
			ob-SNAKEHEAD,ob->temp1,ob->temp2);
		#endif
		ob->angle = atan2_appx(dx,dy);
		ob->dir = angletodir[ob->angle];
		ParseMomentum(ob,ob->angle);
		}
	}
	else if (NOMOM)
	{//SNAKEHEAD->dirchoosetime = 0;
	ParseMomentum(ob,ob->angle);
	}
	if (ob->momentumx || ob->momentumy)
	MoveActor(ob);

// ActorMovement(ob);

}

/*
===============
=
= SelectSnakeDir
=
===============
*/

void SelectSnakeDir (objtype *ob)
{
	int spot,centerx,centery,dx,dy;

	spot = MAPSPOT(ob->tilex,ob->tiley,1)-ICONARROWS;

	if ((spot >= 0) && (spot<= 7) && ((ob->dir!=spot)||(!(ob->flags & FL_DONE))))
	{ centerx= (ob->tilex << 16) + HALFGLOBAL1;
	centery= (ob->tiley << 16) + HALFGLOBAL1;
	dx = abs(centerx - ob->x);
	dy = abs(centery - ob->y);

	if ((dx < SNAKERAD) && (dy < SNAKERAD))
	// new direction
		{ZEROMOM;
		ob->dir = spot;
		ob->flags |= FL_DONE;
		ParseMomentum(ob,dirangle8[ob->dir]);
		SetFinePosition(ob,centerx,centery);
		SetVisiblePosition(ob,ob->x,ob->y);

		if (ob==SNAKEHEAD)
			SoftError("\n path changed at %d, %d",ob->tilex,ob->tiley);
		}
	}

	MoveActor(ob);

}

void T_SnakePath(objtype*ob)
{objtype*temp,*follower;

	if (SNAKEEND && (SNAKELEVEL == 2))
	{if (CheckLine(SNAKEEND,PLAYER[0],SIGHT))
	{if (ob->temp3 == -1)					//if snake can see player
													//and he's presently stopped, restart
		{for(temp=ob;temp;temp=(objtype*)(temp->whatever))
		{temp->temp3 = 0;
			temp->momentumx = temp->temp1;
			temp->momentumy = temp->temp2;
		}
		ob->dirchoosetime = 0;
		}
	}
	else if (ob->temp3 != -1)	//else if he hasn't been stopped, stop him
	{for(temp=ob;temp;temp = (objtype*)(temp->whatever))
		{temp->temp1 = temp->momentumx;
		temp->temp2 = temp->momentumy;
		temp->temp3 = -1;
		temp->momentumx = temp->momentumy = 0;
		}
	}
	else
	return;
	}

	if (ob->dirchoosetime)
	ob->dirchoosetime--;

	else
	{int count = 0;

		for(temp=ob;temp->whatever;temp=(objtype*)(temp->whatever))
			{follower = (objtype*)(temp->whatever);
			follower->temp1 = temp->x;
			follower->temp2 = temp->y;

			SoftError("\n follower %d temp1 set to %4x, temp2 set to %4x",
					count,temp->x,temp->y);
			count ++;
			}
		ob->dirchoosetime = 2 ;//15
	}

	if (ob->momentumx || ob->momentumy)
	SelectSnakeDir(ob);
	//else
	// {ParseMomentum(ob,ob->angle);
	//	MoveActor(ob);
	// }

}

void FindClosestPath(objtype*ob)
{int tx,ty,dx,dy,angle;

	tx = (ob->targettilex << 16) + TILEGLOBAL/2;
	ty = (ob->targettiley << 16) + TILEGLOBAL/2;

	dx= tx - ob->x;
	dy= ob->y - ty;
	angle = atan2_appx(dx,dy);

	ZEROMOM;
	ParseMomentum(ob,angle);
	MoveActor(ob);

}

void T_SnakeFindPath(objtype*ob)
{int i,dx,dy,currdist,mindist,map;
	tpoint dstruct,*dummy=&dstruct;
	objtype*temp,*follower;

	if (ob->targettilex || ob->targettiley)
	{FindClosestPath(ob);
	dx = ob->targettilex - ob->tilex;
	dy = ob->targettiley - ob->tiley;
	if ((!dx) && (!dy))
			{SetTilePosition(ob,ob->tilex,ob->tiley);
			SetVisiblePosition(ob,ob->x,ob->y);
			ob->y = ob->drawy = (ob->tiley << TILESHIFT) + TILEGLOBAL/2;
			NewState(ob,&s_snakepath);
			return;
			}
	}

	else
	{dummy->which = ACTOR;
	mindist = 0x7fffffff;
	for(i=0;i<whichpath;i++)
		{
		SetTilePosition(dummy,SNAKEPATH[i].x,SNAKEPATH[i].y);
		dummy->z = ob->z;
		if (CheckLine(ob,dummy,SIGHT))
		{currdist = FindDistance(ob->tilex-dummy->tilex,ob->tiley-dummy->tiley);
			map = MAPSPOT(ob->tilex,ob->tiley,0)-AREATILE;
			if ((currdist < mindist) && (map >= 0) && (map <= NUMAREAS))
			{ob->targettilex = dummy->tilex;
			ob->targettiley = dummy->tiley;
			mindist = currdist;
			}
		}
		}
	}

	if (ob->dirchoosetime)
		ob->dirchoosetime--;
	else
	{
		for(temp=ob;temp->whatever;temp=(objtype*)(temp->whatever))
		{
			follower = (objtype*)(temp->whatever);
			follower->temp1 = temp->x;
			follower->temp2 = temp->y;
		}
		ob->dirchoosetime = 2 ;//15
	}
}

void T_SnakeFinale(objtype*ob)
{
	if ((ob->state == &s_snakefireworks1)||(ob->state == &s_snakefireworks2))
	{
		if (ob->z != (maxheight-200))
		{
			ob->z --;
			return;
		}
		SetGibSpeed(0x4500);
		SpawnParticles(ob,RANDOM,100);

		SpawnParticles(ob,gt_spit,100);
		ResetGibSpeed();
		NewState(ob,&s_dexplosion1);
	}
	else
	{
		if (!ob->ticcount)
		{
			NewState(EXPLOSIONS,&s_megaremove);
		//  SpawnParticles(ob,RANDOM,100);
			// SpawnParticles(ob,SPIT,100);
			return;
		}

		if (ob->dirchoosetime)
			ob->dirchoosetime --;
		else
		{
			ob->dirchoosetime = (GameRandomNumber("snake finale choose",0) % 7) + 15;
			SetGibSpeed(0x3000);
			SpawnParticles(ob,RANDOM,30);
			SpawnParticles(ob,gt_spit,20);
			ResetGibSpeed();
		}
	}
}

void T_DarkSnakeChase(objtype*ob)
{
	objtype* temp,*follower;
	int tdir,angle;

	if (!(ob->flags & FL_ATTACKMODE))
	{
		if (!(CheckSight(ob,player) || Near(ob,player,4)))
			return;
		else
		{
			ob->flags |= FL_ATTACKMODE;
			MU_StartSong(song_bosssee);
		}
	}

	if (ob->hitpoints <= 0)
	{
		MU_StartSong(song_bossdie);
		KillActor(ob);
		AddMessage("Oscuro defeated!",MSG_CHEAT);
		return;
	}

	angle = AngleBetween(ob,PLAYER[0]);
	tdir = angletodir[angle];
	if (Near(ob,PLAYER[0],6) && (ob->dir == tdir) &&
		(!(ob->state->condition & SF_DOWN)))
	{
		NewState(ob,&s_snakefire1);
		SD_PlaySoundRTP(SD_SNAKEREADYSND,ob->x,ob->y);
	}

	if (!ob->ticcount)
	{
		if (ob->state == &s_darkmonkredhead)
			ob->temp3 = 0; // no longer hitable
		else if ((ob->state == &s_redheadhit) && (ob != SNAKEEND))
			NewState((objtype*)(ob->whatever),&s_redlinkhit);
		else if (ob->state->condition & SF_UP)
			{
			SpawnMissile(ob,dm_spitobj,0x6000,angle,&s_spit1,0x6000);
			SD_PlaySoundRTP(BAS[ob->obclass].fire,ob->x,ob->y);
			//new->z -= 5;
			}
			//spawn spit;
	}

	if (CheckLine(ob,PLAYER[0],SIGHT))
	{
		ob->targettilex = PLAYER[0]->x;
		ob->targettiley = PLAYER[0]->y;
	}

	if (ob->dirchoosetime)
		{
		ob->dirchoosetime--;
		ActorMovement(ob);
		if (NOMOM)
			ob->dirchoosetime = 0;
		}

	else
	{
		//if (ob)
		for(temp=ob;temp->whatever;temp=(objtype*)(temp->whatever))
		{
			follower = (objtype*)(temp->whatever);
			follower->temp1 = temp->x;
			follower->temp2 = temp->y;
		}
		SelectChaseDir(ob);
		ob->dirchoosetime = 7 ;//15
	}
}

void T_DarkmonkReact(objtype*ob)
{
	if (ob->z < nominalheight)
	{
		MISCVARS->monkz += MZADJUST;
		ob->z = nominalheight + (MISCVARS->monkz >> 16);
		//ob->z++;
		return;
	}
	else
	{
		int ocl;

		ocl = ob->temp3;

		if (ocl == p_kesobj)
			NewState(ob,&s_darkmonkabsorb1);
		else if (ocl == p_heatseekobj)
			NewState(ob,&s_darkmonkhball1);
		else if (ocl == p_firebombobj)
			NewState(ob,&s_darkmonkbreathe1);
		else
			NewState(ob,&s_darkmonkchase1);
			ob->dirchoosetime = 0;
	}
}

void T_DarkmonkCharge(objtype*ob)
{
	int dx,dy;

	dx = abs(PLAYER[0]->x - ob->x);
	dy = abs(PLAYER[0]->y - ob->y);
	if ((dx < 0xa000) && (dy < 0xa000))
	{
		DamageThing(PLAYER[0],10);
		Collision(PLAYER[0],ob,0,0);
		M_CheckPlayerKilled(PLAYER[0]);
	}

	if (!ob->ticcount)
		ob->speed >>= 1;

	if (ob->dirchoosetime)
		ob->dirchoosetime --;

	if (NOMOM || (!ob->dirchoosetime))
	{
		ob->angle = AngleBetween(ob,PLAYER[0]);
		ob->dir = angletodir[ob->angle];
		ParseMomentum(ob,ob->angle);
		ob->dirchoosetime = 5;
	}

	ActorMovement(ob);
}

void T_DarkmonkLandAndFire(objtype*ob)
{
	if (ob->z < nominalheight)
	{
		MISCVARS->monkz += MZADJUST;
		ob->z = nominalheight + (MISCVARS->monkz >> 16);
		//ob->z++;
		return;
	}
	if (Near(ob,PLAYER[0],3))
	{
		if (GameRandomNumber("darkmonkland",0)<128)
			NewState(ob,&s_darkmonkbball1);
		else
		{
			ob->angle = AngleBetween(ob,PLAYER[0]);
			ob->dir = angletodir[ob->angle];
			ob->speed <<= 1;		// goes twice as fast
			ZEROMOM;
			ParseMomentum(ob,ob->angle);
			ob->dirchoosetime = 5; // change dir every 5 tics
			ob->hitpoints -= 200; // big penalty for charging
			if (ob->hitpoints <= 0)
			{
				objtype*column = (objtype*)(ob->whatever);

	//			EnableObject((int)column);
				EnableObject(T_SwizzleObjtypeToInt(column));
				ob->whatever = NULL;

				KillActor(ob);
				NewState(ob,&s_darkmonkfastspawn);
				AddMessage("Oscuro flees!",MSG_CHEAT);
				return;
			}
			NewState(ob,&s_darkmonkcharge1);
		}
	}
	else if (ob->temp1)
		NewState(ob,&s_darkmonklightning1);
	else
		NewState(ob,&s_dmgreenthing1);
	ob->temp1 ^= 1;
	ob->dirchoosetime = 0;

}

void T_DarkmonkChase(objtype*ob)
{
	int chance,dx,dy,dist;

	if (!Near(ob,PLAYER[0],2))
	{
		if (ob->z > (maxheight - 100))
		{
			MISCVARS->monkz -= MZADJUST;
			ob->z = nominalheight + (MISCVARS->monkz >> 16);
			//ob->z--;
			return;
		}
	}
	else if (ob->z < nominalheight)
	{
		MISCVARS->monkz += MZADJUST;
		ob->z = nominalheight + (MISCVARS->monkz >> 16);
		//ob->z++;
		return;
	}

	if (CheckLine(ob,PLAYER[0],SIGHT))
	{
		ob->targettilex = PLAYER[0]->x;
		ob->targettiley = PLAYER[0]->y;
	}

	if (!ob->ticcount)
	{
	if (CheckLine(ob,PLAYER[0],SHOOT))	// got a shot at player?
	{
		dx = abs(ob->tilex - PLAYER[0]->tilex);
		dy = abs(ob->tiley - PLAYER[0]->tiley);
		dist = dx>dy ? dx : dy;
		if (!dist || dist==1)
			chance = 300;//300;
		else
			chance = 400/dist;//300/dist;

		if (GameRandomNumber("T_DarkMonkChase",0) < chance)
			{NewState(ob,&s_dmlandandfire);
			return;
			}
		}
	}

	if (ob->dirchoosetime)
		ob->dirchoosetime--;

	if ((ob->flags & FL_STUCK) || (!ob->dirchoosetime))
	{
		SelectChaseDir(ob);
		ob->dirchoosetime = M_CHOOSETIME(ob);
	}
	else
	{
		if (NOMOM)
			ParseMomentum(ob,dirangle8[ob->dir]);
		ActorMovement(ob);
	}
}

//====================== End of Boss Functions ===========================//

void T_GunStand(objtype*ob)
{
	int dy,dx,infrontof,dz;
	objtype* temp;

// if (ob->target)
//  Error("gun reset with non-null target");
	for(temp = firstareaactor[ob->areanumber];temp;temp= temp->nextinarea)
	{
		if (temp == ob)
			continue;
		if (temp->obclass == ob->obclass)
			continue;
		if ((!(temp->flags & FL_SHOOTABLE)) || (temp->flags & FL_DYING))
			continue;

		dy = ob->y - temp->y;
		dx = ob->x - temp->x;
		dz = ob->z - temp->z;
		if ((abs(dy)>0x40000) || (abs(dx)>0x40000) || (abs(dz) > 20))
			continue;

		infrontof = 0;

		switch (ob->dir)
		{
		case north:
			if ((dy > 0) && (abs(dx)<0x8000))
				infrontof = 1;
			break;

		case east:
			if ((dx < 0) && (abs(dy)<0x8000))
				infrontof = 1;
			break;

		case south:
			if ((dy < 0) && (abs(dx)<0x8000))
				infrontof = 1;
			break;

		case west:
			if ((dx > 0) && (abs(dy)<0x8000))
				infrontof = 1;
			break;
		}

		if (infrontof && CheckLine(ob,temp,SHOOT))
		{
			ob->target = temp;
			NewState(ob,&s_gunraise1);
			return;
		}
	}
}

void T_4WayGunStand(objtype*ob)
{
	int dy,dx,dz;
	objtype* temp;

	if (ob->target)
	Error("gun reset with non-null target");
	for(temp = firstareaactor[ob->areanumber];temp;temp= temp->nextinarea)
	{
		if (temp == ob)
			continue;

		if (temp->obclass == ob->obclass)
			continue;

		if ((!(temp->flags & FL_SHOOTABLE)) || (temp->flags & FL_DYING))
			continue;

		dy = abs(ob->x-temp->x);
		dx = abs(ob->y-temp->y);
		dz = abs(ob->z-temp->z);
		if ((dx < 0x40000) && (dy < 0x40000) && (dz< 20) && CheckLine(ob,temp,SHOOT))
			{//if ((dx < 0x8000) || (dy <0x8000))
			ob->target = temp;
			NewState(ob,&s_4waygunfire1);
			return;
		}
	}
}

void A_GunShoot(objtype*ob)
{ int	dx,dy,dz,damage,infrontof,tnear,savedangle;
	objtype * target;

	if (!ob->ticcount)
	{
		target = (objtype*)(ob->target);
		if (!target)
			Error("an instance of %s called gunshoot without a target\n",
				debugstr[ob->obclass]);
		if ((!(target->flags & FL_SHOOTABLE)) || (target->flags & FL_DYING))
		{
			NewState(ob,&s_gunlower1);
			ob->target = NULL;
			return;
		}

		dx = target->x-ob->x;
		dy = ob->y-target->y;
		dz = ob->z-target->z;

		tnear = ((abs(dy)<0x40000) && (abs(dx)<0x40000) && (abs(dz) < 20));
		infrontof = 0;

		switch (ob->dir)
		{
		case north:
			if ((dy > 0) && (abs(dx)<0x8000))
				infrontof = 1;
			break;

		case east:
			if ((dx < 0) && (abs(dy)<0x8000))
				infrontof = 1;
			break;

		case south:
			if ((dy < 0) && (abs(dx)<0x8000))
				infrontof = 1;
			break;

		case west:
			if ((dx > 0) && (abs(dy)<0x8000))
				infrontof = 1;
			break;
		}

		if ((!infrontof) || (!CheckLine(ob,target,SHOOT)) ||
			(!tnear))
		{
			NewState(ob,&s_gunlower1);
			ob->target = NULL;
			return;
		}

		//SD_PlaySoundRTP(SD_FIRE,PLAYER[0]->x,PLAYER[0]->y,ob->x,ob->y);
		//hitchance = 128;

	//	if (!target)
		//		Error("object called shoot without a target\n");

		damage = DMG_AHGUN;

		if (target->obclass == playerobj)
		{
			target->target = ob;
			if (target->flags & FL_BPV)
				damage >>= 1;

		}
		savedangle = ob->angle;
		ob->angle = atan2_appx(dx,dy);
		RayShoot(ob,damage,GameRandomNumber("A_GunShoot Accuracy",0) % 20);
		ob->angle = savedangle;
		SD_PlaySoundRTP(SD_BIGEMPLACEFIRESND,ob->x,ob->y);
	}

}

void A_4WayGunShoot(objtype*ob)
{
	int	dx,dy,dz,damage,savedangle;
	objtype * target;

	if (ob->ticcount == (ob->state->tictime >> 1))
	{
		target = (objtype*)(ob->target);
		if (!target)
			Error("an instance of %s called 4waygunshoot without a target\n",debugstr[ob->obclass]);
		dx = abs(target->x-ob->x);
		dy = abs(ob->y-target->y);
		dz = abs(ob->z-target->z);
		if ((dx > 0x40000) || (dy > 0x40000) || (dz > 20) ||
			(!CheckLine(ob,target,SHOOT)) ||
			(!(target->flags & FL_SHOOTABLE)) ||
			(target->flags & FL_DYING)
			)
		{
			ob->target = NULL;
			NewState(ob,&s_4waygun);
			return;
		}

		//SD_PlaySoundRTP(SD_FIRE,PLAYER[0]->x,PLAYER[0]->y,ob->x,ob->y);
		//hitchance = 128;

		// if (!target)
		//	Error("object called shoot without a target\n");

		damage = DMG_AHGUN;
		SD_PlaySoundRTP(BAS[ob->obclass].fire,ob->x,ob->y);

		if (target->obclass == playerobj)
		{
			target->target = ob;
			if (target->flags & FL_BPV)
				damage >>= 1;
		}

		savedangle = ob->angle;
		ob->angle = 0;
		RayShoot(ob,damage,GameRandomNumber("A_4WayGunShoot Accuracy",0) % 20);
		ob->angle = ANG90;
		RayShoot(ob,damage,GameRandomNumber("A_4WayGunShoot Accuracy",0) % 20);
		ob->angle = ANG180;
		RayShoot(ob,damage,GameRandomNumber("A_4WayGunShoot Accuracy",0) % 20);
		ob->angle = ANG270;
		RayShoot(ob,damage,GameRandomNumber("A_4WayGunShoot Accuracy",0) % 20);
		ob->angle = savedangle;
	}
}

void A_Drain (objtype *ob)
{
	int dx,dy,dz,damage, maxhp;

	dx = abs(PLAYER[0]->x - ob->x);
	dy = abs(PLAYER[0]->y - ob->y);
	dz = abs(PLAYER[0]->z - ob->z);

	if ((dx > TOUCHDIST) || (dy > TOUCHDIST) || (dz > (TOUCHDIST>>10)))
	{
		if(rott_iswolf)		//BGB
		{
//			A_Chase(ob);
			NewState(ob,M_S(CHASE));
			return;
		}
	
		NewState(ob,&s_dmonkshoot5);
		return;
	}

	if (ob->ticcount)
		return;

	else
	{
		if(rott_iswolf)
		{
			damage = (GameRandomNumber("A_Drain",ob->obclass)&3)+2;
			DamageThing (PLAYER[0],damage);
		}else
		{
			damage = (GameRandomNumber("A_Drain",ob->obclass) >> 3);
			DamageThing (PLAYER[0],damage);
			ob->hitpoints += damage;
			maxhp = starthitpoints[gamestate.difficulty][ob->obclass];
			if (ob->hitpoints > maxhp)
				ob->hitpoints = maxhp;
		}

		Collision(PLAYER[0],ob,0,0);
		if (PLAYER[0]->flags & FL_DYING)
			PLAYER[0]->target = ob;
		M_CheckPlayerKilled(PLAYER[0]);
		SD_PlaySoundRTP(SD_MONKGRABSND,ob->x,ob->y);
	}
}

void  A_DmonkAttack(objtype*ob)
{
	int angle,nobclass,nspeed,altangle1=0,altangle2=0,zoff=0,sound;
	statetype *nstate;

	if (!ob->ticcount)
	{
		ob->hitpoints -= 120;//120;
		if (ob->hitpoints <= 0)
		{
			objtype*column = (objtype*)(ob->whatever);

	//		EnableObject((int)column);
			EnableObject(T_SwizzleObjtypeToInt(column));
			ob->whatever = NULL;

			KillActor(ob);
			NewState(ob,&s_darkmonkfastspawn);
			return;
		}
	}

	if (ob->dirchoosetime)
		ob->dirchoosetime --;

	else
	{
		sound = BAS[ob->obclass].fire;
		angle = AngleBetween(ob,PLAYER[0]);
		nspeed = 0x6000;

		if (ob->state == &s_darkmonksphere8)
		{
			nstate = &s_kessphere1;
			nobclass = p_kesobj;
			ob->dirchoosetime = 70;
		}

		else if (ob->state == &s_darkmonkhball7)
		{
			nstate = &s_handball1;
			nobclass = dm_heatseekobj;
			nspeed = 0x3000;
			ob->dirchoosetime = 5;
		}

		else if (ob->state == &s_darkmonkbball7)
		{
			nstate = &s_faceball1;
			nobclass = dm_weaponobj;
			nspeed = 0x3000;
			ob->dirchoosetime = 5;
		}

		else if (ob->state == &s_darkmonklightning9)
		{
			nstate = &s_lightning;
			nobclass = dm_weaponobj;
			ob->dirchoosetime = 3;
			sound++;
		}

		else if (ob->state == &s_dmgreenthing8)
		{
			nstate = &s_energysphere1;
			nobclass = dm_weaponobj;
			sound +=2;
			ob->dirchoosetime = 70;
		}

		else if (ob->state == &s_darkmonkfspark5)
		{
			nstate = &s_floorspark1;

			altangle1 = angle + ANGLES/24;
			altangle2 = angle - ANGLES/24;
			Fix(altangle1);
			Fix(altangle2);
			nobclass = dm_weaponobj;
			ob->dirchoosetime = 3;
			sound += 3;
		}

		else if (ob->state == &s_darkmonkbreathe6)
		{
			nstate = &s_crossfire1;
			ob->dirchoosetime = 3;
			nobclass = dm_weaponobj;
			zoff = -15;
			sound += 3;
		}

		SpawnMissile(ob,nobclass,nspeed,angle,nstate,0xb000);
		SD_PlaySoundRTP(sound,ob->x,ob->y);

		new->z = ob->z+zoff;
		if (altangle1)
		{
			SpawnMissile(ob,nobclass,nspeed,altangle1,nstate,0xb000);
			SpawnMissile(ob,nobclass,nspeed,altangle2,nstate,0xb000);
		}
	}

}

#endif // SHAREWARE endif

//=====================================================================//

/*
===============
=
= T_Stand
=
===============
*/

void T_Stand (objtype *ob)
{
	if (!ob->ticcount)
		SightPlayer (ob);
	else
		SoftError("\n ob type %s ticcount of %d in T_Stand",debugstr[ob->obclass],
					ob->ticcount);
}

void DamagePlayerActor(objtype *ob, int damage)
{
	playertype *pstate;

	switch (gamestate.difficulty)
	{
		case 0:  damage >>= 1;
					break;
		case 1:  damage -= (damage >> 2);
					break;
		case 2:  break;
		case 3:  //damage += (damage>>2);
					break;
		//default: Error("Um, Gamestate.Difficulty, uh, has problems.\n");
	}

	if (!damage) damage++;

	M_LINKSTATE(ob,pstate);

	pstate->health -= damage;
	ob->hitpoints = pstate->health;

	SD_PlaySoundRTP(SD_PLAYERTCHURTSND+(pstate->player),ob->x,ob->y);
	if (ob==player)
	{
		damagecount += damage;
//		if (cybermanenabled)
//			SWIFT_TactileFeedback (10*damage, 15, 15);
		if ( SHOW_BOTTOM_STATUS_BAR() )
			DrawBarHealth (false);
	}

	if (pstate->health<=0)
	{
		pstate->health = 0;
		ob->hitpoints = 0;
	}
}

void DamageNonPlayerActor(objtype *ob,int damage)
{
	//if ((ob->obclass == b_darksnakeobj) && (!ob->temp3))
	// return;

	if (!(ob->flags & FL_ATTACKMODE))
		damage <<= 1;

	ob->hitpoints -= damage;
	if (ob->hitpoints <= 0)
	{
		int sound;

		sound = BAS[ob->obclass].die;
		if (ob->obclass == lowguardobj)
		{
			if (ob->shapeoffset)
				sound ++;
		}
		SD_PlaySoundRTP(sound,ob->x,ob->y);
	}
	else
		SD_PlaySoundRTP(BAS[ob->obclass].hit,ob->x,ob->y);

#if (SHAREWARE == 0)
	if ((ob->obclass == b_robobossobj) && (ob->temp2 <= 2))
	{
		if (ob->hitpoints <
			((3-ob->temp2)*starthitpoints[gamestate.difficulty][ob->obclass]>>2)
			)
		{
			SD_PlaySoundRTP(SD_NMEAPARTSND,ob->x,ob->y);
			ob->temp2++;
			ob->shapeoffset += 16;
			ob->speed += 0x500;
			SpawnNewObj(ob->tilex,ob->tiley,&s_megaexplosions,inertobj);
			new->temp1 = 3;
			new->flags |= FL_ABP;
			MakeActive(new);
		}
		if (ob->temp2 == 1)
			NewState((objtype*)(ob->whatever),&s_NMEhead2);
	}
#endif
	MISCVARS->madenoise = true;
}

void DamageStaticObject(statobj_t*tempstat,int damage)
{

	tempstat->hitpoints -= damage;
	if (tempstat->hitpoints <= 0)
	{
		sprites[tempstat->tilex][tempstat->tiley]=NULL;
		tempstat->flags |= FL_NONMARK;
		if (tempstat->flags&FL_LIGHT)
		{

			if (MAPSPOT(tempstat->tilex,tempstat->tiley,2))
			{
				touchplatetype *tplate;

				for(tplate=touchplate[tempstat->linked_to];tplate;tplate = tplate->nextaction)
//					if (tplate->whichobj == (int)(tempstat))
					if (tplate->whichobj == T_SwizzleStatObjToInt(tempstat))
						RemoveTouchplateAction(tplate,tempstat->linked_to);
			}

			if (tempstat->flags & FL_LIGHTON)
				TurnOffLight(tempstat->tilex,tempstat->tiley);

			if (tempstat->itemnumber<=stat_chandelier)
				//SpawnFallingDebris(tempstat->x,tempstat->y,tempstat->z-32);
			{
				objtype *prevlast = LASTACTOR;

				SpawnSlowParticles(gt_sparks,4,
					tempstat->x,tempstat->y,tempstat->z-32);
				for(prevlast = prevlast->next;prevlast;
					prevlast= prevlast->next)
				{
					prevlast->momentumz = 1; // any positive value will do
					prevlast->momentumx >>= 1;
					prevlast->momentumy >>= 1;
				}
			}
			else
			{

				SpawnStatic(tempstat->tilex,tempstat->tiley,stat_metalshards,-1);
				LASTSTAT->flags |= (FL_ABP|FL_NONMARK);
				sprites[tempstat->tilex][tempstat->tiley] = NULL;
				MakeStatActive(LASTSTAT);
				switch (tempstat->itemnumber)
				{
				case stat_lamp:
				case stat_altbrazier1:
				case stat_altbrazier2:
				case stat_torch:
					SpawnSlowParticles(gt_sparks,5,tempstat->x,tempstat->y,tempstat->z-32);
					break;
				case stat_floorfire:
					SpawnSlowParticles(gt_sparks,5,tempstat->x,tempstat->y,tempstat->z);
					break;
				}
			}
			SpawnSolidStatic(tempstat);
			SD_PlaySoundRTP(SD_ITEMBLOWSND,tempstat->x,tempstat->y);
		}
		else
		{
			switch (tempstat->itemnumber)
			{
			case stat_dariantouch:
				MISCVARS->ETOUCH[tempstat->linked_to].x = MISCVARS->ETOUCH[tempstat->linked_to].y = 0;
			case stat_tntcrate:
			case stat_bonusbarrel:
				SpawnNewObj(tempstat->tilex,tempstat->tiley,&s_staticexplosion1,inertobj);
				MakeActive(new);
				new->flags |= FL_ABP;
				new->whatever = tempstat;
				new->temp2 = damage;

				if (tempstat->itemnumber == stat_bonusbarrel)
					{
					int rand = GameRandomNumber("DamageThing",0);

					if (rand < 80)
						{
						if (rand & 1)
							SpawnStatic(tempstat->tilex,tempstat->tiley,stat_monkmeal,-1);
						else
							SpawnStatic(tempstat->tilex,tempstat->tiley,stat_priestporridge,-1);
						gamestate.healthtotal ++;
						}
					else if (rand < 160)
						{
						if (rand & 1)
							SpawnStatic(tempstat->tilex,tempstat->tiley,stat_lifeitem1,-1);
						else
							SpawnStatic(tempstat->tilex,tempstat->tiley,stat_lifeitem3,-1);
						}
					else
						{
						if (rand & 1)
							SpawnStatic(tempstat->tilex,tempstat->tiley,stat_mp40,-1);
						else
							{
							SpawnStatic(tempstat->tilex,tempstat->tiley,stat_heatseeker,-1);
							gamestate.missiletotal ++;
							}
						LASTSTAT->flags &= ~FL_RESPAWN;
						}
					//LASTSTAT->flags &= ~FL_SHOOTABLE;
					LASTSTAT->flags |= FL_ABP;
					MakeStatActive(LASTSTAT);
					SD_PlaySoundRTP(SD_BONUSBARRELSND,tempstat->x,tempstat->y);
					}
				else
					{
					ExplodeStatic(tempstat);
					if (tempstat == touchsprite)
						touchsprite = NULL;
					}
				SpawnSolidStatic(tempstat);
		//SD_Play(SD_EXPL);
				break;
#if (SHAREWARE == 0)
			case stat_mine:
				SpawnNewObj(tempstat->tilex,tempstat->tiley,&s_grexplosion1,inertobj);
				MakeActive(new);
				new->flags |= FL_ABP;
				new->whatever = tempstat;
				new->temp2 = damage;
				RemoveStatic(tempstat);
				break;

			case stat_tomlarva:
				SD_PlaySoundRTP(SD_ACTORSQUISHSND,tempstat->x,tempstat->y);
				SpawnGroundExplosion(tempstat->x,tempstat->y,tempstat->z);
				//MISCVARS->gibgravity = GRAVITY/2;
				MISCVARS->fulllightgibs = true;
				SetGibSpeed(0x4000);
				SpawnSlowParticles(GUTS,30,tempstat->x, tempstat->y,tempstat->z);
				ResetGibSpeed();
				MISCVARS->fulllightgibs = false;
				//MISCVARS->gibgravity = -1;
				RemoveStatic(tempstat);
				break;
#endif

			case stat_lifeitem1:
			case stat_lifeitem2:
			case stat_lifeitem3:
			case stat_lifeitem4:
				SD_PlaySoundRTP(SD_ITEMBLOWSND,tempstat->x,tempstat->y);
				gamestate.treasurecount ++;
				SpawnSlowParticles(gt_sparks,10,tempstat->x,tempstat->y,tempstat->z);
				SpawnSolidStatic(tempstat);
				break;

			default:

				if ((tempstat->itemnumber == stat_plant) ||
						(tempstat->itemnumber == stat_tree))
					gamestate.plantcount++;

				//tempstat->shapenum = -1;
				//tempstat->flags &= ~FL_SHOOTABLE;
				ExplodeStatic(tempstat);
				SpawnSolidStatic(tempstat);
				break;
			}
		}
	}
}

void DamageThing (void *thing, int damage)
{
	objtype* tempactor;
	statobj_t* tempstat;

	tempactor = (objtype*)thing;
	if (!tempactor)
		return;

	if ((tempactor->which == ACTOR) && (!(tempactor->flags & FL_SHOOTABLE)))
		return;

	if ((tempactor->which == ACTOR) || (tempactor->which == SPRITE))
	{
		if (tempactor->which == ACTOR)
		{
			if (tempactor->obclass == playerobj)
			{
				if ((tempactor->flags & FL_GODMODE) ||
					(tempactor->flags & FL_DOGMODE) ||
					godmode ||
					(gamestate.battlemode == battle_Eluder)
					)
					return;
				DamagePlayerActor(tempactor,damage);
			}
			else
			{
				if ((tempactor->obclass == collectorobj) && (gamestate.SpawnEluder))
					return;
				if (tempactor->hitpoints <= 0)
					return;
				DamageNonPlayerActor(tempactor,damage);
			}
		}
		else
		{
			tempstat = (statobj_t*)thing;

			MISCVARS->madenoise = true;
			if (!(tempstat->flags & FL_SHOOTABLE))
				return;
			DamageStaticObject(tempstat,damage);
		}
	}
}

void ExplodeStatic(statobj_t*tempstat)
{
	//SpawnSolidStatic(tempstat);

	if (tempstat->flags & FL_WOODEN)
	{
		SpawnStatic(tempstat->tilex,tempstat->tiley,stat_woodfrag,-1);
		if ((gamestate.BattleOptions.RespawnItems) &&
			(tempstat->itemnumber == stat_tntcrate)
			)
		{
	//		tempstat->linked_to = (int)(LASTSTAT);
			tempstat->linked_to = T_SwizzleStatObjToInt(LASTSTAT);
			tempstat->flags |= FL_RESPAWN;
		}

	}
	else if (tempstat->flags & FL_METALLIC)
		SpawnStatic(tempstat->tilex,tempstat->tiley,stat_metalfrag,-1);
	else
		SpawnStatic(tempstat->tilex,tempstat->tiley,stat_rubble,-1);
	LASTSTAT->flags |= (FL_ABP|FL_NONMARK);
	sprites[tempstat->tilex][tempstat->tiley] = NULL;
	MakeStatActive(LASTSTAT);
	SD_PlaySoundRTP(SD_ITEMBLOWSND,tempstat->x,tempstat->y);
}

void EnableObject(int object)
{
	objtype* ob;
	int i,gasicon;
	doorobj_t*tdoor;

//	ob = (objtype*)object;
	ob = T_SwizzleObjtypeFromInt(object);
	ob->flags |= FL_ACTIVE;
	if (ob->obclass == bladeobj)
	{
		ParseMomentum(ob,dirangle8[ob->dir]);
		if (ob->whatever)
		{
			objtype *passenger=(objtype*)(ob->whatever);

			passenger->momentumx += ob->momentumx;
			passenger->momentumy += ob->momentumy;
		}
	}

	if (ob->obclass == gasgrateobj)
		{
		NewState(ob,&s_gas2);
		SD_PlaySoundRTP(SD_GASSTARTSND,ob->x,ob->y);
		ob->dirchoosetime = GASTICS;
		for(i=0;i<doornum;i++)
			{

			tdoor = doorobjlist[i];
			gasicon = MAPSPOT(tdoor->tilex,tdoor->tiley,1);
			if (gasicon == GASVALUE)
				LinkedCloseDoor(i);
			}

		MU_StoreSongPosition();
		MU_StartSong(song_gason);
		MISCVARS->GASON = 1;
		ob->temp3 = 105;
		}
	else if (ob->obclass == pillarobj)
	{
		ob->flags |= FL_FLIPPED;
		gamestate.secretcount++;
	}
	if (!(ob->flags & FL_ABP))
	{
		ob->flags |= FL_ABP;
		MakeActive(ob);
	}
}

void DisableObject(int object)
{
	objtype*ob;

// ob = (objtype*)object;
	ob = T_SwizzleObjtypeFromInt(object);
	ob->flags &= ~FL_ACTIVE;
}

void T_MoveColumn(objtype* ob)
{
	int spot,index;

	if (!(ob->flags & FL_ACTIVE))
		return;
/*
	switch (ob->dir)
	{case north:
	ob->momentumy = -PILLARMOM;
	break;
	case south:
	ob->momentumy =  PILLARMOM;
	break;
	case east:
	ob->momentumx =  PILLARMOM;
	break;
	case west:
	ob->momentumx = -PILLARMOM;
	break;
	}

*/
	ActorMovement(ob);
	index = touchindices[ob->tilex][ob->tiley];
	if (index)
	TRIGGER[index-1] = 1;
	ob->temp1 -= PILLARMOM;

	if ((ob->temp1 <= 0) || NOMOM)
	{
		ZEROMOM;
		ob->temp1 = 0x20000;
		ob->flags &= ~FL_ACTIVE;
		spot = MAPSPOT(ob->tilex,ob->tiley,1)-ICONARROWS;
		if ((spot >= 0) && (spot <= 7))
		{
			ob->dir = spot;
			if (!ob->temp2)
			{
				gamestate.secrettotal++;
			}
			else
			{
				ob->flags |= FL_ACTIVE;
			}
			ParseMomentum(ob,dirangle8[ob->dir]);
		}
		else
			ob->flags |= FL_DONE;
	}
}

boolean NextToDoor(objtype*ob)
{
	int tilex,tiley,centerx,centery,dx,dy;

	tilex = ob->tilex;
	tiley = ob->tiley;

	if (M_ISDOOR(tilex+1,tiley) || M_ISDOOR(tilex-1,tiley))
	{
		centery = (tiley << TILESHIFT) + HALFGLOBAL1;
		dy = abs(ob->y - centery);
		if (dy < 0x2000)
			return true;
	}

	if (M_ISDOOR(tilex,tiley+1) || M_ISDOOR(tilex,tiley-1))
	{
		centerx = (tilex << TILESHIFT) + HALFGLOBAL1;
		dx = abs(ob->x - centerx);
		if (dx < 0x2000)
			return true;
	}

	return false;
}

/*
=================
=
= T_Use
=
=================
*/

void T_Use(objtype*ob)
{
	if (ob->ticcount)
		return;

	switch (ob->obclass)
	{
#if (SHAREWARE == 0)
	case b_darianobj:
		if (!DoPanicMapping())
		{
			if(touchsprite)
				touchsprite->flags |= FL_ACTIVE;
		}

		if ((!sprites[PLAYER[0]->tilex][PLAYER[0]->tiley]) &&
			(ob->areanumber == PLAYER[0]->areanumber))
		{
			SpawnNewObj(
				PLAYER[0]->tilex, PLAYER[0]->tiley,
				&s_dspear1, spearobj);
			new->flags |= (FL_ABP);//|FL_INVULNERABLE);
			new->z = 0;
			MakeActive(new);
		}
		ZEROMOM;
		ob->flags |= FL_STUCK;
		SD_PlaySoundRTP(SD_DARIANUSESND, ob->x, ob->y);
		//NewState(ob,&s_darianspears);
		break;
#endif
	}

}

#define RollStart(ob,state,angle)	\
{											\
	int oldspeed = ob->speed;			\
												\
	ob->speed = ROLLMOMENTUM+0x200;	\
	NewState(ob,state);					\
	ParseMomentum(ob,angle);			\
	ob->speed = oldspeed;				\
}											\

void AvoidPlayerMissile(objtype*ob)
{
	objtype *temp;
	int dx,dy,dz;
	int magangle,angle1,rollangle1,rollangle2,dangle1,dangle2;

	if (PLAYER0MISSILE == NULL)
		return;

	if (GameRandomNumber("scott missile avoid",0) > 160)
		return;

	if (ob->momentumz)
		return;

	if ((ob->state->think == T_Roll) || (ob->state->think == T_Reset))
		return;

	temp = PLAYER0MISSILE;

	dx = abs(temp->x - ob->x);
	dy = abs(ob->y - temp->y);
	dz = abs(ob->z - temp->z);
	angle1 = AngleBetween(temp,ob);
	magangle = abs(temp->angle - angle1);

	if (magangle > VANG180)
		magangle = ANGLES - magangle;

	if ((magangle > ANGLES/48) || (dx > 0x50000) || (dy > 0x50000) ||
		(dz > 32))
		return;

	rollangle1 = angle1 + ANGLES/4;
	Fix(rollangle1);
	dangle1 = abs(temp->angle - rollangle1);
	if (dangle1 > VANG180)
		dangle1 = ANGLES - dangle1;

	rollangle2 = angle1 - ANGLES/4;
	Fix(rollangle2);
	dangle2 = abs(temp->angle - rollangle2);
	if (dangle2 > VANG180)
		dangle2 = ANGLES - dangle2;

	ob->momentumx = ob->momentumy = 0;

	if (dangle1 > dangle2)
	{
		RollStart(ob,&s_strikerollleft1,rollangle1);
	}
	else
	{
		RollStart(ob,&s_strikerollright1,rollangle2);
	}
	ob->flags |= FL_NOFRICTION;

	ob->target = PLAYER[0];
	//SelectRollDir(ob);

}

/*
=================
=
= T_Chase
=
=================
*/

void T_Chase (objtype *ob)
{
	int	dx,dy,dz,dist,chance;
	classtype ocl;
	statetype *temp;
	boolean doorok;

	ocl = ob->obclass;

	if ((ocl == deathmonkobj) || (ocl == blitzguardobj))
	{
		dx = abs(PLAYER[0]->x - ob->x);
		dy = abs(ob->y - PLAYER[0]->y);
		dz = abs(ob->z - PLAYER[0]->z);

		if ((dx < TOUCHDIST) && (dy < TOUCHDIST) && (dz < (TOUCHDIST >> 10)))
		{
#if (SHAREWARE == 0)
			if (ocl == deathmonkobj)
			{
				NewState(ob,&s_dmonkshoot1);
				STOPACTOR(ob);
				return;
			}
			else
#endif
			if ((!ob->temp3) && (PLAYERSTATE[0].missileweapon != -1) &&
					(PLAYERSTATE[0].missileweapon < wp_godhand) &&
					!rott_iswolf)
			{
				NewState(ob,&s_blitzsteal1);
				STOPACTOR(ob);
				return;
			}
		}
	}

	ob->flags &= ~FL_DODGE;

	//if (CheckLine(ob,PLAYER[0],DIRCHECK) && (ocl != roboguardobj))

	if (!ob->ticcount)
	{
		if (CheckLine(ob,PLAYER[0],SIGHT))	// got a shot at player?
		{
			if (ocl != roboguardobj)
			{
				ob->targettilex = PLAYER[0]->x;
				ob->targettiley = PLAYER[0]->y;
			}
		}

		if (CheckLine(ob,PLAYER[0],SHOOT) && (!(player->flags&FL_DYING)))	// got a shot at player?
		{
			dx = abs(ob->tilex - PLAYER[0]->tilex);
			dy = abs(ob->tiley - PLAYER[0]->tiley);
			dist = (dx>dy)?(dx):(dy);
			if ((!dist) || (dist==1))
					chance = 300;
			else if (ocl >= b_darianobj)
					chance = 400/dist;
			else
					chance = 300/dist;

			if (GameRandomNumber("T_Chase",ocl) <chance)
			{
				if ((ocl == b_heinrichobj) && (Near(ob,PLAYER[0],4)))
					goto cdoor;

				ob->dir = angletodir[AngleBetween(ob,PLAYER[0])];
				STOPACTOR(ob);
	#if (SHAREWARE == 0)
				if ((ocl == overpatrolobj) && (!Near(ob,PLAYER[0],3)) &&
					(!PLAYERSTATE[0].NETCAPTURED) &&
					(!MISCVARS->NET_IN_FLIGHT))
				{
					NewState(ob,&s_opbolo1);
					MISCVARS->NET_IN_FLIGHT = true;
					return;
				}
	#endif
				if ((ocl == triadenforcerobj) && (!Near(ob,PLAYER[0],3)))
				{
					NewState(ob,&s_enforcerthrow1);
					return;
				}

				temp = M_S(AIM);
				
				if(	((ocl == deathmonkobj) ||
					(ocl == dfiremonkobj)) && rott_iswolf)
						temp=NULL;
				
				if (temp != NULL)
				{
					if ((ob->flags & FL_HASAUTO) && (!ob->temp3))
						ob->temp3 = (GameRandomNumber("T_Chase FL_HASAUTO",ocl) % 5) + 3;
					ob->target = PLAYER[0];
					NewState(ob,temp);
					return;
				}

			}
			//if ((CheckSight(ob,PLAYER[0])) && (!ob->angle))// &&
					//(ocl != b_heinrichobj))
				//ob->flags |= FL_DODGE;
		}
	}
cdoor:
	doorok = NextToDoor(ob);

	if (ob->dirchoosetime)
		ob->dirchoosetime--;

	if ((ob->flags & FL_STUCK) || (!ob->dirchoosetime) || doorok)
	{
		//if (ob->flags & FL_DODGE)
		//	SelectDodgeDir(ob);
		//else
		SelectChaseDir(ob);
		ob->dirchoosetime = M_CHOOSETIME(ob);
	}
	else
	{
		if (NOMOM)
			ParseMomentum(ob,dirangle8[ob->dir]);
		ActorMovement(ob);
	}
}

void SpawnMissile(objtype *shooter,
	classtype nobclass, int nspeed, int nangle,
	statetype *nstate, int offset)
{
	GetNewActor();
	MakeActive(new);
	new->which = ACTOR;
	new->obclass = nobclass;
	new->angle = nangle;
	new->speed = nspeed;
	if (shooter->obclass == playerobj)
		offset += FindDistance(shooter->momentumx,shooter->momentumy);

	SetFinePosition(new,shooter->x + FixedMul(offset,costable[nangle]),
							shooter->y - FixedMul(offset,sintable[nangle]));
	SetVisiblePosition(new,new->x,new->y);
	//SoftError("\n missx:%d, missy:%d, speed:%d, offset:%d, angle%d, drawx:%d, drawy:%d",
	//			new->x,new->y,nspeed,offset,nangle,new->drawx,new->drawy);

	new->z = shooter->z;
	new->areanumber = shooter->areanumber;
	new->soundhandle = -1;
	if (nobclass != inertobj)
	{
		MakeLastInArea(new);
		if (MissileSound == true)
			new->soundhandle = SD_PlaySoundRTP(BAS[new->obclass].operate,new->x,new->y);
	}

	if ((shooter->obclass == playerobj) || (shooter->obclass == wallopobj) ||
		(shooter->obclass == b_robobossobj))
	{
		Set_3D_Momenta(new,new->speed,new->angle,shooter->yzangle);

		if (nobclass == p_drunkmissileobj)
			new->temp1 = new->momentumz;

		new->z -= FixedMulShift(offset,sintable[shooter->yzangle],26);
		if ((shooter->obclass == playerobj) && (shooter->flags & FL_GODMODE))
			new->z -= 10;
	}
	else
		ParseMomentum(new,new->angle);

	if (nobclass == p_drunkmissileobj)
		new->temp3 = VBLCOUNTER/3;

	new->flags |= (FL_NEVERMARK|FL_ABP|FL_NOFRICTION|FL_FULLLIGHT);
	new->whatever = shooter; // keep track of missile possession
	NewState(new,nstate);
}

/*
=================
=
= T_Roll
=
=================
*/

void T_Roll (objtype *ob)
{
	ActorMovement(ob);
}

/*
===============
=
= T_Path
=
===============
*/

void T_Path (objtype *ob)
{
	int dx,dy,dz,ocl,damage=1;
	objtype*temp,*ttarg,*twhat;

	ocl = ob->obclass;

	if (((ocl == firejetobj) || (ocl == bladeobj)) && (!ob->ticcount))
	{
		if (ocl == bladeobj)
		{
			if (ob->state->condition & SF_DOWN )
				ob->flags &= ~FL_BLOCK;
			else if (ob->state->condition & SF_UP)
			{
				ob->flags |= FL_BLOCK;
				damage = 0;
			}
		}

		if ((ob->state->condition & SF_SOUND) && areabyplayer[ob->areanumber])
			SD_PlaySoundRTP(BAS[ob->obclass].operate,ob->x,ob->y);

		if (damage)
		{
			for(temp=firstareaactor[ob->areanumber];temp;temp=temp->nextinarea)
			{
				if (temp == ob)
					continue;

				if (temp->obclass >= roboguardobj)
					continue;

				//WAS
				ttarg = (objtype*)(temp->target);
				twhat = (objtype*)(temp->whatever);

				if ((M_ISACTOR(ttarg) && (ttarg->obclass == b_robobossobj)) ||
					(M_ISACTOR(twhat) && (twhat->obclass == b_robobossobj))
					)
					continue;

				if ((!(temp->flags & FL_SHOOTABLE)) || (temp->flags & FL_DYING))
					continue;

				if (temp->obclass == playerobj)
				{
					if ((temp->flags & FL_GODMODE) ||
							(temp->flags & FL_DOGMODE))
						continue;
					if ((temp->flags & FL_AV) &&
							(ocl == firejetobj))
						continue;
				}
				dx = temp->x - ob->x;
				if (abs(dx) > 0xa000)
					continue;
				dy = temp->y - ob->y;
				if (abs(dy) > 0xa000)
					continue;

				//if (temp->obclass == playerobj)
				//Collision(temp,-temp->momentumx+ob->momentumx,-temp->momentumy + ob->momentumy);
				dz = temp->z - ob->z;
				if (abs(dz) > 32)
					continue;

				DamageThing(temp,EnvironmentDamage(ob));
				if ((ocl == firejetobj) && (temp->obclass < roboguardobj))
					SD_PlaySoundRTP(SD_PLAYERBURNEDSND,temp->x,temp->y);

				if ((gamestate.violence == vl_excessive) &&
					(temp->obclass < roboguardobj))
				{
					if (ocl == bladeobj)
					{
						SpawnParticles(temp,GUTS,1);
						if (temp->hitpoints <= 0)
							temp->flags |= FL_HBM;
					}
					else if (ocl == firejetobj)
					{
						if ((temp->hitpoints <= 0) &&
							(temp->z == nominalheight))
						{
							temp->hitpoints = 0;
							temp->flags |= FL_SKELETON;
							if (temp->obclass == playerobj)
							{
								playertype *pstate;

								temp->flags &= ~FL_COLORED;
								M_LINKSTATE(temp,pstate);
								pstate->health = 0;
								pstate->weapon = -1;
							}

							Collision(temp,ob,-temp->momentumx,-temp->momentumy);
							M_CheckPlayerKilled(temp);

							continue;
						}
					}
				}
				//SD_PlaySoundRTP(SD_ACTORBURNEDSND,temp->x,temp->y);

	//		if ((ocl == bladeobj) || (ob->state->condition == SF_CRUSH))
				Collision(temp,ob,-temp->momentumx,-temp->momentumy);
				M_CheckPlayerKilled(temp);

			}
		}
	}

	if (ob->dir == nodir)
		return;

	if ((ocl != firejetobj) && (ocl != bladeobj) && (ocl != diskobj))
	{
		if (!ob->ticcount)
		{
			if (SightPlayer (ob))
				return;
		}
		else
			SoftError("\n ob type %s with ticcount %d in T_Path",
				debugstr[ob->obclass], ob->ticcount);
	}

	SelectPathDir (ob);
	if (NOMOM)
		ParseMomentum(ob,dirangle8[ob->dir]);
}

int EnvironmentDamage(objtype *ob)
{
	if (BATTLEMODE && (gamestate.BattleOptions.DangerDamage != bo_danger_normal))
	{
		return(gamestate.BattleOptions.DangerDamage);
	}
	else
	{
		int damage = 1;

		switch(ob->obclass)
		{
		case firejetobj:
		case bladeobj:
			damage = 6;
			break;

		case boulderobj:
			damage = 50;
			break;

		case spearobj:
			damage = 7;
			break;

		case gasgrateobj:
			damage = 20;
			break;

		case wallfireobj:
			damage = ((GameRandomNumber("wallfire damage",0) >>3) + 10);
			break;

		case crushcolobj:
			damage = 10;
			break;
		}

		if (gamestate.difficulty < gd_hard)
			damage >>= 1;

		return damage;
	}
	//SoftError("unknown environment danger");
}

void T_AutoShootAlign(objtype*ob)
{
	if (ob->dir != ob->temp1)
		ob->dir = dirorder16[ob->dir][NEXT];
	else
		NewState(ob,M_S(AIM));
}

void T_AutoRealign(objtype*ob)
{
	if (ob->dir != ob->targettilex)
		ob->dir = dirorder16[ob->dir][NEXT];
	else
	{
		objtype *temp;

		NewState(ob,M_S(PATH));
		for(temp=firstareaactor[ob->areanumber];temp;temp=temp->nextinarea)
		{
			if (temp == ob)
				continue;
			if (temp->obclass != ob->obclass)
				continue;
			if (!temp->state->think)
				NewState(temp,UPDATE_STATES[PATH][temp->obclass-lowguardobj]);
		}
	}
}

/*
===============
=
= T_AutoPath
=
===============
*/

void T_AutoPath (objtype *ob)
{
	objtype *temp;

	// ob->temp3 holds random number of shots before resuming path

	if (CheckLine(ob,PLAYER[0],SIGHT) &&
		(Near(ob,PLAYER[0],4) || MISCVARS->madenoise))
	{
		int dx,dy,destdir,ocl;
		statetype *align,*wait;

		ocl = ob->obclass;
		dx = player->x - ob->x;
		dy = ob->y - player->y;
		destdir = (angletodir[atan2_appx(dx,dy)] << 1);
		ob->temp1 = destdir;
		ob->targettilex = ob->dir; //save old dir
#if (SHAREWARE == 0)
		if (ocl == wallopobj)
		{
			//if (ob->temp3)
			// Error("may be writing over temp3");
			ob->temp3 = (GameRandomNumber("T_WallPath",0)%4) + 1;
			align = &s_wallalign;
			wait = &s_wallwait;
		}
		else
#endif
		{
			align = &s_roboalign;
			wait = &s_robowait;
		}

		NewState(ob,align);
		for(temp=firstareaactor[ob->areanumber];temp;temp=temp->nextinarea)
		{
			if (temp == ob)
				continue;

			if (temp->obclass != ob->obclass)
				continue;

			if (temp->flags & FL_DYING)
				continue;

			if (CheckLine(temp,PLAYER[0],SIGHT) &&
				(Near(temp,PLAYER[0],4) || MISCVARS->madenoise))
			{
				dx = PLAYER[0]->x - temp->x;
				dy = temp->y - PLAYER[0]->y;
				destdir = (angletodir[atan2_appx(dx,dy)] << 1);

				temp->temp1 = destdir;
				temp->targettilex = temp->dir;
				NewState(temp,align);
				temp->temp3 = ob->temp3;
			}
			else
				NewState(temp,wait);
		}
		return;
	}

	SD_PlaySoundRTP(SD_ROBOTMOVESND,ob->x,ob->y);

	SelectPathDir(ob);
}

/*
===============
=
= A_Shoot
=
= Try to damage the player, based on skill level and player's speed
=
===============
*/

void A_Shoot (objtype *ob)
{
	int	dx,dy,dz,dist;
	int	accuracy,damage,sound;
	objtype * target;
	int	num;
	int	savedangle;

	ActorMovement(ob);

	ob->flags |= FL_FULLLIGHT;
	//if (!(ob->flags & FL_SHOOTABLE))
	//Error("\na dead instance of %s is shooting at you",debugstr[ob->obclass]);

	if (!ob->ticcount)
	{
		if (ob->obclass == strikeguardobj)
		ob->flags &= ~FL_NOFRICTION;

		target = (objtype*)(ob->target);
		if (!target)
			Error("an instance of %s called shoot without a target\n",debugstr[ob->obclass]);

		ob->flags &= ~FL_FULLLIGHT;

		dx = (target->x - ob->x);
		dy = (ob->y - target->y);
		dz = target->z-ob->z;

		if ((ob->obclass == blitzguardobj) && (ob->temp3) &&
			(ob->temp3 != stat_gasmask) && (ob->temp3 != stat_asbesto) &&
			(ob->temp3 != stat_bulletproof) &&
			(gamestate.difficulty >= gd_medium) &&
			((abs(dx) > 0xc000) || (abs(dy) > 0xc000))
			)
		{
			int i;
			missile_stats* newmissiledata;

			newmissiledata = &PlayerMissileData[GetWeaponForItem(ob->temp3)];

			// ready to annihilate this poor bastard

			SpawnMissile(ob,
				newmissiledata->obclass, newmissiledata->speed,
				AngleBetween(ob,player), newmissiledata->state,
				newmissiledata->offset);

			if (newmissiledata->obclass == p_drunkmissileobj)
			{
				for(i=0;i<4;i++)
				{
				SpawnMissile(ob,newmissiledata->obclass,newmissiledata->speed,
								AngleBetween(ob,player), newmissiledata->state,
								newmissiledata->offset);
				}
			}
			ob->target = NULL;
			ob->temp2 --;
			if (ob->temp2 == 0)
				ob->temp3 = 0;
			return;
		}

		if ((!areabyplayer[ob->areanumber]) && (target->obclass ==  playerobj))
			return;

		//if (!CheckLine(ob,target,SHOOT))		// player is behind a wall
		//return;

		savedangle=ob->angle;
		ob->angle = atan2_appx (dx,dy);
		dist = FindDistance(dx,dy);
		ob->yzangle = FINEANGLES-atan2_appx(dist, dz<<10);

		if ((ob->yzangle>MAXYZANGLE) && (ob->yzangle<FINEANGLES-MAXYZANGLE))
			ob->yzangle=MAXYZANGLE;

		dist>>=16;

		accuracy=(WHICHACTOR<<4)+((gamestate.difficulty) << 6);

		num = GameRandomNumber("A_Shoot3",ob->obclass);

		if (num<128) num=128; // Don't let accuracy fall below 50% original

		accuracy=FixedMulShift(num,accuracy,8); // scale accuracy based off randomness

		// check for maximum accuracy;

		if (accuracy>255) accuracy=255;

		if (ob->obclass==highguardobj)
			damage=DMG_MP40;
		else if (ob->obclass == triadenforcerobj)
			damage=DMG_MP40;
		else
			damage=DMG_ENEMYBULLETWEAPON;

		RayShoot (ob, damage, 255-accuracy);

		ob->angle=savedangle;
		sound = BAS[ob->obclass].fire;
		SD_PlaySoundRTP(sound,ob->x,ob->y);
		MISCVARS->madenoise = true;
		if ((!(ob->flags& FL_HASAUTO)) || (!ob->temp3))
			ob->target = NULL;
	}
}

void A_Repeat(objtype*ob)
{
	ActorMovement(ob);

	if (!ob->ticcount)
	{
		ob->temp3 --;
		if (ob->temp3 <= 0)
		NewState(ob,M_S(CHASE));
	}
}

void  A_MissileWeapon(objtype *ob)
{
	int	sound,nspeed,noffset,zoffset;

#if (SHAREWARE == 0)
	int oldyzangle;
#endif
	classtype nobclass;
	statetype*nstate;

	if ((ob->obclass == wallopobj) || (ob->obclass == roboguardobj));
	//SelectPathDir(ob);
	else
	ActorMovement(ob);

	if (!ob->ticcount)
	{
#if (SHAREWARE == 0)
		if ((ob->obclass == wallopobj) && (!ob->temp3))
		{
			NewState(ob,&s_wallrestore);
			return;
		}
#endif
		if ((ob->obclass == b_darianobj) &&
			(!CheckLine(ob,PLAYER[0],SHOOT)))
		{
			NewState(ob,M_S(CHASE));
			return;
		}
		// Move sounds, flags into switch cases

		sound = BAS[ob->obclass].fire;
		nspeed = 0x4000;
		noffset = 0x8000;
		zoffset = 0;
		switch (ob->obclass)
		{
		case triadenforcerobj:
			nobclass = grenadeobj;
			nstate= &s_grenade1;
			sound++;
			break;

		case roboguardobj:
			nobclass = shurikenobj;
			nspeed = 0x2000;
			noffset = 0x10000;
			nstate = &s_robogrdshuriken1;
			break;

		/*
		case b_darkmonkobj:
			nobclass = dmfballobj;
			nstate = &s_dmfball1;
			break;
		*/
		/*
		case b_robobossobj:
			nobclass = bigshurikenobj;
			nstate = &s_oshuriken1;
			break;
			*/
#if (SHAREWARE == 0)
		case b_darianobj:
			nobclass = missileobj;
			//nspeed = 0x100;
			//noffset = 0x18000;
			nstate = &s_missile1;
			zoffset = -20;
			break;

		case dfiremonkobj:
			nobclass = fireballobj;
			nstate = &s_monkfire1;
			break;

		case overpatrolobj:
			nobclass = netobj;
			nstate = &s_bolocast1;
			sound ++;
			break;

		case wallopobj:
			{
				int dx,dy,dz,xydist;

				ob->temp2 ^= 1; // increment numfired
				ob->temp3 --; // decrement random fire no.

				dx = PLAYER[0]->x-ob->x;
				dy = ob->y-PLAYER[0]->y;
				if (GameRandomNumber("bcraft shoot up/down",0) < 128)
					dz = 10;
				else
					dz = -10;
				xydist = FindDistance(dx,dy);
				oldyzangle = ob->yzangle;
				ob->yzangle = atan2_appx(xydist,dz<<10);
				if (ob->temp2)
				{
					nobclass = missileobj;
					nstate = &s_missile1;
				}
				else
				{
					nobclass = bigshurikenobj;
					nstate = &s_bstar1;
				}
			}
			break;
#endif
		}

		SpawnMissile(ob,nobclass,nspeed,AngleBetween(ob,PLAYER[0]),nstate,noffset);
		new->z += zoffset;
		SD_PlaySoundRTP(sound,ob->x,ob->y);
		MISCVARS->madenoise = true;
		if (ob->obclass == triadenforcerobj)
		{
			//new->flags |= (FL_SHOOTABLE);
			new->temp1 = 0x50000;
		}
#if (SHAREWARE == 0)
		else if (ob->obclass == wallopobj)
		ob->yzangle = oldyzangle;
#endif

	}
}

void	A_Wallfire(objtype *ob)
{
	if (!(ob->flags & FL_ACTIVE))
		return;

	if (!ob->ticcount)
	{
		SpawnMissile(ob,wallfireobj,0x4000,ob->angle,&s_crossfire1,0xa000);
		if (areabyplayer[ob->areanumber])
		SD_PlaySoundRTP(SD_FIRECHUTESND,ob->x,ob->y);
		new->dir = angletodir[new->angle];
		new->z = nominalheight;
	}

}

void T_Reset(objtype *ob)
{
	ActorMovement(ob);

	if (ob->ticcount)
		return;

	ob->momentumx = ob->momentumy = ob->dirchoosetime = 0;
	ob->flags &= ~FL_NOFRICTION;
}

void SelectRollDir(objtype *ob)
{
	int angle,tryx,tryy;

	if (ob->state == &s_strikerollright1)
		angle = AngleBetween(ob,PLAYER[0]) + ANGLES/4;
	else
		angle = AngleBetween(ob,PLAYER[0]) - ANGLES/4;

	Fix(angle);
	tryx = ob->x + FixedMul(0x20000l,costable[angle]);
	tryy = ob->y - FixedMul(0x20000l,sintable[angle]);
	ZEROMOM;
	if (QuickSpaceCheck(ob,tryx,tryy))
	{
		int oldspeed;
		oldspeed = ob->speed;
		ob->speed = ROLLMOMENTUM;
		ParseMomentum(ob,angle);
		ob->speed = oldspeed;
		ob->dirchoosetime = 5;
		ob->flags |= FL_NOFRICTION;
	}
	else
		ob->dirchoosetime = 0;
}

void SelectDodgeDir (objtype *ob)
{
	int		dx,dy,i,tx,ty;
	unsigned absdx,absdy;
	dirtype  dirtry[5];
	dirtype  turnaround,tdir,olddir;

	olddir = ob->dir;
	if (ob->flags & FL_FIRSTATTACK)
	{
	//
	// turning around is only ok the very first time after noticing the
	// player
	//
		turnaround = nodir;
		ob->flags &= ~FL_FIRSTATTACK;
	}
	else
		turnaround=opposite[ob->dir];

	if (ob->targettilex || ob->targettiley)
	{
		tx = ob->targettilex;
		ty = ob->targettiley;
		dx= tx - ob->x;
		dy= ty - ob->y;
		if ( ((dx < MINACTORDIST) && (dx > -MINACTORDIST)) &&
				((dy < MINACTORDIST) && (dy > -MINACTORDIST)))
		{
			dx= PLAYER[0]->x-ob->x;
			dy= PLAYER[0]->y-ob->y;
		}
	}
	else
	{
		dx= PLAYER[0]->x-ob->x;
		dy= PLAYER[0]->y-ob->y;
	}

//
// arange 5 direction choices in order of preference
// the four cardinal directions plus the diagonal straight towards
// the player
//
	if (dx>ACTORSIZE)
	{
		dirtry[1]= east;
		dirtry[3]= west;
	}
	else if (dx < -ACTORSIZE)
	{
		dirtry[1]= west;
		dirtry[3]= east;
	}

	if (dy>ACTORSIZE)
	{
		dirtry[2]= south; // south
		dirtry[4]= north; // north
	}
	else if (dy <-ACTORSIZE)
	{
		dirtry[2]= north; // north
		dirtry[4]= south; // south
	}

//
// randomize a bit for dodging
//
	absdx = abs(dx);
	absdy = abs(dy);

	if (absdx > absdy)
	{
		tdir = dirtry[1];
		dirtry[1] = dirtry[2];
		dirtry[2] = tdir;
		tdir = dirtry[3];
		dirtry[3] = dirtry[4];
		dirtry[4] = tdir;
	}

	if (GameRandomNumber("SelectDogeDir",ob->obclass) < 128)
	{
		tdir = dirtry[1];
		dirtry[1] = dirtry[2];
		dirtry[2] = tdir;
		tdir = dirtry[3];
		dirtry[3] = dirtry[4];
		dirtry[4] = tdir;
	}

	dirtry[0] = diagonal [dirtry[1]] [dirtry[2]];

	ZEROMOM;

	for (i=0;i<5;i++)
	{
		if ((dirtry[i] == nodir) || (dirdiff[dirtry[i]][olddir] > 1))
			continue;
		M_CHECKDIR(ob,dirtry[i]);
	}

//
// turn around only as a last resort
//
//	for(tdir = east;tdir<=southeast;tdir++)
	//if (tdir != turnaround)
//	M_CHECKDIR(ob,tdir);

	if (turnaround != nodir)
		M_CHECKDIR(ob,turnaround);
}

#define TryAbruptProximalDirections(trydir)				\
	{																	\
	next = dirorder[trydir][NEXT];							\
	prev = dirorder[trydir][PREV];							\
	if (GameRandomNumber("actor choose dir",0) < 128)	\
		{																\
		dirtype temp = next;										\
																		\
		next = prev;												\
		prev = temp;												\
		}																\
																		\
	if (!dirtried[next])											\
		{																\
		M_CHECKDIR(ob,next);										\
		dirtried[next]=1;											\
		}																\
																		\
	if (!dirtried[prev])											\
		{																\
		M_CHECKDIR(ob,prev);										\
		dirtried[prev]=1;											\
		}																\
																		\
	}

#define TrySmoothProximalDirections(trydir)						\
	{															\
																\
	if (((trydir == olddir) || (dirdiff[trydir][olddir] < 2)) &&	\
		(!dirtried[trydir]))													\
		{																				\
		M_CHECKDIR(ob,trydir);													\
		dirtried[trydir] = 1;													\
		}																				\
	next = dirorder[olddir][NEXT];											\
	prev = dirorder[olddir][PREV];											\
																						\
	if (dirdiff[trydir][next] <= dirdiff[trydir][prev])				\
		{																				\
		start = next;																\
		whichway = NEXT;															\
		}																				\
	else																				\
		{																				\
		start = prev;																\
		whichway = PREV;															\
		}																				\
																						\
	for (tdir= start; tdir != dirorder[trydir][whichway];			\
		tdir = dirorder[tdir][whichway]									\
		)																			\
		{																				\
		if (dirtried[tdir])														\
			continue;																\
		M_CHECKDIR(ob,tdir);													\
		dirtried[tdir]=1;														\
		}																				\
																						\
	}

#define ChasePlayer(ob)								\
{															\
	dx= player->x-ob->x;								\
	dy= ob->y-player->y;								\
	if ((abs(dx) < 0xb000) && (abs(dy) < 0xb000)) \
		return;												\
	dummy.x = player->x;								\
	dummy.y = player->y;								\
}

void SelectChaseDir (objtype *ob)
{
	int dx,dy,whichway,tx,ty,actrad,visible,
		realdiff;
	dirtype dtry1,dtry2,tdir,olddir,next,prev,start,straight;
	tpoint dummy;
	byte dirtried[9] = {0};

	olddir=ob->dir;
	visible = CheckLine(ob,PLAYER[0],SIGHT);

	/*
	if (ob->flags & FL_FIRSTATTACK)
	{
	//
	// turning around is only ok the very first time after noticing the
	// player
	//
		turnaround = opposite[ob->dir];
		ob->flags &= ~FL_FIRSTATTACK;
	}
	else
		turnaround=nodir;
	*/
	dummy.which = ACTOR;
	dummy.z = ob->z;
	if (ob->targettilex || ob->targettiley)
		{
		tx = ob->targettilex;
		ty = ob->targettiley;
		dx= tx - ob->x;
		dy= ob->y - ty;
		dummy.x = tx;
		dummy.y = ty;
		if ((abs(dx) < 0x2000) && (abs(dy) < 0x2000))
			ChasePlayer(ob);
		}
	else
		ChasePlayer(ob);

	//if ((abs(dx) < 0x10000) && (abs(dy) < 0x10000))
	//return;
	straight = angletodir[atan2_appx(dx,dy)];
	realdiff = dirdiff[straight][ob->dir];
	ZEROMOM;

	//insertion 20

	actrad = ACTORSIZE;
	dtry1=nodir;
	dtry2=nodir;

	if (dx> actrad)
		dtry1= east;
	else if (dx< -actrad)
		dtry1= west;
	if (dy> actrad)
		dtry2=north;
	else if (dy < -actrad)
		dtry2= south;

	if (abs(dy)>abs(dx))
		{
		tdir=dtry1;
		dtry1=dtry2;
		dtry2=tdir;
		}

	if (GameRandomNumber("chase minor",0) < 80)
		{
		tdir=dtry1;
		dtry1=dtry2;
		dtry2=tdir;
		}

	ZEROMOM;

	if ((!visible) || (realdiff > 2))  // don't worry about abrupt or unrealistic turns if player
						// can't see guards
		{
		M_CHECKDIR(ob,straight);
		dirtried[straight]=1;
		next = dirorder[straight][NEXT];
		prev = dirorder[straight][PREV];

		if ((dtry1 != nodir) && (dtry1 != straight))
			{
			M_CHECKDIR(ob,dtry1);
			dirtried[dtry1]=1;
			}

		if ((dtry2 != nodir) && (!dirtried[dtry2]))
			{
			M_CHECKDIR(ob,dtry2);
			dirtried[dtry2]=1;
			}

		if (dtry1 != nodir)
			TryAbruptProximalDirections(dtry1);

		if (dtry2 != nodir)
			TryAbruptProximalDirections(dtry2);
		}

	else
		{
		if (realdiff < 2)
			{
			M_CHECKDIR(ob,straight);
			dirtried[straight]=1;
			}

		if (dtry1 != nodir)
			TrySmoothProximalDirections(dtry1);

		if (dtry2 != nodir)
			TrySmoothProximalDirections(dtry2);

		}

	if ((dtry1!=nodir) || (dtry2!=nodir))
		{
		if (GameRandomNumber("actor choose dir",0) < 128)
			whichway = NEXT;
		else
			whichway = PREV;

		for(tdir = dirorder[olddir][whichway];tdir != olddir;tdir = dirorder[tdir][whichway])
			{
			if (dirtried[tdir])
				continue;
			M_CHECKDIR(ob,tdir);
			}
		}

	ob->dir = olddir;
}

int Near(objtype *ob,void* what,int distance)

{
	objtype *aw;

	aw = (objtype*) what;

	if (FindDistance((aw->x - ob->x),(aw->y - ob->y)) <= (distance<<16))
		return 1;
	return 0;
}

/*
===============
=
= SelectPathDir
=
===============
*/

void SelectPathDir (objtype *ob)
	{
	int spot,centerx,centery,dx,dy,set,done,radius,ocl;

	ocl = ob->obclass;

	if ((ocl == bladeobj) && (!(ob->flags & FL_ACTIVE)))
	return;

	spot = MAPSPOT(ob->tilex,ob->tiley,1)-ICONARROWS;
	set = ((ocl == wallopobj) || (ocl == roboguardobj));
	done = (((!set) && (ob->dir == spot)) ||
			(set && (ob->dir == (spot<<1))));

	if ((spot >= 0) && (spot<= 7) && (!done))
		{
		centerx= (ob->tilex << 16) + HALFGLOBAL1;
		centery= (ob->tiley << 16) + HALFGLOBAL1;
		dx = abs(centerx - ob->x);
		dy = abs(centery - ob->y);
		//radius = (ob->speed > 0x4800)?(0xb000):(0x4000);
		radius = 0x4000;

		if ((dx < radius) && (dy < radius))
	// new direction
			{
			ZEROMOM;
			if ((ocl == wallopobj) || (ocl == roboguardobj))
			{
			ob->dir = spot<<1;
			ParseMomentum(ob,dirangle16[ob->dir]);
			}
			else
			{
			ob->dir = spot;
			ParseMomentum(ob,dirangle8[ob->dir]);
			}
			dx = centerx - ob->x;
			dy = centery - ob->y;
			SetFinePosition(ob,centerx,centery);
			SetVisiblePosition(ob,centerx,centery);
		/*
		if (((ocl == bladeobj) || (ocl == diskobj)) && ob->whatever)
			{objtype*passenger = (objtype*)(ob->whatever);

			passenger->x += dx;
			passenger->y += dy;
			passenger->drawx = passenger->x;
			passenger->drawy = passenger->y;
			passenger->tilex = passenger->x >> 16;
			passenger->tiley = passenger->y >> 16;
			}*/
//		if (ob==SNAKEHEAD)
//		Debug("\n path changed at %d, %d",
//			ob->tilex,ob->tiley);
			}
		}
	if (NOMOM)
		{
		if ((ocl == wallopobj) || (ocl == roboguardobj))
			ParseMomentum(ob,dirangle16[ob->dir]);
		else
			ParseMomentum(ob,dirangle8[ob->dir]);
		}

	//if ((ob->obclass == firejetobj) || (ob->obclass == bladeobj))
	//MoveActor(ob);
	//else
	ActorMovement(ob);

	}

/*
================
=
= CheckSight
=
= Checks a straight line between player and current object
=
= If the sight is ok, check alertness and angle to see if they notice
=
= returns true if the player has been spoted
=
================
*/

boolean CheckSight (objtype *ob,void *atwhat)
{
	long	deltax,deltay;
	objtype * what;
//
// don't bother tracing a line if the area isn't connected to the player's
//
	if (!areabyplayer[ob->areanumber])
		return false;

//
// if the player is real close, sight is automatic
//
	what = (objtype*)atwhat;
	deltax = what->x - ob->x;
	deltay = what->y - ob->y;

	if ((deltax > -MINSIGHT) && (deltax < MINSIGHT)	&&
		(deltay > -MINSIGHT) && (deltay < MINSIGHT))
		return true;

//
// see if they are looking in the right direction
//
	switch (ob->dir)
	{
	case north:
		if (deltay > 0)
			return false;
		break;

	case east:
		if (deltax < 0)
			return false;
		break;

	case south:
		if (deltay < 0)
			return false;
		break;

	case west:
		if (deltax > 0)
			return false;
		break;
	}

//
// trace a line to check for blocking tiles (corners)
//
	return CheckLine (ob,atwhat,SIGHT);

}

void ActivateEnemy(objtype*ob)
{
	statetype *temp;

	ob->flags |= (FL_ATTACKMODE|FL_FIRSTATTACK);
	if (ob->obclass == roboguardobj)
		return;

	if (ob->temp3 == SNEAKY)
	{
		NewState(ob,&s_sneakyrise1);
		ob->temp3=0;
	}
	else if ((temp = M_S(CHASE)) != NULL)
		NewState(ob,temp);
	/*
	ob->speed = ENEMYRUNSPEED;
	*/
	if (ob->obclass == b_heinrichobj)
		ob->speed = 7*ob->speed/2;
	else if (ob->obclass == b_darianobj)
		ob->speed = 3*SPDPATROL;
	if (ob->door_to_open != -1)
		ob->door_to_open = -1; // ignore the door opening command
	ob->dirchoosetime = 0;
}

/*
===============
=
= FirstSighting
=
= Puts an actor into attack mode and possibly reverses the direction
= if the player is behind it
=
===============
*/

void FirstSighting (objtype *ob)
{
	statetype *temp;
	int sound;

	if (ob->temp3 == SNEAKY)
	{
		NewState(ob,&s_sneakyrise1);
		ob->temp3=0;
		if (ob->shapeoffset==0)
			SD_PlaySoundRTP(SD_SNEAKYSPRINGMSND,ob->x,ob->y);
		else
			SD_PlaySoundRTP(SD_SNEAKYSPRINGFSND,ob->x,ob->y);
	}
	else if ((temp = M_S(CHASE)) != NULL)
	{
		int rand;

		NewState(ob,temp);
		sound = BAS[ob->obclass].see;
		rand = GameRandomNumber("FirstSighting low",0);
		if ((ob->obclass > lowguardobj) && (ob->obclass <= blitzguardobj) && (rand < 128)) //hack for alternate
			sound++;
			//if ((ob->obclass == lowguardobj) && (rand < 80))
			//sound ++;
		else if (ob->obclass == lowguardobj)
		{
			if (rand < 128)
			{
				if ((PLAYERSTATE[0].player == 1) ||
					(PLAYERSTATE[0].player == 3))
					sound++;
			}
			else
				sound += 2;

			if (ob->shapeoffset)
				sound += 4;
		}
		SD_PlaySoundRTP(sound,ob->x,ob->y);
		if ((ob->obclass>=b_darianobj) && (ob->obclass<=b_darksnakeobj))
		{
			MU_StartSong(song_bosssee);
		}
	}

	/*
	ob->speed = ENEMYRUNSPEED;*/
	if (ob->obclass == b_heinrichobj)
		ob->speed = 7*ob->speed/2;
	else if (ob->obclass == b_darianobj)
		ob->speed = 3*SPDPATROL;
	if (ob->door_to_open != -1)
	ob->door_to_open = -1; // ignore the door opening command
	ob->dirchoosetime = 0;
	ob->flags |= (FL_ATTACKMODE|FL_FIRSTATTACK);
}

/*
===============
=
= SightPlayer
=
= Called by actors that ARE NOT chasing the player.  If the player
= is detected (by sight, noise, or proximity), the actor is put into
= it's combat frame and true is returned.
=
= Incorporates a random reaction delay
=
===============
*/

boolean SightPlayer (objtype *ob)
{
	//if (ob->flags & FL_ATTACKMODE)
	//Error ("An instance of %s in ATTACKMODE called SightPlayer!",debugstr[ob->obclass]);

	if (!areabyplayer[ob->areanumber])
		return false;

	if (ob->obclass == b_robobossobj)
		{
		if (!(CheckSight(ob,player) || Near(ob,player,6)))
			return false;

		}

	else if (ob->flags & FL_AMBUSH)
		{
		if (!CheckSight (ob,PLAYER[0]))
			{
			//SoftError("\n failed from ambush in SightPlayer");
			return false;
			}
		ob->flags &= ~FL_AMBUSH;
		}
	else
	{
		if (ob->temp3 == SNEAKY)
		{
			if (!Near(ob,PLAYER[0],2))
				return false;
		}
		else if (!((MISCVARS->madenoise) ||
					(CheckSight (ob,player)) ||
					(Near(ob,player,4))
					)
				)
		{
			//SoftError("\n failed from SightPlayer");
			return false;
		}
	}

	FirstSighting (ob);

	return true;
}

/*
=====================
=
= CheckLine
=
= Returns true if a straight line between two obs is unobstructed
=
=====================
*/

boolean CheckLine (void *from, void *to, int condition)
{
	objtype	*tempactor,*ob,*orig;
	statobj_t *checksprite;
	int destx,desty,destz;
	int desttilex,desttiley;
	int snx,sny;
	int incr[2];
	int thedir[2];
	int cnt;
	int grid[2];
	int index;
	int vx,vy;
	int yzangle;
	int value;
	int dx,dy,dz;
	int xydist;
	int otx,oty,count=0;

	ob = (objtype*)to;
	orig = (objtype*)from;
	if (ob->which == SPRITE)
	{
		destx = ((statobj_t*)to)->x;
		desty = ((statobj_t*)to)->y;
		destz = ((statobj_t*)to)->z;
	}
	else
	{
		destx = ob->x;
		desty = ob->y;
		destz = ob->z;
	}

	desttilex=destx>>16;
	desttiley=desty>>16;

	if ((desttilex == orig->tilex) && (desttiley == orig->tiley))
		return true;

	dx=destx-orig->x;
	dy=orig->y-desty;
	dz=orig->z-destz;
	xydist = FindDistance(dx,dy);
	yzangle = atan2_appx(xydist,dz<<10);

	if ((yzangle>MAXYZANGLE) && (yzangle<FINEANGLES-MAXYZANGLE))
	{
		#if (0)
		Debug("\nfailed from yzangle");
		#endif
		return false;
	}

	//angle = atan2_appx(dx,dy);
	otx = orig->x >> TILESHIFT;
	oty = orig->y >> TILESHIFT;

	if (xydist==0)
	{
		/*
		SoftError("\nCheckLine:xydist=0");
		if (orig->which == ACTOR)
		SoftError("shooter: %s",debugstr[orig->obclass]);
		if (ob->which == ACTOR)
		SoftError("target: %s",debugstr[ob->obclass]);*/
		vy=-dy;
		vx=dx;
	}
	else
	{
		vy = -FixedDiv2(dy,xydist);
		vx = FixedDiv2(dx,xydist);
	}
	snx=orig->x&0xffff;
	sny=orig->y&0xffff;

	grid[0]=otx;
	grid[1]=oty;

	if (vx>0)
	{
		thedir[0]=1;
		snx^=0xffff;
		incr[1]=-vx;
	}
	else
	{
		thedir[0]=-1;
		incr[1]=vx;
	}
	if (vy>0)
	{
		thedir[1]=1;
		sny^=0xffff;
		incr[0]=vy;
	}
	else
	{
		thedir[1]=-1;
		incr[0]=-vy;
	}
	cnt=FixedMul(snx,incr[0])+FixedMul(sny,incr[1]);

	do
	{
		count ++;
		/*
		if (count > 1000)
			Error("possible infinite loop in CheckLine");
		if ((grid[0] < 0) || (grid[0] > (MAPSIZE-1)) ||
			(grid[1] < 0) || (grid[1] > (MAPSIZE-1)))
			Error("out of bounds in check line, grid[0] = %d, grid[1] = %d",grid[0],grid[1]);
		*/
		if ((grid[0]==desttilex) && (grid[1]==desttiley))
			return true;
		tempactor = (objtype*)actorat[grid[0]][grid[1]];
		value = tilemap[grid[0]][grid[1]];
		checksprite = sprites[grid[0]][grid[1]];
		if (value)
			{
			if (value&0x8000)
				{
				if (!(value&0x4000))
					{
					doorobj_t*dptr = doorobjlist[value&0x3ff];

					if (dptr->position < 0x8000)
						{

						int x = (grid[0] << 16) + 0x8000;
						int y = (grid[1] << 16) + 0x8000;

						if (dptr->vertical)
							{
							if (abs(dx) > abs(x-orig->x))
								return false;
							}
						else
							{
							if (abs(dy) > abs(orig->y-y))
								return false;
							}
						}
					}
				else
					{
					if (condition == SHOOT)
						{
						if ( maskobjlist[value&0x3ff]->flags & MW_SHOOTABLE )
							{
							#if (0)
							SoftError("\nfailed from shootable mask");
						#endif
							return false;
							}
						else if ( maskobjlist[value&0x3ff]->flags & MW_WEAPONBLOCKING )
							{
							#if (0)
							SoftError("\nfailed from block mask");
							#endif
							return false;
							}
						}
					else if ((condition == MISSILE) &&
								( maskobjlist[value&0x3ff]->flags & MW_BLOCKING )
							)
						return false;
					}
				}
			else
				{
				#if (0)
				SoftError("\n obx %d, oby %d, origx %d, origy %d"
							"\n xydist %d, vx %d, vy %d",ob->x,ob->y,orig->x,
							orig->y,xydist,vx,vy);

				SoftError("\nfailed from normal wall");
				#endif
				return false;
				}
			}
		if (condition == SHOOT)
		{
			if (tempactor && (tempactor->which == ACTOR) &&
				(tempactor->flags & FL_BLOCK) && (tempactor != orig) &&
				(tempactor != ob)) //&&
//				(InRange(orig,tempactor,
//				FindDistance(orig->x-tempactor->x,orig->y-tempactor->y) )
//				==true) )
			{
				#if (0)
				SoftError("\nfailed from actor");
				#endif
				return false;
			}
		}

		if (checksprite && (checksprite->flags & FL_BLOCK) &&
			(condition == SHOOT) &&
			((void *)checksprite != to) &&
			(checksprite->itemnumber!=stat_disk) &&
			(InRange(orig,(objtype *)checksprite,
			FindDistance(orig->x-checksprite->x,orig->y-checksprite->y) )
			==true) )

		{
			#if (0)
			SoftError("\nfailed from sprite");
			#endif
			return false;
		}

		if (tempactor && (tempactor->which == PWALL))
		{
		#if (0)
			SoftError("\nfailed from pushwall");
			#endif
			return false;
		}
		index=(cnt>=0);
		cnt+=incr[index];
		grid[index]+=thedir[index];
	}
	while (1);
}

/*
=====================
=
= ShootActor
=
= Shoot an actor.
=
=====================
*/
void ShootActor(objtype * shooter, objtype * target, int damage, int accuracy, int angle)
{
	int dx,dy,dist;
	int newmomx, newmomy;
	int tcl;

	if (target->flags & FL_DYING)
		return;

	dx = abs(shooter->x - target->x);
	dy = abs(shooter->y - target->y);
	dist = FindDistance(dx,dy)>>16;

	tcl=target->obclass;

	if (tcl==playerobj)
		{
		target->target=shooter;
		if (target->flags&FL_BPV)
			{
			playertype *pstate;

			M_LINKSTATE(target,pstate);
			pstate->protectiontime -= (damage<<1);
			if (pstate->protectiontime < 1)
				pstate->protectiontime = 1;
			if (target==player)
				GM_UpdateBonus (pstate->protectiontime, false);
			return;
			}
		else if ((target->flags&FL_GODMODE) || (target->flags&FL_DOGMODE) || godmode)
			return;
		//damage=FixedMulShift((gamestate.difficulty+1),damage,2); // player object difficulty
		}

	else if (tcl == NMEsaucerobj)
	{
		target->momentumx = target->momentumy = 0;
		NewState(target,&s_explosion1);
		target->flags &= ~FL_SHOOTABLE;
		return;
	}
	else if (tcl == b_darianobj)
		MISCVARS->ESAU_SHOOTING = false;
	else if ((tcl == strikeguardobj) || (tcl == b_heinrichobj))
		target->target = shooter;

	if ((  (!(target->flags & FL_SHOOTABLE)) ||
			(tcl == roboguardobj) || (tcl == wallopobj) ||
			(tcl == patrolgunobj) ) &&
		(tcl!=playerobj)  )
		SpawnMetalSparks(target,angle);

	else if ((tcl < b_darianobj) || (tcl > b_darksnakeobj))
	{

		//target->flags &= ~FL_USE;

		damage=FixedMulShift(511-accuracy,damage,9); // Min half damage
		if (dist<64)
		{
			if (dist>2)
				damage=FixedMulShift(63-dist,damage,6);
			if (damage<1)
				damage=1;
		}
		else
			damage=1;

		if (damage>MAXDAMAGE) damage=MAXDAMAGE; // absolutely clip it

		DamageThing(target,damage);
		if ((tcl == collectorobj) && gamestate.SpawnDeluder)
		{
			Collision(target,shooter,0,0);
			if (target->hitpoints <= 0)
				BATTLE_CheckGameStatus(battle_shot_deluder,shooter->dirchoosetime);
		}
		else
		{
			newmomx = FixedMul(damage<<7,costable[angle]);
			newmomy = -FixedMul(damage<<7,sintable[angle]);
			Collision(target,shooter,
				-(target->momentumx)+newmomx,
				-(target->momentumy)+newmomy);
			if (tcl == playerobj)
			{
				playertype *pstate;

				M_LINKSTATE(target,pstate);
				if (pstate->health <= 0)
				{
					if (shooter->obclass == playerobj)
					{
						if (!target->momentumz)
							BATTLE_PlayerKilledPlayer(
								battle_kill_with_bullet,
								shooter->dirchoosetime,
								target->dirchoosetime);
						else
							BATTLE_PlayerKilledPlayer(
								battle_kill_with_bullet_in_air,
								shooter->dirchoosetime,
								target->dirchoosetime);
					}
				}
			}
//		SoftError("ShootActor: damage=%ld dist=%ld\n",damage,dist);

			if ((GameRandomNumber("disembowel",0)<64) &&
				(gamestate.violence == vl_excessive))
			{
				int temp;
				temp=target->temp1;
				target->temp1=angle;

				SpawnParticles(target,DISEMBOWEL,damage>>3);
				target->temp1=temp;
			}
			else if (gamestate.violence > 0)
				SpawnBlood(target,angle);
		}
	}
}

/*
=====================
=
= ShootSprite
=
= Shoot a sprite.
=
=====================
*/
void ShootSprite(objtype * shooter,
	statobj_t * target, int damage,
	int accuracy, int angle)
{
	int dx,dy,dist;

	if (!(target->flags & FL_SHOOTABLE))
	{
// Watchout for sprite being passed in as actor WARNING
		SpawnMetalSparks((objtype *)target,angle);
	}
	else
	{
		dx = abs(shooter->x - target->x);
		dy = abs(shooter->y - target->y);
		dist = FindDistance(dx,dy)>>16;

		damage=FixedMulShift(511-accuracy,damage,9); // Min half damage
		if (dist<64)
		{
			if (dist>2)
				damage=FixedMulShift(63-dist,damage,6);
			if (damage<1)
				damage=1;
		}
		else
			damage=1;

		if (damage>MAXDAMAGE) damage=MAXDAMAGE; // absolutely clip it

	//	SoftError("ShootSprite: damage=%ld dist=%ld\n",damage,dist);

		DamageThing((objtype *)target,damage);
		if (FirstExplosionState(new->state))
			new->whatever = shooter;

		SpawnStaticDamage(target, angle);
	}
}

/*
=====================
=
= RayShoot
=
= Cast a ray out at the shooter's angle and yzangle, return
=
=====================
*/

void RayShoot (objtype * shooter, int damage, int accuracy)
{
	objtype	*tempactor;
	statobj_t *checksprite;
	int snx,sny;
	int incr[2];
	int zincr[2];
	int thedir[2];
	int cnt;
	int grid[2];
	int index;
	int vx,vy;
	int angle;
	int yzangle;
	int value;
	int offset;
	int z, tcnt;
	int lastcnt;
	int bullethole=0;
	enum {gs_door, gs_wall, gs_floor, gs_ceiling, gs_pushwall};
	int smokecondition=0;

	if ((shooter->areanumber==player->areanumber) &&
		(Near(shooter,player,3)))
	{
		SetIllumination(2);
	}

	offset = ((GameRandomNumber("RayShoot",0)-128)>>MAXSHOOTSHIFT);
	offset = FixedMulShift(accuracy,offset,8);

	if (offset>MAXSHOOTOFFSET)
	{
		offset=MAXSHOOTOFFSET;
	}
	else if (offset<-MAXSHOOTOFFSET)
	{
		offset=-MAXSHOOTOFFSET;
	}

	angle=(shooter->angle+offset)&(FINEANGLES-1);

	offset = ((GameRandomNumber("RayShoot",1)-128)>>MAXSHOOTSHIFT);
	offset = FixedMulShift(accuracy,offset,8);

	if (offset>MAXSHOOTOFFSET)
	{
		offset=MAXSHOOTOFFSET;
	}
	else if (offset<-MAXSHOOTOFFSET)
	{
		offset=-MAXSHOOTOFFSET;
	}

	yzangle=(shooter->yzangle+offset)&(FINEANGLES-1);

	vy = -sintable[angle];
	vx = costable[angle];
	snx=shooter->x&0xffff;
	sny=shooter->y&0xffff;
	grid[0]=shooter->tilex;
	grid[1]=shooter->tiley;
	if (shooter->obclass==playerobj)
	{
		playertype * pstate;

		M_LINKSTATE(shooter,pstate);
		z=shooter->z+pstate->playerheight-32;
	}
	else
		z=shooter->z-7;

	if (vx>0)
	{
		thedir[0]=1;
		snx^=0xffff;
		incr[1]=-vx;
	}
	else
	{
		thedir[0]=-1;
		incr[1]=vx;
	}
	if (vy>0)
	{
		thedir[1]=1;
		sny^=0xffff;
		incr[0]=vy;
	}
	else
	{
		thedir[1]=-1;
		incr[0]=-vy;
	}
	zincr[0]=-FixedMulShift(sintable[yzangle],abs(vx),26);
	zincr[1]=-FixedMulShift(sintable[yzangle],abs(vy),26);

	cnt=FixedMul(snx,incr[0])+FixedMul(sny,incr[1]);
	index= (cnt >= 0);
	
	tcnt=1024;
	do
	{
		tempactor = (objtype*)actorat[grid[0]][grid[1]];
		value = tilemap[grid[0]][grid[1]];
		checksprite = sprites[grid[0]][grid[1]];
		if (value)
		{
			if (value&0x8000)
			{
				if (!(value&0x4000))
				{
					if ((doorobjlist[value&0x3ff]->action==dr_closed) || (z<maxheight-64))
					{
						smokecondition=gs_door;
						break;
					}
					else if (doorobjlist[value&0x3ff]->position<=0x8000)
					{
						smokecondition=gs_door;
						break;
					}
				}
				else
				{
					if ( maskobjlist[value&0x3ff]->flags & MW_SHOOTABLE )
					{
						if (z>maxheight-64) // Are we shooting above the glass
						{
							UpdateMaskedWall(value&0x3ff);
							return;
						}
					}
					else if ( maskobjlist[value&0x3ff]->flags & MW_WEAPONBLOCKING )
					{
						smokecondition=gs_door;
						break;
					}
				}
			}
			else
			{
				smokecondition=gs_wall;
				break;
			}
		}

		if (checksprite &&
			((checksprite->flags & FL_BLOCK)||(checksprite->flags & FL_SHOOTABLE)) &&
			(abs(checksprite->z-z)<32) &&
			(InRange(shooter,(objtype *)checksprite,
			FindDistance(shooter->x-checksprite->x,shooter->y-checksprite->y) )
			==true
			)
			)
		{
			ShootSprite(shooter, checksprite, damage, accuracy, angle);
			return;
		}

		if (tempactor)
		{
			if (tempactor->which == ACTOR)
			{
				if ((abs(tempactor->z-z)<32 ) &&
					(!(tempactor->flags & FL_DYING)) &&
					(tempactor->flags & FL_BLOCK) &&
					(tempactor != shooter) &&
					(tempactor->obclass!=diskobj) &&
					( InRange(shooter,tempactor,
					FindDistance(shooter->x-tempactor->x,
						shooter->y-tempactor->y) ) == true )
					)
				{
					ShootActor(shooter, tempactor, damage, accuracy, angle);
					return;
				}
			}
			else if (tempactor->which == PWALL)
				return;
		}

		if (z<-32)
		{
			smokecondition=gs_ceiling;
			break;
		}
		else if (z>maxheight)
		{
			smokecondition=gs_floor;
			break;
		}
		index= (cnt >= 0);
		cnt+=incr[index];
		z  +=zincr[index];
		grid[index]+=thedir[index];
		grid[index] &= (MAPSIZE-1);
	}
//	while (1);
	while (tcnt--);

	if (IsWindow(grid[0],grid[1]))
		return;

	lastcnt=cnt-incr[index];

	if (smokecondition==gs_floor)
	{
		int dist;
		int tangentangle;

		tangentangle=tantable[yzangle];
		if (tangentangle!=0)
		{
			dist=FixedDiv2(((shooter->z-maxheight)<<10),(tangentangle<<1));
			xintercept=shooter->x+FixedMul(dist,costable[angle]);
			yintercept=shooter->y-FixedMul(dist,sintable[angle]);
		}
		z=maxheight;
//		bullethole=5;
	}
	else if (smokecondition==gs_ceiling)
	{
		int dist;
		int tangentangle;

		if (sky!=0)
			return;
		tangentangle=tantable[yzangle];
		if (tangentangle!=0)
		{
			dist=FixedDiv2(((shooter->z+32)<<10),(tangentangle<<1));
			xintercept=shooter->x+FixedMul(dist,costable[angle]);
			yintercept=shooter->y-FixedMul(dist,sintable[angle]);
		}
		z=-32;
//		bullethole=5;
	}
	else
	{
		int dx,dy,xydist;

#define CORNERVALUE  0x500

		if (IsWindow(grid[0],grid[1]))
			return;
		if (lastcnt<0)
		{
			xintercept=grid[0]<<16;
			if (smokecondition==gs_door)
			{
				if (thedir[0]<0)
					xintercept+=0x9fff;
				else
					xintercept+=0x5fff;
				yintercept=FixedScale(xintercept-shooter->x,vy,vx)+shooter->y;
				if ((yintercept>>16)!=grid[1])
				{
					if ((yintercept>>16)>grid[1])
						yintercept=(grid[1]<<16)+0xffff;
					else
						yintercept=(grid[1]<<16);
				}
			}
			else if (smokecondition==gs_wall)
			{
				if (thedir[0]<0)
				{
					objtype * ta;

					xintercept += 0x10000;
					yintercept=FixedScale(xintercept-shooter->x,vy,vx)+shooter->y;

					xintercept += SMOKEWALLOFFSET;
					bullethole=1;
					if (yintercept < ((grid[1] << 16) + CORNERVALUE))
					bullethole = 0;
					else if (yintercept > ((grid[1] << 16) + 0x10000 - CORNERVALUE))
					bullethole = 0;

					ta = (objtype*)actorat[grid[0]][grid[1]];
					if ((ta) && (ta->which==PWALL))
						bullethole=0;
				}
				else
				{
					objtype * ta;

					yintercept=FixedScale(xintercept-shooter->x,vy,vx)+shooter->y;
					xintercept-=SMOKEWALLOFFSET;
					bullethole=2;
					if (yintercept < ((grid[1] << 16) + CORNERVALUE))
					bullethole = 0;
					else if (yintercept > ((grid[1] << 16) + 0x10000 - CORNERVALUE))
					bullethole = 0;

					ta = (objtype*)actorat[grid[0]][grid[1]];
					if ((ta) && (ta->which==PWALL))
						bullethole=0;
				}
			}
		}
		else
		{
			yintercept=grid[1]<<16;
			if (smokecondition==gs_door)
			{
				if (thedir[1]<0)
					yintercept+=0x9fff;
				else
					yintercept+=0x5fff;
				xintercept=FixedScale(yintercept-shooter->y,vx,vy)+shooter->x;
				if ((xintercept>>16)!=grid[0])
				{
					if ((xintercept>>16)>grid[0])
						xintercept=(grid[0]<<16)+0xffff;
					else
						xintercept=(grid[0]<<16);
				}
			}
			else if (smokecondition==gs_wall)
			{
				if (thedir[1]<0)
				{
					objtype * ta;

					yintercept += 0x10000;
					xintercept=FixedScale(yintercept-shooter->y,vx,vy)+shooter->x;

					yintercept += SMOKEWALLOFFSET;
					bullethole=3;
					if (xintercept < ((grid[0] << 16) + CORNERVALUE))
					bullethole = 0;
					else if (xintercept > ((grid[0] << 16) + 0x10000 - CORNERVALUE))
					bullethole = 0;

					ta = (objtype*)actorat[grid[0]][grid[1]];
					if ((ta) && (ta->which==PWALL))
						bullethole=0;
				}
				else
				{
					objtype * ta;

					xintercept=FixedScale(yintercept-shooter->y,vx,vy)+shooter->x;
					yintercept-=SMOKEWALLOFFSET;
					bullethole=4;
					if (xintercept < ((grid[0] << 16) + CORNERVALUE))
					bullethole = 0;
					else if (xintercept > ((grid[0] << 16) + 0x10000 - CORNERVALUE))
					bullethole = 0;

					ta = (objtype*)actorat[grid[0]][grid[1]];
					if ((ta) && (ta->which==PWALL))
						bullethole=0;
				}
			}
		}
		dx = xintercept - shooter->x;
		dy = shooter->y - yintercept;
		xydist = FindDistance(dx,dy);
		if (shooter->obclass==playerobj)
		{
			playertype * pstate;

			M_LINKSTATE(shooter,pstate);
			z=shooter->z-FixedMulShift(xydist,tantable[yzangle],25)+pstate->playerheight-32;
		}
		else
			z=shooter->z-FixedMulShift(xydist,tantable[yzangle],25);
		if (smokecondition==gs_wall)
		{
			if (z<-32)
				z=-32;
		}
	}
	SpawnGunSmoke(xintercept,yintercept,z,angle,bullethole);
}

/*
=====================
=
= T_BossDied ()
=
=====================
*/

void T_BossDied (objtype *ob)
{
	if (ob->ticcount)
		return;

	switch (ob->obclass)
	{
		case b_darianobj:
		case b_heinrichobj:
		case b_darkmonkobj:
		case b_robobossobj:
		case b_darksnakeobj:
			playstate = ex_bossdied;
		break;
	}
}

/*
=====================
=
= T_Wind ()
=
=====================
*/

static int WindDistance = 1000;
static int WindCurrentDistance = 1000;
static int WindHandle = -1;
static int WindLastTic = -1;
static int WindPlaying = false;
static int WindPitch = 0;
static int WindDestPitch = 0;
static int WindPitchRate = 0;

void T_Wind ( objtype *ob )
{
	int distance;
	int dx;
	int dy;

	if ( ( ticcount - WindLastTic ) > 0 )
	{
		WindDistance = 1000;

		WindPitch += WindPitchRate;
		if ( WindPitch == WindDestPitch )
		{
			WindDestPitch = ( RandomNumber( "Wind Pitch", 0 ) - 128 ) << 3;
			WindPitchRate = 1;
			if ( WindDestPitch < WindPitch )
			{
				WindPitchRate = -WindPitchRate;
			}
		}
	}
	WindLastTic = ticcount;

	dx = ( ob->x - PLAYER[0]->x );
	dy = ( PLAYER[0]->y - ob->y );

	distance = 1000;
	if ( areabyplayer[ ob->areanumber ] )
	{
		distance = ( FindDistance( dx, dy ) ) >> 13;
	}

	if ( distance < WindDistance )
	{
		WindDistance = distance;
	}

	if ( WindDistance < 255 )
	{
		WindPlaying = true;
		WindCurrentDistance = WindDistance;
	}
	else
	{
		if ( WindPlaying )
		{
			WindCurrentDistance += 3;
		}
	}

	if ( WindPlaying )
	{
		if ( WindCurrentDistance < 255 )
		{
			if ( !SD_SoundActive( WindHandle ) )
			{
				WindHandle = SD_PlayPitchedSound( SD_WINDSND,
					255 - WindCurrentDistance, WindPitch );
			}
			else
			{
				SD_SetSoundPitch( WindHandle, WindPitch );
				SD_SetPan( WindHandle, 255 - WindCurrentDistance, 255 - WindCurrentDistance,
					255 - WindCurrentDistance );
			}
		}
		else
		{
			SD_StopSound( WindHandle );
			WindPlaying = false;
		}
	}
}

/*
=====================
=
= StopWind ()
=
=====================
*/

void StopWind(void)
{
	objtype *temp;

	FX_SetReverb( 0 );

	SD_StopSound( WindHandle );
	WindDistance		= 1000;
	WindCurrentDistance = 1000;
	WindHandle			= -1;
	WindLastTic			= -1;
	WindPlaying			= false;
	WindPitch			= 0;
	WindDestPitch		= 0;
	WindPitchRate		= 0;

	for(temp=FIRSTACTOR;temp;temp=temp->next)
	{
		if (temp->soundhandle != -1)
			SD_StopSound(temp->soundhandle);
	}
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
/**********************************************************************
   module: RT_BATTL.C

   author: James R. Dose
   phone:  (214)-271-1365 Ext #221
   date:   September 8, 1994

   Battle mode support routines for Rise of the Triad.

   (c) Copyright 1994 Apogee Software.  All Rights Reserved.
**********************************************************************/

#include <string.h>
#include "rt_def.h"
#include "rottnet.h"
#include "isr.h"
#include "rt_battl.h"
#include "rt_actor.h"
#include "rt_rand.h"
#include "rt_playr.h"
#include "rt_game.h"
#include "rt_sound.h"
#include "rt_com.h"
#include "rt_msg.h"
#include "rt_view.h"

#include "rt_util.h"
#include "rt_main.h"
//MED
// #include "memcheck.h"

#define INFINITE -1

static battle_status BATTLE_StartRound( void );

static int Timer;
static int TimeLimit;
static int NumberOfPlayers;
static int BattleRound;
static int BattleMode;

static boolean RoundOver;
static boolean KillsEndGame;
static boolean KeepTrackOfKills;
boolean UpdateKills;

static boolean SwapFlag;

static battle_type BattleOptions;

specials BattleSpecialsTimes =
      {
      60, // god
      60, // dog
      20, // shrooms
      20, // elasto
      60, // asbestos vest
      60, // bullet proof vest
      GASTICS / VBLCOUNTER, // gas mask
      60, // mercury mode

      300, // god respawn
      60, // dog respawn
      60, // shrooms respawn
      60, // elasto respawn
      60, // asbestos vest respawn
      60, // bullet proof vest respawn
      60, // gas mask respawn
      60  // mercury mode respawn
      };

short WhoKilledWho[ MAXPLAYERS ][ MAXPLAYERS ];
short BATTLE_Points[ MAXPLAYERS ];
short BATTLE_PlayerOrder[ MAXPLAYERS ];
short BATTLE_Team[ MAXPLAYERS ];
short BATTLE_TeamLeader[ MAXPLAYERS ];
int   BATTLE_NumberOfTeams;
int   BATTLE_NumCollectorItems;
int   PointGoal;
int   DisplayPoints;
int   BATTLE_It;

boolean BATTLE_ShowKillCount;

boolean BATTLEMODE = false;

/*---------------------------------------------------------------------
	Function Prototypes:
---------------------------------------------------------------------*/

static int BATTLE_CheckKills
	(
	battle_event reason,
	int player
	);

/*---------------------------------------------------------------------
	Function: BATTLE_Init

	Initializes the battle information.
---------------------------------------------------------------------*/

void BATTLE_Init
	(
	int battlemode,
	int numplayers
	)

	{
	int index;
   int index2;
   int team;
   int TeamNumber[ MAXPLAYERCOLORS ];

   #if (BATTLECHECK == 1)
      if ( ( gamestate.teamplay ) && ( BattleMode == battle_Tag ) )
         {
         Error( "BATTLE_Init : Cannot play Tag in team mode.\n" );
         }

      if ( ( gamestate.teamplay ) && ( BattleMode == battle_CaptureTheTriad ) )
         {
         Error( "BATTLE_Init : Can only play Capture the Triad in team mode.\n" );
         }
   #endif

	Timer   = 0;
	RoundOver = false;

	BattleRound = -1;
   BATTLE_It = 0;

	BattleMode = battlemode;

	BATTLEMODE = false;

   UpdateKills = true;

	gamestate.BattleOptions.Gravity       = NORMAL_GRAVITY;
	gamestate.BattleOptions.Speed         = bo_normal_speed;
	gamestate.BattleOptions.Ammo          = bo_normal_shots;
	gamestate.BattleOptions.HitPoints     = bo_character_hitpoints;
	gamestate.BattleOptions.LightLevel    = bo_light_normal;
   gamestate.BattleOptions.Kills         = bo_kills_default;
	gamestate.BattleOptions.DangerDamage  = bo_danger_normal;
	gamestate.BattleOptions.TimeLimit     = bo_time_infinite;
   gamestate.BattleOptions.RespawnTime   = bo_normal_respawn_time;
   gamestate.BattleOptions.RandomWeapons = false;
   gamestate.BattleOptions.FriendlyFire  = true;
   gamestate.BattleOptions.WeaponPersistence = false;
	gamestate.BattleOptions.SpawnMines    = false;

	if ( BattleMode != battle_StandAloneGame )
		{
		BATTLEMODE = true;

      if ( gamestate.Product == ROTT_SHAREWARE )
         {
         switch( battlemode )
            {
            case battle_Normal :
            case battle_Collector :
            case battle_Hunter :
               break;

            default :
               Error( "Shareware version can only play Normal, Collector, "
                  "or Hunter in Comm-bat game." );
            }
         }

		gamestate.BattleOptions.Gravity       = BattleOptions.Gravity;
		gamestate.BattleOptions.Speed         = BattleOptions.Speed;
		gamestate.BattleOptions.Ammo          = BattleOptions.Ammo;
		gamestate.BattleOptions.HitPoints     = BattleOptions.HitPoints;
		gamestate.BattleOptions.LightLevel    = BattleOptions.LightLevel;
		gamestate.BattleOptions.Kills         = BattleOptions.Kills;
		gamestate.BattleOptions.DangerDamage  = BattleOptions.DangerDamage;
		gamestate.BattleOptions.TimeLimit     = BattleOptions.TimeLimit;
      gamestate.BattleOptions.RespawnTime   = BattleOptions.RespawnTime;
      gamestate.BattleOptions.RandomWeapons = BattleOptions.RandomWeapons;
      gamestate.BattleOptions.FriendlyFire  = BattleOptions.FriendlyFire;
      gamestate.BattleOptions.SpawnMines    = BattleOptions.SpawnMines;
      gamestate.BattleOptions.WeaponPersistence = BattleOptions.WeaponPersistence;
      }

	gamestate.ShowScores                 = true;
	gamestate.BattleOptions.SpawnHealth  = true;
	gamestate.BattleOptions.SpawnWeapons = true;
   gamestate.BattleOptions.SpawnDangers = true;
	gamestate.SpawnCollectItems          = false;
	gamestate.SpawnEluder                = false;
	gamestate.SpawnDeluder               = false;
	gamestate.BattleOptions.RespawnItems = false;

	NumberOfPlayers = numplayers;


   BATTLE_NumberOfTeams = numplayers;
	for( index = 0; index < MAXPLAYERS; index++ )
		{
      BATTLE_PlayerOrder[ index ] = index;
		BATTLE_Points[ index ] = 0;
      for( index2 = 0; index2 < MAXPLAYERS; index2++ )
         {
         WhoKilledWho[ index ][ index2 ] = 0;
         }

      BATTLE_Team[ index ] = index;
      BATTLE_TeamLeader[ index ] = index;
      }


   if ( gamestate.teamplay )
      {
      for( index = 0; index < MAXPLAYERCOLORS; index++ )
         {
         TeamNumber[ index ] = -1;
         }

      BATTLE_NumberOfTeams = 0;

      for( index = 0; index < numplayers; index++ )
         {
         team = PLAYERSTATE[ index ].uniformcolor;
         if ( TeamNumber[ team ] == -1 )
            {
            TeamNumber[ team ] = BATTLE_NumberOfTeams;
            BATTLE_TeamLeader[ BATTLE_NumberOfTeams ] = index;
            BATTLE_NumberOfTeams++;
            }
         BATTLE_Team[ index ] = TeamNumber[ team ];
         }
      }

	PointGoal = gamestate.BattleOptions.Kills;
	if ( ( gamestate.BattleOptions.Kills == bo_kills_random ) ||
		( gamestate.BattleOptions.Kills == bo_kills_blind ) )
		{
		// Possibility of playing from 5 to 50 kills
		PointGoal = ( GameRandomNumber( "BATTLE_Init", 0 ) % 46 ) + 5;
		}

   DisplayPoints = PointGoal;

	for( index = 0; index < MAXPLAYERS; index++ )
		{
		gamestate.PlayerHasGun[ index ] = true;
		}

	KillsEndGame = true;
	KeepTrackOfKills = true;

	switch( BattleMode )
		{
		case battle_StandAloneGame :
			KillsEndGame      = false;
			KeepTrackOfKills  = false;
			break;

		case battle_Normal :
			break;

		case battle_ScoreMore :
			break;

		case battle_Collector :
			for( index = 0; index < MAXPLAYERS; index++ )
				{
				gamestate.PlayerHasGun[ index ] = false;
				}
			KillsEndGame     = false;
			KeepTrackOfKills = false;
			gamestate.BattleOptions.SpawnHealth  = false;
			gamestate.BattleOptions.SpawnWeapons = false;
			gamestate.SpawnCollectItems          = true;
			break;

		case battle_Scavenger :
			KillsEndGame     = false;
			KeepTrackOfKills = false;
			gamestate.BattleOptions.SpawnWeapons = true;
			gamestate.BattleOptions.SpawnHealth  = true;
			gamestate.SpawnCollectItems          = true;
			break;

		case battle_Hunter :
         PointGoal *= BATTLE_NumberOfTeams;
			KillsEndGame      = false;
			KeepTrackOfKills  = true;
         BATTLE_It = 0;
         for( index = 0; index < NumberOfPlayers; index++ )
            {
            if ( BATTLE_Team[ index ] == 0 )
               {
               gamestate.PlayerHasGun[ index ] = false;
               }
            }
			break;

		case battle_Tag :
			for( index = 0; index < MAXPLAYERS; index++ )
				{
				gamestate.PlayerHasGun[ index ] = false;
				}

			gamestate.BattleOptions.SpawnHealth  = false;
			gamestate.BattleOptions.SpawnWeapons = false;
			gamestate.BattleOptions.SpawnDangers = true;
			KeepTrackOfKills = true;
			KillsEndGame     = true;
			break;

		case battle_Eluder :
			KeepTrackOfKills   = false;
			KillsEndGame       = false;

			for( index = 0; index < MAXPLAYERS; index++ )
				{
				gamestate.PlayerHasGun[ index ] = false;
				}

			gamestate.BattleOptions.SpawnWeapons = false;
			gamestate.SpawnEluder                = true;
			break;

		case battle_Deluder :
			KeepTrackOfKills    = false;
			KillsEndGame        = false;
			gamestate.SpawnDeluder = true;
			break;

		case battle_CaptureTheTriad :
         KillsEndGame     = false;
         KeepTrackOfKills = false;
			break;
		}

	if ( BattleMode != battle_StandAloneGame )
		{
		if ( BattleOptions.RespawnItems )
			{
			gamestate.BattleOptions.RespawnItems = true;
			}

		if ( !BattleOptions.SpawnDangers )
			{
			gamestate.BattleOptions.SpawnDangers = false;
			}

		if ( !BattleOptions.SpawnHealth )
			{
			gamestate.BattleOptions.SpawnHealth = false;
			}

		if ( !BattleOptions.SpawnWeapons )
			{
			gamestate.BattleOptions.SpawnWeapons = false;
			}

		if ( gamestate.BattleOptions.Kills == bo_kills_blind )
			{
			gamestate.ShowScores = false;
			}

      GRAVITY = gamestate.BattleOptions.Gravity;

      if ( gamestate.BattleOptions.Kills == bo_kills_infinite )
         {
         KillsEndGame = false;
         }
		}

	BATTLE_StartRound();

   #if (BATTLEINFO == 1)
      SoftError( "GRAVITY      = %d\n", GRAVITY );
      SoftError( "BO_Gravity   = %d\n", BattleOptions.Gravity );
      SoftError( "BO_Speed     = %d\n", BattleOptions.Speed );
      SoftError( "BO_Ammo      = %d\n", BattleOptions.Ammo );
      SoftError( "BO_HitPoints = %d\n", BattleOptions.HitPoints );
      SoftError( "BO_Dangers   = %d\n", BattleOptions.SpawnDangers );
      SoftError( "BO_Health    = %d\n", BattleOptions.SpawnHealth );
      SoftError( "BO_Weapons   = %d\n", BattleOptions.SpawnWeapons );
      SoftError( "BO_Respawn   = %d\n", BattleOptions.RespawnItems );
      SoftError( "BO_Light     = %d\n", BattleOptions.LightLevel );
      SoftError( "BO_Kills     = %d\n", BattleOptions.Kills );
      SoftError( "BO_DangerDam = %d\n", BattleOptions.DangerDamage );
      SoftError( "BO_TimeLimit = %d\n", BattleOptions.TimeLimit );
   #endif
	}


/*---------------------------------------------------------------------
   Function: BATTLE_GetSpecials

   Set the battle special times.
---------------------------------------------------------------------*/

void BATTLE_GetSpecials
	(
   void
	)

   {
   int *src;
   int *dest;

   src  = ( int * )&BattleSpecialsTimes;
   dest = ( int * )&gamestate.SpecialsTimes;

   while( src < ( int * )( &BattleSpecialsTimes + 1 ) )
      {
      *dest = *src * VBLCOUNTER;
      dest++;
      src++;
      }
   }


/*---------------------------------------------------------------------
	Function: BATTLE_SetOptions

	Set the battle options.
---------------------------------------------------------------------*/

void BATTLE_SetOptions
	(
	battle_type *options
	)

	{
	memcpy( &BattleOptions, options, sizeof( battle_type ) );
	}


/*---------------------------------------------------------------------
   Function: BATTLE_GetOptions

   Returns the battle options.
---------------------------------------------------------------------*/

void BATTLE_GetOptions
   (
   battle_type *options
   )

   {
	memcpy( options, &BattleOptions, sizeof( battle_type ) );
   }


/*---------------------------------------------------------------------
   Function: BATTLE_Shutdown

   Shutsdown the battle information.
---------------------------------------------------------------------*/

void BATTLE_Shutdown
   (
   void
   )

   {
   int index;
   int index2;

   Timer             = 0;
   RoundOver         = false;
   BattleRound       = 0;
   BattleMode        = battle_StandAloneGame;
   BATTLEMODE        = false;
   NumberOfPlayers   = 1;
   BATTLE_NumberOfTeams = 1;
   PointGoal         = 0;
   KillsEndGame      = false;
   KeepTrackOfKills  = false;

   for( index = 0; index < MAXPLAYERS; index++ )
      {
      BATTLE_Points[ index ] = 0;
      for( index2 = 0; index2 < MAXPLAYERS; index2++ )
         {
         WhoKilledWho[ index ][ index2 ] = 0;
         }
		gamestate.PlayerHasGun[ index ] = true;
		}
	gamestate.BattleOptions.SpawnHealth  = true;
	gamestate.BattleOptions.SpawnWeapons = true;
	gamestate.BattleOptions.SpawnDangers = true;
   gamestate.BattleOptions.RandomWeapons = false;
   gamestate.BattleOptions.FriendlyFire  = true;
   gamestate.BattleOptions.WeaponPersistence = false;
	gamestate.BattleOptions.SpawnMines    = false;

	gamestate.ShowScores        = true;
	gamestate.SpawnCollectItems = false;
	gamestate.SpawnEluder       = false;
	gamestate.SpawnDeluder      = false;
	}



/*---------------------------------------------------------------------
	Function: BATTLE_StartRound

	Begins a round of battle.
---------------------------------------------------------------------*/

static battle_status BATTLE_StartRound
	(
	void
	)

	{
	int index;

	Timer     = 0;
	TimeLimit = INFINITE;
	RoundOver = false;

	if ( !BATTLEMODE )
		{
		return( battle_no_event );
		}

	BattleRound++;

	if ( gamestate.BattleOptions.TimeLimit == bo_time_infinite )
      {
		if ( BattleMode == battle_Hunter )
			{
	      TimeLimit = MINUTES_TO_GAMECOUNT( 99 );
         }
      else
         {
         TimeLimit = INFINITE;
         }
      }
   else
      {
      TimeLimit = MINUTES_TO_GAMECOUNT( gamestate.BattleOptions.TimeLimit );
      }

	if ( BattleMode == battle_Hunter )
		{
		for( index = 0; index < MAXPLAYERS; index++ )
			{
			gamestate.PlayerHasGun[ index ] = true;
			}

		if ( ( gamestate.BattleOptions.Kills != bo_kills_infinite ) &&
         ( BattleRound >= PointGoal ) )
			{
			return( battle_end_game );
			}

      BATTLE_It = BattleRound % BATTLE_NumberOfTeams;
      for( index = 0; index < NumberOfPlayers; index++ )
         {
         if ( BATTLE_Team[ index ] == BATTLE_It )
            {
            gamestate.PlayerHasGun[ index ] = false;
            }
         }
		}

	return( battle_no_event );
	}

/*---------------------------------------------------------------------
	Function: BATTLE_CheckGameStatus

	Checks if certain battle mode conditions have been met and
	determines the appropriate response.
---------------------------------------------------------------------*/

battle_status BATTLE_CheckGameStatus
   (
   battle_event reason,
   int player
   )

   {
   battle_status status;
   int team;

   if ( ( player < 0 ) || ( player >= MAXPLAYERS ) )
      {
      #if (BATTLECHECK == 1)
         Error( "BATTLE_CheckGameStatus - reason %d : Player out of range!\n",
            reason );
      #else
         return( battle_no_event );
      #endif
      }

   if ( !BATTLEMODE )
      {
      return( battle_no_event );
      }

   team = BATTLE_Team[ player ];

   status = battle_no_event;

   switch( reason )
      {
      case battle_refresh :
         Timer++;
         if ( ( TimeLimit != INFINITE ) &&
            ( Timer > TimeLimit ) )
            {
            RoundOver = true;

            if ( BattleMode == battle_Hunter )
               {
               status = BATTLE_StartRound();
               if ( status == battle_no_event )
                  {
                  status = battle_end_round;
                  }
               }
            else
               {
               status = battle_out_of_time;
               }

            UpdateKills = true;
            }

         if ( UpdateKills )
            {
            BATTLE_SortPlayerRanks();
            if ( gamestate.ShowScores )
               {
               DrawKills (false);
               }
            UpdateKills = false;
            }

         if ( RoundOver )
            {
            return( battle_end_game );
            }
         break;

      case battle_player_killed :
         #if (BATTLEINFO == 1)
            SoftError( "BATTLE_CheckGameStatus: Player %d Died", player );
            SoftError( "---ticks = %d\n", Timer );
         #endif

         switch( BattleMode )
            {
            case battle_Normal :
            case battle_ScoreMore :
            case battle_Hunter :
               if ( BattleOptions.FriendlyFire )
                  {
                  BATTLE_Points[ team ]--;
                  UpdateKills = true;
                  }
               break;

            case battle_Tag :
               // Same as being tagged
               if ( BattleOptions.FriendlyFire )
                  {
                  BATTLE_Points[ team ]++;
                  UpdateKills = true;
                  }
               break;
            }

         WhoKilledWho[ player ][ player ]++;
         break;

      case battle_get_collector_item :

         if ( ( BattleMode != battle_Collector ) &&
            ( BattleMode != battle_Scavenger ) )
            {
            #if (BATTLECHECK == 1)
               Error( "BATTLE_CheckGameStatus : Got collector item on wrong battle mode!" );
            #else
               return( battle_no_event );
            #endif
            }
         BATTLE_Points[ team ]++;
         UpdateKills = true;

         BATTLE_NumCollectorItems--;
         if ( BATTLE_NumCollectorItems <= 0 )
            {
            RoundOver = true;
            return( battle_end_game );
            }
         break;

      case battle_caught_eluder :
         if ( BattleMode == battle_Deluder )
            {
            return( battle_no_event );
            }

         if ( BattleMode != battle_Eluder )
            {
            #if (BATTLECHECK == 1)
               Error( "BATTLE_CheckGameStatus : Caught Eluder on non-Eluder battle mode!" );
            #else
               return( battle_no_event );
            #endif
            }

         BATTLE_Points[ team ]++;
         UpdateKills = true;

         if ( ( gamestate.BattleOptions.Kills != bo_kills_infinite ) &&
            ( BATTLE_Points[ team ] >= PointGoal ) )
            {
            RoundOver = true;
            return( battle_end_game );
            }
         RespawnEluder();
         break;

      case battle_shot_deluder :
         if ( BattleMode == battle_Eluder )
            {
            return( battle_no_event );
            }

         if ( BattleMode != battle_Deluder )
            {
            #if (BATTLECHECK == 1)
               Error( "BATTLE_CheckGameStatus : Shot Eluder on non-Eluder battle mode!" );
            #else
               return( battle_no_event );
            #endif
            }

         BATTLE_Points[ team ]++;
         UpdateKills = true;

         if ( ( gamestate.BattleOptions.Kills != bo_kills_infinite ) &&
            ( BATTLE_Points[ team ] >= PointGoal ) )
            {
            RoundOver = true;
            return( battle_end_game );
            }
         RespawnEluder();
         break;

      case battle_captured_triad :
         if ( BattleMode != battle_CaptureTheTriad )
            {
            #if (BATTLECHECK == 1)
               Error( "BATTLE_CheckGameStatus : Triad Captured on invalid battle mode!" );
            #else
               return( battle_no_event );
            #endif
            }

         if ( consoleplayer == player )
            {
            AddMessage( "You captured a triad!  You rule!", MSG_GAME );
            }

         BATTLE_Points[ team ]++;
         UpdateKills = true;

         if ( ( gamestate.BattleOptions.Kills != bo_kills_infinite ) &&
            ( BATTLE_Points[ team ] >= PointGoal ) )
            {
            RoundOver = true;
            return( battle_end_game );
            }
         break;

      default :
         #if (BATTLECHECK == 1)
            Error( "BATTLE_CheckGameStatus called with a reason of %d.",
               reason );
         #else
            return( battle_no_event );
         #endif
         break;
      }

   return( status );
   }

/*---------------------------------------------------------------------
   Function: BATTLE_SortPlayerRanks

   Sorts the players in order of score.
---------------------------------------------------------------------*/

void BATTLE_SortPlayerRanks
   (
   void
   )

   {
   int i;
   int j;
   int temp;

   SwapFlag = false;

   if ( BattleMode == battle_Tag )
      {
      for( i = 0; i < BATTLE_NumberOfTeams - 1; i++ )
         {
         for( j = i + 1; j < BATTLE_NumberOfTeams; j++ )
            {
            if ( BATTLE_Points[ BATTLE_PlayerOrder[ i ] ] >
               BATTLE_Points[ BATTLE_PlayerOrder[ j ] ] )
               {
               SwapFlag = true;
               temp = BATTLE_PlayerOrder[ i ];
               BATTLE_PlayerOrder[ i ] = BATTLE_PlayerOrder[ j ];
               BATTLE_PlayerOrder[ j ] = temp;
               }
            }
         }
      }
   else
      {
      for( i = 0; i < BATTLE_NumberOfTeams - 1; i++ )
         {
         for( j = i + 1; j < BATTLE_NumberOfTeams; j++ )
            {
            if ( BATTLE_Points[ BATTLE_PlayerOrder[ i ] ] <
               BATTLE_Points[ BATTLE_PlayerOrder[ j ] ] )
               {
               SwapFlag = true;
               temp = BATTLE_PlayerOrder[ i ];
               BATTLE_PlayerOrder[ i ] = BATTLE_PlayerOrder[ j ];
               BATTLE_PlayerOrder[ j ] = temp;
               }
            }

         if ( BattleMode != battle_Hunter )
            {
            BATTLE_It = BATTLE_PlayerOrder[ 0 ];
            }
         }
      }

   #if (BATTLEINFO == 1)
      for( i = 0; i < BATTLE_NumberOfTeams; i++ )
         {
         SoftError( "Sorted rank %d = player %d : Score = %d\n", i,
            BATTLE_PlayerOrder[ i ], BATTLE_Points[ BATTLE_PlayerOrder[ i ] ] );
         }
   #endif

   if ( ( SwapFlag == true ) && ( gamestate.ShowScores ) &&
      ( SHOW_TOP_STATUS_BAR() || SHOW_KILLS() ) )
      {
      SD_Play ( SD_ENDBONUS1SND );
      }
   }


/*---------------------------------------------------------------------
   Function: BATTLE_PlayerKilledPlayer

   Increases the number of kills a player has.
---------------------------------------------------------------------*/

battle_status BATTLE_PlayerKilledPlayer
   (
   battle_event reason,
   int killer,
   int victim
   )

   {
   int points;
   int status;
   int killerteam;
   int victimteam;

   #if (BATTLEINFO == 1)
      SoftError( "PlayerKilledPlayer:\nMode = %d\n", BattleMode );
      SoftError( "Reason = %d\n", reason );
      SoftError( "killer = %d, team = %d\n", killer, killerteam );
      SoftError( "victim = %d, team = %d\n", victim, victimteam );
      SoftError( "---ticks = %d\n", Timer );
   #endif

   if ( ( killer < 0 ) || ( killer >= MAXPLAYERS ) )
      {
      #if (BATTLECHECK == 1)
         Error( "BATTLE_PlayerKilledPlayer - reason %d : Killer out of range!\n",
            reason );
      #else
         return( battle_no_event );
      #endif
      }
   if ( ( victim < 0 ) || ( victim >= MAXPLAYERS ) )
      {
      #if (BATTLECHECK == 1)
         Error( "BATTLE_PlayerKilledPlayer - reason %d : Victim out of range!\n",
            reason );
      #else
         return( battle_no_event );
      #endif
      }

   if ( ( killer == victim ) && ( reason != battle_kill_with_missile ) &&
      ( reason != battle_kill_with_missile_in_air ) )
      {
      #if (BATTLECHECK == 1)
         Error( "BATTLE_PlayerKilledPlayer : Player "
         "killed self with illegal reason of %d.", reason );
      #else
         return( battle_no_event );
      #endif
      }

   killerteam = BATTLE_Team[ killer ];
   victimteam = BATTLE_Team[ victim ];

   if ( ( killerteam < 0 ) || ( killerteam >= BATTLE_NumberOfTeams ) ||
      ( victimteam < 0 ) || ( victimteam >= BATTLE_NumberOfTeams ) )
      {
      #if (BATTLECHECK == 1)
         Error( "BATTLE_PlayerKilledPlayer - reason %d : Team out of range!\n",
            reason );
      #else
         return( battle_no_event );
      #endif
      }

   if ( !BATTLEMODE )
      {
      return( battle_no_event );
      }

   if ( ( consoleplayer == victim ) &&
      ( reason == battle_kill_by_crushing ) )
      {
      AddMessage( "Oh yeah.  You've been crushed.", MSG_GAME );
      }

   status = battle_no_event;
   if ( BattleMode == battle_ScoreMore )
      {
      points = 0;
      switch( reason )
         {
         case battle_kill_with_missile :
            points = 1;
            break;

         case battle_kill_with_bullet :
            points = 2;
            break;

         case battle_kill_with_missile_in_air :
            points = 2;
            break;

         case battle_kill_with_bullet_in_air :
            points = 3;
            break;

         case battle_kill_by_crushing :
            points = 4;
            break;

         default :
            #if (BATTLECHECK == 1)
               Error( "BATTLE_PlayerKilledPlayer called with a reason of %d.",
                  reason );
            #else
               return( battle_no_event );
            #endif
         }

      if ( killerteam == victimteam )
         {
         if ( BattleOptions.FriendlyFire )
            {
            BATTLE_Points[ killerteam ]--;
            WhoKilledWho[ killer ][ victim ]++;
            }
         }
      else
         {
         BATTLE_Points[ killerteam ]      += points;
         WhoKilledWho[ killer ][ victim ] += points;
         }
      UpdateKills = true;
      }
   else if ( BattleMode == battle_Tag )
      {
      if ( reason == battle_player_tagged )
         {
         WhoKilledWho[ killer ][ victim ]++;
         BATTLE_Points[ victimteam ]++;
         UpdateKills = true;
         BATTLE_It   = victimteam;

         if ( ( gamestate.BattleOptions.Kills != bo_kills_infinite ) &&
            ( BATTLE_Points[ victimteam ] >= PointGoal ) )
            {
            RoundOver = true;
            status = battle_end_game;
            }
         }
      #if (BATTLECHECK == 1)
      else if ( reason != battle_kill_by_crushing )
         {
         Error( "BATTLE_PlayerKilledPlayer - reason %d : "
            "Illegal reason in Tag!\n", reason );
         }
      #endif

      return( status );
      }
   else if ( BattleMode == battle_Hunter )
      {
      switch( reason )
         {
         case battle_kill_with_missile :
         case battle_kill_with_bullet :
         case battle_kill_with_missile_in_air :
         case battle_kill_with_bullet_in_air :
         case battle_kill_by_crushing :
            if ( victimteam == BATTLE_It )
               {
               WhoKilledWho[ killer ][ victim ]++;
               if ( killerteam == victimteam )
                  {
                  if ( BattleOptions.FriendlyFire )
                     {
                     BATTLE_Points[ killerteam ]--;
                     UpdateKills = true;
                     }
                  }
               else
                  {
                  BATTLE_Points[ killerteam ]++;
                  UpdateKills = true;
                  }
               }
            break;
         #if (BATTLECHECK == 1)
         default :
            Error( "BATTLE_PlayerKilledPlayer called with a "
               "reason of %d in Hunter.", reason );
         #endif
         }
      }
   else
      {
      switch( reason )
         {
         case battle_kill_with_missile :
         case battle_kill_with_bullet :
         case battle_kill_with_missile_in_air :
         case battle_kill_with_bullet_in_air :
         case battle_kill_by_crushing :
            WhoKilledWho[ killer ][ victim ]++;
            if ( KeepTrackOfKills )
               {
               if ( killerteam == victimteam )
                  {
                  if ( BattleMode == battle_Normal )
                     {
                     if ( BattleOptions.FriendlyFire )
                        {
                        BATTLE_Points[ killerteam ]--;
                        UpdateKills = true;
                        }
                     }
                  }
               else
                  {
                  BATTLE_Points[ killerteam ]++;
                  UpdateKills = true;
                  }
               }
            break;

         default :
            #if (BATTLECHECK == 1)
               Error( "BATTLE_PlayerKilledPlayer called with a reason of %d.",
                  reason );
            #else
               return( battle_no_event );
            #endif
         }
      }

   if ( ( KillsEndGame ) && ( BATTLE_Points[ killerteam ] >= PointGoal ) )
      {
      RoundOver = true;
      status = battle_end_game;
      }

   return( status );
   }
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// RT_BUILD.C

#include "RT_DEF.H"
#include <string.h>
// #include <DOS.H>
// #include "watcom.h"
#include <stdio.h>
#include <stdlib.h>
// #include <conio.h>

#include "rt_build.h"
#include "_rt_build.h"
// #include "rt_dr_a.h"
#include "rt_draw.h"
#include "rt_scale.h"
#include "rt_menu.h"
#include "rt_main.h"
#include "isr.h"
#include "rt_util.h"
#include "engine.h"
#include "lumpy.h"
// #include "rt_fc_a.h"
#include "z_zone.h"
#include "w_wad.h"
#include "rt_view.h"
#include "rt_cfg.h"
#include "rt_vid.h"

#include "rt_sound.h"
#include "modexlib.h"
#include "rt_str.h"
//MED
// #include "memcheck.h"

byte * intensitytable;


// LOCAL VARIABLES

static byte * menubuf;
static byte * menubuffers[2];
static char menutitles[2][40];
static int alternatemenubuf=0;
static int titleshade=16;
static int titleshadedir=1;
static int titleyoffset=0;
static char titlestring[40]="\0";
static int readytoflip;
static boolean MenuBufStarted=false;
static int mindist=0x2700;
static boolean BackgroundDrawn=false;

static plane_t planelist[MAXPLANES];
static plane_t *planeptr;

static StringShade=16;

extern void (*USL_MeasureString)(char *, int *, int *, font_t *);






//******************************************************************************
//
// DrawRotPost
//
//******************************************************************************

//void DrawRotPost ( int height, byte * src, byte * buf, int origheight)
void DrawRotPost ( int height, byte * src, unsigned buf, int origheight)
{
	int y1;
	int y2;

	hp_srcstep=(origheight<<18)/height;
	y1 = (((centery<<8)-(height<<5)+(MENUOFFY<<8)));
	y2 = (((height<<6)+y1)>>8);

	if (((y1>>8)>=200) || (y2<0))
		return;
	if (y1<0)
	{
		hp_startfrac=FixedMulShift(-y1,hp_srcstep,8);
		y2 = (((height<<6)+y1)>>8);
		y1=0;
	}
	else
	{
		hp_startfrac=FixedMulShift(255-(y1&0xff),hp_srcstep,8);
		y1>>=8;
	}
	if (y2>200)
	{
		DrawMenuPost(200-y1, src, buf+ylookup[y1]);
	}
	else
	{
		DrawMenuPost(y2-y1, src, buf+ylookup[y1]);
	}
}



/*
========================
=
= GetPoint
=
========================
*/

void GetPoint (int x1, int y1, int px, int py, int * screenx, int * height, int angle)
{

  fixed gxt,gyt,nx,ny;
  fixed gxtt,gytt;
  int gx,gy;


//
// translate point to view centered coordinates
//
  gx = x1-px;
  gy = y1-py;

//
// calculate newx
//
  gxt = FixedMul(gx,costable[angle]);
  gyt = FixedMul(gy,sintable[angle]);
  nx =gxt-gyt;

  if (nx<mindist)
	  nx=mindist;


//
// calculate newy
//
  gxtt = FixedMul(gx,sintable[angle]);
  gytt = FixedMul(gy,costable[angle]);
  ny = gytt+gxtt;

// too close, don't overflow the divid'


  *screenx = 160 + ((ny*NORMALWIDTHMULTIPLIER)/nx);				// DEBUG: use assembly divide

  *height = NORMALHEIGHTDIVISOR/nx;

  if (*screenx<0) *screenx=0;

}


/*
========================
=
= InterpolatePlane
=
========================
*/

void InterpolatePlane (visobj_t * plane)
{
	int d1,d2;
	int top;
	int topinc;
	int bot;
	int botinc;
	int i;
	int texture;
	int dh;
	int dx;
	int height;


	dx=(plane->x2-plane->x1+1);
	if (plane->h1<=0 || plane->h2<=0 || (dx==0))
		return;
	d1=65536/plane->h1;
	d2=65536/plane->h2;
	dh=((plane->h2-plane->h1)<<8)/dx;
	top=0;
	topinc=(d1)*((plane->textureend-plane->texturestart)>>4);
	bot=d2*dx;
	botinc=d1-d2;
	height=(plane->h1<<8);
	if (plane->x1>=viewwidth)
		return;
	for (i=plane->x1;i<=plane->x2;i++)
		{
		if ((i>=0 && i<viewwidth)&&(posts[i].wallheight<(height>>8)))
			{
			if (bot)
				{
				texture=((top/bot)+(plane->texturestart>>4))>>6;
				posts[i].texture=texture*plane->viewx;
				posts[i].lump=plane->shapenum;
				posts[i].wallheight=(height>>8);
				posts[i].offset=plane->viewx;
				}
			}
		top+=topinc;
		bot+=botinc;
		height+=dh;
		}
}

//******************************************************************************
//
// DrawPlanePosts
//
//******************************************************************************

void	DrawPlanePosts (void)
{
	int height;
//	char * buf;
	unsigned buf;
	byte * shape;
	int lastwall=-2;
	int plane;
	int i;

	shadingtable=colormap+(16<<8);
	for (plane=0;plane<4;plane++)
		{
		VGAWRITEMAP(plane);
//		buf=(byte *)(bufferofs);
		buf=bufferofs;
		for (i=plane;i<viewwidth;i+=4,buf++)
			{
			height=(posts[i].wallheight);
			if (height<=4)
				continue;
			if (lastwall!=posts[i].lump)
				{
				lastwall=posts[i].lump;
				if (lastwall==-1)
					shape=menubuf;
				else
//					shape=W_CacheLumpNum(lastwall,PU_CACHE);
					shape=W_CacheWallLumpNum(lastwall,PU_CACHE);
				}
			DrawRotPost (height,shape+posts[i].texture,buf,posts[i].offset);
			}
		}
}

//******************************************************************************
//
// NextPlaneptr
//
//******************************************************************************

void NextPlaneptr ( void )
{
	if (planeptr < &planelist[MAXPLANES-1]) // don't let it overflo'
  		planeptr++;
}

//******************************************************************************
//
// RestPlaneptr
//
//******************************************************************************

void ResetPlaneptr ( void )
{
	planeptr = &planelist[0];
}

//******************************************************************************
//
// NextVisptr
//
//******************************************************************************

void NextVisptr ( void )
{
	if (visptr < &vislist[MAXVISIBLE-1]) // don't let it overflo'
  		visptr++;
}

//******************************************************************************
//
// ResetVisptr
//
//******************************************************************************

void ResetVisptr ( void )
{
	visptr = &vislist[0];
}

//******************************************************************************
//
// SetupPlanes
//
//******************************************************************************

void SetupPlanes ( void )
{
	int i;

	for (i=0;i<320;i++)
		posts[i].wallheight=-1;
}



//******************************************************************************
//
// CalcPlanes
//
//******************************************************************************

void CalcPlanes ( int px, int py, int angle )
{
	plane_t * pptr;

	ResetVisptr();
	for (pptr = &planelist[0]; pptr<planeptr; pptr++)
		{
		if (SideOfLine(pptr->x1,pptr->y1,pptr->x2,pptr->y2,px,py)<0)
			{
			GetPoint (pptr->x1,pptr->y1,px,py,&visptr->x1,&visptr->h1,angle);
			GetPoint (pptr->x2,pptr->y2,px,py,&visptr->x2,&visptr->h2,angle);
			visptr->textureend=0x0;
			visptr->texturestart=pptr->texturewidth;
			}
		else
			{
			GetPoint (pptr->x2,pptr->y2,px,py,&visptr->x1,&visptr->h1,angle);
			GetPoint (pptr->x1,pptr->y1,px,py,&visptr->x2,&visptr->h2,angle);
			visptr->texturestart=0x0;
			visptr->textureend=pptr->texturewidth;
			}
		visptr->shapenum=pptr->texture;
		visptr->viewx=pptr->origheight;
		visptr->viewheight=MAX(visptr->h1,visptr->h2);
		NextVisptr();
		}
}


//******************************************************************************
//
// DrawTransformedPlanes
//
//******************************************************************************

void DrawTransformedPlanes ( void )
{
	int numvisible;
	int greatest;
	int height;
	int i;
	visobj_t * closest;

	numvisible = visptr-&vislist[0];
	if (!numvisible)
		return;												 // no visible objects
	for (i = 0; i<numvisible; i++)
		{
		greatest = 0;
		for (visstep=&vislist[0] ; visstep<visptr ; visstep++)
			{
			height = visstep->viewheight;
			if (height > greatest)
				{
				greatest = height;
				closest = visstep;
				}
			}
		InterpolatePlane(closest);
		closest->viewheight = 0;
		}
}


//******************************************************************************
//
// ClearMenuBuf
//
//******************************************************************************

void ClearMenuBuf ( void )
{
	byte * shape;

	if (MenuBufStarted==false)
		Error("Called ClearMenuBuf without menubuf started\n");

	shape=W_CacheLumpName(MENUBACKNAME,PU_CACHE);
	shape+=8;
	memcpy (menubuf,shape,TEXTUREW*TEXTUREHEIGHT);
}

//******************************************************************************
//
// ShutdownMenuBuf
//
//******************************************************************************

void ShutdownMenuBuf ( void )
{
	if (MenuBufStarted==false)
		return;
	MenuBufStarted=false;
	SafeFree(menubuffers[0]);
	SafeFree(menubuffers[1]);
	if (loadedgame==false)
		SetViewSize(viewsize);
}

//******************************************************************************
//
// SetupMenuBuf
//
//******************************************************************************

void SetupMenuBuf ( void )
{
#define SRCH 148
#define SRCW 258
#define PLANEX1 (-0x24000)
#define PLANEX2 (0x23fff)
#define PLANEW (16<<10)
#define PLANEY (0x40000)
#define PLANEW2 (0x5a827)

	if (MenuBufStarted==true)
		return;
	MenuBufStarted=true;

	// No top offsets like in game

	centery=100;
	centeryfrac=centery<<16;

	strcpy(titlestring,menutitles[0]);

	screenofs=0;
	viewwidth=320;
	viewheight=200;

	alternatemenubuf=0;

	ResetPlaneptr();
	planeptr->texture=-1;
	planeptr->y1=PLANEX1;
	planeptr->x1=PLANEW;
	planeptr->y2=PLANEX2;
	planeptr->x2=PLANEW;
	planeptr->origheight=TEXTUREHEIGHT;
	planeptr->texturewidth=TEXTUREWIDTH;
	NextPlaneptr();
	planeptr->texture=-1;
	planeptr->y1=PLANEX1;
	planeptr->x1=-PLANEW;
	planeptr->y2=PLANEX2;
	planeptr->x2=-PLANEW;
	planeptr->origheight=TEXTUREHEIGHT;
	planeptr->texturewidth=TEXTUREWIDTH;
	NextPlaneptr();
	planeptr->texture=W_GetNumForName(MENUBACKNAME);
	planeptr->y1=PLANEX1;
	planeptr->x1=PLANEW;
	planeptr->y2=PLANEX1;
	planeptr->x2=-PLANEW;
	planeptr->origheight=TEXTUREHEIGHT;
	planeptr->texturewidth=TEXTUREWIDTH;
	NextPlaneptr();
	planeptr->texture=W_GetNumForName(MENUBACKNAME);
	planeptr->y1=PLANEX2;
	planeptr->x1=PLANEW;
	planeptr->y2=PLANEX2;
	planeptr->x2=-PLANEW;
	planeptr->origheight=TEXTUREHEIGHT;
	planeptr->texturewidth=TEXTUREWIDTH;
	NextPlaneptr();

	menubuffers[0]=SafeMalloc(TEXTUREW*TEXTUREHEIGHT);
	menubuffers[1]=SafeMalloc(TEXTUREW*TEXTUREHEIGHT);
	menubuf=menubuffers[0];
	ClearMenuBuf();
	BackgroundDrawn=false;
}


//******************************************************************************
//
// PositionMenuBuf
//
//******************************************************************************

void PositionMenuBuf( int angle, int distance, boolean drawbackground )
{
	int px,py;
	font_t * oldfont;
	int width,height;


	if (MenuBufStarted==false)
		Error("Called PositionMenuBuf without menubuf started\n");
	CalcTics();
	SetupPlanes();
	if ((drawbackground==true) || (BackgroundDrawn==false))
		{
		VL_DrawPostPic (W_GetNumForName("trilogo"));
		}
	px=FixedMulShift(distance,costable[angle&(FINEANGLES-1)],16);
	py=FixedMulShift(-distance,sintable[angle&(FINEANGLES-1)],16);
	CalcPlanes(px,py,(angle+ANG180)&(FINEANGLES-1));
	DrawTransformedPlanes();
	DrawPlanePosts();
	oldfont=CurrentFont;
	CurrentFont = (font_t *)W_CacheLumpName ("newfnt1", PU_CACHE);
	US_MeasureStr (&width, &height, titlestring);
	US_ClippedPrint ((320-width)>>1, MENUTITLEY-titleyoffset, titlestring);
	CurrentFont=oldfont;
	FlipPage();
	titleshade+=titleshadedir;
	if (abs(titleshade-16)>6)
		titleshadedir=-titleshadedir;
	if (BackgroundDrawn==false)
		{
		VL_CopyDisplayToHidden();
		BackgroundDrawn=true;
		}
}

//******************************************************************************
//
// RefreshMenuBuf
//
//******************************************************************************

void RefreshMenuBuf( int time )
{
	int i;

	if (MenuBufStarted==false)
		Error("Called RefreshMenuBuf without menubuf started\n");

	if (readytoflip)
		return;

	for (i=0;i<=time;i+=tics)
		{
		PositionMenuBuf (0,NORMALVIEW,false);
		}
}

//******************************************************************************
//
// ScaleMenuBufPost
//
//******************************************************************************

void ScaleMenuBufPost (byte * src, int topoffset, byte * buf)
{
	int  d;
	int  offset;
	int  length;
	int  s;


	while (1)
		{
		offset=*(src++);
		if (offset==0xff)
			return;
		else
			{
			d=offset-topoffset;
			length=*(src++);
			for (s=0;s<length;s++,d++)
				*(buf+d)=*(src+s);
			src+=length;
			}
		}
}

//******************************************************************************
//
// SetAlternateMenuBuf
//
//******************************************************************************

void SetAlternateMenuBuf ( void )
{
  if (MenuBufStarted==false)
	  Error("Called SetAlternateMenuBuf without menubuf started\n");

  alternatemenubuf^=1;
  readytoflip=1;
  menubuf=menubuffers[alternatemenubuf];
}

//******************************************************************************
//
// SetMenuTitle
//
//******************************************************************************

void SetMenuTitle ( char * menutitle )
{
  if (MenuBufStarted==false)
	  Error("Called SetMenuTitle without menubuf started\n");
  strcpy(menutitles[alternatemenubuf],menutitle);
  if (readytoflip==0)
	  strcpy(titlestring,menutitle);
}

//******************************************************************************
//
// DrawMenuBufPicture
//
//******************************************************************************

void DrawMenuBufPicture (int x, int y, byte * pic, int w, int h)
{
	byte *buffer;
	int i;

	if (MenuBufStarted==false)
		Error("Called DrawMenuBufPictoure without menubuf started\n");

	if ((x<0) || (x+w>=TEXTUREW))
		Error ("DrawMenuBufPicture: x is out of range\n");
	if ((y<0) || (y+h>=TEXTUREHEIGHT))
		Error ("DrawMenuBufPicture: y is out of range\n");

	for (i=0;i<w;i++)
		{
		buffer = (byte*)menubuf+y+((x+i)*TEXTUREHEIGHT);
		memcpy(buffer,pic,h);
		pic+=h;
		}
}

//******************************************************************************
//
// DrawMenuBufItem
//
//******************************************************************************

void DrawMenuBufItem (int x, int y, int shapenum)
{
	byte *buffer;
	int cnt;
	byte *shape;
	patch_t *p;

	if (MenuBufStarted==false)
		Error("Called DrawMenuBufItem without menubuf started\n");

	shape = W_CacheLumpNum (shapenum, PU_CACHE);
	p = (patch_t *)shape;

	if (((x-p->leftoffset)<0) || ((x-p->leftoffset+p->width)>=TEXTUREW))
		Error ("DrawMenuBufItem: x is out of range\n");
	if (((y-p->topoffset)<0) || ((y-p->topoffset+p->height)>=TEXTUREHEIGHT))
		Error ("DrawMenuBufItem: y is out of range\n");

	buffer = (byte*)menubuf+y+((x-p->leftoffset)*TEXTUREHEIGHT);

	for (cnt = 0; cnt < p->width; cnt++,buffer+=TEXTUREHEIGHT)
		ScaleMenuBufPost ((byte *)(p->collumnofs[cnt]+shape),
								p->topoffset, buffer);
}

//******************************************************************************
//
// IScaleMenuBufPost
//
//******************************************************************************

void IScaleMenuBufPost (byte * src, int topoffset, byte * buf, int color)
{
	int  d;
	int  offset;
	int  length;
	int  s;


	while (1)
		{
		offset=*(src++);
		if (offset==0xff)
			return;
		else
			{
			d=offset-topoffset;
			length=*(src++);
			for (s=0;s<length;s++,d++)
				*(buf+d)=*(intensitytable+((*(src+s))<<8)+color);
			src+=length;
			}
		}
}


//******************************************************************************
//
// DrawIMenuBufItem
//
//******************************************************************************

void DrawIMenuBufItem (int x, int y, int shapenum, int color)
{
	byte *buffer;
	int cnt;
	byte *shape;
	patch_t *p;


	if (MenuBufStarted==false)
		Error("Called DrawIMenuBufItem without menubuf started\n");

	shape = W_CacheLumpNum (shapenum, PU_CACHE);
	p = (patch_t *)shape;

	if (((x-p->leftoffset)<0) || ((x-p->leftoffset+p->width)>=TEXTUREW))
		Error ("DrawIMenuBufItem: x is out of range\n");
	if (((y-p->topoffset)<0) || ((y-p->topoffset+p->height)>=TEXTUREHEIGHT))
		Error ("DrawIMenuBufItem: y is out of range\n");

	buffer = (byte*)menubuf+y+((x-p->leftoffset)*TEXTUREHEIGHT);

	for (cnt = 0; cnt < p->width; cnt++,buffer+=TEXTUREHEIGHT)
		IScaleMenuBufPost ((byte *)(p->collumnofs[cnt]+shape),
								p->topoffset, buffer, color);
}


//******************************************************************************
//
// TScaleMenuBufPost
//
//******************************************************************************
void TScaleMenuBufPost (byte * src, int topoffset, byte * buf)
{
	int  d;
	int  offset;
	int  length;
	byte pixel;
	int  s;


	while (1)
		{
		offset=*(src++);
		if (offset==0xff)
			return;
		else
			{
			d=offset-topoffset;
			length=*(src++);
			for (s=0;s<length;s++,d++)
				{
				pixel = *(buf+d);
				pixel = *(shadingtable+pixel);
				*(buf+d) = pixel;
				}
			src+=length;
			}
		}
}


//******************************************************************************
//
// CScaleMenuBufPost
//
//******************************************************************************
void CScaleMenuBufPost (byte * src, int topoffset, byte * buf)
{
	int  d;
	int  offset;
	int  length;
	byte pixel;
	int  s;


	while (1)
		{
		offset=*(src++);
		if (offset==0xff)
			return;
		else
			{
			d=offset-topoffset;
			length=*(src++);
			for (s=0;s<length;s++,d++)
				{
				pixel = *(src+s);
				pixel = *(shadingtable+pixel);
				*(buf+d) = pixel;
				}
			src+=length;
			}
		}
}


//******************************************************************************
//
// EraseMenuBufRegion
//
//******************************************************************************

void EraseMenuBufRegion (int x, int y, int width, int height)
{
	byte *buffer;
	int xx,yy;
	byte * shape;

	if (MenuBufStarted==false)
		Error("Called EraseMenuBufRegion without menubuf started\n");

	if ((x<0) || (x+width>=TEXTUREW))
		Error ("EraseMenuBufRegion: x is out of range\n");
	if ((y<0) || (y+height>=TEXTUREHEIGHT))
		Error ("EraseMenuBufRegion: y is out of range\n");

	shape=W_CacheLumpName(MENUBACKNAME,PU_CACHE);
	shape+=8;
	shape+=(x*TEXTUREHEIGHT)+y;
	buffer = (byte*)menubuf+(x*TEXTUREHEIGHT)+y;

	for (xx = 0; xx < width; xx++)
		{
		for (yy = 0; yy < height; yy++)
			*(buffer+yy)=*(shape+yy);
		buffer+=TEXTUREHEIGHT;
		shape+=TEXTUREHEIGHT;
		}
}


//******************************************************************************
//
// DrawTMenuBufPic
//
//******************************************************************************

void DrawTMenuBufPic (int x, int y, int shapenum)
{
	byte *buffer;
	byte *buf;
	int xx,yy;
	int plane;
	int pixel;
	byte *shape;
	byte *src;
	pic_t *p;

	if (MenuBufStarted==false)
		Error("Called DrawTMenuBufPic without menubuf started\n");

	shadingtable=colormap+(25<<8);

	shape = W_CacheLumpNum (shapenum, PU_CACHE);
	p = (pic_t *)shape;

	if ((x<0) || ((x+(p->width<<2))>=TEXTUREW))
		Error ("DrawTMenuBufPic: x is out of range\n");
	if ((y<0) || ((y+p->height)>=TEXTUREHEIGHT))
		Error ("DrawTMenuBufPic: y is out of range\n");

	buffer = (byte*)menubuf+(x*TEXTUREHEIGHT)+y;

	src=(byte *)&p->data;
	for (plane=0;plane<4;plane++,buffer+=TEXTUREHEIGHT)
		{
		for (yy = 0; yy < p->height; yy++)
			{
			buf=buffer+yy;
			for (xx = 0; xx < p->width; xx++,buf+=TEXTUREHEIGHT<<2)
				{
				pixel = *(buf);
				pixel = *(shadingtable+pixel);
				*(buf) = pixel;
				}
			}
		}
}


//******************************************************************************
//
// DrawTMenuBufItem
//
//******************************************************************************

void DrawTMenuBufItem (int x, int y, int shapenum)
{
	byte *buffer;
	int cnt;
	byte *shape;
	patch_t *p;


	if (MenuBufStarted==false)
		Error("Called DrawTMenuBufItem without menubuf started\n");

	shape = W_CacheLumpNum (shapenum, PU_CACHE);
	p = (patch_t *)shape;

	shadingtable=colormap+(25<<8);

	if (((x-p->leftoffset)<0) || ((x-p->leftoffset+p->width)>=TEXTUREW))
		Error ("DrawTMenuBufItem: x is out of range\n");
	if (((y-p->topoffset)<0) || ((y-p->topoffset+p->height)>=TEXTUREHEIGHT))
		Error ("DrawTMenuBufItem: y is out of range\n");

	buffer = (byte*)menubuf+y+((x-p->leftoffset)*TEXTUREHEIGHT);

	for (cnt = 0; cnt < p->width; cnt++,buffer+=TEXTUREHEIGHT)
		TScaleMenuBufPost ((byte *)(p->collumnofs[cnt]+shape),
								p->topoffset, buffer);
}

//******************************************************************************
//
// DrawColoredMenuBufItem
//
//******************************************************************************

void DrawColoredMenuBufItem (int x, int y, int shapenum, int color)
{
	byte *buffer;
	int cnt;
	byte *shape;
	patch_t *p;


	if (MenuBufStarted==false)
		Error("Called DrawColoredMenuBufItem without menubuf started\n");

	shape = W_CacheLumpNum (shapenum, PU_CACHE);
	p = (patch_t *)shape;

	shadingtable=playermaps[color]+(16<<8);

	if (((x-p->leftoffset)<0) || ((x-p->leftoffset+p->width)>=TEXTUREW))
		Error ("DrawColoredMenuBufItem: x is out of range\n");
	if (((y-p->topoffset)<0) || ((y-p->topoffset+p->height)>=TEXTUREHEIGHT))
		Error ("DrawColoredMenuBufItem: y is out of range\n");

	buffer = (byte*)menubuf+y+((x-p->leftoffset)*TEXTUREHEIGHT);

	for (cnt = 0; cnt < p->width; cnt++,buffer+=TEXTUREHEIGHT)
		CScaleMenuBufPost ((byte *)(p->collumnofs[cnt]+shape),
								p->topoffset, buffer);
}

//******************************************************************************
//
// DrawMenuBufPic
//
//******************************************************************************

void DrawMenuBufPic (int x, int y, int shapenum)
{
	byte *buffer;
	byte *buf;
	int xx,yy;
	int plane;
	byte *shape;
	byte *src;
	pic_t *p;

	if (MenuBufStarted==false)
		Error("Called DrawMenuBufPic without menubuf started\n");

	shape = W_CacheLumpNum (shapenum, PU_CACHE);
	p = (pic_t *)shape;

	if ((x<0) || ((x+(p->width<<2))>=TEXTUREW))
		Error ("DrawTMenuBufPic: x is out of range\n");
	if ((y<0) || ((y+p->height)>=TEXTUREHEIGHT))
		Error ("DrawTMenuBufPic: y is out of range\n");


	buffer = (byte*)menubuf+(x*TEXTUREHEIGHT)+y;

	src=(byte *)&p->data;
	for (plane=0;plane<4;plane++,buffer+=TEXTUREHEIGHT)
		{
		for (yy = 0; yy < p->height; yy++)
			{
			buf=buffer+yy;
			for (xx = 0; xx < p->width; xx++,buf+=TEXTUREHEIGHT<<2)
				*(buf)=*(src++);
			}
		}
}




//******************************************************************************
//
// DrawTMenuBufBox
//
//******************************************************************************


void DrawTMenuBufBox ( int x, int y, int width, int height )
	{
	byte *buffer;
	int	xx;
	int	yy;
	int	pixel;

	if (MenuBufStarted==false)
		Error("Called DrawTMenuBufBox without menubuf started\n");

	shadingtable = colormap + ( 25 << 8 );

	if ( ( x < 0 ) || ( ( x + width ) >= TEXTUREW ) )
		Error ("DrawTMenuBar : x is out of range\n");
	if ( ( y < 0 ) || ( y + height ) >= TEXTUREHEIGHT )
		Error ("DrawTMenuBar : y is out of range\n");

	buffer = ( byte * )menubuf + ( x * TEXTUREHEIGHT ) + y;

	for ( xx = 0; xx < width; xx++ )
		{
		for ( yy = 0; yy < height; yy++ )
			{
			pixel = *( buffer + yy );
			pixel = *( shadingtable + pixel );
			*( buffer + yy ) = pixel;
			}

		buffer += TEXTUREHEIGHT;
		}
	}


//******************************************************************************
//
// DrawTMenuBufHLine
//
//******************************************************************************

void DrawTMenuBufHLine (int x, int y, int width, boolean up)
{
	byte *buffer;
	byte *buf;
	int xx;
	int plane;
	int pixel;
	int w = width>>2;
	int ww = w;

	if ((x<0) || ((x+(width))>=TEXTUREW))
		Error ("DrawTMenuBufBox: x is out of range\n");
	if (y<0)
		Error ("DrawTMenuBufBox: y is out of range\n");

	buffer = (byte*)menubuf+(x*TEXTUREHEIGHT)+y;

	if (up)
		shadingtable=colormap+(13<<8);
	else
		shadingtable=colormap+(25<<8);

	for (plane = 0; plane < 4; plane++, buffer += TEXTUREHEIGHT)
	{
		w = ww;
		switch (plane)
		{
			case 0:
				if (width % 4)
					w++;
			break;
			case 1:
				if ((width % 4) > 1)
					w++;
			break;
			case 2:
				if ((width % 4) > 2)
					w++;
			break;
		}


		buf = buffer;
		for (xx = 0; xx < w; xx++, buf += (TEXTUREHEIGHT<<2))
		{
			pixel = *(buf);
			pixel = *(shadingtable+pixel);
			*(buf) = pixel;
		}
	}
}

//******************************************************************************
//
// DrawTMenuBufVLine
//
//******************************************************************************

void DrawTMenuBufVLine (int x, int y, int height, boolean up)
{
	byte *buffer;
	byte *buf;
	int yy;
	int pixel;

	if (x<0)
		Error ("DrawTMenuBufBox: x is out of range\n");
	if ((y<0) || ((y+height)>=TEXTUREHEIGHT))
		Error ("DrawTMenuBufBox: y is out of range\n");

	buffer = (byte*)menubuf+(x*TEXTUREHEIGHT)+y;

	if (up)
		shadingtable=colormap+(13<<8);
	else
		shadingtable=colormap+(25<<8);

	for (yy = 0; yy < height; yy++)
	{
		buf = buffer+yy;
		pixel = *(buf);
		pixel = *(shadingtable+pixel);
		*(buf) = pixel;
	}
}

//******************************************************************************
//******************************************************************************
//
// STRING ROUTINES
//
//******************************************************************************
//******************************************************************************


//******************************************************************************
//
// DrawMenuBufPropString ()
//
//******************************************************************************

void DrawMenuBufPropString (int px, int py, char *string)
{
	byte  pix;
	int	width,height,ht;
	byte  *source, *dest, *origdest;
	int	ch;


	if (MenuBufStarted==false)
		Error("Called DrawMenuBufPropString without menubuf started\n");

	ht = CurrentFont->height;
	dest = origdest = (byte*)menubuf+(px*TEXTUREHEIGHT)+py;

	while ((ch = *string++)!=0)
	{
		ch -= 31;
		width = CurrentFont->width[ch];
		source = ((byte *)CurrentFont)+CurrentFont->charofs[ch];
		while (width--)
		{
			height = ht;
			while (height--)
			{
				pix = *source;
				if (pix)
					*dest = pix;

				source++;
				dest ++;
			}

			PrintX++;
			origdest+=TEXTUREHEIGHT;
			dest = origdest;
		}
	}

}


//******************************************************************************
//
// DrawMenuBufIString ()
//
//******************************************************************************

void DrawMenuBufIString (int px, int py, char *string, int color)
{
	byte  pix;
	int	width,height,ht;
	byte  *source, *dest, *origdest;
	int	ch;

	if (MenuBufStarted==false)
		Error("Called DrawMenuBufPropString without menubuf started\n");

	if ( ( color < 0 ) || ( color > 255 ) )
		{
		Error( "Intensity Color out of range\n" );
		}

	ht = IFont->height;
	dest = origdest = (byte*)menubuf+(px*TEXTUREHEIGHT)+py;

	PrintX = px;
	PrintY = py;

	while ((ch = *string++)!=0)
	{
		// Tab
		if ( ch == '\x9' )
			{
			int offset;

			PrintX	-= px;
			offset	 = 4 * 5 - PrintX % ( 4 * 5 );
			PrintX	+= offset + px;
			origdest += offset * TEXTUREHEIGHT;
			dest		= origdest;
			continue;
			}

		ch -= 31;
		width = IFont->width[ ch ];

		source = ( ( byte * )IFont ) + IFont->charofs[ ch ];

		while (width--)
		{
			height = ht;
			while (height--)
			{
				pix = *source;
				if ( pix != 0xFE )
					{
					*dest = ( ( byte )intensitytable[ ( pix << 8 ) + color ] );
					GetIntensityColor( pix );
					}

				source++;
				dest ++;
			}

			PrintX++;
			origdest+=TEXTUREHEIGHT;
			dest = origdest;
		}
	}

}


//******************************************************************************
//
// DrawTMenuBufPropString ()
//
// Draws a string at px, py to bufferofs
//
//******************************************************************************

void DrawTMenuBufPropString (int px, int py, char *string)
{
	byte  pix;
	int	width,height,ht;
	byte  *source, *dest, *origdest;
	int	ch;


	if (MenuBufStarted==false)
		Error("Called DrawTMenuBufPropString without menubuf started\n");

	ht = CurrentFont->height;
	dest = origdest = (byte*)menubuf+(px*TEXTUREHEIGHT)+py;

	shadingtable=colormap+(StringShade<<8);
	while ((ch = *string++)!=0)
	{
		ch -= 31;
		width = CurrentFont->width[ch];
		source = ((byte *)CurrentFont)+CurrentFont->charofs[ch];
		while (width--)
		{
			height = ht;
			while (height--)
			{
				pix = *source;
				if (pix)
					{
					pix = *dest;
					pix = *(shadingtable+pix);
					*dest = pix;
					}
				source++;
				dest ++;
			}

			PrintX++;
			origdest+=TEXTUREHEIGHT;
			dest = origdest;
		}
	}
}


//******************************************************************************
//
// MenuBufCPrintLine() - Prints a string centered on the current line and
//	 advances to the next line. Newlines are not supported.
//
//******************************************************************************

void MenuBufCPrintLine (char *s)
{
	int w, h;

	USL_MeasureString (s, &w, &h, CurrentFont);

	if (w > WindowW)
		Error("MenuBufCPrintLine() - String exceeds width");

	PrintX = WindowX + ((WindowW - w) / 2);
	DrawMenuBufPropString (PrintX, PrintY, s);
	PrintY += h;
}

//******************************************************************************
//
// MenuBufCPrint() - Prints a string in the current window. Newlines are
//	 supported.
//
//******************************************************************************

void MenuBufCPrint (char *s)
{
	char  c,
			*se;

	while (*s)
	{
		se = s;
		while ((c = *se) && (c != '\n'))
			se++;
		*se = '\0';

		MenuBufCPrintLine(s);

		s = se;
		if (c)
		{
			*se = c;
			s++;
		}
	}
}

//******************************************************************************
//
// MenuBufPrintLine() - Prints a string on the current line and
//	 advances to the next line. Newlines are not supported.
//
//******************************************************************************

void MenuBufPrintLine (char *s)
{
	int w, h;

	USL_MeasureString (s, &w, &h, CurrentFont);

	if (w > WindowW)
		Error("MenuBufCPrintLine() - String exceeds width");

	PrintX = WindowX;
	DrawMenuBufPropString (PrintX, PrintY, s);
	PrintY += h;
}

//******************************************************************************
//
// MenuBufPrint() - Prints a string in the current window. Newlines are
//	 supported.
//
//******************************************************************************

void MenuBufPrint (char *s)
{
	char  c,
			*se;

	while (*s)
	{
		se = s;
		while ((c = *se) && (c != '\n'))
			se++;
		*se = '\0';

		MenuBufPrintLine(s);

		s = se;
		if (c)
		{
			*se = c;
			s++;
		}
	}
}

//******************************************************************************
//
// MenuTBufPrintLine() - Prints a string on the current line and
//	 advances to the next line. Newlines are not supported.
//
//******************************************************************************

void MenuTBufPrintLine (char *s, int shade)
{
	int w, h;

	USL_MeasureString (s, &w, &h, CurrentFont);

	if (w > WindowW)
		Error("MenuBufCPrintLine() - String exceeds width");

	PrintX = WindowX;
	StringShade=shade;
	DrawTMenuBufPropString (PrintX, PrintY, s);
	PrintY += h;
}

//******************************************************************************
//
// FlipMenuBuf
//
//******************************************************************************

void FlipMenuBuf ( void )
{
	int i;
	int dh;
	int h;
	int y;
	int dy;
	int time;
	int flip;

	if (MenuBufStarted==false)
		Error("Called FlipMenuBuf without menubuf started\n");

	if (!readytoflip)
		Error("FlipMenuBuf called without SetAlternateMenuBuf beforehand");
	readytoflip=0;
	if (Menuflipspeed<=5)
		{
		menubuf=menubuffers[alternatemenubuf];
		strcpy(titlestring,menutitles[alternatemenubuf]);
		RefreshMenuBuf(0);
		}
	else
		{
		menubuf=menubuffers[alternatemenubuf^1];
		strcpy(titlestring,menutitles[alternatemenubuf^1]);
		time=Menuflipspeed-5;
		dh=(1024<<8)/time;
		h=0;
		dy=((MENUTITLEY*6)<<8)/time;
		y=0;
		flip=0;
		titleyoffset=0;
		for (i=0;i<time;i+=tics)
			{
			PositionMenuBuf(h>>8,NORMALVIEW,true);
			h+=dh*tics;
			y+=dy*tics;
			titleyoffset=y>>8;
			if ((h>=512<<8) && (flip==0))
				{
				MN_PlayMenuSnd (SD_MENUFLIP);
				h=1536<<8;
				dy=-dy;
				menubuf=menubuffers[alternatemenubuf];
				strcpy(titlestring,menutitles[alternatemenubuf]);
				flip=1;
				}
			}
		}
	titleyoffset=0;
	BackgroundDrawn=false;
}



//******************************************************************************
//
// RotatePlane
//
//******************************************************************************

void RotatePlane ( void )
{
	SetupMenuBuf();

	while (!(Keyboard[0x01]))
		{
		RefreshMenuBuf(100);
		SetAlternateMenuBuf();
		ClearMenuBuf();
		DrawMenuBufPic  (0,0,W_GetNumForName("newg11"));
		DrawMenuBufItem (0,0,W_GetNumForName("apogee"));
		FlipMenuBuf();
		EraseMenuBufRegion(30,30,30,30);
		RefreshMenuBuf(100);
		SetAlternateMenuBuf();
		ClearMenuBuf();
		FlipMenuBuf();
		}
	ShutdownMenuBuf();
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
//****************************************************************************
//
// RT_CFG.C
//
//****************************************************************************

#define _ROTT_

// #include <io.h>
#include <stdlib.h>
// #include <fcntl.h>
#include <string.h>
// #include <bios.h>
// #include <conio.h>
#include <ctype.h>
// #include <process.h>

#ifdef _ROTT_
#include "rt_def.h"
#else
#include "st_def.h"
#endif

#include "rt_cfg.h"
#include "version.h"

#ifdef _ROTT_

#include "scriplib.h"
#include "rt_playr.h"
#include "rt_menu.h"
#include "rt_game.h"
#include "rt_in.h"
#include "z_zone.h"
#include "w_wad.h"
#include "rt_crc.h"
#include "rt_sound.h"
#include "rt_util.h"
#include "rt_main.h"
#include "rt_view.h"
#include "rt_msg.h"
#include "rt_battl.h"
#include "rt_net.h"
#include "isr.h"
#include "fx_man.h"
#include "develop.h"

#else

#include "st_def.h"
#include "rt_cfg.h"
#include "scriplib.h"
#include "rt_sound.h"
#include "st_util.h"

#endif
//MED
// #include "memcheck.h"


//******************************************************************************
//
// GLOBALS
//
//******************************************************************************

boolean WriteSoundFile	= true;

int	FXMode			= 1;
int	MusicMode		= 1;
int	MUvolume			= 196;
int	FXvolume			= 196;

fx_blaster_config SBSettings =
	{
	0x220, fx_SB, 7, 1, 5, 0x330, 0x620
	};

boolean mouseenabled	= 1;
boolean joystickenabled  = 0;
boolean joypadenabled	= 0;
int	joystickport	= 0;
int	mouseadjustment  = 5;
int	threshold		= 1;
int	NumVoices		= 4;
int	NumChannels		= 1;
int	NumBits			= 8;
int	MidiAddress		= 0x330;
boolean cybermanenabled  = false;
boolean assassinenabled  = false;
boolean spaceballenabled = false;
boolean AutoDetailOn	= true;
int	DoubleClickSpeed = 20;
boolean BobbinOn			= true;
int	Menuflipspeed	= 15;
int	DetailLevel		= 2;			//HI DETAIL
int	fandc				= 1;
int	blanktime		= (2*60*VBLCOUNTER);
boolean ConfigLoaded	= false;
boolean stereoreversed	= false;

int	DefaultDifficulty		= 2;
int	DefaultPlayerCharacter = 0;
int	DefaultPlayerColor	= 0;
byte	passwordstring[20];

#ifndef _ROTT_

int	fulllight		= 0;
int	viewsize			= 7;

#endif
MacroList CommbatMacros[MAXMACROS];

char *ApogeePath = "APOGEECD";

//******************************************************************************
//
// LOCALS
//
//******************************************************************************

static char SoundName[13]  = "SOUND.ROT";

#ifdef _ROTT_

static char *ConfigName = "CONFIG.ROT";
static char *ScoresName = "SCORES.ROT";
static char *ROTT		= "ROTT.ROT";
static char *CONFIG	= "SETUP.ROT";
static char *BattleName = "BATTLE.ROT";

AlternateInformation RemoteSounds;
//AlternateInformation PlayerGraphics;
AlternateInformation GameLevels;
AlternateInformation BattleLevels;
char CodeName[MAXCODENAMELENGTH];

#endif


#ifdef _ROTT_

//******************************************************************************
//
// ReadScores ()
//
//******************************************************************************

void ReadScores (void)
{
	int file;
	char filename[ 128 ];

	GetPathFromEnvironment( filename, ApogeePath, ScoresName );
//	if (w_chkaccess (filename) == 0)
	if (w_chkaccess (filename) == 0)
	{
		file = SafeOpenRead (filename);
		SafeRead (file, &Scores, sizeof (Scores));
		w_close(file);
	}
	else
		gamestate.violence = 0;
}

#endif

//******************************************************************************
//
// ReadInt
//
//******************************************************************************

void ReadInt (const char * s1, int * val)
{
	GetToken (true);
	if (!strcmpi (token,s1))
		{
		if (TokenAvailable()==true)
			{
			GetToken(false);
			*val=ParseNum(token);
			}
		}
}

//******************************************************************************
//
// ReadBoolean
//
//******************************************************************************

void ReadBoolean (const char * s1, boolean * val)
{
	int temp;

	temp = (int)(*val);
	ReadInt (s1,&temp);
	*val = (boolean) temp;
}

//******************************************************************************
//
// ReadUnsigned
//
//******************************************************************************

void ReadUnsigned (const char * s1, unsigned * val)
{
	int temp;

	temp = (int)(*val);
	ReadInt (s1,&temp);
	*val = (unsigned) temp;
}


//******************************************************************************
//
// ParseSoundFile ()
//
//******************************************************************************

boolean ParseSoundFile (void)
{
	boolean retval = true;
	int version	= 0;

	ReadInt("Version",&version);

	if (version == ROTTVERSION)
	{
		// Read in Music Mode

		ReadInt ("MusicMode",&MusicMode);

		// Read in FX Mode

		ReadInt ("FXMode",&FXMode);

		// Read in Music Volume

		ReadInt ("MusicVolume", &MUvolume);

		// Read in FX Volume

		ReadInt ("FXVolume", &FXvolume);

		// Read in numvoices

		ReadInt ("NumVoices",&NumVoices);

		// Read in numchannels

		ReadInt ("NumChannels",&NumChannels);

		// Read in numbits

		ReadInt ("NumBits",&NumBits);

		// Read in Midi Address

		ReadInt ("MidiAddress",&MidiAddress);

		// Read in stereo reversal

		ReadBoolean ("StereoReverse",&stereoreversed);

		// Read in Sound Blaster info
		ReadUnsigned ("SBType",  &SBSettings.Type );
		ReadUnsigned ("SBPort",  &SBSettings.Address );
		ReadUnsigned ("SBIrq",	&SBSettings.Interrupt );
		ReadUnsigned ("SBDma8",  &SBSettings.Dma8 );
		ReadUnsigned ("SBDma16", &SBSettings.Dma16 );
		ReadUnsigned ("SBMidi",  &SBSettings.Midi );
		ReadUnsigned ("SBEmu",	&SBSettings.Emu );
	}
	else
		retval = false;

	return (retval);
}



//******************************************************************************
//
// SetSoundDefaultValues ()
//
//******************************************************************************
void SetSoundDefaultValues
	(
	void
	)

	{
	fx_blaster_config blaster;
	int status;

	//
	//  no config file, so select default values
	//
	MusicMode	= 0;
	FXMode		= 0;
	NumVoices	= 4;
	NumChannels = 1;
	NumBits	= 8;
	MidiAddress = 0x330;
	stereoreversed = false;

	status = FX_GetBlasterSettings( &blaster );
	if ( status == FX_Ok )
		{
		SBSettings.Type		= blaster.Type;
		SBSettings.Address	= blaster.Address;
		SBSettings.Interrupt = blaster.Interrupt;
		SBSettings.Dma8		= blaster.Dma8;
		SBSettings.Dma16	= blaster.Dma16;
		SBSettings.Midi		= blaster.Midi;
		SBSettings.Emu		= blaster.Emu;
		}
	}


#ifdef _ROTT_

extern char	pword[ 13 ];
//******************************************************************************
//
// ConvertStringToPasswordString ()
//
//******************************************************************************

#define PASSWORDENCRYPTER "7d7e4a2d3b6a0319554654231f6d2a"

void ConvertStringToPasswordString ( char * string )
{
	unsigned int ui;
	int i;
	char temp[3];

	memset(temp,0,sizeof(temp));

	for (i=0;i<13;i++)
		{
		memcpy(&temp[0],&string[i<<1],2);
//		sscanf(&temp[0],"%x",&passwordstring[i]);
		sscanf(&temp[0],"%x",&ui);
		passwordstring[i]=ui;
		}
}

//******************************************************************************
//
// ConvertPasswordStringToPassword ()
//
//******************************************************************************

void ConvertPasswordStringToPassword ( void )
{
	int i;
	int x;
	char temp[3];
	char key[40];

	memset(temp,0,sizeof(temp));
	strcpy(&key[0],PASSWORDENCRYPTER);

	for (i=0;i<12;i++)
		{
		memcpy(&temp[0],&key[i<<1],2);
		sscanf(&temp[0],"%x",&x);
		pword[i]=passwordstring[i]^x;
		}
	memcpy(&temp[0],&key[i<<1],2);
	sscanf(&temp[0],"%x",&x);
	gamestate.violence=passwordstring[i]^x;
	if (
		(gamestate.violence<0) ||
		(gamestate.violence>3)
		)
		gamestate.violence=0;
}

//******************************************************************************
//
// ConvertPasswordStringToString ()
//
//******************************************************************************

void ConvertPasswordStringToString ( char * string )
{
	int i;
	char temp[8];

	memset(temp,0,sizeof(temp));

	for (i=0;i<13;i++)
		{
		itoa((passwordstring[i]>>4),&temp[0],16);
		string[(i<<1)+0]=temp[0];
		itoa((passwordstring[i]&0xf),&temp[0],16);
		string[(i<<1)+1]=temp[0];
		}
}

//******************************************************************************
//
// ConvertPasswordToPasswordString ()
//
//******************************************************************************

void ConvertPasswordToPasswordString ( void )
{
	int i;
	int x;
	char temp[3];
	char key[40];

	memset(temp,0,sizeof(temp));
	strcpy(&key[0],PASSWORDENCRYPTER);

	for (i=0;i<12;i++)
		{
		memcpy(&temp[0],&key[i<<1],2);
		sscanf(&temp[0],"%x",&x);
		passwordstring[i]=pword[i]^x;
		}
	memcpy(&temp[0],&key[i<<1],2);
	sscanf(&temp[0],"%x",&x);
	passwordstring[i]=gamestate.violence^x;
}

//******************************************************************************
//
// ParseConfigFile ()
//
//******************************************************************************

boolean ParseConfigFile (void)
{
//	int temp;
	boolean retval = true;
	int version	= 0;

	ReadInt("Version",&version);

	if (version == ROTTVERSION)
	{
		// Read in MouseEnabled

		ReadBoolean("MouseEnabled",&mouseenabled);

		// Read in JoystickEnabled

		ReadBoolean("JoystickEnabled",&joystickenabled);

		// Read in JoypadEnabled

		ReadBoolean("JoypadEnabled",&joypadenabled);

		// Read in JoystickPort

		ReadInt("JoystickPort",&joystickport);

		// Read in ViewSize

		ReadInt("ViewSize",&viewsize);

		// Read in MouseAdjustment

		ReadInt("MouseAdjustment",&mouseadjustment);

		// Read in threshold

		ReadInt("Threshold",&threshold);

		// Read in Auto Detail

		ReadBoolean ("AutoDetail", &AutoDetailOn);

		// Read in Light Dim

		ReadInt ("LightDim", &fulllight);

		// Read in Bobbin' On

		ReadBoolean ("BobbingOn", &BobbinOn);

		// Read in Double Click Speed

		ReadInt ("DoubleClickSpeed", &DoubleClickSpeed);

		// Read in Menu Flip Speed

		ReadInt ("MenuFlipSpeed", &Menuflipspeed);

		// Read in Detail Level

		ReadInt ("DetailLevel", &DetailLevel);

		// Read in Floor and Ceiling

		ReadInt ("FloorCeiling", &fandc);

		// Read in MessagesEnabled

		ReadBoolean ("Messages", &MessagesEnabled );

		// Read in Autorun

		ReadInt ("AutoRun", &gamestate.autorun );

		// Read in GammaIndex

		ReadInt ("GammaIndex", &gammaindex);

		// Read screen blanking time

		ReadInt ("BlankTime", &blanktime);

		blanktime=blanktime*60*VBLCOUNTER;

		// Read keys

		ReadInt ("Fire",		&buttonscan[0]);
		ReadInt ("Strafe",		&buttonscan[1]);
		ReadInt ("Run",			&buttonscan[2]);
		ReadInt ("Use",			&buttonscan[3]);
		ReadInt ("LookUp",		&buttonscan[4]);
		ReadInt ("LookDn",		&buttonscan[5]);
		ReadInt ("Swap",		&buttonscan[6]);
		ReadInt ("Drop",		&buttonscan[7]);
		ReadInt ("TargetUp",	&buttonscan[8]);
		ReadInt ("TargetDn",	&buttonscan[9]);
		ReadInt ("SelPistol",	&buttonscan[10]);
		ReadInt ("SelDualPistol",&buttonscan[11]);
		ReadInt ("SelMP40",	&buttonscan[12]);
		ReadInt ("SelMissile",  &buttonscan[13]);
		ReadInt ("AutoRun",	&buttonscan[14]);
		ReadInt ("LiveRemRid",  &buttonscan[15]);
		ReadInt ("StrafeLeft",  &buttonscan[16]);
		ReadInt ("StrafeRight", &buttonscan[17]);
		ReadInt ("VolteFace",	&buttonscan[18]);
		ReadInt ("Aim",			&buttonscan[19]);
		ReadInt ("Forward",	&buttonscan[20]);
		ReadInt ("Right",		&buttonscan[21]);
		ReadInt ("Backward",	&buttonscan[22]);
		ReadInt ("Left",		&buttonscan[23]);
		ReadInt ("Map",			&buttonscan[24]);
		ReadInt ("SendMessage", &buttonscan[25]);
		ReadInt ("DirectMessage",&buttonscan[26]);

		ReadInt ("MouseButton0",&buttonmouse[0]);
		ReadInt ("MouseButton1",&buttonmouse[1]);
		ReadInt ("MouseButton2",&buttonmouse[2]);
		ReadInt ("DblClickB0",  &buttonmouse[3]);
		ReadInt ("DblClickB1",  &buttonmouse[4]);
		ReadInt ("DblClickB2",  &buttonmouse[5]);

		ReadInt ("JoyButton0",  &buttonjoy[0]);
		ReadInt ("JoyButton1",  &buttonjoy[1]);
		ReadInt ("JoyButton2",  &buttonjoy[2]);
		ReadInt ("JoyButton3",  &buttonjoy[3]);
		ReadInt ("DblClickJB0", &buttonjoy[4]);
		ReadInt ("DblClickJB1", &buttonjoy[5]);
		ReadInt ("DblClickJB2", &buttonjoy[6]);
		ReadInt ("DblClickJB3", &buttonjoy[7]);

		ReadInt ("JoyMaxX",	&joyxmax);
		ReadInt ("JoyMaxY",	&joyymax);
		ReadInt ("JoyMinX",	&joyxmin);
		ReadInt ("JoyMinY",	&joyymin);

		ReadInt( "DefaultDifficulty", &DefaultDifficulty );
		ReadInt( "DefaultPlayerCharacter", &DefaultPlayerCharacter );
		ReadInt( "DefaultPlayerColor", &DefaultPlayerColor );

		// Get Password string
		GetToken (true);
		if (!stricmp (token, "SecretPassword"))
			{
			GetTokenEOL (false);
			ConvertStringToPasswordString ( &name[0] );
			}

//		if (!CybermanPresent)
//			cybermanenabled = false;

//		if (!AssassinPresent)
//			assassinenabled = false;

//		if (!SpaceBallPresent)
//			spaceballenabled = false;

		if (!MousePresent)
			mouseenabled = false;

		if (!JoysPresent[joystickport])
			joystickenabled = false;

		// precaution

		if (!joyxmin || !joyxmax || !joyymin || !joyymax)
			joystickenabled = false;

		if (joystickenabled)
			IN_SetupJoy (joystickport, joyxmin, joyxmax, joyymin, joyymax);
	}
	else
		retval = false;

	return (retval);
}


//******************************************************************************
//
// ParseBattleFile ()
//
//******************************************************************************
boolean ParseBattleFile (void)
{
	boolean retval = true;
	int version	= 0;
	int index;
	int temp;
	extern specials BattleSpecialsTimes;

	ReadInt("Version",&version);
	if (version != ROTTVERSION)
		retval = false;
	else
		{
		ReadBoolean( "ShowKillCount", &BATTLE_ShowKillCount );

		ReadInt( "GodModeTime",					&BattleSpecialsTimes.GodModeTime );
		ReadInt( "DogModeTime",					&BattleSpecialsTimes.DogModeTime );
		ReadInt( "ShroomsModeTime",				&BattleSpecialsTimes.ShroomsModeTime );
		ReadInt( "ElastoModeTime",				&BattleSpecialsTimes.ElastoModeTime );
		ReadInt( "AsbestosVestTime",			&BattleSpecialsTimes.AsbestosVestTime );
		ReadInt( "BulletProofVestTime",		&BattleSpecialsTimes.BulletProofVestTime );
		ReadInt( "GasMaskTime",					&BattleSpecialsTimes.GasMaskTime );
		ReadInt( "MercuryModeTime",				&BattleSpecialsTimes.MercuryModeTime );
		ReadInt( "GodModeRespawnTime",			&BattleSpecialsTimes.GodModeRespawnTime );
		ReadInt( "DogModeRespawnTime",			&BattleSpecialsTimes.DogModeRespawnTime );
		ReadInt( "ShroomsModeRespawnTime",	&BattleSpecialsTimes.ShroomsModeRespawnTime );
		ReadInt( "ElastoModeRespawnTime",		&BattleSpecialsTimes.ElastoModeRespawnTime );
		ReadInt( "AsbestosVestRespawnTime",	&BattleSpecialsTimes.AsbestosVestRespawnTime );
		ReadInt( "BulletProofVestRespawnTime", &BattleSpecialsTimes.BulletProofVestRespawnTime );
		ReadInt( "GasMaskRespawnTime",			&BattleSpecialsTimes.GasMaskRespawnTime );
		ReadInt( "MercuryModeRespawnTime",	&BattleSpecialsTimes.MercuryModeRespawnTime );

		ReadBoolean( "EKG", &battlegibs );

		for( index = battle_Normal; index < battle_NumBattleModes; index++ )
			{
			// Read Gravity
			temp = BATTLE_Options[ index ].Gravity;
			ReadInt( "Gravity", &temp );
			BATTLE_Options[ index ].Gravity = temp;

			// Read Speed
			temp = bo_normal_speed;
			ReadInt( "Speed", &temp );
			if ( ( temp >= bo_normal_speed ) &&
				( temp <= bo_fast_speed ) )
				{
				BATTLE_Options[ index ].Speed = temp;
				}

			if ( ( index != battle_Collector ) && ( index != battle_Tag ) &&
				( index != battle_Eluder ) )
				{
				// Read Ammo
				temp = bo_normal_shots;
				BATTLE_Options[ index ].Ammo = bo_normal_shots;
				ReadInt( "Ammo", &temp );
				if ( ( temp >= bo_one_shot ) &&
					( temp <= bo_infinite_shots ) )
					{
					BATTLE_Options[ index ].Ammo = temp;
					}
				}

			if ( index != battle_Eluder )
				{
				// Read Hitpoints
				temp = BATTLE_Options[ index ].HitPoints;
				ReadInt( "Hitpoints", &temp );
				BATTLE_Options[ index ].HitPoints = temp;
				}

			// Read Spawn Dangers
			temp = 1;
			ReadInt( "SpawnDangers", &temp );
			BATTLE_Options[ index ].SpawnDangers = temp;

			if ( index != battle_Eluder )
				{
				// Read Spawn Health
				temp = 1;
				ReadInt( "SpawnHealth", &temp );
				BATTLE_Options[ index ].SpawnHealth = temp;

				// Read Spawn Mines
				temp = 0;
				ReadInt( "SpawnMines", &temp );
				BATTLE_Options[ index ].SpawnMines = temp;
				}

			if ( ( index != battle_Collector ) && ( index != battle_Tag ) &&
				( index != battle_Eluder ) )
				{
				// Read Spawn Weapons
				temp = 1;
				ReadInt( "SpawnWeapons", &temp );
				BATTLE_Options[ index ].SpawnWeapons = temp;

				// Read Random Weapons
				temp = 0;
				ReadInt( "RandomWeapons", &temp );
				BATTLE_Options[ index ].RandomWeapons = temp;

				// Read Weapon Persistence
				temp = 0;
				ReadInt( "WeaponPersistence", &temp );
				BATTLE_Options[ index ].WeaponPersistence = temp;
				}

			if ( ( index == battle_Normal ) || ( index == battle_ScoreMore ) ||
				( index == battle_Hunter ) || ( index == battle_Tag ) )
				{
				// Read Friendly Fire
				temp = 1;
				ReadInt( "FriendlyFire", &temp );
				BATTLE_Options[ index ].FriendlyFire = temp;
				}

			if ( index != battle_Eluder )
				{
				// Read Respawn Items
				temp = 1;
				ReadInt( "RespawnItems", &temp );
				BATTLE_Options[ index ].RespawnItems = temp;
				}

			// Read Light Level
			temp = bo_light_normal;
			ReadInt( "LightLevel", &temp );
			if ( ( temp >= bo_light_dark ) &&
				( temp <= bo_light_lightning ) )
				{
				BATTLE_Options[ index ].LightLevel = temp;
				}

			if ( ( index != battle_Collector ) && ( index != battle_Scavenger ) )
				{
				// Read Point Goal
				temp = bo_kills_default;
				ReadInt( "PointGoal", &temp );
				BATTLE_Options[ index ].Kills = temp;
				if ( temp < bo_kills_random )
					{
					BATTLE_Options[ index ].Kills = bo_kills_default;
					}
				}

			if ( index != battle_Eluder )
				{
				// Read Danger Damage
				temp = bo_danger_normal;
				ReadInt( "DangerDamage", &temp );
				BATTLE_Options[ index ].DangerDamage = temp;
				}

			// Read Time Limit
			temp = bo_time_infinite;
			ReadInt( "TimeLimit", &temp );
			if ( ( index == battle_Hunter ) && ( temp == bo_time_infinite ) )
				{
				temp = 99;
				}
			BATTLE_Options[ index ].TimeLimit = temp;

			// Read Respawn time
			temp = bo_normal_respawn_time;
			ReadInt( "RespawnTime", &temp );
			BATTLE_Options[ index ].RespawnTime = temp;
			}
		}

	return (retval);
	}

//******************************************************************************
//
// SetBattleDefaultValues ()
//
//******************************************************************************

void SetBattleDefaultValues (void)
{
	int index;

	//
	//  no config file, so select default values
	//
	for( index = battle_StandAloneGame; index < battle_NumBattleModes;
		index++ )
		{
		BATTLE_Options[ index ].Gravity		= NORMAL_GRAVITY;
		BATTLE_Options[ index ].Speed		= bo_normal_speed;
		BATTLE_Options[ index ].Ammo			= bo_normal_shots;
		BATTLE_Options[ index ].HitPoints	= bo_default_hitpoints;
		BATTLE_Options[ index ].SpawnDangers = 1;
		BATTLE_Options[ index ].SpawnHealth  = 1;
		BATTLE_Options[ index ].SpawnMines	= 0;
		BATTLE_Options[ index ].SpawnWeapons = 1;
		BATTLE_Options[ index ].RespawnItems = 1;
		BATTLE_Options[ index ].RandomWeapons = 0;
		BATTLE_Options[ index ].WeaponPersistence = 0;
		BATTLE_Options[ index ].FriendlyFire = 1;
		BATTLE_Options[ index ].LightLevel	= bo_light_normal;
		BATTLE_Options[ index ].Kills		= bo_kills_default;
		BATTLE_Options[ index ].DangerDamage = bo_danger_normal;
		BATTLE_Options[ index ].TimeLimit	= bo_time_infinite;
		BATTLE_Options[ index ].RespawnTime  = bo_normal_respawn_time;
		}

	BATTLE_Options[ battle_CaptureTheTriad ].Kills  = 1;
	BATTLE_Options[ battle_Hunter ].TimeLimit		= 1;
	BATTLE_Options[ battle_Eluder ].SpawnHealth	= 0;
	BATTLE_Options[ battle_Eluder ].RespawnItems	= 0;
	BATTLE_Options[ battle_Eluder ].SpawnWeapons	= 0;
	BATTLE_Options[ battle_Eluder ].FriendlyFire	= 0;
	BATTLE_Options[ battle_Collector ].SpawnWeapons = 0;
	BATTLE_Options[ battle_Collector ].FriendlyFire = 0;
	BATTLE_Options[ battle_Tag ].SpawnWeapons		= 0;
	battlegibs=false;
	BATTLE_ShowKillCount = true;
	}

//******************************************************************************
//
// SetConfigDefaultValues ()
//
//******************************************************************************

void SetConfigDefaultValues (void)
{
	//
	//  no config file, so select default values
	//
	if (MousePresent)
		mouseenabled = true;

	joystickenabled = false;
	joypadenabled	= false;
	joystickport	= 0;
	viewsize		= 7;
	mouseadjustment = 5;
	gammaindex		= 0;
	gamestate.violence = 3;
	passwordstring[0]=0x7d;
	passwordstring[1]=0x7e;
	passwordstring[2]=0x4a;
	passwordstring[3]=0x2d;
	passwordstring[4]=0x3b;
	passwordstring[5]=0x6a;
	passwordstring[6]=0x03;
	passwordstring[7]=0x19;
	passwordstring[8]=0x55;
	passwordstring[9]=0x46;
	passwordstring[10]=0x54;
	passwordstring[11]=0x23;
	passwordstring[12]=0x1c;
}
#endif

//******************************************************************************
//
// DeleteSoundFile ()
//
//******************************************************************************
void DeleteSoundFile ( void )
{
	char filename[ 128 ];

	GetPathFromEnvironment( filename, ApogeePath, SoundName );
	unlink (filename);			// Delete SOUND.ROT
}

//******************************************************************************
//
// ReadConfig ()
//
//******************************************************************************


void ReadConfig (void)
{
	char filename[ 128 ];

	GetPathFromEnvironment( filename, ApogeePath, SoundName );
	SetSoundDefaultValues ();
//	if (w_chkaccess (filename) == 0)
	if (w_chkaccess (filename) == 0)
	{
		LoadScriptFile (filename);

		if (ParseSoundFile () == false)
		{
	//			DeleteSoundFile();
		}

		Z_Free (scriptbuffer);
	}
	else if ( !SOUNDSETUP )
	{
//		Error( "Could not find SOUND.ROT.  Please run SNDSETUP to configure "
//			"your sound hardware." );
	}


#ifdef _ROTT_
	ReadScores();

	GetPathFromEnvironment( filename, ApogeePath, ConfigName );
	SetConfigDefaultValues ();
//	if (access(filename,F_OK)==0)
	if (w_chkaccess(filename)==0)
	{
		LoadScriptFile(filename);

		if (ParseConfigFile () == false)
		{
//			unlink (filename);			// Delete CONFIG.ROT
		}

		Z_Free(scriptbuffer);
	}

	GetPathFromEnvironment( filename, ApogeePath, BattleName );
	SetBattleDefaultValues ();
//	if (access(filename,F_OK)==0)
	if (w_chkaccess(filename)==0)
	{
		LoadScriptFile(filename);

		if (ParseBattleFile() == false)
		{
//			unlink (filename);			// Delete BATTLE.ROT
		}

		Z_Free(scriptbuffer);
	}
#endif
	ConfigLoaded = true;
}

//******************************************************************************
//
// CheckVendor ()
//
//******************************************************************************

#if (SHAREWARE==1)
#define VENDORDOC ("VENDOR.DOC")
#define VENDORLUMP ("VENDOR")
#else
#define VENDORDOC ("LICENSE.DOC")
#define VENDORLUMP ("LICENSE")
#endif

void CheckVendor (void)
{
	boolean saveout=false;
	int wadcrc;
	int filecrc;
	int size;
	int lump;
	byte * vendor;
	char filename[ 128 ];

	GetPathFromEnvironment( filename, ApogeePath, VENDORDOC );
//	if (w_chkaccess (filename) == 0)
	if (w_chkaccess (filename) == 0)
		{
		size = LoadFile(filename,&vendor);
		filecrc = CalculateCRC (vendor, size);
		SafeFree(vendor);
		lump=W_GetNumForName(VENDORLUMP);
		vendor = W_CacheLumpNum(lump,PU_CACHE);
		size=W_LumpLength(lump);
		wadcrc = CalculateCRC (vendor, size);
		if (wadcrc != filecrc)
			saveout=true;
		}
	else
		saveout=true;

	if (saveout==true)
	{
		lump=W_GetNumForName(VENDORLUMP);
		vendor = W_CacheLumpNum(lump,PU_CACHE);
		size = W_LumpLength(lump);
		SaveFile (filename,vendor,size);
	}
}

//******************************************************************************
//
// WriteParameter
//
//******************************************************************************

void WriteParameter (int file, const char * s1, int val)
{
	char s[50];

	// Write out Header
	SafeWriteString (file, (char *)s1);

	// Write out space character
	strcpy (&s[0],(const char *)"  ");
	SafeWriteString (file, &s[0]);

	// Write out value
	itoa(val,&s[0],10);
	SafeWriteString (file, &s[0]);

	// Write out EOL character
	strcpy (&s[0],(const char *)"\n");
	SafeWriteString (file, &s[0]);
}


//******************************************************************************
//
// WriteParameterHex
//
//******************************************************************************

void WriteParameterHex (int file, const char * s1, int val)
{
	char s[50];

	// Write out Header
	SafeWriteString (file, (char *)s1);

	// Write out space character
	strcpy (&s[0],(const char *)"  $");
	SafeWriteString (file, &s[0]);

	// Write out value
	itoa(val,&s[0],16);
	SafeWriteString (file, &s[0]);

	// Write out EOL character
	strcpy (&s[0],(const char *)"\n");
	SafeWriteString (file, &s[0]);
}



#ifdef _ROTT_

//******************************************************************************
//
// WriteScores ()
//
//******************************************************************************

void WriteScores (void)
{
	int file;
	char filename[ 128 ];

	GetPathFromEnvironment( filename, ApogeePath, ScoresName );
//	file=SafeOpenWrite( filename );

	file=w_open( filename, "w+b");
	if(file<0)
		return;
	
	SafeWrite (file, &Scores, sizeof (Scores));
	w_close(file);
}


//******************************************************************************
//
// WriteBattleConfig ()
//
//******************************************************************************

void WriteBattleConfig
	(
	void
	)

	{
	int  file;
	int  index;
	char filename[ 128 ];
	extern specials BattleSpecialsTimes;

	// Write Battle File
	GetPathFromEnvironment( filename, ApogeePath, BattleName );
//	file = open( filename, O_RDWR | O_TEXT | O_CREAT | O_TRUNC,
 //	S_IREAD | S_IWRITE );
	file = w_open( filename, "w+b");

	if ( file == -1 )
	{
//		Error( "Error opening %s: %s", filename, strerror( errno ) );
//		Error( "Error opening %s", filename );
		printf( "Error opening %s", filename );
		return;
	}

	// Write out BATTLECONFIG header
	SafeWriteString( file,
		";Rise of the Triad Battle Configuration File\n"
		";						(c) 1995\n"
		";\n"
		";You may change these options at you own risk.  Using any values\n"
		";other than the ones documented may make the game unplayable.\n"
		";If this happens, you may delete this file (BATTLE.ROT) and ROTT\n"
		";will recreate it with the default values selected.\n"
		";\n"
		";With that in mind, have fun!\n"
		";\n"
		"\n" );

	// Write out Version
	WriteParameter( file, "Version								", ROTTVERSION );

	// Write out BATTLE_ShowKillPics
	SafeWriteString(file, "\n;\n");
	WriteParameter( file, "; Yes								- ", 1 );
	WriteParameter( file, "; No								- ", 0 );
	WriteParameter( file, "ShowKillCount						", BATTLE_ShowKillCount );

	// Write out specials' times
	SafeWriteString(file, "\n;\n"
		"; These are the time in seconds of the various powerups.\n"
		"; You could modify these to give you infinite Mercury mode,\n"
		"; stronger vests, or to make them persistant.\n;\n" );

	WriteParameter( file, "GodModeTime					", BattleSpecialsTimes.GodModeTime );
	WriteParameter( file, "DogModeTime					", BattleSpecialsTimes.DogModeTime );
	WriteParameter( file, "ShroomsModeTime				", BattleSpecialsTimes.ShroomsModeTime );
	WriteParameter( file, "ElastoModeTime				", BattleSpecialsTimes.ElastoModeTime );
	WriteParameter( file, "AsbestosVestTime			", BattleSpecialsTimes.AsbestosVestTime );
	WriteParameter( file, "BulletProofVestTime		", BattleSpecialsTimes.BulletProofVestTime );
	WriteParameter( file, "GasMaskTime					", BattleSpecialsTimes.GasMaskTime );
	WriteParameter( file, "MercuryModeTime				", BattleSpecialsTimes.MercuryModeTime );
	WriteParameter( file, "GodModeRespawnTime			", BattleSpecialsTimes.GodModeRespawnTime );
	WriteParameter( file, "DogModeRespawnTime			", BattleSpecialsTimes.DogModeRespawnTime );
	WriteParameter( file, "ShroomsModeRespawnTime	", BattleSpecialsTimes.ShroomsModeRespawnTime );
	WriteParameter( file, "ElastoModeRespawnTime		", BattleSpecialsTimes.ElastoModeRespawnTime );
	WriteParameter( file, "AsbestosVestRespawnTime	", BattleSpecialsTimes.AsbestosVestRespawnTime );
	WriteParameter( file, "BulletProofVestRespawnTime ", BattleSpecialsTimes.BulletProofVestRespawnTime );
	WriteParameter( file, "GasMaskRespawnTime			", BattleSpecialsTimes.GasMaskRespawnTime );
	WriteParameter( file, "MercuryModeRespawnTime	", BattleSpecialsTimes.MercuryModeRespawnTime );

	// Write out battlegibs
	SafeWriteString(file, "\n;\n");
	WriteParameter( file, "; Yes								- ", 1 );
	WriteParameter( file, "; No								- ", 0 );
	WriteParameter( file, "EKG									", battlegibs );

	// Describe options

	// Write out Gravity
	SafeWriteString(file, "\n"
								";\n"
								"; Here is a description of the possible values for"
								" each option:\n"
								";\n"
								"; Gravity options:\n" );
	WriteParameter( file, ";	Low Gravity				- ", LOW_GRAVITY );
	WriteParameter( file, ";	Normal Gravity			- ", NORMAL_GRAVITY );
	WriteParameter( file, ";	High Gravity				- ", HIGH_GRAVITY );

	// Write out Speed
	SafeWriteString(file, ";\n"
								"; Speed options:\n" );
	WriteParameter( file, ";	Normal Speed				- ", bo_normal_speed );
	WriteParameter( file, ";	Fast Speed				- ", bo_fast_speed );

	// Write out Ammo
	SafeWriteString(file, ";\n"
								"; Ammo options:\n" );
	WriteParameter( file, ";	One Shot					- ", bo_one_shot );
	WriteParameter( file, ";	Normal Shots				- ", bo_normal_shots );
	WriteParameter( file, ";	Infinite Shots			- ", bo_infinite_shots );

	// Write out Hit Points
	SafeWriteString(file, ";\n"
								"; Hitpoint options:\n" );
	WriteParameter( file, ";	Character Hitpoints	- ", bo_character_hitpoints );
	WriteParameter( file, ";		1 Hitpoint			- ", 1 );
	WriteParameter( file, ";		25 Hitpoints			- ", 25 );
	WriteParameter( file, ";	100 Hitpoints			- ", 100 );
	WriteParameter( file, ";	500 Hitpoints			- ", 500 );
	WriteParameter( file, ";	250 Hitpoints			- ", 250 );
	WriteParameter( file, ";	4000 Hitpoints			- ", 4000 );

	// Write out Danger Spawning
	SafeWriteString(file, ";\n"
								"; SpawnDangers options:\n"
								";	Spawn Dangers			-	1\n"
								";	Don't Spawn Dangers	-	0\n" );

	// Write out Health Spawning
	SafeWriteString(file, ";\n"
								"; SpawnHealth options:\n"
								";	Spawn Health				-	1\n"
								";	Don't Spawn Health		-	0\n" );

	// Write out Mine Spawning
	SafeWriteString(file, ";\n"
								"; SpawnMines options:\n"
								";	Spawn Mines				-	1\n"
								";	Don't Spawn Mines		-	0\n" );

	// Write out Weapon Spawning
	SafeWriteString(file, ";\n"
								"; SpawnWeapons options:\n"
								";	Spawn Weapons			-	1\n"
								";	Don't Spawn Weapons	-	0\n" );

	// Write out Random Weapons
	SafeWriteString(file, ";\n"
								"; RandomWeapons options:\n"
								";	Randomize Weapons		-	1\n"
								";	Don't Randomize Weapons -	0\n" );

	// Write out Weapon Persistence
	SafeWriteString(file, ";\n"
								"; WeaponPersistence options:\n"
								";	Weapons Persist			-	1\n"
								";	Weapons don't Persist	-	0\n" );

	// Write out Friendly Fire
	SafeWriteString(file, ";\n"
								"; FriendlyFire options:\n"
								";	Penalize Friendly Fire  -	1\n"
								";	No penalty				-	0\n" );

	// Write out Respawn Items
	SafeWriteString(file, ";\n"
								"; RespawnItems options:\n"
								";	Respawn Items			-	1\n"
								";	Don't Respawn Items	-	0\n" );

	// Write out Light Level
	SafeWriteString(file, ";\n"
								"; LightLevel options:\n" );
	WriteParameter( file, ";	Dark						- ", bo_light_dark );
	WriteParameter( file, ";	Normal Light Levels	- ", bo_light_normal );
	WriteParameter( file, ";	Bright						- ", bo_light_bright );
	WriteParameter( file, ";	Fog							- ", bo_light_fog );
	WriteParameter( file, ";	Periodic light			- ", bo_light_periodic );
	WriteParameter( file, ";	Lightning					- ", bo_light_lightning );

	// Write out Point Goal
	SafeWriteString(file, ";\n"
								"; PointGoal options:\n" );
	WriteParameter( file, ";			1 Point			- ", 1 );
	WriteParameter( file, ";			5 Points			- ", 5 );
	WriteParameter( file, ";			11 Points			- ", 11 );
	WriteParameter( file, ";			21 Points			- ", 21 );
	WriteParameter( file, ";			50 Points			- ", 50 );
	WriteParameter( file, ";			100 Points			- ", 100 );
	WriteParameter( file, ";		Random Points			- ", bo_kills_random );
	WriteParameter( file, ";		Blind Points			- ", bo_kills_blind );
	WriteParameter( file, ";	Infinite Points			- ", bo_kills_infinite );

	// Write out Danger Damage
	SafeWriteString(file, ";\n"
								"; DangerDamage options:\n" );
	WriteParameter( file, ";	Normal Damage			- ", bo_danger_normal );
	WriteParameter( file, ";	Low Damage				- ", bo_danger_low );
	WriteParameter( file, ";	Kill						- ", bo_danger_kill );

	// Write out TimeLimit
	SafeWriteString(file, ";\n"
								"; TimeLimit options:\n" );
	WriteParameter( file, ";	1 minute					- ", 1 );
	WriteParameter( file, ";	2 minute					- ", 2 );
	WriteParameter( file, ";	5 minutes				- ", 5 );
	WriteParameter( file, ";	10 minutes				- ", 10 );
	WriteParameter( file, ";	21 minutes				- ", 21 );
	WriteParameter( file, ";	30 minutes				- ", 30 );
	WriteParameter( file, ";	99 minutes				- ", 99 );
	WriteParameter( file, ";	No limit					- ", bo_time_infinite );

	// Write out RespawnTime
	SafeWriteString(file, ";\n"
								"; RespawnTime options:\n" );
	WriteParameter( file, ";	1 second					- ", 1 );
	WriteParameter( file, ";	1 minute					- ", 60 );
	WriteParameter( file, ";	2 minutes				- ", 120 );
	WriteParameter( file, ";		normal					- ", bo_normal_respawn_time );

	for( index = battle_Normal; index < battle_NumBattleModes; index++ )
		{
		SafeWriteString(file, "\n;\n");
		switch( index )
			{
			case battle_Normal :
				SafeWriteString( file, "; Standard battle options\n;\n" );
				break;

			case battle_ScoreMore :
				SafeWriteString( file, "; Score More battle options\n;\n" );
				break;

			case battle_Collector :
				SafeWriteString( file, "; Collector battle options\n;\n" );
				break;

			case battle_Scavenger :
				SafeWriteString( file, "; Scavenger battle options\n;\n" );
				break;

			case battle_Hunter :
				SafeWriteString( file, "; Hunter battle options\n;\n" );
				break;

			case battle_Tag :
				SafeWriteString( file, "; Tag battle options\n;\n" );
				break;

			case battle_Eluder :
				SafeWriteString( file, "; Eluder battle options\n;\n" );
				break;

			case battle_Deluder :
				SafeWriteString( file, "; Deluder battle options\n;\n" );
				break;

			case battle_CaptureTheTriad :
				SafeWriteString( file, "; Capture the Triad battle options\n;\n" );
				break;
			}

		// Write out Gravity
		WriteParameter( file, "Gravity			",
			BATTLE_Options[ index ].Gravity );

		// Write out Speed
		WriteParameter( file, "Speed				",
			BATTLE_Options[ index ].Speed );

		if ( ( index != battle_Collector ) && ( index != battle_Tag ) &&
			( index != battle_Eluder ) )
			{
			// Write out Ammo
			WriteParameter( file, "Ammo				",
				BATTLE_Options[ index ].Ammo );
			}

		if ( index != battle_Eluder )
			{
			// Write out Hit Points
			WriteParameter( file, "Hitpoints		",
				BATTLE_Options[ index ].HitPoints );
			}

		// Write out Danger Spawning
		WriteParameter( file, "SpawnDangers	",
			BATTLE_Options[ index ].SpawnDangers );

		if ( index != battle_Eluder )
			{
			// Write out Health Spawning
			WriteParameter( file, "SpawnHealth		",
				BATTLE_Options[ index ].SpawnHealth );

			// Write out Mine Spawning
			WriteParameter( file, "SpawnMines		",
				BATTLE_Options[ index ].SpawnMines );
			}

		if ( ( index != battle_Collector ) && ( index != battle_Tag ) &&
			( index != battle_Eluder ) )
			{
			// Write out Weapon Spawning
			WriteParameter( file, "SpawnWeapons	",
				BATTLE_Options[ index ].SpawnWeapons );

			// Write out Random Weapons
			WriteParameter( file, "RandomWeapons	",
				BATTLE_Options[ index ].RandomWeapons );

			// Write out Weapon Persistence
			WriteParameter( file, "WeaponPersistence",
				BATTLE_Options[ index ].WeaponPersistence );
			}

		if ( ( index == battle_Normal ) || ( index == battle_ScoreMore ) ||
			( index == battle_Hunter ) || ( index == battle_Tag ) )
			{
			// Write out Friendly Fire
			WriteParameter( file, "FriendlyFire	",
				BATTLE_Options[ index ].FriendlyFire );
			}

		if ( index != battle_Eluder )
			{
			// Write out Respawn Items
			WriteParameter( file, "RespawnItems	",
				BATTLE_Options[ index ].RespawnItems );
			}

		// Write out Light Level
		WriteParameter( file, "LightLevel		",
			BATTLE_Options[ index ].LightLevel );

		if ( ( index != battle_Collector ) && ( index != battle_Scavenger ) )
			{
			// Write out Point Goal
			WriteParameter( file, "PointGoal		",
				BATTLE_Options[ index ].Kills );
			}

		if ( index != battle_Eluder )
			{
			// Write out Danger Damage
			WriteParameter( file, "DangerDamage	",
				BATTLE_Options[ index ].DangerDamage );
			}

		// Write out TimeLimit
		WriteParameter( file, "TimeLimit		",
			BATTLE_Options[ index ].TimeLimit );

		// Write out RespawnTime
		WriteParameter( file, "RespawnTime		",
			BATTLE_Options[ index ].RespawnTime );
		}

	w_close( file );
	}

#endif

//******************************************************************************
//
// WriteSoundConfig ()
//
//******************************************************************************

void WriteSoundConfig
	(
	void
	)

	{
	int file;
	char filename[ 128 ];

	if ( !WriteSoundFile )
		{
		return;
		}

	GetPathFromEnvironment( filename, ApogeePath, SoundName );
//	file = open ( filename, O_RDWR | O_TEXT | O_CREAT | O_TRUNC,
//		S_IREAD | S_IWRITE);
	file = w_open ( filename, "w+b");

	if (file == -1)
	{
//		Error ("Error opening %s: %s", filename, strerror(errno));
//		Error ("Error opening %s", filename);
		printf ("Error opening %s", filename);
		return;
	}

	// Write out ROTTSOUND header

	SafeWriteString (file, ";Rise of the Triad Sound File\n");
	SafeWriteString (file, ";						(c) 1995\n\n");

	// Write out Version

	WriteParameter(file,"Version			",ROTTVERSION);

	// Write out Music Mode

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Music Modes\n");
	SafeWriteString(file,"; 0  -  Off\n");
	SafeWriteString(file,"; 1  -  UltraSound\n");
	SafeWriteString(file,"; 2  -  Sound Blaster\n");
	SafeWriteString(file,"; 3  -  Sound Man 16\n");
	SafeWriteString(file,"; 4  -  Pro Audio Spectrum\n");
	SafeWriteString(file,"; 5  -  Awe32\n");
	SafeWriteString(file,"; 6  -  SoundScape\n");
	SafeWriteString(file,"; 7  -  Wave Blaster\n");
	SafeWriteString(file,"; 8  -  General Midi\n");
	SafeWriteString(file,"; 9  -  Sound Canvas\n");
	SafeWriteString(file,"; 10 -  Adlib\n");
	WriteParameter(file,"MusicMode		",MusicMode);

	// Write out FX Mode

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; FX Modes\n");
	SafeWriteString(file,"; 0  -  Off\n");
	SafeWriteString(file,"; 1  -  UltraSound\n");
	SafeWriteString(file,"; 2  -  Sound Blaster\n");
	SafeWriteString(file,"; 3  -  Sound Man 16\n");
	SafeWriteString(file,"; 4  -  Pro Audio Spectrum\n");
	SafeWriteString(file,"; 5  -  Awe32\n");
	SafeWriteString(file,"; 6  -  SoundScape\n");
	SafeWriteString(file,"; 7  -  Adlib\n");
	SafeWriteString(file,"; 8  -  Disney Sound Source\n");
	SafeWriteString(file,"; 9  -  Tandy Sound Source\n");
	SafeWriteString(file,"; 10 -  PC Speaker\n");
	WriteParameter(file,"FXMode			",FXMode);

	// Write in Music Volume

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Music Volume\n");
	SafeWriteString(file,"; (low) 0 - 255 (high)\n");
	WriteParameter (file, "MusicVolume	", MUvolume);

	// Write in FX Volume

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; FX Volume\n");
	SafeWriteString(file,"; (low) 0 - 255 (high)\n");
	WriteParameter (file, "FXVolume		", FXvolume);

	// Write out numvoices

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Number of Voices\n");
	SafeWriteString(file,"; 1 - 8\n");
	WriteParameter(file,"NumVoices		",NumVoices);

	// Write out numchannels

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Stereo or Mono\n");
	SafeWriteString(file,"; 1 - Mono\n");
	SafeWriteString(file,"; 2 - Stereo\n");
	WriteParameter(file,"NumChannels		",NumChannels);

	// Write out numbits

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Resolution\n");
	SafeWriteString(file,"; 8 bit\n");
	SafeWriteString(file,"; 16 bit\n");
	WriteParameter(file,"NumBits			",NumBits);

	// Write out Midi Address

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Midi Addresses\n");
	SafeWriteString(file,"; $300\n");
	SafeWriteString(file,"; $310\n");
	SafeWriteString(file,"; $320\n");
	SafeWriteString(file,"; $330\n");
	SafeWriteString(file,"; $340\n");
	SafeWriteString(file,"; $350\n");
	SafeWriteString(file,"; $360\n");
	SafeWriteString(file,"; $370\n");
	SafeWriteString(file,"; $380\n");
	WriteParameterHex(file,"MidiAddress		",MidiAddress);

	// Write out stereo reversal

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; ReverseStereo\n");
	SafeWriteString(file,"; 0 no reversal\n");
	SafeWriteString(file,"; 1 reverse stereo\n");
	WriteParameter (file,"StereoReverse		",stereoreversed);

	// Write out Sound Blaster info

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Sound Blaster Settings\n");
	WriteParameter(file, "SBType			", SBSettings.Type );
	WriteParameterHex(file, "SBPort			", SBSettings.Address );
	WriteParameter(file, "SBIrq				", SBSettings.Interrupt );
	WriteParameter(file, "SBDma8			", SBSettings.Dma8 );
	WriteParameter(file, "SBDma16			", SBSettings.Dma16 );
	WriteParameterHex(file, "SBMidi			", SBSettings.Midi );
	WriteParameterHex(file, "SBEmu				", SBSettings.Emu );

	w_close (file);
	}


//******************************************************************************
//
// WriteConfig ()
//
//******************************************************************************

void WriteConfig (void)
{
	int file;
	char filename[ 128 ];
	char passwordtemp[50];
	static int inconfig = 0;

	if (inconfig > 0)
		return;

	inconfig++ ;

	if ( !ConfigLoaded )
		{
		return;
		}

	// Write Sound File
	WriteSoundConfig();

  // Write Config, Battle and Score files
#ifdef _ROTT_
	WriteScores();
	WriteBattleConfig();

	GetPathFromEnvironment( filename, ApogeePath, ConfigName );
//	file = open( filename,O_RDWR | O_TEXT | O_CREAT | O_TRUNC
//	, S_IREAD | S_IWRITE);
	file = w_open( filename, "w+b");

	if (file == -1)
	{
//		Error ("Error opening %s: %s",filename,strerror(errno));
//		Error ("Error opening %s", filename);
		printf ("Error opening %s", filename);
		return;
	}

	// Write out ROTTCONFIG header

	SafeWriteString (file, ";Rise of the Triad Configuration File\n");
	SafeWriteString (file, ";						(c) 1995\n\n");

	// Write out Version

	WriteParameter(file,"Version			",ROTTVERSION);

	// Write out MouseEnabled

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 1 - Mouse Enabled\n");
	SafeWriteString(file,"; 0 - Mouse Disabled\n");
	WriteParameter(file,"MouseEnabled	",mouseenabled);

	// Write out JoystickEnabled

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 1 - Joystick Enabled\n");
	SafeWriteString(file,"; 0 - Joystick Disabled\n");
	WriteParameter(file,"JoystickEnabled  ",joystickenabled);

	// Write out JoypadEnabled

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 1 - Joypad Enabled\n");
	SafeWriteString(file,"; 0 - Joypad Disabled\n");
	WriteParameter(file,"JoypadEnabled	",joypadenabled);

	// Write out JoystickPort

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 0 - Use Joystick Port 1\n");
	SafeWriteString(file,"; 1 - Use Joystick Port 2\n");
	WriteParameter(file,"JoystickPort	",joystickport);

	// Write out ViewSize

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Size of View port.\n");
	SafeWriteString(file,"; (smallest) 0 - 10 (largest)\n");
	WriteParameter(file,"ViewSize			",viewsize);

	// Write out MouseAdjustment

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Sensitivity of Mouse\n");
	SafeWriteString(file,"; (lowest) 0 - 11 (highest)\n");
	WriteParameter(file,"MouseAdjustment  ",mouseadjustment);

	// Write out threshold

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Threshold of Mouse and Joystick\n");
	SafeWriteString(file,"; (smallest) 1 - 15 (largest)\n");
	WriteParameter(file,"Threshold		",threshold);

	// Write in Cyberman Enabled

//	SafeWriteString(file,"\n;\n");
//	SafeWriteString(file,"; 1 - Cyberman Enabled\n");
//	SafeWriteString(file,"; 0 - Cyberman Disabled\n");
//	WriteParameter(file,"CybermanEnabled  ",cybermanenabled);

	// Write in Spaceball Enabled

//	SafeWriteString(file,"\n;\n");
//	SafeWriteString(file,"; 1 - Spaceball Enabled\n");
//	SafeWriteString(file,"; 0 - Spaceball Disabled\n");
//	WriteParameter(file,"SpaceballEnabled ",spaceballenabled);

	// Write in Auto Detail

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 1 - Auto Detail on\n");
	SafeWriteString(file,"; 0 - Auto Detail off\n");
	WriteParameter (file,"AutoDetail		", AutoDetailOn);

	// Write in Light Dim

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 1 - Light Diminishing on\n");
	SafeWriteString(file,"; 0 - Light Diminishing off\n");
	WriteParameter (file,"LightDim			", fulllight);

	// Write in Bobbin' On

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 1 - Bobbing on\n");
	SafeWriteString(file,"; 0 - Bobbing off\n");
	WriteParameter (file,"BobbingOn		", BobbinOn);

	// Write in Double Click Speed

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; (slowest) 50 - 5 (fastest)\n");
	WriteParameter (file,"DoubleClickSpeed ", DoubleClickSpeed);

	// Write in Menu Flip Speed

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Menu Flip Speed\n");
	SafeWriteString(file,"; (slowest) 100 - 5 (fastest)\n");
	WriteParameter (file,"MenuFlipSpeed	", Menuflipspeed);

	// Write in Detail Level

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 0 - Detail Level Low\n");
	SafeWriteString(file,"; 1 - Detail Level Medium\n");
	SafeWriteString(file,"; 2 - Detail Level High\n");
	WriteParameter (file,"DetailLevel		", DetailLevel);

	// Write in Floor and Ceiling

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 1 - Floor and Ceiling on\n");
	SafeWriteString(file,"; 0 - Floor and Ceiling off\n");
	WriteParameter (file,"FloorCeiling	", fandc);

	// Write in DisableMessages

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 1 - Messages on\n");
	SafeWriteString(file,"; 0 - Messages off\n");
	WriteParameter (file,"Messages			", MessagesEnabled );

	// Write in AutoRun

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 1 - AutoRun on\n");
	SafeWriteString(file,"; 0 - AutoRun off\n");
	WriteParameter (file,"AutoRun			", gamestate.autorun );

	// Write in GammaIndex

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; 0 - Gamma Correction level 1\n");
	SafeWriteString(file,"; 1 - Gamma Correction level 2\n");
	SafeWriteString(file,"; 2 - Gamma Correction level 3\n");
	SafeWriteString(file,"; 3 - Gamma Correction level 4\n");
	SafeWriteString(file,"; 4 - Gamma Correction level 5\n");
	WriteParameter (file,"GammaIndex		", gammaindex);

	// Write out screen saver time
	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Minutes before screen blanking\n");
	WriteParameter (file,"BlankTime		", blanktime/(VBLCOUNTER*60));


	// Write out keys

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Scan codes for keyboard buttons\n");
	WriteParameter (file,"Fire				", buttonscan[0]);
	WriteParameter (file,"Strafe			", buttonscan[1]);
	WriteParameter (file,"Run				", buttonscan[2]);
	WriteParameter (file,"Use				", buttonscan[3]);
	WriteParameter (file,"LookUp			", buttonscan[4]);
	WriteParameter (file,"LookDn			", buttonscan[5]);
	WriteParameter (file,"Swap				", buttonscan[6]);
	WriteParameter (file,"Drop				", buttonscan[7]);
	WriteParameter (file,"TargetUp			", buttonscan[8]);
	WriteParameter (file,"TargetDn			", buttonscan[9]);
	WriteParameter (file,"SelPistol		", buttonscan[10]);
	WriteParameter (file,"SelDualPistol	", buttonscan[11]);
	WriteParameter (file,"SelMP40			", buttonscan[12]);
	WriteParameter (file,"SelMissile		", buttonscan[13]);
	WriteParameter (file,"AutoRun			", buttonscan[14]);
	WriteParameter (file,"LiveRemRid		", buttonscan[15]);
	WriteParameter (file,"StrafeLeft		", buttonscan[16]);
	WriteParameter (file,"StrafeRight		", buttonscan[17]);
	WriteParameter (file,"VolteFace		", buttonscan[18]);
	WriteParameter (file,"Aim				", buttonscan[19]);
	WriteParameter (file,"Forward			", buttonscan[20]);
	WriteParameter (file,"Right				", buttonscan[21]);
	WriteParameter (file,"Backward			", buttonscan[22]);
	WriteParameter (file,"Left				", buttonscan[23]);
	WriteParameter (file,"Map				", buttonscan[24]);
	WriteParameter (file,"SendMessage		", buttonscan[25]);
	WriteParameter (file,"DirectMessage	", buttonscan[26]);

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Mouse buttons\n");

	WriteParameter (file,"MouseButton0	", buttonmouse[0]);
	WriteParameter (file,"MouseButton1	", buttonmouse[1]);
	WriteParameter (file,"MouseButton2	", buttonmouse[2]);
	WriteParameter (file,"DblClickB0		", buttonmouse[3]);
	WriteParameter (file,"DblClickB1		", buttonmouse[4]);
	WriteParameter (file,"DblClickB2		", buttonmouse[5]);

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Joystick buttons\n");

	WriteParameter (file,"JoyButton0		", buttonjoy[0]);
	WriteParameter (file,"JoyButton1		", buttonjoy[1]);
	WriteParameter (file,"JoyButton2		", buttonjoy[2]);
	WriteParameter (file,"JoyButton3		", buttonjoy[3]);
	WriteParameter (file,"DblClickJB0		", buttonjoy[4]);
	WriteParameter (file,"DblClickJB1		", buttonjoy[5]);
	WriteParameter (file,"DblClickJB2		", buttonjoy[6]);
	WriteParameter (file,"DblClickJB3		", buttonjoy[7]);

	SafeWriteString(file,"\n;\n");
	SafeWriteString(file,"; Joystick calibration coordinates\n");

	WriteParameter (file,"JoyMaxX			", joyxmax);
	WriteParameter (file,"JoyMaxY			", joyymax);
	WriteParameter (file,"JoyMinX			", joyxmin);
	WriteParameter (file,"JoyMinY			", joyymin);

	// Write out DefaultDifficulty
	SafeWriteString(file,"\n;\n");
	WriteParameter(file,"; Easy				- ", gd_baby );
	WriteParameter(file,"; Medium			- ", gd_easy );
	WriteParameter(file,"; Hard				- ", gd_medium );
	WriteParameter(file,"; Crezzy			- ", gd_hard );
	WriteParameter(file,"DefaultDifficulty	", DefaultDifficulty );

	// Write out DefaultPlayerCharacter
	SafeWriteString(file,"\n;\n");
	WriteParameter(file,"; Taradino Cassatt	- ", 0 );
	WriteParameter(file,"; Thi Barrett		- ", 1 );
	WriteParameter(file,"; Doug Wendt			- ", 2 );
	WriteParameter(file,"; Lorelei Ni			- ", 3 );
	WriteParameter(file,"; Ian Paul Freeley	- ", 4 );
	WriteParameter(file,"DefaultPlayerCharacter ", DefaultPlayerCharacter );

	// Write out DefaultPlayerColor
	SafeWriteString(file,"\n;\n");
	WriteParameter(file,"; Gray				- ", 0 );
	WriteParameter(file,"; Brown				- ", 1 );
	WriteParameter(file,"; Black				- ", 2 );
	WriteParameter(file,"; Tan				- ", 3 );
	WriteParameter(file,"; Red				- ", 4 );
	WriteParameter(file,"; Olive				- ", 5 );
	WriteParameter(file,"; Blue				- ", 6 );
	WriteParameter(file,"; White				- ", 7 );
	WriteParameter(file,"; Green				- ", 8 );
	WriteParameter(file,"; Purple			- ", 9 );
	WriteParameter(file,"; Orange			- ", 10 );
	WriteParameter(file,"DefaultPlayerColor	", DefaultPlayerColor );

	// Writeout password Password string
	SafeWriteString(file,"\n;\nSecretPassword			");
	memset(passwordtemp,0,sizeof(passwordtemp));
	ConvertPasswordStringToString ( &passwordtemp[0] );
	SafeWriteString(file,&passwordtemp[0]);

	w_close (file);
#endif
	inconfig--;
}

#ifdef _ROTT_


//****************************************************************************
//
// GetAlternatePath ()
//
//****************************************************************************

void GetAlternatePath (char * tokenstr, AlternateInformation *info)
{
	strcpy (&info->path[0], ".\0");
	GetToken (true);
	if (!stricmp (token, tokenstr))
		{
		GetTokenEOL (false);
		memset (&info->path[0], 0, sizeof (info->path));
		strcpy (&info->path[0], &name[0]);
		}
}


//****************************************************************************
//
// GetAlternateFile ()
//
//****************************************************************************

void GetAlternateFile (char * tokenstr, AlternateInformation *info)
{
	// Read in remote sound file
	//
	strcpy (&info->file[0], "foo.foo\0");
	GetToken (true);
	if (!stricmp (token, tokenstr))
		{
		if (TokenAvailable()==true)
			{
			GetToken (false);
			if (stricmp (token, "~"))
				{
				#if (SHAREWARE == 0)
				info->avail = true;
				memset (&info->file[0], 0, sizeof (info->file));
				strcpy (&info->file[0], &token[0]);
				#else
				printf("Alternate file %s ignored.\n",token);
				memset (&info->file[0], 0, sizeof (info->file));
				#endif
				}
			}
		}
}


//****************************************************************************
//
// ReadSETUPFiles ()
//
//****************************************************************************

void ReadSETUPFiles (void)
{
	char filename[ 128 ];
	int i;

	RemoteSounds.avail	= false;
//	PlayerGraphics.avail = false;
	GameLevels.avail	= false;
	BattleLevels.avail	= false;

	GetPathFromEnvironment( filename, ApogeePath, CONFIG );
	if (w_chkaccess (filename) == 0)
	{
		LoadScriptFile (filename);

		GetTokenEOL (true);	//MODEMNAME
		GetTokenEOL (true);	//MODEMINITSTR
		GetTokenEOL (true);	//MODEMHANGUP
		GetTokenEOL (true);	//RATE
		GetTokenEOL (true);	//COMPORT
		GetTokenEOL (true);	//IRQ
		GetTokenEOL (true);	//UART
		GetTokenEOL (true);	//PULSE
		GetTokenEOL (true);	//AUTOMATICDIALOUT

		GetAlternatePath ("REMOTESOUNDPATH", &RemoteSounds);
//		GetAlternatePath ("PLAYERGRAPHICSPATH", &PlayerGraphics);
		GetAlternatePath ("GAMELEVELPATH", &GameLevels);
		GetAlternatePath ("BATTLELEVELPATH", &BattleLevels);

		// Get CodeName
		GetToken (true);
		if (stricmp (token, "CODENAME"))
			Error ("Can't find %s token.\n", "CODENAME");

		GetTokenEOL (false);
		memset (&CodeName[0], 0, sizeof (CodeName));
		if (stricmp (name, "~"))
			{

			// Get First (MAXCODENAMELENGTH-1) characters
			for (i=0;i<MAXCODENAMELENGTH-1;i++)
				CodeName[i]=name[i];
			}
		GetTokenEOL (true);	//NUMPLAYERS
		GetTokenEOL (true);	//NETWORKSOCKET
		GetTokenEOL (true);	//DEFAULT
		for (i=0;i<14;i++)
			GetTokenEOL (true);  //NUMBERLIST

		memset (CommbatMacros, 0, sizeof(CommbatMacros) );

		for (i=0;i<MAXMACROS;i++)
			{
			GetToken (true);

			GetTokenEOL (true);

			if (name[0] != '~')
				{
				memcpy (&CommbatMacros[i].macro[0], &name[0], strlen (name));
				CommbatMacros[i].avail = 1;
				}
			}

		Z_Free (scriptbuffer);
	}

	GetPathFromEnvironment( filename, ApogeePath, ROTT );
	if (w_chkaccess (filename) == 0)
	{
		LoadScriptFile (filename);

		GetTokenEOL (true);	//PHONENUMBER

		GetAlternateFile ("REMOTESOUNDFILE", &RemoteSounds);
//		GetAlternateFile ("PLAYERGRAPHICSFILE", &PlayerGraphics);
		GetAlternateFile ("GAMELEVELFILE", &GameLevels);
		GetAlternateFile ("COMMBATLEVELFILE", &BattleLevels);

		Z_Free (scriptbuffer);

//		unlink (filename);			// Delete ROTT.ROT
	}
}

#endif

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// #include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// #include <conio.h>
#include <ctype.h>
// #include <dos.h>
// #include <process.h>
#include <stdarg.h>
// #include <bios.h>
// #include <ctype.h>
#include "rt_def.h"
#include "_rt_com.h"
#include "rt_com.h"
#include "rt_util.h"
#include "rt_in.h"
#include "rt_crc.h"
#include "rt_playr.h"
#include "isr.h"
#include "rt_msg.h"
#include "rottnet.h"
#include "rt_main.h"
#include "rt_net.h"
#include "rt_draw.h"
//#include "rt_ser.h"
//MED
// #include "memcheck.h"

// GLOBAL VARIABLES

// Same as in real mode
rottcom_t   rottcom_tmp;		//BGB

// rottcom_t   *rottcom = NULL;
rottcom_t   *rottcom = &rottcom_tmp;

int badpacket;
int consoleplayer;
byte ROTTpacket[MAXCOMBUFFERSIZE];
int controlsynctime;

// LOCAL VARIABLES
// static union  REGS   comregs;
static int    ComStarted=false;
static int    transittimes[MAXPLAYERS];


/*
===============
=
= InitROTTNET
=
===============
*/

void InitROTTNET (void)
{
	int netarg;
//	long netaddress;
	nlint netaddress;

	if (ComStarted==true)
		return;
	ComStarted=true;

	netarg=CheckParm ("net");
	netarg++;

	netaddress=atol(_argv[netarg]);
	rottcom=(rottcom_t *)netaddress;
   remoteridicule = false;
   remoteridicule = rottcom->remoteridicule;
   if (rottcom->ticstep != 1)
      remoteridicule = false;
   if (remoteridicule == true)
      {
      if (!quiet)
         printf("ROTTNET: LIVE Remote Ridicule Enabled\n");
      }

   if (!quiet)
      {
      printf("ROTTNET: Communicating on vector %ld\n",rottcom->intnum);
      printf("ROTTNET: consoleplayer=%ld\n",rottcom->consoleplayer);
      }
}

/*
================
=
= ReadPacket
=
================
*/

boolean ReadPacket (void)
{
   word   crc;
   word   sentcrc;

   // Set command (Get Packet)
	rottcom->command=CMD_GET;

   badpacket = 0;

   // Check to see if a packet is ready

//	int386(rottcom->intnum,&comregs,&comregs);

   // Is it ready?

   if (rottcom->remotenode!=-1)
      {
      // calculate crc on packet
      crc=CalculateCRC (&rottcom->data[0], rottcom->datalength-sizeof(word));

      // get crc inside packet
      sentcrc=*((word *)(&rottcom->data[rottcom->datalength-sizeof(word)]));

      // are the crcs the same?
      if (crc!=sentcrc)
         {
         badpacket=1;
         SoftError("BADPKT at %ld\n",ticcount);
         }
      if (networkgame==false)
         {
         rottcom->remotenode=server;
         }
      else
         {
         if ((IsServer==true) && (rottcom->remotenode>0))
            rottcom->remotenode--;
         }
      memcpy(&ROTTpacket[0], &rottcom->data[0], rottcom->datalength);

//      SoftError( "ReadPacket: time=%ld size=%ld src=%ld type=%d\n",ticcount, rottcom->datalength,rottcom->remotenode,rottcom->data[0]);

#if 0
      rottcom->command=CMD_OUTQUEBUFFERSIZE;
      int386(rottcom->intnum,&comregs,&comregs);
      SoftError( "outque size=%ld\n",*((short *)&(rottcom->data[0])));
      rottcom->command=CMD_INQUEBUFFERSIZE;
      int386(rottcom->intnum,&comregs,&comregs);
      SoftError( "inque size=%ld\n",*((short *)&(rottcom->data[0])));
#endif
      return true;
      }
   else // Not ready yet....
      return false;
}


/*
=============
=
= WritePacket
=
=============
*/

void WritePacket (void * buffer, int len, int destination)
{
   word      crc;

   // set send command
	rottcom->command=CMD_SEND;

   // set destination
   rottcom->remotenode=destination;

   if (len>(MAXCOMBUFFERSIZE-sizeof(word)))
      {
      Error("WritePacket: Overflowed buffer\n");
      }

   // copy local buffer into realmode buffer
   memcpy((byte *)&(rottcom->data[0]),(byte *)buffer,len);

   // calculate CRC
   crc=CalculateCRC (buffer, len);

   // put CRC into realmode buffer packet
   *((word *)&rottcom->data[len])=crc;

   // set size of realmode packet including crc
   rottcom->datalength=len+sizeof(word);

   if (*((byte *)buffer)==0)
       Error("Packet type = 0\n");

   if (networkgame==true)
      {
      if (IsServer==true)
         rottcom->remotenode++; // server fix-up
      }

//   SoftError( "WritePacket: time=%ld size=%ld src=%ld type=%d\n",ticcount,rottcom->datalength,rottcom->remotenode,rottcom->data[0]);
   // Send It !
//	int386(rottcom->intnum,&comregs,&comregs);

#if 0
   rottcom->command=CMD_OUTQUEBUFFERSIZE;
   int386(rottcom->intnum,&comregs,&comregs);
   SoftError( "outque size=%ld\n",*((short *)&(rottcom->data[0])));
   rottcom->command=CMD_INQUEBUFFERSIZE;
   int386(rottcom->intnum,&comregs,&comregs);
   SoftError( "inque size=%ld\n",*((short *)&(rottcom->data[0])));
#endif
}




/*
=============
=
= ValidSyncPacket
=
=============
*/
boolean ValidSyncPacket ( synctype * sync )
{
   if (ReadPacket() && (badpacket==0))
      {
      if (((syncpackettype *)&(ROTTpacket[0]))->type==COM_SYNC)
         {
         memcpy(&(sync->pkt),&(ROTTpacket[0]),sizeof(sync->pkt));
         return true;
         }
      }
   return false;
}

/*
=============
=
= SendSyncPacket
=
=============
*/
void SendSyncPacket ( synctype * sync, int dest)
{
   sync->pkt.type=COM_SYNC;
   sync->sendtime=ticcount;
   WritePacket( &(sync->pkt.type) , sizeof(syncpackettype) , dest );
}


/*
=============
=
= SlavePhaseHandler
=
=============
*/

boolean SlavePhaseHandler( synctype * sync )
{
   boolean done;

   done=false;

   switch (sync->pkt.phase)
      {
      case SYNC_PHASE1:
         break;
      case SYNC_PHASE2:
         ISR_SetTime(sync->pkt.clocktime);
         break;
      case SYNC_PHASE3:
         sync->pkt.clocktime=ticcount;
         break;
      case SYNC_PHASE4:
         ISR_SetTime(ticcount-sync->pkt.delta);
         sync->pkt.clocktime=ticcount;
         break;
      case SYNC_PHASE5:
         ISR_SetTime(ticcount-sync->pkt.delta);
         sync->sendtime=sync->pkt.clocktime;
         done=true;
         break;
      }
   return done;
}



/*
=============
=
= MasterPhaseHandler
=
=============
*/

boolean MasterPhaseHandler( synctype * sync )
{
   boolean done;

   done=false;

   switch (sync->pkt.phase)
      {
      case SYNC_PHASE1:
         sync->pkt.phase=SYNC_PHASE2;
         sync->pkt.clocktime=ticcount+(sync->deltatime>>1);
         break;
      case SYNC_PHASE2:
         sync->pkt.phase=SYNC_PHASE3;
         break;
      case SYNC_PHASE3:
         sync->pkt.delta=sync->pkt.clocktime-ticcount+(sync->deltatime>>1);
         sync->pkt.phase=SYNC_PHASE4;
         break;
      case SYNC_PHASE4:
         sync->pkt.phase=SYNC_PHASE5;
         sync->pkt.delta=sync->pkt.clocktime-ticcount+(sync->deltatime>>1);
         sync->sendtime=ticcount+SYNCTIME;
         sync->pkt.clocktime=sync->sendtime;
         done=true;
         break;
      }
   return done;
}


/*
=============
=
= SetTime
=
=============
*/

void SetTime ( void )
{
   int i;
   syncpackettype * syncpacket;
   boolean done=false;

   syncpacket=(syncpackettype *)SafeMalloc(sizeof(syncpackettype));


   // Sync clocks

   if (networkgame==true)
      {
      if (IsServer==true)
         {
         for (i=0;i<numplayers;i++)
            {
            if (PlayerInGame(i)==false)
               continue;
            if (standalone==true)
               SyncTime(i);
            else if (i!=consoleplayer)
               SyncTime(i);
            if (standalone==true)
               printf("SetTime: player#%ld\n",i);
            }
         }
      else
         {
         SyncTime(0);
         }
      }
   else // Modem 2-player game
      {
      if (consoleplayer==0)
         SyncTime(server);
      else
         SyncTime(server);
      }

   if ( ( (networkgame==true) && (IsServer==true) ) ||
        ( (networkgame==false) && (consoleplayer==0) )
      ) // Master/Server
      {
      int nump;
      int time;

      syncpacket->type=COM_START;
      syncpacket->clocktime=ticcount;
      controlsynctime=syncpacket->clocktime;
      if (networkgame==true)
         nump=numplayers;
      else
         nump=1;

      time = ticcount;

      for (i=0;i<nump;i++)
         {
         WritePacket( &(syncpacket->type) , sizeof(syncpackettype) , i );
         }

      while (ticcount<time+(VBLCOUNTER/4)) ;

      for (i=0;i<nump;i++)
         {
         WritePacket( &(syncpacket->type) , sizeof(syncpackettype) , i );
         }

      if (standalone==true)
         printf("SetTime: Start packets sent\n");
      }
   else // Slave/Client
      {
      while (done==false)
         {
         AbortCheck("SetTime aborted as client");

         if (ReadPacket() && (badpacket==0))
            {
            memcpy(syncpacket,&(ROTTpacket[0]),sizeof(syncpackettype));
            if (syncpacket->type==COM_START)
               {
               controlsynctime=syncpacket->clocktime;
               done=true;
               }
            }
         }
      }
   if (standalone==false)
      {
      AddMessage("All players synched.",MSG_SYSTEM);
      ThreeDRefresh();
      }
   SafeFree(syncpacket);

//
// flush out any extras
//
   while (ticcount<controlsynctime+VBLCOUNTER)
      {
      ReadPacket ();
      }
}

/*
=============
=
= InitialMasterSync
=
=============
*/
void InitialMasterSync ( synctype * sync, int client )
{
   boolean done=false;
   int i;

   if (networkgame==true)
      {
      for (i=0;i<numplayers;i++)
         {
         if (i<=client)
            continue;
         sync->pkt.type=COM_SYNC;
         sync->pkt.phase=SYNC_MEMO;
         sync->pkt.clocktime=client;
         SendSyncPacket(sync,i);
         }
      }

   // Initialize send time so as soon as we enter the loop, we send

   sync->sendtime=ticcount-SYNCTIME;

   while (done==false)
      {
      sync->pkt.phase=SYNC_PHASE0;

      AbortCheck("Initial sync aborted as master");
	   if ((sync->sendtime+SYNCTIME) <= ticcount)
         SendSyncPacket(sync,client);
      if (ValidSyncPacket(sync)==true)
         {
         if (sync->pkt.phase==SYNC_PHASE0)
            {
            int time=ticcount;

            while (time+SYNCTIME>ticcount)
               {
               ReadPacket();
               }
            time=ticcount;
            while (time+SYNCTIME>ticcount) {}
            done=true;
            }
         }
      }
}

/*
=============
=
= InitialSlaveSync
=
=============
*/
void InitialSlaveSync ( synctype * sync )
{
   boolean done=false;

   while (done==false)
      {
      AbortCheck("Initial sync aborted as slave");
      if (ValidSyncPacket(sync)==true)
         {
         if (sync->pkt.phase==SYNC_MEMO)
            {
            char str[50]="Server is synchronizing player ";
            char str2[10];

            strcat(str,itoa(sync->pkt.clocktime+1,str2,10));
            AddMessage(str,MSG_SYSTEM);
            ThreeDRefresh();
            }
         if (sync->pkt.phase==SYNC_PHASE0)
            {
            int time=ticcount;

            SendSyncPacket(sync,server);
            while (time+SYNCTIME>ticcount)
               {
               ReadPacket();
               }
            done=true;
            }
         }
      }
   AddMessage("Server is synchronizing your system",MSG_SYSTEM);
   ThreeDRefresh();
}


/*
=============
=
= SyncTime
=
=============
*/

void SyncTime( int client )
{
   int dtime[NUMSYNCPHASES];
   boolean done;
   int i;
   synctype * sync;

   sync=(synctype *)SafeMalloc(sizeof(synctype));

   if ( ((networkgame==true) && (IsServer==true)) ||
         ((networkgame==false) && (consoleplayer==0)) )
      {
      // Master

      InitialMasterSync ( sync, client );

      done=false;

      // Initial setup for Master
      // Initialize send time so as soon as we enter the loop, we send

      sync->pkt.phase=SYNC_PHASE1;
      sync->sendtime=ticcount-SYNCTIME;

      while (done==false)
         {
         // Master

         AbortCheck("SyncTime aborted as master");

		   if ((sync->sendtime+SYNCTIME) <= ticcount)
            SendSyncPacket(sync,client);

         while (ValidSyncPacket(sync)==true)
            {

            // find average delta

            sync->deltatime=0;

            // calculate last delta

            dtime[sync->pkt.phase]=ticcount-sync->sendtime;

            for (i=0;i<=sync->pkt.phase;i++)
               sync->deltatime+=dtime[i];
            if (i!=0)
               sync->deltatime/=i;
            else
               Error("SyncTime: this should not happen\n");

            done = MasterPhaseHandler( sync );

            SendSyncPacket(sync,client);

            }
         }
      }
   else
      {
      // Slave

      InitialSlaveSync ( sync );

      done=false;

      while (done==false)
         {
         // Slave

         AbortCheck("SyncTime aborted as slave");

         while (ValidSyncPacket(sync)==true)
            {
            done = SlavePhaseHandler( sync );

            if (done==false)
               SendSyncPacket(sync,server);

            }
         }
      }

   while (sync->sendtime > ticcount)
      {
      while (ReadPacket()) {}
      }
   while ((sync->sendtime+SYNCTIME) > ticcount)
      {
      }

   if ( ((networkgame==true) && (IsServer==true)) ||
         ((networkgame==false) && (consoleplayer==0)) )
      SetTransitTime( client, (sync->deltatime>>1));

   SafeFree(sync);
}

/*
=============
=
= SetTransitTime
=
=============
*/

void SetTransitTime( int client, int time )
{
   transittimes[client]=time;
}

/*
=============
=
= GetTransitTime
=
=============
*/

int GetTransitTime( int client )
{
   return transittimes[client];
}

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// CRC lib

#include	<stdio.h>
#include	<stdlib.h>
#include	<string.h>
#include "rt_crc.h"
//MED
// #include "memcheck.h"

/* variables */
static unsigned short int crc16tab[256] =
{
	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

/* driver */
#if 0
main(argc,argv)
int argc; char **argv;
{
	if(argc>2) perr("Usage:  crcfast [filename]");
	if(argc==2) strcpy(filename,argv[1]);
	else
	{
		printf("\nEnter filename:  "); gets(filename);
	}
	if((fp=fopen(filename,"rb"))==NULL) perr("Can't open file");
	num=0L; crc16=crctt=0;
	while((ch=fgetc(fp))!=EOF)
	{
		num++;
		crc16=updatecrc(crc16,ch);
//		crctt=updcrc(crctt,ch);
	}
	fclose(fp);
	printf("\nNumber of bytes = %lu\nCRC16 = %04X\nCRCTT = %04X",
		num,crc16,crctt);
}

#endif

/* update crc reverse */
int updatecrc(int crc, int c)
{
	int tmp;
	tmp=crc^c;
	crc=(crc>>8)^crc16tab[tmp & 0xff];
	return crc;
}

//******************************************************************************
//
// CalculateCRC ()
//
//******************************************************************************

word CalculateCRC (byte *source, unsigned size)
{
   unsigned i;
   int checksum;
	int tmp;

   checksum=0;

   for (i = 0; i < size; i++)
      {
   	tmp=checksum^(*(source++));
	   checksum=(checksum>>8)^crc16tab[tmp & 0xff];
      }

   return ((word)checksum);

}








/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "rt_debug.h"
#include "isr.h"
#include "rt_game.h"
#include "rt_menu.h"
#include "rt_build.h"
#include "rt_str.h"
#include "rt_vid.h"
#include "rt_playr.h"
#include "rt_main.h"
#include "rt_util.h"
#include "rt_draw.h"
#include "rt_in.h"
#include "z_zone.h"
#include "rt_ted.h"
#include "rt_view.h"
#include "develop.h"
#include "rt_msg.h"
#include "rt_net.h"
#include "rt_sound.h"
#include "rt_stat.h"
#include "rt_map.h"

#include <stdlib.h>
#include <ctype.h>
//MED
// #include "memcheck.h"


typedef struct {
   char code[15];
   byte length;
} CodeStruct;

// typedef
enum
{
   ENABLECHEAT,               // enable cheats
   ENABLECHEATALT,            // enable cheats
   SOMEITEMS,                 // three keys, more health
   SOMEITEMSALT,              // three keys, more health
   INVULNERABLE,              // normal god mode
   INVULNERABLEALT,           // normal god mode
   WARP,                      // warp
   WARPALT,                   // warp
   ITEMS,                     // all keys, armor, 100% health
   ITEMSALT,                  // all keys, armor, 100% health
   GODMODEPWUP,               // god mode powerup
	GODMODEPWUPALT,            // god mode powerup
#if (SHAREWARE == 0)
   DOGMODEPWUP,               // dog mode powerup
   DOGMODEPWUPALT,            // dog mode powerup
#endif
	MERCURYPWUP,               // mercury mode powerup
   MERCURYPWUPALT,            // mercury mode powerup
   SHROOMSPWUP,               // shrooms mode powerup
   SHROOMSPWUPALT,            // shrooms mode powerup
   ELASTOPWUP,                // elasto mode powerup
   ELASTOPWUPALT,             // elasto mode powerup
   RESTARTGAME,               // warp to level 1, start with pistol
   RESTARTGAMEALT,            // warp to level 1, start with pistol
   HURTPLAYER,                // hurt player 10%
   HURTPLAYERALT,             // hurt player 10%
   TOMHALLMODE,               // run fast all the time
	TOMHALLMODEALT,            // run fast all the time
   NORMAL,                    // back to normal
   NORMALALT,                 // back to normal
   LIGHTDIMON,                // light diminishing on
   LIGHTDIMONALT,             // light diminishing on
   LIGHTDIMOFF,               // light diminishing off
   LIGHTDIMOFFALT,            // light diminishing off
   FOGON,                     // fog on (0x00 - 0x80 minmax)
   FOGONALT,                  // fog on (0x00 - 0x80 minmax)
   FOGOFF,                    // fog off (0x80 - 0xFF minmax)
   FOGOFFALT,                 // fog off (0x80 - 0xFF minmax)
   QUITGAME,                  // blow out of game
   QUITGAMEALT,               // blow out of game
   ENDLEVEL,                  // end the current level
   ENDLEVELALT,               // end the current level
   FANDCOFF,                  // floor and ceiling off
   FANDCOFFALT,               // floor and ceiling off
   FANDCON,                   // floor and ceiling on
   FANDCONALT,                // floor and ceiling on
   BULLETARMOR,               // bullet proof armor
   BULLETARMORALT,            // bullet proof armor
   FIREARMOR,                 // fire proof armor
   FIREARMORALT,              // fire proof armor
   GASMASK,                   // gas mask
   GASMASKALT,                // gas mask
   OUTFIT,                    // all keys, armor, 100% health, MP40, heatseek
   OUTFITALT,                 // all keys, armor, 100% health, MP40, heatseek
   KILLPLAYER,                // kill player
	KILLPLAYERALT,             // kill player
	RESTARTLEVEL,              // re-enter level
	RESTARTLEVELALT,           // re-enter level
   WEAPONTWOPISTOL,           // give double pistol
   WEAPONTWOPISTOLALT,        // give double pistol
   WEAPONMP40,                // give mp40
   WEAPONMP40ALT,             // give mp40
   WEAPONBAZOOKA,             // give bazooka
   WEAPONBAZOOKAALT,          // give bazooka
   WEAPONHEAT,                // give heatseeker
   WEAPONHEATALT,             // give heatseeker
   WEAPONDRUNK,               // give drunk missile
   WEAPONDRUNKALT,            // give drunk missile
   WEAPONFIREBOMB,            // give firebomb
   WEAPONFIREBOMBALT,         // give firebomb
   WEAPONFIREWALL,            // give firewall
   WEAPONFIREWALLALT,         // give firewall
	WEAPONGOD,                 // give godhand
	WEAPONGODALT,              // give godhand

#if (SHAREWARE == 0)

   WEAPONSPLIT,               // give split missile
   WEAPONSPLITALT,            // give split missile
   WEAPONKES,                 // give kes
   WEAPONKESALT,              // give kes
   WEAPONBAT,                 // give bat
   WEAPONBATALT,              // give bat
   WEAPONDOG,                 // give dogmode
   WEAPONDOGALT,              // give dogmode
#endif

   MISSILECAMTOGGLE,          // Turn missile cam on/off
   MISSILECAMTOGGLEALT,       // Turn missile cam on/off
   HUDTOGGLE,                 // Turn HUD on/off
   HUDTOGGLEALT,              // Turn HUD on/off
   ROTATIONFUN,               // Rotation fun
   DEMORECORD,                // Start recording demo
   DEMOEND,                   // End recording demo
   DEMOPLAYBACK,              // Playback demo
   CRAZYGIBS,                 // Engine Killing Gibs
   JUKEBOX,                   // JukeBox
   JUKEBOXALT,                // JukeBox
   MAPCHEAT,                  // Map Cheat
   MAPCHEATALT,               // Map Cheat Alt
   NOCLIP,                  // Map Cheat
   NOCLIPALT,               // Map Cheat Alt
   MAXCODES
};

CodeStruct Codes[MAXCODES + 4] =
{
	{"KCITSPID",    8},        // enable cheats
	{"CCE\\",       4},        // enable cheats
   {"REKCALS",     7},        // three keys, more health
   {"MUB\\",       4},        // three keys, more health
   {"NIJOHC",      6},        // normal god mode
	{"WWW\\",       4},        // normal god mode
	{"OTOG",        4},        // warp
	{"LTG\\",       4},        // warp
	{"SYOTXIS",     7},        // all keys, armor, 100% health
	{"IAG\\",       4},        // all keys, armor, 100% health
   {"DASOOT",      6},        // god mode powerup
   {"DOG\\",       4},        // god mode powerup
#if (SHAREWARE == 0)
   {"FOOW",        4},        // dog mode powerup
	{"GOD\\",       4},        // dog mode powerup
#endif
	{"YOBYLF",      6},        // mercury mode powerup
	{"REM\\",       4},        // mercury mode powerup
	{"PIRTDAB",     7},        // shrooms mode powerup
	{"RHS\\",       4},        // shrooms mode powerup
	{"GNIOB",       5},        // elasto mode powerup
	{"ALE\\",       4},        // elasto mode powerup
	{"SREBOOG",     7},        // warp to level 1, start with pistol
	{"OOG\\",       4},        // warp to level 1, start with pistol
	{"KCAHW",       5},        // hurt player 10%
	{"FOO\\",       4},        // hurt player 10%
	{"DEEPS",       5},        // run fast all the time
	{"AFR\\",       4},        // run fast all the time
	{"CINAP",       5},        // back to normal
	{"NAP\\",       4},        // back to normal
	{"NOMID",       5},        // light diminishing on
	{"NOD\\",       4},        // light diminishing on
	{"FFOMID",      6},        // light diminishing off
	{"FOD\\",       4},        // light diminishing off
	{"NODNOL",      6},        // fog on (0x00 - 0x80 minmax)
	{"NOF\\",       4},        // fog on (0x00 - 0x80 minmax)
	{"LONDON",      6},        // fog off (0x80 - 0xFF minmax)
	{"FOF\\",       4},        // fog off (0x80 - 0xFF minmax)
	{"SETAGOG",     7},        // blow out of game
	{"R8L\\",       4},        // blow out of game
	{"HCRAOG",      6},        // end the current level
	{"LCE\\",       4},        // end the current level
	{"683ATOG",     7},        // floor and ceiling off
	{"NOC\\",       4},        // floor and ceiling off
	{"684ATOG",     7},        // floor and ceiling on
	{"FOC\\",       4},        // floor and ceiling on
	{"EMTOOHS",     7},        // bullet proof armor
	{"RAB\\",       4},        // bullet proof armor
	{"EMNRUB",      6},        // fire proof armor
	{"RAF\\",       4},        // fire proof armor
	{"GNUDGNUL",    8},        // gas mask
	{"RAG\\",       4},        // gas mask
	{"KCAPTNUH",    8},        // all keys, armor, 100% health, MP40, heatseek
	{"PFO\\",       4},        // all keys, armor, 100% health, MP40, heatseek
	{"EM68",        4},        // kill player
	{"EID\\",       4},        // kill player
	{"NEER",        4},        // re-enter level
	{"LER\\",       4},        // re-enter level
   {"OOWNHOJ",     7},        // give double pistol
	{"2WG\\",       4},        // give double pistol
	{"MEGULP",      6},        // give mp40
	{"3WG\\",       4},        // give mp40
	{"ALLINAV",     7},        // give bazooka
	{"4WG\\",       4},        // give bazooka
	{"SEMITTOH",    8},        // give heatseeker
   {"5WG\\",       4},        // give heatseeker
   {"EZOOB",       5},        // give drunk missile
   {"6WG\\",       4},        // give drunk missile
   {"BMOBERIF",    8},        // give firebomb
   {"7WG\\",       4},        // give firebomb
	{"SENOB",       5},        // give firewall
	{"8WG\\",       4},        // give firewall
	{"AYEES",       5},        // give god hand
   {"9WG\\",       4},        // give god hand

#if (SHAREWARE == 0)

   {"TILPS",       5},        // give split missile
   {"AWG\\",       4},        // give split missile
	{"HTAEDFOSEK", 10},        // give kes
   {"BWG\\",       4},        // give kes
	{"NUREMOH",     8},        // give bat
   {"CWG\\",       4},        // give bat
   {"OJUC",        4},        // give dog weapon
   {"DWG\\",       4},        // give dog weapon
#endif
   {"EDIR",        4},        // give MISSILE CAM
   {"MAC\\",       4},        // give Missile Cam
   {"EREHW",       5},        // turn where am i on/off
   {"DUH\\",       4},        // give hud
   {"NUF\\",       4},        // Rotation fun
   {"DROCER",      6},        // Demo RECORD
   {"POTS",        4},        // Demo stop recording
   {"YALP",        4},        // Demo Playback
   {"GKE\\",       4},        // Engine Killing Gibs
   {"ORTSEAM",     7},        // JukeBox
   {"EEL\\",       4},        // JukeBox
   {"REITRAC",     7},        // Map Cheat
   {"PAM\\",       4},        // Map Cheat

   {"PILCON",      6},        // Noclip Cheat
   {"LCN\\",       4},        // Noclip Cheat

   {"UOY\\",       4},        // Secret Message
   {"EVAH",        4},        // Secret Message
   {"ON\\",        3},        // Secret Message
   {"EFIL",        4},        // Secret Message

};




/*
================
=
= CheatSpawnItem
=
================
*/

void CheatSpawnItem (int item)
   {
   SpawnStatic(player->tilex, player->tiley, item,-1);
   LASTSTAT->z = player->z;
	MakeStatActive(LASTSTAT);
	LASTSTAT->flags|=FL_ABP;
   }


/*
================
=
= FixupPowerupsY
=
================
*/

void FixupPowerupsY (void)
{
	player->z   = nominalheight;
}


/*
================
=
= EnableCheatCodes
=
================
*/

void EnableCheatCodes (void)
{
	DebugOk ^= 1;

	if (DebugOk)
      AddMessage ("Cheat Codes \\cENABLED!", MSG_CHEAT);
	else
      AddMessage ("Cheat Codes \\cDISABLED!", MSG_CHEAT);
}


/*
================
=
= ResetCheatCodes
=
================
*/

void ResetCheatCodes (void)
{
//	godmode = false;
}

/*
================
=
= DoMapCheat
=
================
*/

void DoMapCheat (void)
{
   AddMessage ("Entire Map Revealed!", MSG_CHEAT);
   CheatMap ();
}

/*
================
=
= DoGodMode
=
================
*/

void DoGodMode (void)
{
	if (godmode)
      AddMessage ("Woundless With Weapons \\cOFF", MSG_CHEAT);
	else
      AddMessage ("Woundless With Weapons \\cON", MSG_CHEAT);

	godmode ^= 1;
}


/*
================
=
= DoWarp
=
================
*/

void DoWarp (void)
{
/*
	char str[10];
	boolean esc;
	int level;

   CurrentFont = smallfont;

   US_CenterWindow(26,3);
	PrintY+=6;

   US_Print(" Warp to level(1-99):");

   VW_UpdateScreen();

   ShutdownClientControls();

   esc = !US_LineInput (px, py, str, NULL, true, 2, 25, 13);

   if (!esc)
   {
      level = ParseNum (str);
      if (level>0 && level<=99)
      {
         gamestate.mapon = level-1;
         playstate = ex_warped;
         gamestate.episode = GetEpisode (gamestate.mapon);
      }
   }

   while (Keyboard[sc_Escape])
		IN_UpdateKeyboard ();
   IN_ClearKeyboardQueue ();

*/

   int level;

   MU_StoreSongPosition();
   MU_StartSong( song_secretmenu);
   StopWind();
   ShutdownClientControls();

   SetupMenuBuf();
   SetUpControlPanel ();

   level = CP_LevelSelectionMenu();

   CleanUpControlPanel();
   ShutdownMenuBuf();

   while( Keyboard[ sc_Escape ] )
      {
		IN_UpdateKeyboard();
      }
   IN_ClearKeyboardQueue();

   if ((level == -1) || (level == gamestate.mapon))
      {
      MU_StartSong(song_level);
      MU_RestoreSongPosition();
      }

   if ( level >= 0 )
      {
      playstate = ex_warped;
      gamestate.mapon   = level;
      gamestate.episode = GetEpisode( gamestate.mapon );

      VL_FadeOut (0, 255, 0, 0, 0, 20);
      }
   else
      {
      SetupScreen(true);
      }

   StartupClientControls();
   }

/*
================
=
= DoJukeBox
=
================
*/

void DoJukeBox
   (
   void
   )

   {
   StopWind();
   ShutdownClientControls();

   SetupMenuBuf();
   SetUpControlPanel ();

   MU_JukeBoxMenu();

   CleanUpControlPanel();
   ShutdownMenuBuf();

   SetupScreen(true);

   while( Keyboard[ sc_Escape ] )
      {
		IN_UpdateKeyboard();
      }
   IN_ClearKeyboardQueue();

   StartupClientControls();
   }



/*
================
=
= DoNormalThing
=
================
*/

void DoNormalThing (void)
{
   AddMessage ("BACK TO NORMAL.  AH.", MSG_CHEAT);

	player->flags &= ~(FL_BPV|FL_AV|FL_GASMASK);
	locplayerstate->protectiontime = 0;

   if (player->flags & FL_ELASTO)
      player->flags &= ~FL_NOFRICTION;
   player->flags &= ~(FL_SHROOMS|FL_ELASTO|FL_FLEET);
	locplayerstate->poweruptime = 0;

	InitializeWeapons(locplayerstate);
	locplayerstate->keys = 0;

   DrawPlayScreen (false);
}



/*
================
=
= DoItemCheat
=
================
*/

void DoItemCheat (void)
{
   AddMessage ("Items Aplenty!", MSG_CHEAT);

	GivePoints (100000);
	HealPlayer (99, player);

	locplayerstate->keys = 0xF;
	DrawKeys (false);

   player->flags &= ~(FL_GASMASK|FL_BPV|FL_AV);
   CheatSpawnItem(stat_bulletproof);

   /*
   player->flags |= FL_BPV;
	player->flags &= ~(FL_GASMASK|FL_AV);
	locplayerstate->protectiontime = POWERUPTICS;
   GM_DrawBonus (stat_bulletproof);
   */
}

/*
================
=
= DoSomeItemCheat
=
================
*/

void DoSomeItemCheat (void)
{
   AddMessage ("Slacker pack!", MSG_CHEAT);

   HealPlayer (40, player);

   locplayerstate->keys = 0x7;
	DrawKeys (false);
}


/*
================
=
= DoGodModePowerup
=
================
*/

void DoGodModePowerup (void)
   {

   if (PLAYER[0]->flags & FL_GODMODE)
	  return;

   CheatSpawnItem(stat_godmode);
   }


/*
================
=
= DoDogModePowerup
=
================
*/

void DoDogModePowerup (void)
   {

   if (PLAYER[0]->flags & FL_DOGMODE)
	  return;

   CheatSpawnItem(stat_dogmode);
   }


/*
================
=
= DoMercuryModePowerup
=
================
*/

void DoMercuryModePowerup (void)
   {

   if (PLAYER[0]->flags & FL_FLEET)
	  return;

   CheatSpawnItem(stat_fleetfeet);
   }


/*
================
=
= DoElastoModePowerup
=
================
*/

void DoElastoModePowerup (void)
   {
   if (PLAYER[0]->flags & FL_ELASTO)
	  return;

   CheatSpawnItem(stat_elastic);
   }


/*
================
=
= DoShroomsModePowerup
=
================
*/

void DoShroomsModePowerup (void)
   {
   if (PLAYER[0]->flags & FL_SHROOMS)
	  return;

   AddMessage ("SHROOMS MODE POWERDOWN!", MSG_CHEAT);

   CheatSpawnItem(stat_mushroom);
   }


/*
================
=
= RestartNormal
=
================
*/

void RestartNormal (void)
{
	DoNormalThing ();

   AddMessage ("Restart to level 1", MSG_CHEAT);
	gamestate.mapon   = 0;
	playstate         = ex_warped;
	gamestate.episode = GetEpisode (gamestate.mapon);
}


/*
================
=
= HurtPlayer
=
================
*/

void HurtPlayer (void)
{
   int oldhitpoints;

   oldhitpoints = player->hitpoints;
	DamageThing (player, MaxHitpointsForCharacter(locplayerstate) / 10);
   if (player->hitpoints < oldhitpoints)
      AddMessage ("OUCH!!!!", MSG_CHEAT);

   Collision(player,player,0,0);
}


/*
================
=
= SetLightDiminish
=
================
*/

void SetLightDiminish (boolean off)
{
	if (off)
	{
      AddMessage ("Light Diminishing \\cOff", MSG_CHEAT);
		fulllight = 1;
	}
	else
	{
      AddMessage ("Light Diminishing \\cOn", MSG_CHEAT);
		fulllight = 0;
	}
}


/*
================
=
= SetFog
=
================
*/

void SetFog (boolean on)
{
	if (on)
	{
      AddMessage ("Fog \\cOn", MSG_CHEAT);
		MAPSPOT(2,0,1)=105;
		MAPSPOT(3,0,1)=0;
		SetupLightLevels ();

	}
	else
	{
      AddMessage ("Fog \\cOff", MSG_CHEAT);
		MAPSPOT(2,0,1)=104;
		SetupLightLevels ();
	}
}



/*
================
=
= ToggleMissileCam
=
================
*/

void ToggleMissileCam (void)
{
   if (missilecam==false)
      {
      missilecam=true;
      AddMessage ("Missile Cam \\cOn", MSG_CHEAT);
      }
   else
      {
      missilecam=false;
      AddMessage ("Missile Cam \\cOff", MSG_CHEAT);
      }
}

/*
================
=
= ToggleHUD
=
================
*/

void ToggleHUD (void)
{
   if (HUD==false)
      {
      HUD=true;
      AddMessage ("HUD \\cOn", MSG_CHEAT);
      }
   else
      {
      HUD=false;
      AddMessage ("HUD \\cOff", MSG_CHEAT);
      }
}



/*
================
=
= EndLevel
=
================
*/

void EndLevel (void)
{
   AddMessage ("End Level", MSG_CHEAT);
   playstate = ex_skiplevel;
}


/*
================
=
= FloorandCeiling
=
================
*/

void FloorandCeiling (boolean off)
{
	if (off)
	{
      AddMessage ("Floor and Ceiling \\cON", MSG_CHEAT);
		fandc = 1;
	}
	else
	{
      AddMessage ("Floor and Ceiling \\cOFF", MSG_CHEAT);
		fandc = 0;
	}
}


/*
================
=
= GiveGasMask
=
================
*/

void GiveGasMask ()
   {

	if (PLAYER[0]->flags & FL_GASMASK)
     return;

   CheatSpawnItem(stat_gasmask);
   }

/*
================
=
= GiveBulletProofArmor
=
================
*/

void GiveBulletProofArmor ()
   {
	if (PLAYER[0]->flags & FL_BPV)
     return;


   CheatSpawnItem(stat_bulletproof);
   }

/*
================
=
= GiveAsbestoArmor
=
================
*/

void GiveAsbestoArmor ()
   {
	if (PLAYER[0]->flags & FL_AV)
     return;

   CheatSpawnItem(stat_asbesto);
   }


/*
================
=
= OutfitPlayer
=
================
*/
void OutfitPlayer ()
{
   AddMessage ("Outfit Player!", MSG_CHEAT);

	locplayerstate->keys = 0xF;
	DrawKeys (false);
	HealPlayer (99, player);

   /*
   player->flags |= FL_BPV;
	player->flags &= ~(FL_GASMASK|FL_AV);
	locplayerstate->protectiontime = POWERUPTICS;
   GM_DrawBonus (stat_bulletproof);

	GiveWeapon (player,wp_mp40);
   */

#if (SHAREWARE == 0)
   CheatSpawnItem(stat_splitmissile);
#else
   CheatSpawnItem(stat_heatseeker);
#endif


}

/*
================
=
= KillPlayer
=
================
*/

void KillPlayer ()
{
   AddMessage ("Say Goodnight.", MSG_CHEAT);
	playstate = ex_died;
}



/*
================
=
= RestartCurrentLevel
=
================
*/

void RestartCurrentLevel (void)
{
	playstate         = ex_warped;
	gamestate.episode = GetEpisode (gamestate.mapon);
}

/*
================
=
= EndDemo
=
================
*/
void EndDemo ( void )
{
	char str[10];
	boolean esc;
	int demonumber;

   if (demorecord==false)
      return;

   ShutdownClientControls();

   CurrentFont = smallfont;

   demorecord = false;
   US_CenterWindow (26, 4);
   US_CPrint ("Save demo as:");
   US_Print  ("\n");
	US_CPrint ("Demo Number (1-4):");

   VW_UpdateScreen();

   esc = !US_LineInput (px, py, str, NULL, true, 1, 25, 13);

   if (!esc)
   {
      demonumber = ParseNum (str);
      if ((demonumber > 0) && (demonumber < 5))
      {
         SaveDemo (demonumber);
      }
   }

   IN_ClearKeysDown ();

   while (Keyboard[sc_Enter])
      IN_UpdateKeyboard ();
   while (Keyboard[sc_Escape])
      IN_UpdateKeyboard ();
	IN_ClearKeyboardQueue ();

   StartupClientControls();
}


/*
================
=
= RecordDemoQuery
=
================
*/
void RecordDemoQuery ( void )
{
   char str[10];
	boolean esc;
	int level;

   ShutdownClientControls();

   CurrentFont = smallfont;

   US_CenterWindow (26, 5);
   PrintY += 6;

   US_CPrint ("Record Demo");
   US_Print  ("\n");
#if (SHAREWARE==0)
   US_CPrint ("Which level (1-36):");
#else
   US_CPrint ("Which level (1-8):");
#endif

   VW_UpdateScreen();

   esc = !US_LineInput (px, py, str, NULL, true, 2, 25, 13);

   if (!esc)
      {
      level = ParseNum (str);
#if (SHAREWARE==0)
      if ((level > 0) && (level < 37))
#else
      if ((level > 0) && (level < 9))
#endif
         {
         gamestate.mapon = level-1;
         playstate = ex_demorecord;
         }
      }

   while (Keyboard[sc_Enter])
      IN_UpdateKeyboard ();
   while (Keyboard[sc_Escape])
      IN_UpdateKeyboard ();
   IN_ClearKeyboardQueue ();

   StartupClientControls();
}

/*
================
=
= PlaybackDemoQuery
=
================
*/
void PlaybackDemoQuery ( void )
{
   char str[10];
	boolean esc;
	int level;

   ShutdownClientControls();

   CurrentFont = smallfont;
   US_CenterWindow (33, 4);
   US_CPrint ("Playback demo");
   US_Print ("\n");
   US_CPrint ("Enter demo number (1-4):");

   VW_UpdateScreen ();

   esc = !US_LineInput (px, py, str, NULL, true, 1, 25, 13);

   if (!esc)
   {
      level = ParseNum (str);
      if ((level > 0) && (level < 5))
         {
         if (DemoExists (level) == true)
            LoadDemo (level);
         }
   }

   while (Keyboard[sc_Enter])
      IN_UpdateKeyboard ();
   while (Keyboard[sc_Escape])
      IN_UpdateKeyboard ();
   IN_ClearKeyboardQueue ();

   StartupClientControls();
}

/*
================
=
= DebugKeys
=
================
*/

int DebugKeys (void)
{
#if (DEVELOPMENT == 1)
	char str[10];
	boolean esc;
	int level;
	int i,f,temp;
	static int whichpowerup    = 0;
	static int whichprotection = 0;

	if (Keyboard[sc_G])     // G = god mode
	{
      DoGodMode ();
      while (Keyboard[sc_G])
         IN_UpdateKeyboard ();
      return 1;
	}
   else if (Keyboard[sc_Q])         // Q = fast quit
      QuitGame ();
   else if (Keyboard[sc_W])         // W = warp to level
   {
      DoWarp ();
      return 1;
   }
	else if (Keyboard[sc_F])     // F = FPS
	{
		f=0;
		for (i=0;i<VBLCOUNTER*10;i+=tics)
			{
			ThreeDRefresh();
			DoSprites();
			CalcTics ();
			f++;
			}

		CurrentFont = smallfont;

		US_CenterWindow (12,2);
		temp=f*10;
		SoftError("fps  = %2ld.%2ld\n",temp/100,temp%100);

		US_Print ("FPS=");
		US_PrintUnsigned (temp/100);
		US_Print (".");
		US_PrintUnsigned (temp%100);

		VW_UpdateScreen();
		IN_Ack();

		return 1;
	}
	else if (Keyboard[sc_H])     // H = hurt self
	{
		IN_ClearKeysDown ();
		HurtPlayer ();
	}
	else if (Keyboard[sc_Z])     // Z = end level
	{
      EndLevel ();
	}
	else if (Keyboard[sc_P])     // P = step through powerups
	{
		whichpowerup++;
		if (whichpowerup == 6)
			whichpowerup = 0;

		switch (whichpowerup)
		{
			case 0:  // nothing
				if (player->flags & FL_ELASTO)
					player->flags &= ~FL_NOFRICTION;
				player->flags &= ~(FL_SHROOMS|FL_ELASTO|FL_FLEET|FL_GODMODE|FL_DOGMODE);
				locplayerstate->poweruptime = 0;
				GM_UpdateBonus (0, true);
			break;

			case 1:  // god mode
            DoGodModePowerup ();
			break;

			case 2:  // dog mode
            DoDogModePowerup ();
			break;

			case 3:  // fleet feet
            DoMercuryModePowerup ();
			break;

			case 4:  // elasto
            DoElastoModePowerup ();
			break;

			case 5:  // shrooms
            DoShroomsModePowerup ();
			break;
		}

		while (Keyboard[sc_P])
			IN_UpdateKeyboard ();
	}
	else if (Keyboard[sc_A])     // step through armor
	{
		whichprotection++;
		if (whichprotection == 4)
			whichprotection = 0;

		switch (whichprotection)
      {
         case 0:  // nothing
            player->flags &= ~(FL_BPV|FL_AV|FL_GASMASK);
				locplayerstate->protectiontime = 0;
            GM_UpdateBonus (0, false);
         break;

         case 1:  // gas mask
            GiveGasMask ();
         break;

         case 2:  // armor
            GiveBulletProofArmor ();
         break;

         case 3:  // fire vest
            GiveAsbestoArmor ();
         break;
      }

      while (Keyboard[sc_A])
         IN_UpdateKeyboard ();
   }
   else if (Keyboard[sc_O])     // O = outfit player
   {
      OutfitPlayer ();

		IN_ClearKeysDown ();
		IN_Ack ();
		return 1;
	}
	else if (Keyboard[sc_K])     // K = kill self
	{
		IN_ClearKeysDown ();
      locplayerstate->lives = -1;
      KillPlayer ();
	}
	else if (Keyboard[sc_I])        // I = item cheat
	{
      DoItemCheat ();
		return 1;
	}
	else if (Keyboard[53])        // \ = back to normal
	{
      DoNormalThing ();
      return 1;
   }
   else if (Keyboard[sc_R])
   {
      RecordDemoQuery();
   }
   else if (Keyboard[sc_E])
   {
      EndDemo();
   }
   else if (Keyboard[sc_D])
   {
      PlaybackDemoQuery();
   }
#endif
   return (0);
}


/*
================
=
= WeaponCheat
=
================
*/

void WeaponCheat (int weapon)
   {
   if ((player->flags & FL_GODMODE) || (player->flags & FL_DOGMODE))
      return;

   if ((weapon <= wp_mp40) && (PLAYERSTATE[0].HASBULLETWEAPON[weapon]))
      return;

   CheatSpawnItem(GetItemForWeapon(weapon));

   }



/*
================
=
= CheckCode ()
=
================
*/

extern boolean		player_noclip;

void CheckCode (int which)
{
   int pos = (LastLetter-1)&(MAXLETTERS-1);
   int num = 0;
   int start;

   start = pos;

   while ((toupper(LetterQueue[pos]) == Codes[which].code[num]) &&
          (num < Codes[which].length))
   {
      pos = (pos-1)&(MAXLETTERS-1);
      num++;
   }

	if (num == Codes[which].length)
   {
      // Kill last letter so the debug rtn will not keep triggering
      LetterQueue[start] = 0;

      switch (which)
      {
         case ENABLECHEAT:
         case ENABLECHEATALT:
            EnableCheatCodes ();
         break;

         case INVULNERABLE:
         case INVULNERABLEALT:
            DoGodMode ();
         break;

         case WARP:
         case WARPALT:
            DoWarp ();
         break;

         case ITEMS:
         case ITEMSALT:
            DoItemCheat ();
         break;

         case SOMEITEMS:
         case SOMEITEMSALT:
            DoSomeItemCheat ();
         break;

			case GODMODEPWUP:
			case GODMODEPWUPALT:
            DoGodModePowerup ();
         break;

#if (SHAREWARE == 0)
         case DOGMODEPWUP:
         case DOGMODEPWUPALT:
            DoDogModePowerup ();
         break;
#endif

         case MERCURYPWUP:
         case MERCURYPWUPALT:
            DoMercuryModePowerup ();
         break;

         case SHROOMSPWUP:
			case SHROOMSPWUPALT:
            DoShroomsModePowerup ();
         break;

         case ELASTOPWUP:
         case ELASTOPWUPALT:
            DoElastoModePowerup ();
         break;

         case RESTARTGAME:
         case RESTARTGAMEALT:
            RestartNormal ();
         break;

         case HURTPLAYER:
         case HURTPLAYERALT:
               HurtPlayer ();
         break;

         case TOMHALLMODE:
         case TOMHALLMODEALT:
            gamestate.autorun = true;
            AddMessage("Autorun enabled!",MSG_CHEAT);
         break;

         case NORMAL:
         case NORMALALT:
            DoNormalThing ();
         break;

         case LIGHTDIMON:
         case LIGHTDIMONALT:
            SetLightDiminish (false);
         break;

         case LIGHTDIMOFF:
         case LIGHTDIMOFFALT:
            SetLightDiminish (true);
         break;

         case FOGON:
         case FOGONALT:
            SetFog (true);
         break;

			case FOGOFF:
         case FOGOFFALT:
            SetFog (false);
         break;

         case QUITGAME:
         case QUITGAMEALT:
            QuitGame ();
         break;

         case ENDLEVEL:
         case ENDLEVELALT:
				EndLevel ();
         break;

         case FANDCOFF:
         case FANDCOFFALT:
            FloorandCeiling (false);
         break;

         case FANDCON:
         case FANDCONALT:
            FloorandCeiling (true);
         break;

         case BULLETARMOR:
         case BULLETARMORALT:
            GiveBulletProofArmor ();
         break;

         case FIREARMOR:
         case FIREARMORALT:
            GiveAsbestoArmor ();
			break;

         case GASMASK:
         case GASMASKALT:
            GiveGasMask ();
         break;

         case OUTFIT:
         case OUTFITALT:
            OutfitPlayer ();
         break;

         case KILLPLAYER:
         case KILLPLAYERALT:
            KillPlayer ();
         break;

         case RESTARTLEVEL:
         case RESTARTLEVELALT:
				RestartCurrentLevel ();
			break;


         case WEAPONTWOPISTOL:
         case WEAPONTWOPISTOLALT:
             WeaponCheat(wp_twopistol);
             break;

         case WEAPONMP40:
         case WEAPONMP40ALT:
             WeaponCheat(wp_mp40);
             break;

         case WEAPONBAZOOKA:
         case WEAPONBAZOOKAALT:
             WeaponCheat(wp_bazooka);
             break;
         case WEAPONFIREBOMB:
         case WEAPONFIREBOMBALT:
             WeaponCheat(wp_firebomb);
             break;

         case WEAPONHEAT:
         case WEAPONHEATALT:
             WeaponCheat(wp_heatseeker);
             break;

         case WEAPONDRUNK:
         case WEAPONDRUNKALT:
             WeaponCheat(wp_drunk);
             break;

         case WEAPONFIREWALL:
         case WEAPONFIREWALLALT:
             WeaponCheat(wp_firewall);
             break;

         case WEAPONGOD:
         case WEAPONGODALT:
             WeaponCheat(wp_godhand);
             break;


#if (SHAREWARE == 0)

         case WEAPONSPLIT:
         case WEAPONSPLITALT:
             WeaponCheat(wp_split);
             break;

         case WEAPONKES:
         case WEAPONKESALT:
             WeaponCheat(wp_kes);
             break;

         case WEAPONBAT:
         case WEAPONBATALT:
             WeaponCheat(wp_bat);
             break;

         case WEAPONDOG:
         case WEAPONDOGALT:
             WeaponCheat(wp_dog);
             break;
#endif

         case MISSILECAMTOGGLE:
         case MISSILECAMTOGGLEALT:
             ToggleMissileCam();
             break;

         case HUDTOGGLE:
         case HUDTOGGLEALT:
             ToggleHUD();
             break;

         case ROTATIONFUN:
            ShutdownClientControls();
            RotationFun();
            StartupClientControls();
            SetupScreen( true );
            break;
         case DEMORECORD:
            RecordDemoQuery();
            break;
         case DEMOEND:
            EndDemo();
            break;
         case DEMOPLAYBACK:
            PlaybackDemoQuery();
            break;
         case CRAZYGIBS:
            if (gamestate.violence == vl_excessive)
               {

               ludicrousgibs ^= 1;
               if (ludicrousgibs == true)
                  AddMessage("EKG mode on!",MSG_GAME);
               else
                  AddMessage("EKG mode off!",MSG_GAME);
               }
            break;

         case JUKEBOX:
         case JUKEBOXALT:
            DoJukeBox();
         break;
         case MAPCHEAT:
         case MAPCHEATALT:
            DoMapCheat();
         break;

         case NOCLIP:
         case NOCLIPALT:
            player_noclip=!player_noclip;

			if (player_noclip)
			  AddMessage ("Noclip ENABLED!", MSG_CHEAT);
			else
			  AddMessage ("Noclip DISABLED!", MSG_CHEAT);
         break;
      }
   }
}


/*
================
=
= CheckDebug ()
=
================
*/

void CheckDebug (void)
{
	int which;
	if (DebugOk == false)
		{
      CheckCode (0);      // Check for Debug switch only
      CheckCode (1);      // Check for Debug switch only
      CheckCode (2);      // Check for Slacker pack
      CheckCode (3);      // Check for Slacker pack
      }
	else
      {
      if (demoplayback==true)
         {
         return;
         }
      else if (demorecord==true)
         {
         CheckCode (DEMORECORD);
         CheckCode (DEMOEND);
         }
      else
         {
         for (which = 0; which < MAXCODES; which++) // Check all debug codes
            CheckCode (which);
         }
      }
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// #include <mem.h>
#include "rt_def.h"
#include "rt_util.h"
#include "rt_sound.h"
#include "rt_net.h"
#include "rt_dmand.h"
#include "_rt_dman.h"
#include "fx_man.h"
#include "develop.h"
//MED
// #include "memcheck.h"

static boolean Recording=false;
static boolean Feeder=false;
static byte * RecordingBuffer;
static int Playingvoice;
static int RecordingPointer;
static int FeederPointer;
static boolean Playback=false;
static boolean Playing=false;
static byte * PlaybackBuffer;
static int PlaybackPointer;
static int PlayingPointer;
static boolean RecordingSemaphore=false;

//#define FX_StartDemandFeedPlayback MV_StartDemandFeedPlayback
//#define FX_StartRecording          MV_StartRecording
//#define FX_StopRecord              MV_StopRecord
//#include "multivoc.h"

//***************************************************************************
//
// SD_UpdatePlaybackSound - Update playback of a sound in chunks
//
//***************************************************************************
void SD_UpdatePlaybackSound ( char ** ptr, unsigned long * length )
   {
   if ( Playing==false )
      {
      *ptr = NULL;
      *length = 0;
      return;
      }
   if (PlayingPointer==PlaybackPointer)
      {
      *ptr = NULL;
      *length = 0;
      if (Playback==false)
         {
         FX_StopSound( Playingvoice );
         SafeFree ( PlaybackBuffer );
         Playing=false;
         }
      return;
      }

   *length=PLAYBACKDELTASIZE;

   if (PlayingPointer==-1)
      {
      *ptr = NULL;
      *length = 0;
      return;
      }

   *ptr=&PlaybackBuffer[PlayingPointer];

   PlayingPointer = (PlayingPointer + *length) &
                      (PLAYBACKBUFFERSIZE - 1);
   }

//***************************************************************************
//
// SD_StartIncomingSound - Setup to receive an incoming sound in chunks
//
//***************************************************************************

void SD_StartIncomingSound ( void )
{
   if (SD_Started==false)
      return;
   if ( ( Recording==true ) || ( Playback==true ) )
      {
      return;
      }

   Playback=true;
   PlaybackBuffer = SafeMalloc (PLAYBACKBUFFERSIZE);
   Playing = false;
   PlayingPointer = -1;
   PlaybackPointer = 0;

   Playingvoice = FX_StartDemandFeedPlayback ( SD_UpdatePlaybackSound,
                  RECORDINGSAMPLERATE,
                  0, 255, 255, 255, 255, -1);
   if (Playingvoice==ST_NULL)
      {
      SafeFree(PlaybackBuffer);
      Playback=false;
      }
}

//***************************************************************************
//
// SD_StopIncomingSound - Stop receiving an incoming sound and playback
//
//***************************************************************************

void SD_StopIncomingSound ( void )
{
   if (SD_Started==false)
      return;
   Playback=false;
}


//***************************************************************************
//
// SD_UpdateIncomingSound - Update an incoming sound
//
//***************************************************************************

void SD_UpdateIncomingSound ( byte * ptr, word length )
{
   int amount;

   if (SD_Started==false)
      return;

   if ( Playback==false )
      {
      return;
      }
   amount=length;
   if (PlaybackPointer+length > PLAYBACKBUFFERSIZE)
      amount=PLAYBACKBUFFERSIZE-PlaybackPointer;
   memcpy ( &PlaybackBuffer[PlaybackPointer],
            ptr, amount);
   PlaybackPointer = (PlaybackPointer + amount) &
                      (PLAYBACKBUFFERSIZE - 1);

   ptr+=amount;

   if (length!=amount)
      {
      amount=length-amount;
      memcpy ( &PlaybackBuffer[PlaybackPointer],
               ptr, amount);
      PlaybackPointer = (PlaybackPointer + amount) &
                         (PLAYBACKBUFFERSIZE - 1);
      }

   if (PlayingPointer==-1)
      {
      Playing=true;
      PlayingPointer=0;
      }
   if (PlaybackPointer==PlayingPointer)
      {
      Playback=false;
      }
}

//***************************************************************************
//
// SD_UpdateRecordingSound - Update recording a sound in chunks
//
//***************************************************************************
extern int whereami;
void SD_UpdateRecordingSound ( char * ptr, int length )
   {
   int amount;

   whereami = 69;
   if ( Recording==false )
      {
      return;
      }
   whereami = 70;
   amount=length;
   if (RecordingPointer+length > RECORDINGBUFFERSIZE)
      amount=RECORDINGBUFFERSIZE-RecordingPointer;
   memcpy ( &RecordingBuffer[RecordingPointer],
            ptr, amount);
   whereami = 71;
   RecordingPointer = (RecordingPointer + amount) &
                      (RECORDINGBUFFERSIZE - 1);

   if (length!=amount)
      {
      ptr += amount;
      amount=length-amount;
      memcpy ( &RecordingBuffer[RecordingPointer],
               ptr, amount);
      RecordingPointer = (RecordingPointer + amount) &
                         (RECORDINGBUFFERSIZE - 1);
      }
   whereami = 72;
   if (Feeder == false)
      {
      Feeder = true;
      }

   whereami = 73;
   if (RecordingPointer==FeederPointer)
      {
      Recording=false;
      }
   whereami = 74;
   }

//***************************************************************************
//
// SD_StartRecordingSound - Start recording a sound in chunks
//
//***************************************************************************

boolean SD_StartRecordingSound ( void )
{
   int status;

   if (SD_Started==false)
      return false;
   if (remoteridicule == false)
      return false;
   if ( ( Recording==true ) || ( Playback==true ) || (Feeder==true))
      {
      return false;
      }
   Recording=true;
   RecordingBuffer = SafeMalloc (RECORDINGBUFFERSIZE);
   Feeder = false;
   FeederPointer = -1;
   RecordingPointer = 0;

   status=FX_StartRecording( RECORDINGSAMPLERATE, SD_UpdateRecordingSound);

   if (status!=FX_Ok)
      {
      Recording=false;
      SafeFree(RecordingBuffer);
      return false;
      }

   return true;
}

//***************************************************************************
//
// SD_StopRecordingSound - Stop recording a sound
//
//***************************************************************************

void SD_StopRecordingSound ( void )
{
   if (SD_Started==false)
      return;
   if (Recording == true)
      {
      FX_StopRecord();
      Recording=false;
      }
}

//***************************************************************************
//
// SD_SetRecordingActive - Set the recording active flag
//
//***************************************************************************

void SD_SetRecordingActive ( void )
{
   RecordingSemaphore=true;
}

//***************************************************************************
//
// SD_ClearRecordingActive - Clear the recording active flag
//
//***************************************************************************

void SD_ClearRecordingActive ( void )
{
   RecordingSemaphore=false;
}

//***************************************************************************
//
// SD_RecordingActive - Check if recording is active on some system
//
//***************************************************************************

boolean SD_RecordingActive ( void )
{
   return RecordingSemaphore;
}

//***************************************************************************
//
// SD_GetSoundData - Returns next piece of sound data, returns:
//
//                   nodata if no sound data is ready
//                   newsound if it is the start of a new sound
//                            data is also returned;
//                   endsound if the sound is finished
//                   data if data is ready
//
//***************************************************************************

recordstate SD_GetSoundData ( byte * data, word length )
{
   recordstate status=rs_data;
   int amount;

   if (SD_Started==false)
      return rs_nodata;

   if (Feeder==false)
      return rs_nodata;

   if (FeederPointer==RecordingPointer)
      {
      if (Recording==false)
         {
         SafeFree(RecordingBuffer);
         Feeder=false;
         return rs_endsound;
         }
      else
         {
         return rs_nodata;
         }
      }

   if (FeederPointer==-1)
      {
      status=rs_newsound;
      FeederPointer=0;
      }

   amount=length;

   if (FeederPointer+length > RECORDINGBUFFERSIZE)
      amount=RECORDINGBUFFERSIZE-FeederPointer;
   memcpy ( data, &RecordingBuffer[FeederPointer], amount);

   FeederPointer = (FeederPointer + amount) &
                      (RECORDINGBUFFERSIZE - 1);

   data += amount;

   if (length!=amount)
      {
      amount=length-amount;
      memcpy ( data, &RecordingBuffer[FeederPointer], amount);
      FeederPointer = (FeederPointer + amount) &
                        (RECORDINGBUFFERSIZE - 1);
      }

   return status;
}

//***************************************************************************
//
// SD_SoundDataReady - Returns true if data is ready
//
//***************************************************************************

boolean SD_SoundDataReady ( void )
{
   if (SD_Started==false)
      return false;
   return Feeder;
}



/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "rt_sound.h"
#include "rt_door.h"
#include "rt_actor.h"
#include "rt_stat.h"
#include "_rt_door.h"
#include "z_zone.h"
#include "w_wad.h"
#include "rt_ted.h"
#include "rt_draw.h"
#include "rt_main.h"
#include "rt_playr.h"
#include "rt_util.h"
#include "rt_menu.h"
#include "rt_ted.h"
#include "rt_msg.h"
#include "rt_game.h"
#include "rt_vid.h"
#include "rt_net.h"
// #include "isr.h"
#include "develop.h"
#include "rt_rand.h"
#include "engine.h"
#include <stdlib.h>
#include <string.h>
//MED
// #include "memcheck.h"

/*=============================================================================

							DOORS

doorobjlist[] holds most of the information for the doors

Open doors conect two areas, so sounds will travel between them and sight
	will be checked when the player is in a connected area.

Areaconnect is incremented/decremented by each door. If >0 they connect

Every time a door opens or closes the areabyplayer matrix gets recalculated.
	An area is true if it connects with the player's current spor.

=============================================================================
*/


// Global Variables


#define ELEVATORMUSICTIME	560

elevator_t	ELEVATOR[MAXELEVATORS];
int				_numelevators;
animmaskedwallobj_t* FIRSTANIMMASKEDWALL,*LASTANIMMASKEDWALL;
maskedwallobj_t* FIRSTMASKEDWALL,*LASTMASKEDWALL;
byte				touchindices[MAPSIZE][MAPSIZE],lasttouch;
touchplatetype	*touchplate[MAXTOUCHPLATES],*lastaction[MAXTOUCHPLATES];

byte				numactions[MAXTOUCHPLATES];
int				totalactions;

byte				TRIGGER[MAXTOUCHPLATES];
doorobj_t		*doorobjlist[MAXDOORS];
int				doornum;
maskedwallobj_t *maskobjlist[MAXMASKED];
int				maskednum;

pwallobj_t	*pwallobjlist[MAXPWALLS];
int				pwallnum;

byte				areaconnect[NUMAREAS][NUMAREAS];

boolean			areabyplayer[NUMAREAS];


// Local Variables

static void (*touchactions[NUMTOUCHPLATEACTIONS])(int) =
						{ActivatePushWall,
						ActivateMoveWall,
						LinkedOpenDoor,
						LinkedCloseDoor,
						EnableObject,
						DisableObject,
						ActivateLight,
						DeactivateLight};

#if ((DEVELOPMENT == 1))
#if ((LOADSAVETEST == 1))
static char*touchstrings[NUMTOUCHPLATEACTIONS] =
						{"ActivatePushWall",
						"ActivateMoveWall",
						"LinkedOpenDoor",
						"LinkedCloseDoor",
						"EnableObject",
						"DisableObject",
						"ActivateLight",
						"DeactivateLight"
						};
#endif
#endif
#if ((DEVELOPMENT == 1))
#if ((ELEVATORTEST == 1))

static char*elevstring[NUMELEVATORACTIONS] =
						{"ready at source",
						"ready at destination",
						"moving to source",
						"moving to destination",
						"doorclosing"
						};
#endif
#endif


/*
===============
=
= MakeMaskedWallActive
=
===============
*/

void MakeMaskedWallActive(maskedwallobj_t* tmwall)
 {if (!FIRSTMASKEDWALL)
	FIRSTMASKEDWALL	= tmwall;
  else
	{tmwall->prev = LASTMASKEDWALL;
		LASTMASKEDWALL->next = tmwall;
	}
  LASTMASKEDWALL = tmwall;
 }

/*
===============
=
= MakeMaskedWallInactive
=
===============
*/


void MakeMaskedWallInactive(maskedwallobj_t* tmwall)
{
 if (tmwall == LASTMASKEDWALL)
	LASTMASKEDWALL = tmwall->prev;
 else
	tmwall->next->prev = tmwall->prev;

 if (tmwall == FIRSTMASKEDWALL)
	FIRSTMASKEDWALL = tmwall->next;
 else
	tmwall->prev->next = tmwall->next;

 tmwall->prev = NULL;
 tmwall->next = NULL;

}


/*
===============
=
= ActivateAnimMaskedWall
=
===============
*/

void ActivateAnimMaskedWall(animmaskedwallobj_t* amwall)
{
	if (!FIRSTANIMMASKEDWALL)
		FIRSTANIMMASKEDWALL	= amwall;
	else
		{
		amwall->prev = LASTANIMMASKEDWALL;
		LASTANIMMASKEDWALL->next = amwall;
		}
	LASTANIMMASKEDWALL = amwall;
}

/*
===============
=
= DeactivateAnimMaskedWall
=
===============
*/


void DeactivateAnimMaskedWall(animmaskedwallobj_t* amwall)
{
 if (amwall == LASTANIMMASKEDWALL)
	LASTANIMMASKEDWALL = amwall->prev;
 else
	amwall->next->prev = amwall->prev;

 if (amwall == FIRSTANIMMASKEDWALL)
	FIRSTANIMMASKEDWALL = amwall->next;
 else
	amwall->prev->next = amwall->next;

 amwall->prev = NULL;
 amwall->next = NULL;

}


int PlatformHeight(int tilex,int tiley)
	{
	int platform;

	if (!IsPlatform(tilex,tiley))
		return nominalheight;

	platform = MAPSPOT(tilex,tiley,2);

	switch(platform)
		{
		case 1:
			return -10;
		case 4:
			return nominalheight;
		case 5:
		case 6:
			return nominalheight - 64;
		case 7:
			return nominalheight;
		case 8:
		case 9:
			return -10;
		}

	return -1000;
	}

void SpawnAnimatedMaskedWall ( int num )
{
	animmaskedwallobj_t * temp;

	temp = (animmaskedwallobj_t *)Z_LevelMalloc(sizeof(animmaskedwallobj_t),PU_LEVELSTRUCT,NULL);
	if (!temp)
		Error("SpawnAnimatedMaskedWall: Failed on allocation of animated masked wall");
	temp->num=num;
	temp->count=AMW_NUMFRAMES;
	temp->ticcount=AMW_TICCOUNT;
	temp->next=NULL;
	temp->prev=NULL;
	ActivateAnimMaskedWall(temp);
}

void KillAnimatedMaskedWall ( animmaskedwallobj_t * temp )
{
	DeactivateAnimMaskedWall(temp);
	Z_Free(temp);
}


void DoAnimatedMaskedWalls ( void )
{
	boolean done;
	animmaskedwallobj_t * temp;

	for(temp=FIRSTANIMMASKEDWALL;temp;)
		{
		done=false;
		temp->ticcount-=tics;
		while (temp->ticcount<0)
			{
			temp->ticcount+=AMW_TICCOUNT;
			temp->count--;
			maskobjlist[temp->num]->bottomtexture++;
			if (temp->count==0)
				{
				done=true;
				break;
				}
			}
		if (done==true)
			{
			animmaskedwallobj_t * temp2;

			temp2=temp->next;
			KillAnimatedMaskedWall(temp);
			temp=temp2;
			}
		else
			temp=temp->next;
		}
}


int GetIndexForAction(void (*action)(int))
{int i;

 for(i=0;i<NUMTOUCHPLATEACTIONS;i++)
  if (action == touchactions[i])
	return i;

 Error("Touchplate Action Not Matched");
 return -1;
}


void SaveTouchPlates(byte ** buffer,int *size)
{int i,k;
 byte * tptr;
 touchplatetype *temp;
 saved_touch_type dummy;

 *size = sizeof(TRIGGER);
 *size += sizeof(numactions);
 *size += sizeof(saved_touch_type)*totalactions;

 *buffer = (byte *)SafeMalloc(*size);
 tptr = *buffer;
 memcpy(tptr,&TRIGGER[0],sizeof(TRIGGER));
 tptr+=sizeof(TRIGGER);

 memcpy(tptr,&numactions[0],sizeof(numactions));
 tptr+=sizeof(numactions);

 #if ((DEVELOPMENT == 1))
 #if (LOADSAVETEST == 1)
	Debug("\n\nSAVE INFO\n");
	Debug("---------");

	Debug("\n\nTOUCHINDICES\n");
	Debug("------------\n\n");
	for(i=0;i<MAPSIZE;i++)
	for(j=0;j< MAPSIZE;j++)
		if (touchindices[i][j])
		Debug("\ntouchindices[%3d][%3d]: %d",i,j,touchindices[i][j]);

	Debug("\n\nTRIGGER: ");
	for(i=0;i<(sizeof(TRIGGER)/sizeof(TRIGGER[0]));i++)
	if (TRIGGER[i])
		Debug("%1d",TRIGGER[i]);
	Debug("\n\nNUMACTIONS PER TOUCHPLATE\n");
	Debug("-------------------------\n\n");
	for(i=0;i<(sizeof(numactions)/sizeof(numactions[0]));i++)
	if (numactions[i])
	Debug("\n %2d: %2d",i,numactions[i]);
 #endif
 #endif

 for(i=0;i<lasttouch;i++)
	{
	#if ((DEVELOPMENT == 1))
	#if (LOADSAVETEST == 1)
	Debug("\n\nTOUCHPLATE[%2d]\n",i);
	Debug("--------------\n\n");
	#endif
	#endif

	for(k=0,temp=touchplate[i];temp;k++,temp = temp->nextaction)
		{
		dummy.tictime = temp->tictime;
		dummy.ticcount = temp->ticcount;
		dummy.triggered = temp->triggered;
		dummy.done = temp->done;
		dummy.complete = temp->complete;

		if (temp->action)
			dummy.actionindex = GetIndexForAction(temp->action);
		else
			dummy.actionindex = -1;

		if (temp->swapaction)
			dummy.swapactionindex = GetIndexForAction(temp->swapaction);
		else
			dummy.swapactionindex = -1;
		if ((dummy.actionindex > 5) || (dummy.swapactionindex > 5)) // means whichobj holds pointer to actor
			{
			statobj_t *tstat;

//			tstat = (statobj_t*)(temp->whichobj);
			tstat = T_SwizzleStatObjFromInt(temp->whichobj);
			dummy.whichobj = (tstat->whichstat|FL_TSTAT);
			}

		else if ((dummy.actionindex > 3) || (dummy.swapactionindex > 3))

			{
			objtype *tactor;

//			tactor = (objtype*)(temp->whichobj);
			tactor = T_SwizzleObjtypeFromInt(temp->whichobj);
			dummy.whichobj = (tactor->whichactor|FL_TACT);
			}

		else
			dummy.whichobj = temp->whichobj;

		#if ((DEVELOPMENT == 1))
		#if (LOADSAVETEST == 1)
		Debug("action node %d: tictime: %d, ticcount: %d ",k,dummy.tictime,dummy.ticcount);
		if (dummy.actionindex == -1)
			Debug("action: -1,");
		else
			Debug("action: %13s,",touchstrings[dummy.actionindex]);

		if (dummy.swapactionindex == -1)
			Debug("swapaction: -1,");
		else
			Debug("swapaction: %13s,",touchstrings[dummy.swapactionindex]);

		if (dummy.whichobj & FL_TACT)
			Debug("whichobj (actor): %4x\n",(dummy.whichobj & ~FL_TACT));
		else
			Debug("whichobj (nonactor): %4x\n",dummy.whichobj);
		#endif
		#endif


		memcpy(tptr,&dummy,sizeof(saved_touch_type));
		tptr+=sizeof(saved_touch_type);
		}
	}
}

statobj_t* GetStatForIndex(int index)
{statobj_t *temp;

 for(temp = FIRSTSTAT;temp;temp=temp->statnext)
	if (temp->whichstat == index)
	return temp;

 SoftError("\nstat not found in GetStatForIndex");
 return NULL;

}


void LoadTouchPlates(byte * buffer, int size)
{touchplatetype *temp;
 int i,savedactions,loadedactions,index=0;
 saved_touch_type dummy;

 savedactions = (size-sizeof(TRIGGER)-sizeof(numactions))/sizeof(saved_touch_type);
 memset(touchplate,0,sizeof(touchplate));
 memset(lastaction,0,sizeof(lastaction));
 memset(numactions,0,sizeof(numactions));
 totalactions = 0;

 memcpy(&TRIGGER[0],buffer,sizeof(TRIGGER));
 buffer += sizeof(TRIGGER);

 memcpy(&numactions[0],buffer,sizeof(numactions));
 buffer += sizeof(numactions);

 for(loadedactions=0,index=0,i=0;i<savedactions;i++)
  {memcpy(&dummy,buffer,sizeof(saved_touch_type));
	temp = (touchplatetype*)Z_LevelMalloc(sizeof(touchplatetype),PU_LEVELSTRUCT,NULL);
	if (!temp)
		Error("LoadTouchplates: Failed on allocation of touchplates %ld of %ld",i,savedactions);
	memset(temp,0,sizeof(*temp));

	temp->tictime = dummy.tictime;
	temp->ticcount = dummy.ticcount;
	temp->triggered = dummy.triggered;
	temp->done = dummy.done;
	temp->complete = dummy.complete;

	if (dummy.whichobj & FL_TACT)
	{
//		temp->whichobj = (nlint)(objlist[dummy.whichobj & ~FL_TACT]);
		temp->whichobj = T_SwizzleObjtypeToInt(
			objlist[dummy.whichobj & ~FL_TACT]);
	}
	else if (dummy.whichobj & FL_TSTAT)
	{
//		temp->whichobj = (nlint)(GetStatForIndex(dummy.whichobj & ~FL_TSTAT));
		temp->whichobj = T_SwizzleStatObjToInt(
			GetStatForIndex(dummy.whichobj & ~FL_TSTAT));
	}
	else
		temp->whichobj = dummy.whichobj;
	if (dummy.actionindex != -1)
		temp->action = touchactions[dummy.actionindex];
	else
		temp->action = NULL;

	if (dummy.swapactionindex != -1)
	temp->swapaction = touchactions[dummy.swapactionindex];
	else
	temp->swapaction = NULL;

	buffer+=sizeof(saved_touch_type);

	while (!numactions[index])
	index ++;

	AddTouchplateAction(temp,index);

	/*if (touchplate[index])
	lastaction[index]->nextaction = temp;
	else
	touchplate[index] = temp;
	lastaction[index] = temp;*/

	totalactions ++;

	loadedactions++;
	if (loadedactions == numactions[index]) // found end of a touchplate's actions, goto next touch.
	{loadedactions = 0;
	index++;
	}
  }


 #if ((DEVELOPMENT == 1))
 #if (LOADSAVETEST == 1)
	Debug("\n\nLOAD INFO\n");
	Debug("---------");

	Debug("\n\nTOUCHINDICES\n");
	Debug("------------\n\n");
	for(i=0;i<MAPSIZE;i++)
	for(j=0;j< MAPSIZE;j++)
		if (touchindices[i][j])
		Debug("\ntouchindices[%3d][%3d]: %d",i,j,touchindices[i][j]);

	Debug("\n\nTRIGGER: ");
	for(i=0;i<(sizeof(TRIGGER)/sizeof(TRIGGER[0]));i++)
	if (TRIGGER[i])
		Debug("%1d",TRIGGER[i]);
	Debug("\n\nNUMACTIONS PER TOUCHPLATE\n");
	Debug("-------------------------\n\n");
	for(i=0;i<(sizeof(numactions)/sizeof(numactions[0]));i++)
	if (numactions[i])
	Debug("\n %2d: %2d",i,numactions[i]);

	for(i=0;i<lasttouch;i++)
	{
	Debug("\n\nTOUCHPLATE[%2d]\n",i);
	Debug("--------------\n\n");

	for(k=0,temp=touchplate[i];temp;k++,temp = temp->nextaction)
		{
		Debug("action node %d: tictime: %d, ticcount: %d ",k,temp->tictime,temp->ticcount);
		if (!temp->action)
			Debug("action: NULL,");
		else
			Debug("action: %13s,",touchstrings[GetIndexForAction(temp->action)]);

		if (!temp->swapaction)
			Debug("swapaction: NULL,");
		else
			Debug("swapaction: %13s,",touchstrings[GetIndexForAction(temp->swapaction)]);

		Debug("whichobj: %4x\n",(int)temp->whichobj);
		}
	}
 #endif
 #endif

	SafeFree(objlist);

}




void AddTouchplateAction(touchplatetype *tplate,int index)
{
 if (touchplate[index])
	{tplate->prevaction = lastaction[index];
	lastaction[index]->nextaction = tplate;
	}
  else
	touchplate[index] = tplate;
  lastaction[index] = tplate;

}




void  RemoveTouchplateAction(touchplatetype *tplate,int index)
{
  if (tplate == lastaction[index])	// remove from master list
	lastaction[index] = tplate->prevaction;
  else
	tplate->nextaction->prevaction = tplate->prevaction;

  if (tplate == touchplate[index])
	touchplate[index] = tplate->nextaction;
  else
	tplate->prevaction->nextaction = tplate->nextaction;

  Z_Free(tplate);
  numactions[index]--;
  totalactions--;

}



void  Link_To_Touchplate(word touchlocx, word touchlocy, void (*maction)(int), void (*swapaction)(int), int wobj, int delaytime)
{touchplatetype *temp;
 int index;

 index = touchindices[touchlocx][touchlocy]-1;

 temp = (touchplatetype*)Z_LevelMalloc(sizeof(touchplatetype),PU_LEVELSTRUCT,NULL);
 if (!temp)
	Error("Link_To_Touchplate: Failed on allocation of touchplate\n");
 memset(temp,0,sizeof(*temp));
 temp->action = maction;
 temp->swapaction = swapaction;
 temp->whichobj = wobj;
 temp->tictime = temp->ticcount = delaytime;

 AddTouchplateAction(temp,index);
 /*if(touchplate[index])
	lastaction[index]->nextaction=temp;
 else
	touchplate[index] = temp;
 lastaction[index] = temp;*/
 numactions[index]++;
 totalactions++;
}



void ClockLink (void (*saction)(int), void (*eaction)(int), int wobj,int whichclock)
{touchplatetype*temp;


 // adding two actions per clock
 temp = (touchplatetype*)Z_LevelMalloc(sizeof(touchplatetype),PU_LEVELSTRUCT,NULL);
 if (!temp)
	Error("ClockLink: Failed on allocation of clock");
 memset(temp,0,sizeof(*temp));
 temp->action = saction;
 temp->swapaction = eaction;
 temp->whichobj = wobj;
 temp->clocktype = 1;

 AddTouchplateAction(temp,whichclock);
/*  if(touchplate[whichclock])
	lastaction[whichclock]->nextaction = temp;
  else
	touchplate[whichclock] = temp;
  lastaction[whichclock]=temp;*/

 numactions[whichclock]++;
 totalactions ++;
}


void DisplayMessageForAction(touchplatetype *temp, boolean *wallmessage,
									boolean *doormessage, boolean*columnmessage)
	{

	if ((temp->action == ActivatePushWall) ||
		(temp->action == ActivateMoveWall)
		)
		{
		if (*wallmessage == false)
			{
			if (temp->clocktype)
				AddMessage("Time-delay wall moves.",MSG_GAME);
			else
				AddMessage("A wall moves.",MSG_GAME);
			*wallmessage = true;
			}
		}

	else if (temp->action == LinkedCloseDoor)
		{
		if (*doormessage == false)
			{
			if (temp->clocktype)
				AddMessage("Time-delay door closes.",MSG_GAME);
			else
				AddMessage("A door closes.",MSG_GAME);
			*doormessage = true;
			}
		}

	else if (temp->action == LinkedOpenDoor)
		{
		if (*doormessage == false)
			{
			if (temp->clocktype)
				AddMessage("Time-delay door opens.",MSG_GAME);
			else
				AddMessage("A door opens.",MSG_GAME);
			*doormessage = true;
			}
		}

	else if (temp->action == EnableObject)
		{
//		objtype *tempactor = (objtype*)(temp->whichobj);
		objtype *tempactor = T_SwizzleObjtypeFromInt(temp->whichobj);

		if (M_ISACTOR(tempactor) && (tempactor->obclass == pillarobj))
			{
			if (*columnmessage == false)
				{
				if (temp->clocktype)
					AddMessage("Time-delay column moves.",MSG_GAME);
				else
					AddMessage("A column moves.",MSG_GAME);
				*columnmessage = true;
				}
			}
		}
	}

void TriggerStuff(void)
	{
	touchplatetype *temp;
	int i,touchcomplete,j;
	int playeron;
	void (*tempact)(int);
	boolean wallmessage,doormessage,columnmessage;

	for(i=0;i<lasttouch;i++)
		{
		playeron = false;
		for( j = 0; j < numplayers; j++ )
			{
			if ( i == touchindices[ PLAYER[ j ]->tilex ][ PLAYER[ j ]->tiley ] - 1 )
				{
				playeron = true;
				break;
				}
			}


		if (!TRIGGER[i])
			continue;

		else if (touchplate[i]->complete)
			{
			if (!playeron)
				TRIGGER[i] = 0;
			continue;
			}

		if (touchplate[i]->done)
			{
			if (!playeron)
				{
				for(temp = touchplate[i];temp;temp = temp->nextaction)
					temp->triggered=false;
				TRIGGER[i] = 0;
				touchplate[i]->done = false;
				}
			}

		else
			{
			wallmessage = false;
			doormessage = false;
			columnmessage = false;

			for(temp = touchplate[i];temp;temp = temp->nextaction)
				{
				if (temp->action && (!temp->triggered))
					{
					if (!temp->ticcount)
						{
						temp->action(temp->whichobj);
						if (temp->action == ActivateMoveWall)
							{
							int tilex,tiley;

							tilex = pwallobjlist[temp->whichobj]->tilex;
							tiley = pwallobjlist[temp->whichobj]->tiley;
							tilemap[tilex][tiley] = 0;

							}
						if (gamestate.difficulty == gd_baby)
							{
							DisplayMessageForAction(temp,&wallmessage,&doormessage,&columnmessage);
							}

						tempact = temp->action;
						temp->action = temp->swapaction;
						temp->swapaction = tempact;
						temp->ticcount = temp->tictime;
						temp->triggered = true;
						}

					else
						temp->ticcount --;
					}
				}
	//done:

			// check to see if any actions will ever be triggered by this
			// touchplate again; if not, null touchplate out; else,
			// check status of other actions

			touchcomplete = 1;
			for(temp = touchplate[i];temp;temp = temp->nextaction)
				{
				if (temp->action)
					{
					touchcomplete = 0;
					break;
					}
				}

			if (touchcomplete)
				touchplate[i]->complete = 1; // this touchplate is out of commission
			else
				{
				touchplate[i]->done = true;
				for(temp = touchplate[i];temp;temp = temp->nextaction)
					{
					if (temp->action && (!temp->triggered))
						{
						touchplate[i]->done = false;
						break;
						}
					}
				}
			}
		}
	}


//==================== Tile stuff ====================================

boolean CheckTile(int x, int y)
{

	if ((x < 2) || (x > (MAPSIZE-1)) || (y < 2) || (y > (MAPSIZE - 1)))
	return false;

	if (actorat[x][y])
	{objtype *check = (objtype*)(actorat[x][y]);
		if (insetupgame)
		return false;
		if (!(M_ISACTOR(check) && (check->obclass == playerobj)))
		return false;
	}
	if (DiskAt(x,y))
		return false;
	if (sprites[x][y])
		return false;
	if ((tilemap[x][y]) && (IsPlatform(x,y)==false))
		return false;
	if ((AREANUMBER(x,y)<=0) || (AREANUMBER(x,y)>NUMAREAS))
		return false;
	if (IsWindow(x,y))
		return false;
	return true;
}


#define CountTile(x,y) \
{							\
 if (oldarea == AREANUMBER(x,y))\
	{if (CheckTile(x,y))			\
		numemptytiles ++;						\
															\
	areanumbercount++;							\
	if (areanumbercount == numareatiles[oldarea])\
		return numemptytiles;							\
	}															\
																	\
}																	\


int Number_of_Empty_Tiles_In_Area_Around(int x, int y)
{int roverx,rovery,areanumbercount=0,
	numemptytiles=0,oldarea,i,limit,j;

 oldarea = AREANUMBER(x,y);

	for (i=1;;i++)
		{roverx = x-i;
		rovery = y-i;

		CountTile(roverx,rovery);
		limit = i<<1;

		for(j=0;j<limit;j++)
			{roverx++;
			CountTile(roverx,rovery);
			}

		for(j=0;j<limit;j++)
			{rovery++;
			CountTile(roverx,rovery);
			}

		for(j=0;j<limit;j++)
			{roverx--;
			CountTile(roverx,rovery);
			}

		for(j=0;j<limit-1;j++)
			{rovery--;
			CountTile(roverx,rovery);
			}
		}
}



#define CheckSet(x,y)		\
{if (CheckTile(x,y) && (oldarea == AREANUMBER(x,y))) \
	{*stilex = x;	\
	*stiley = y;	\
	return;				\
	} \
}							\



void FindEmptyTile(int *stilex, int *stiley)
{
	int i,j,x,y,oldarea,roverx,rovery,limit;

	oldarea = AREANUMBER(*stilex,*stiley);

	x = *stilex;
	y = *stiley;

	if (CheckTile(x,y) && (oldarea == AREANUMBER(x,y)))
		return;

//	for (i=1;;i++)
//	for (i=1; i<512; i++)
	for (i=1; i<64; i++)
	{
		roverx = x-i;
		rovery = y-i;

		CheckSet(roverx,rovery);
		limit = i<<1;

		for(j=0;j<limit;j++)
		{
			roverx++;
			CheckSet(roverx,rovery);
		}

		for(j=0;j<limit;j++)
		{
			rovery++;
			CheckSet(roverx,rovery);
		}

		for(j=0;j<limit;j++)
		{
			roverx--;
			CheckSet(roverx,rovery);
		}

		for(j=0;j<limit-1;j++)
		{
			rovery--;
			CheckSet(roverx,rovery);
		}
	}
}

//================================================================




void RecursiveConnect (int areanumber)
{
	int	i;

	for (i=0;i<NUMAREAS;i++)
	{
		if (areaconnect[areanumber][i] && !areabyplayer[i])
		{
			areabyplayer[i] = true;
			RecursiveConnect (i);
		}
	}
}


/*
==============
=
= ConnectAreas
=
= Scans outward from playerarea, marking all connected areas
=
==============
*/

void ConnectAreas (void)
{objtype*temp;
 statobj_t*tstat;
 int i;
#define MASTER_DISK(ob) ((ob->obclass == diskobj) && (ob->flags & FL_MASTER))

	memset (areabyplayer,0,sizeof(areabyplayer));
	for (i=0;i<numplayers;i++)
		{
		areabyplayer[PLAYER[i]->areanumber] = true;
		RecursiveConnect (PLAYER[i]->areanumber);
		}
	for(temp=FIRSTACTOR;temp;temp=temp->next)
		{
		if (MASTER_DISK(temp))
		continue;
		if (!areabyplayer[temp->areanumber])
			continue;
		if (!(temp->flags & FL_ABP))
			{temp->flags |= FL_ABP;
			MakeActive(temp);
			}
		}

	for(tstat=FIRSTSTAT;tstat;tstat=tstat->statnext)
	{if (areabyplayer[tstat->areanumber])
		{if (!(tstat->flags & FL_ABP))
			{tstat->flags |= FL_ABP;
				MakeStatActive(tstat);
			}
		}
		else if (tstat->flags & FL_ABP)
		{MakeStatInactive(tstat);
		tstat->flags &= ~FL_ABP;
		}
	}

	for(i=0;i<maskednum;i++)
	{if (areabyplayer[maskobjlist[i]->areanumber])
		{if (!(maskobjlist[i]->flags & MW_ABP))
			{maskobjlist[i]->flags |= MW_ABP;
				MakeMaskedWallActive(maskobjlist[i]);
			}
		}
		else if (maskobjlist[i]->flags & MW_ABP)
		{MakeMaskedWallInactive(maskobjlist[i]);
		maskobjlist[i]->flags &= ~MW_ABP;
		}
	}
}


void InitAreas (void)
{
	memset (areabyplayer,0,sizeof(areabyplayer));
	memset (areaconnect,0,sizeof(areaconnect));
}


/*
===============
=
= InitDoorList
=
===============
*/

void InitDoorList (void)
{
	doornum=0;
	pwallnum=0;
	maskednum=0;
	lasttouch = 0;
	numclocks=0;

	memset(touchindices,0,sizeof(touchindices));
	memset(touchplate,0,sizeof(touchplate));
	memset(lastaction,0,sizeof(lastaction));
	memset(numactions,0,sizeof(numactions));
	totalactions = 0;
	memset(TRIGGER,0,sizeof(TRIGGER));
	memset(Clocks,0,sizeof(Clocks));
	FIRSTMASKEDWALL=NULL;
	LASTMASKEDWALL=NULL;
	FIRSTANIMMASKEDWALL=NULL;
	LASTANIMMASKEDWALL=NULL;
}

/*
===============
=
= IsWall
=
===============
*/

int IsWall (int tilex, int tiley)
{
	int map;

	map=MAPSPOT(tilex,tiley,0);

	if ((map>=1) && (map<=89))
		return 1;

	else if ((map>=106) && (map<=107))
		return 1;

	else if ((map>=224) && (map<=233))
		return 1;

	else if ((map>=242) && (map<=244))
		return 1;

	return 0;
}



/*
===============
=
= InitElevators
=
===============
*/

void InitElevators(void)
{_numelevators = 0;
 memset(ELEVATOR,0,sizeof(ELEVATOR));

}



/*
===============
=
= IsDoor
=
===============
*/

int IsDoor (int tilex, int tiley)
{
	int map;

	map=MAPSPOT(tilex,tiley,0);

	if ((map>=33) && (map<=35))
		return 1;

	if ((map>=90) && (map<=104))
		return 1;

	if ((map>=154) && (map<=156))
		return 1;

	if (M_ISDOOR(tilex,tiley))
		return 1;

	return 0;
}


/*
===============
=
= SpawnDoor
=
===============
*/

void SpawnDoor (int tilex, int tiley, int lock, int texture)
{
	int i;
	doorobj_t * lastdoorobj;
	int up,dn,lt,rt;
	int abovewallstart;
	int swallstart;
	int basetexture;

	abovewallstart=W_GetNumForName("ABVWSTRT")+1;
	swallstart=W_GetNumForName("SIDESTRT")+1;

	doorobjlist[doornum]=(doorobj_t*)Z_LevelMalloc(sizeof(doorobj_t),PU_LEVELSTRUCT,NULL);
	if (!doorobjlist[doornum])
		Error("SpawnDoor: Failed on allocation of door %ld ",doornum);
	memset(doorobjlist[doornum],0,sizeof(doorobj_t));
	lastdoorobj=doorobjlist[doornum];

	if (
		( MAPSPOT(tilex,tiley,1) >= 29 ) &&
		( MAPSPOT(tilex,tiley,1) <= 32 )
		)
	{
		lock = MAPSPOT(tilex,tiley,1) - 28;
	}

	lastdoorobj->position = 0;
	lastdoorobj->tilex = tilex;
	lastdoorobj->tiley = tiley;
	lastdoorobj->lock = lock;
	lastdoorobj->action = dr_closed;
	lastdoorobj->which = DOOR;
	lastdoorobj->flags = 0;
	lastdoorobj->eindex = -1;

	//
	// make the door space solid
	//

	if (loadedgame==false)
		actorat[tilex][tiley] = lastdoorobj;

	if (IsDoor(tilex,tiley-1)) up=2;
	else if (IsWall(tilex,tiley-1)) up=1;
	else up=0;

	if (IsDoor(tilex,tiley+1)) dn=2;
	else if (IsWall(tilex,tiley+1)) dn=1;
	else dn=0;

	if (IsDoor(tilex-1,tiley)) lt=2;
	else if (IsWall(tilex-1,tiley)) lt=1;
	else lt=0;

	if (IsDoor(tilex+1,tiley)) rt=2;
	else if (IsWall(tilex+1,tiley)) rt=1;
	else rt=0;

	if ((up==1) && (dn==1))
		lastdoorobj->vertical = true;
	else if ((lt==1) && (rt==1))
		lastdoorobj->vertical = false;
	else if ((up>0) && (dn>0))
		lastdoorobj->vertical = true;
	else if ((lt>0) && (rt>0))
		lastdoorobj->vertical = false;
	else if (up>0)
		lastdoorobj->vertical = true;
	else if (dn>0)
		lastdoorobj->vertical = true;
	else if (lt>0)
		lastdoorobj->vertical = false;
	else if (rt>0)
		lastdoorobj->vertical = false;

	switch (texture)
		{
		case 4:		//BGB: Wolf3D door.
		case 5:		//BGB: Wolf3D door.
			basetexture = W_CheckNumForName("WLFDOOR1\0");
			if(basetexture<0)
			{
				basetexture = W_GetNumForName("RAMDOOR1\0");
			}
			break;
		case 6:		//BGB: Wolf3D door.
			basetexture = W_CheckNumForName("WLFDOOR3\0");
			if(basetexture<0)
			{
				basetexture = W_GetNumForName("RAMDOOR1\0");
			}
			break;

		case 0:
		case 8:
			basetexture = W_GetNumForName("RAMDOOR1\0");
			break;

		case 1:
		case 9:
			basetexture = W_GetNumForName("DOOR2\0");
			break;


		case 2:
		case 3:
		case 13:
			basetexture = W_GetNumForName("TRIDOOR1\0");
			break;

		case 10:
		case 11:
		case 14:
			basetexture = W_GetNumForName("SDOOR4\0");
			break;



		case 12:
			basetexture = W_GetNumForName("EDOOR\0");
			break;
		case 15:
			basetexture = W_GetNumForName("SNDOOR\0");
			break;
		case 16:
			basetexture = W_GetNumForName("SNADOOR\0");
			break;
		case 17:
			basetexture = W_GetNumForName("SNKDOOR\0");
			break;

		case 18:
			basetexture = W_GetNumForName("TNDOOR\0");
			break;
		case 19:
			basetexture = W_GetNumForName("TNADOOR\0");
			break;
		case 20:
			basetexture = W_GetNumForName("TNKDOOR\0");
			break;
		default:
			Error("Illegal door value encountered\n");
			break;
		}
	lastdoorobj->basetexture = basetexture;
	lastdoorobj->texture = lastdoorobj->basetexture;

	SD_PreCacheSoundGroup(SD_OPENDOORSND,SD_CLOSEDOORSND);

//
// make the door tile a special tile, and mark the adjacent tiles
// for door sides
//
	tilemap[tilex][tiley] = doornum | 0x8000;

	switch (texture)
		{
		case 4:		//BGB
		case 5:		//BGB
		case 6:		//BGB
//			lastdoorobj->sidepic	= W_GetNumForName("SIDE8");
			lastdoorobj->sidepic	= W_GetNumForName("WALL65");
			lastdoorobj->alttexture = W_GetNumForName("ABOVEW3");
			break;

		case 0:
		case 1:
		case 2:
		case 3:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
			lastdoorobj->sidepic	= W_GetNumForName("SIDE8");
			lastdoorobj->alttexture = W_GetNumForName("ABOVEW3");
			break;

		case 15:
		case 16:
		case 17:
		#if (SHAREWARE == 1)
			lastdoorobj->sidepic = W_GetNumForName("SIDE8");

		#else
			lastdoorobj->sidepic	= W_GetNumForName("SIDE16");
		#endif

			lastdoorobj->alttexture = W_GetNumForName("ABOVEW16");
			break;

		case 18:
		case 19:
		case 20:
		#if (SHAREWARE == 1)
			lastdoorobj->sidepic = W_GetNumForName("SIDE8");
			lastdoorobj->alttexture = W_GetNumForName("ABOVEW3");

		#else
			lastdoorobj->sidepic	= W_GetNumForName("SIDE17");
			lastdoorobj->alttexture = W_GetNumForName("ABOVEW17");

		#endif

			break;
		default:
			Error("Illegal door value encountered\n");
			break;
		}



	if ((lock>0) && (lock<5))
		lastdoorobj->sidepic	= W_GetNumForName("lock1")+lock-1;

	PreCacheLump(lastdoorobj->sidepic,PU_CACHEWALLS);
	PreCacheLump(lastdoorobj->alttexture,PU_CACHEWALLS);

	if (lastdoorobj->vertical==true)
	{
		if (up==1)
			tilemap[tilex][tiley-1] |= 0x4000;
		else if (up==2)
			lastdoorobj->flags|=DF_MULTI;
		if (dn==1)
			tilemap[tilex][tiley+1] |= 0x4000;
		else if (dn==2)
			lastdoorobj->flags|=DF_MULTI;
	}
	else
	{
		if (lt==1)
			tilemap[tilex-1][tiley] |= 0x4000;
		else if (lt==2)
			lastdoorobj->flags|=DF_MULTI;
		if (rt==1)
			tilemap[tilex+1][tiley] |= 0x4000;
		else if (rt==2)
			lastdoorobj->flags|=DF_MULTI;
	}

	for (i=0;i<9;i++)
		PreCacheLump(lastdoorobj->texture+i,PU_CACHEWALLS);
	doornum++;
	lastdoorobj++;
	if (doornum==MAXDOORS)
		Error ("Too many doors on level!");

}

/*
===============
=
= MakeWideDoorVisible
=
===============
*/
void MakeWideDoorVisible ( int doornum )
{
	int dx,dy;
	doorobj_t * dr2;
	doorobj_t * dr;
	int tx,ty;

	dr=doorobjlist[doornum];

	dx=0;dy=0;
	if (dr->vertical==true)
		dy=1;
	else
		dx=1;
	spotvis[dr->tilex][dr->tiley]=1;
	tx=dr->tilex+dx;
	ty=dr->tiley+dy;
	while (M_ISDOOR(tx,ty))
		{
		int num;

		num=tilemap[tx][ty]&0x3ff;
		dr2=doorobjlist[num];
		if (!(dr2->flags&DF_MULTI))
			break;
		spotvis[tx][ty]=1;

		tx+=dx;
		ty+=dy;
		}
	tx=dr->tilex-dx;
	ty=dr->tiley-dy;
	while (M_ISDOOR(tx,ty))
		{
		int num;

		num=tilemap[tx][ty]&0x3ff;
		dr2=doorobjlist[num];
		if (!(dr2->flags&DF_MULTI))
			break;
		spotvis[tx][ty]=1;

		tx-=dx;
		ty-=dy;
		}
}

/*
=====================
=
= LockLinkedDoor
=
=====================
*/

void LockLinkedDoor (int door)
{
	doorobj_t*dptr;

	dptr = doorobjlist[door];
	if (!dptr->lock)
		dptr->lock=5;
}

/*
=====================
=
= IsDoorLinked
=
=====================
*/

boolean IsDoorLinked (int door)
{
	doorobj_t*dptr;

	dptr = doorobjlist[door];
	if (dptr->lock==5)
		return true;
	return false;
}


/*
===============
=
= FixDoorAreaNumbers
=
===============
*/
void FixDoorAreaNumbers ( void )
{
	int i;
	int up,dn,lt,rt;
	int tilex,tiley;

	for (i=0;i<doornum;i++)
		{
		tilex=doorobjlist[i]->tilex;
		tiley=doorobjlist[i]->tiley;
		up=MAPSPOT(tilex,tiley-1,0)-AREATILE;
		dn=MAPSPOT(tilex,tiley+1,0)-AREATILE;
		lt=MAPSPOT(tilex-1,tiley,0)-AREATILE;
		rt=MAPSPOT(tilex+1,tiley,0)-AREATILE;

		up = ((up>0) && (up<=NUMAREAS));
		dn = ((dn>0) && (dn<=NUMAREAS));
		lt = ((lt>0) && (lt<=NUMAREAS));
		rt = ((rt>0) && (rt<=NUMAREAS));


		if (doorobjlist[i]->vertical==true)
			{
			if (rt)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex+1,tiley,0);
			else if (lt)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex-1,tiley,0);
			else
				Error("FixDoors: Couldn't fix up area at x=%ld y=%ld\n",tilex,tiley);
			}
		else
			{
			if (dn)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex,tiley+1,0);
			else if (up)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex,tiley-1,0);
			else
				Error("FixDoors: Couldn't fix up area at x=%ld y=%ld\n",tilex,tiley);
			}
		if (IsDoorLinked(i))
			UtilizeDoor(i,LockLinkedDoor);
		}
}


//===========================================================================

/*
=====================
=
= OpenDoor
=
=====================
*/

void OpenDoor (int door)
{
	if (doorobjlist[door]->action == dr_open)
		doorobjlist[door]->ticcount = 0;			// reset open time
	else
		{
		doorobjlist[door]->action = dr_opening;	// start it opening
		}
}

/*
=====================
=
= DoorUnBlocked
=
=====================
*/

boolean DoorUnBlocked (int door)
{
	int	tilex,tiley;
	objtype *check;
	doorobj_t*dptr;

	dptr = doorobjlist[door];

//
// don't close on anything solid
//

	tilex = dptr->tilex;
	tiley = dptr->tiley;
	check = (objtype*)actorat[tilex][tiley];

	if (check && (check->which == ACTOR))
		return false;

	if (dptr->vertical==true)
	{
		check = (objtype*)actorat[tilex-1][tiley];
		if (check && (check->which==ACTOR) && ((check->x+MINDIST) >> TILESHIFT) == tilex )
			return false;
		check = (objtype*)actorat[tilex+1][tiley];
		if (check && (check->which==ACTOR) && ((check->x-MINDIST) >> TILESHIFT) == tilex )
			return false;
	}
	else if (dptr->vertical==false)
	{
		check = (objtype*)actorat[tilex][tiley-1];
		if (check && (check->which==ACTOR) && ((check->y+MINDIST) >> TILESHIFT) == tiley )
			return false;
		check = (objtype*)actorat[tilex][tiley+1];
		if (check && (check->which==ACTOR) && ((check->y-MINDIST) >> TILESHIFT) == tiley )
			return false;
	}
	return true;
}


/*
=====================
=
= DoorReadyToClose
=
= Alter the door's state
=
=====================
*/

boolean DoorReadyToClose(int door)
{
	doorobj_t*dptr;
	int dx,dy;
	doorobj_t * dr2;
	int tx,ty;


	dptr = doorobjlist[door];

	if (dptr->action==dr_closed)
		return true;

	if (DoorUnBlocked(door)==false)
		return false;

	dx=0;dy=0;
	if (dptr->vertical==true)
		dy=1;
	else
		dx=1;
	tx=dptr->tilex+dx;
	ty=dptr->tiley+dy;
	while (M_ISDOOR(tx,ty))
		{
		int num;

		num=tilemap[tx][ty]&0x3ff;
		dr2=doorobjlist[num];
		if (!(dr2->flags&DF_MULTI))
			break;
		if (DoorUnBlocked(num)==false)
			return false;
		tx+=dx;
		ty+=dy;
		}
	tx=dptr->tilex-dx;
	ty=dptr->tiley-dy;
	while (M_ISDOOR(tx,ty))
		{
		int num;

		num=tilemap[tx][ty]&0x3ff;
		dr2=doorobjlist[num];
		if (!(dr2->flags&DF_MULTI))
			break;
		if (DoorUnBlocked(num)==false)
			return false;
		tx-=dx;
		ty-=dy;
		}
	return true;
}


/*
=====================
=
= CloseDoor
=
=====================
*/

void CloseDoor (int door)
{
	int	tilex,tiley,area;
	doorobj_t*dptr;

	dptr = doorobjlist[door];
	if (dptr->action == dr_closed)
		return;
	tilex = dptr->tilex;
	tiley = dptr->tiley;

//
// play door sound
//
	area = MAPSPOT(tilex,tiley,0)-AREATILE;
	if (areabyplayer[area])
		{
		dptr->soundhandle=SD_PlaySoundRTP ( SD_CLOSEDOORSND, dptr->tilex<<16, dptr->tiley<<16 );
		}

	dptr->action = dr_closing;
//
// make the door space solid
//
	actorat[tilex][tiley] = dptr;
}



/*
=====================
=
= OperateDoor
=
= The player wants to change the door's direction
=
=====================
*/

void OperateDoor (int keys, int door, boolean localplayer )
{
	int	lock;
	doorobj_t*dptr;

	dptr = doorobjlist[door];
	if ( ( dptr->flags & DF_ELEVLOCKED ) ||
		( MISCVARS->GASON && ( MAPSPOT( dptr->tilex,
		dptr->tiley, 1 ) == GASVALUE ) ) )
		{
		if ( localplayer )
			{
			// locked
			SD_Play ( SD_NOITEMSND );
			}
		return;
		}

	lock = dptr->lock;
	if ( lock && !( keys & ( 1 << ( lock - 1 ) ) ) )
		{
		if ( localplayer )
			{
			// locked
			switch (lock)
				{
				case 1:
					AddMessage("You need the \\EGOLD key",MSG_DOOR);
					break;

				case 2:
					AddMessage("You need the \\FSILVER key",MSG_DOOR);
					break;

				case 3:
					AddMessage("You need the \\8IRON key",MSG_DOOR);
					break;

				case 4:
					AddMessage("You need the \\AOSCURO key",MSG_DOOR);
					break;

				default:
					AddMessage("This door appears to be locked",MSG_DOOR);
					break;
				}

			SD_Play( SD_NOITEMSND );
			}
		return;
		}
	UseDoor(door);
	}

/*
=====================
=
= LinkedOpenDoor
=
=====================
*/

void LinkedOpenDoor (int door)
{
	UtilizeDoor(door,OpenDoor);
}

/*
=====================
=
= LinkedCloseDoor
=
=====================
*/

void LinkedCloseDoor (int door)
{
	if (DoorReadyToClose(door)==true)
		UtilizeDoor(door,CloseDoor);
}

/*
=====================
=
= UtilizeDoor
=
= Alter the door's state
=
=====================
*/

void UtilizeDoor (int door,void (*action)(int))
{
	doorobj_t*dptr;
	int dx,dy;
	doorobj_t * dr2;
	int tx,ty;

	dptr = doorobjlist[door];

	action(door);

	dx=0;dy=0;
	if (dptr->vertical==true)
		dy=1;
	else
		dx=1;
	tx=dptr->tilex+dx;
	ty=dptr->tiley+dy;
	while (M_ISDOOR(tx,ty))
		{
		int num;

		num=tilemap[tx][ty]&0x3ff;
		dr2=doorobjlist[num];
		if (!(dr2->flags&DF_MULTI))
			break;
		action(num);
		tx+=dx;
		ty+=dy;
		}
	tx=dptr->tilex-dx;
	ty=dptr->tiley-dy;
	while (M_ISDOOR(tx,ty))
		{
		int num;

		num=tilemap[tx][ty]&0x3ff;
		dr2=doorobjlist[num];
		if (!(dr2->flags&DF_MULTI))
			break;
		action(num);
		tx-=dx;
		ty-=dy;
		}
}

/*
=====================
=
= UseDoor
=
= Alter the door's state
=
=====================
*/

void UseDoor (int door)
{
	switch (doorobjlist[door]->action)
	{
	case dr_closing:
		SD_StopSound(doorobjlist[door]->soundhandle);
	case dr_closed:
		UtilizeDoor(door,OpenDoor);
		break;
	case dr_opening:
		SD_StopSound(doorobjlist[door]->soundhandle);
	case dr_open:
		if (DoorReadyToClose(door)==true)
			UtilizeDoor(door,CloseDoor);
		break;
	}
}

//===========================================================================

/*
===============
=
= DoorOpen
=
= Close the door after three seconds
=
===============
*/

void DoorOpen (int door)
{doorobj_t* dptr;

 dptr = doorobjlist[door];
 dptr->ticcount += 1;
 if ((dptr->ticcount >= OPENTICS) &&
	(!(dptr->flags & DF_TIMED)) &&
	(DoorReadyToClose(door)==true))
	UtilizeDoor(door,CloseDoor);
}



/*
===============
=
= DoorOpening
=
===============
*/

void DoorOpening (int door)
{
	int		area1,area2;
	word  	*map;
	long		position;
	int		tilex,tiley;

	position = doorobjlist[door]->position;
	tilex = doorobjlist[door]->tilex;
	tiley = doorobjlist[door]->tiley;
	if (!position)
	{
	//
	// door is just starting to open, so connect the areas
	//
		map = &MAPSPOT(tilex,tiley,0);

		if (doorobjlist[door]->vertical==true)
		{
			area1 =	*(map+1);
			area2 =	*(map-1);
		}
		else
		{
		area1 =	*(map-mapwidth);
		area2 =	*(map+mapwidth);
		}
		area1 -= AREATILE;
		area2 -= AREATILE;
		areaconnect[area1][area2]++;
		areaconnect[area2][area1]++;
		if ((insetupgame==false) && (loadedgame==false))
			ConnectAreas ();
		if (areabyplayer[area1])
			{
			doorobjlist[door]->soundhandle=SD_PlaySoundRTP ( SD_OPENDOORSND, doorobjlist[door]->tilex<<16, doorobjlist[door]->tiley<<16 );
			}
	}

//
// slide the door by an adaptive amount
//
	position += 1<<12;
	if (position >= 0xffff)
	{
	//
	// door is all the way open
	//
		position = 0xffff;
		doorobjlist[door]->ticcount = 0;
		doorobjlist[door]->action = dr_open;
		if (doorobjlist[door] == actorat[tilex][tiley])
			actorat[tilex][tiley] = 0;
	}

	doorobjlist[door]->position = position;
	doorobjlist[door]->texture=doorobjlist[door]->basetexture+((position+1)>>13);
}


/*
===============
=
= DoorClosing
=
===============
*/

void DoorClosing (int door)
{
	int		area1,area2;
	word		*map;
	long		position;
	int		tilex,tiley;
	doorobj_t *dptr;

	dptr = doorobjlist[door];

	tilex = dptr->tilex;
	tiley = dptr->tiley;

	position = dptr->position;

//
// slide the door by an adaptive amount
//
	position -= 1<<12;
	if (position < (0xffff >> 1))
		ResolveDoorSpace(tilex,tiley);


	if (position <= 0)
	{
	//
	// door is closed all the way, so disconnect the areas
	//
		position = 0;

		dptr->action = dr_closed;



		map = &MAPSPOT(tilex,tiley,0);

		if (areabyplayer[(*map-AREATILE)])
			{
			dptr->soundhandle=SD_PlaySoundRTP ( SD_DOORHITSND, dptr->tilex<<16, dptr->tiley<<16 );
			}

		if (dptr->vertical==true)
		{
			area1 =	*(map+1);
			area2 =	*(map-1);
		}
		else
		{
			area1 =	*(map-mapwidth);
			area2 =	*(map+mapwidth);
		}
		area1 -= AREATILE;
		area2 -= AREATILE;
		areaconnect[area1][area2]--;
		areaconnect[area2][area1]--;

		ConnectAreas ();
	}

	dptr->position = position;
	dptr->texture=dptr->basetexture+((position+1)>>13);
}

/*
===============
=
= IsMaskedWall
=
===============
*/

int IsMaskedWall (int tilex, int tiley)
{
	int map;

	if (IsPlatform(tilex,tiley))
		return 1;

	map=MAPSPOT(tilex,tiley,0);

	if ((map>=157) && (map<=160))
		return 1;

	if ((map>=162) && (map<=179))
		return 1;

	if (M_ISMWALL(tilex,tiley))
		return 1;

	return 0;
}

/*
===============
=
= SpawnMaskedWall
=
===============
*/


void SpawnMaskedWall (int tilex, int tiley, int which, int flags)
{word *map;
 int area1, area2;
 int up,dn,lt,rt;
 int himask;
 boolean sidepic;
 int side, middle, above, bottom;
 maskedwallobj_t * lastmaskobj;
 boolean metal;
 int maskedstart;
 int abovemaskedwallstart;
 int swallstart;

	himask=W_GetNumForName("HMSKSTRT")+1;
	maskedstart=W_GetNumForName("MASKSTRT");
	abovemaskedwallstart=W_GetNumForName("ABVMSTRT");
	swallstart=W_GetNumForName("SIDESTRT");

	maskobjlist[maskednum]=(maskedwallobj_t*)Z_LevelMalloc(sizeof(maskedwallobj_t),PU_LEVELSTRUCT,NULL);
	memset(maskobjlist[maskednum],0,sizeof(maskedwallobj_t));
	lastmaskobj=maskobjlist[maskednum];

	sidepic=true;

	lastmaskobj->tilex = tilex;
	lastmaskobj->tiley = tiley;
	lastmaskobj->which = MWALL;
	up=MAPSPOT(tilex,tiley-1,0)-AREATILE;
	dn=MAPSPOT(tilex,tiley+1,0)-AREATILE;
	lt=MAPSPOT(tilex-1,tiley,0)-AREATILE;
	rt=MAPSPOT(tilex+1,tiley,0)-AREATILE;

	if (IsMaskedWall(tilex,tiley-1)) up=2;
	else if (IsWall(tilex,tiley-1)) up=1;
	else up=0;

	if (IsMaskedWall(tilex,tiley+1)) dn=2;
	else if (IsWall(tilex,tiley+1)) dn=1;
	else dn=0;

	if (IsMaskedWall(tilex-1,tiley)) lt=2;
	else if (IsWall(tilex-1,tiley)) lt=1;
	else lt=0;

	if (IsMaskedWall(tilex+1,tiley)) rt=2;
	else if (IsWall(tilex+1,tiley)) rt=1;
	else rt=0;

	if ((up==1) && (dn==1))
		lastmaskobj->vertical = true;
	else if ((lt==1) && (rt==1))
		lastmaskobj->vertical = false;
	else if ((up>0) && (dn>0))
		lastmaskobj->vertical = true;
	else if ((lt>0) && (rt>0))
		lastmaskobj->vertical = false;
	else if (up>0)
		lastmaskobj->vertical = true;
	else if (dn>0)
		lastmaskobj->vertical = true;
	else if (lt>0)
		lastmaskobj->vertical = false;
	else if (rt>0)
		lastmaskobj->vertical = false;

	tilemap[tilex][tiley] = maskednum | 0xc000;
	map = &MAPSPOT(tilex,tiley,0);

	if (lastmaskobj->vertical==true)
		{
		area1 =	*(map+1);
		area2 =	*(map-1);
		area1 -= AREATILE;
		area2 -= AREATILE;
		if (lt==0 && rt==0)
			{
			areaconnect[area1][area2]++;
			areaconnect[area2][area1]++;
			}
		}
	else
		{
		area1 =	*(map-mapwidth);
		area2 =	*(map+mapwidth);
		area1 -= AREATILE;
		area2 -= AREATILE;
		if (up==0 && dn==0)
			{
			areaconnect[area1][area2]++;
			areaconnect[area2][area1]++;
			}
		}
	lastmaskobj->flags=flags;

	if (IsPlatform(tilex,tiley))
		{
		if (MAPSPOT(tilex,tiley,0)==21)
			{
			metal=true;
			actorat[tilex][tiley]=0;
			}
		else
			metal=false;
		}



	switch (which)
		{
		case mw_peephole:

		//#if (SHAREWARE == 1)
			side = W_GetNumForName("SIDE21");
			middle = W_GetNumForName("ABOVEM4A") ;
			above  = W_GetNumForName("ABOVEM4") ;
		/*
		#else
			side	= W_GetNumForName("SIDE16");
			middle = W_GetNumForName("ABOVEM3A") ;
			above  = W_GetNumForName("ABOVEM2A") ;

		#endif
		*/
			bottom = W_GetNumForName("PEEPMASK");
			break;


		case mw_dogwall:

			side = W_GetNumForName("SIDE21");
			above  = W_GetNumForName("ABOVEM4") ;

	#if (SHAREWARE == 1)
			middle = W_GetNumForName("ABOVEM4A") ;
	#else
			middle = W_GetNumForName("ABOVEM9") ;

	#endif
			bottom = W_GetNumForName("DOGMASK");
			break;

		case mw_multi1:

  /*
		#if (SHAREWARE == 1)
			side = W_GetNumForName("SIDE21");
			middle = W_GetNumForName("ABOVEM4A") ;
			above  = W_GetNumForName("ABOVEM4") ;

		#else
  */
			//side	= W_GetNumForName("SIDE23") ;
			side	= W_GetNumForName("SIDE21") ;
			middle = W_GetNumForName("ABOVEM5A") ;
			above  = W_GetNumForName("ABOVEM5") ;

	// #endif

			bottom = W_GetNumForName("MULTI1");
			break;

		case mw_multi2:
		/*
		#if (SHAREWARE == 1)
			side = W_GetNumForName("SIDE21");
			middle = W_GetNumForName("ABOVEM4A");
			above  = W_GetNumForName("ABOVEM4") ;

		#else
		*/
			//side	= W_GetNumForName("SIDE23") ;
			side	= W_GetNumForName("SIDE21") ;
			middle = W_GetNumForName("ABOVEM5B");
			above  = W_GetNumForName("ABOVEM5") ;


		//#endif

			bottom = W_GetNumForName("MULTI2");
			break;

		case mw_multi3:

		/*
		#if (SHAREWARE == 1)
			side = W_GetNumForName("SIDE21");
			middle = W_GetNumForName("ABOVEM4A") ;
			above  = W_GetNumForName("ABOVEM4")  ;

		#else
		*/
			//side	= W_GetNumForName("SIDE23") ;
			side	= W_GetNumForName("SIDE21") ;
			middle = W_GetNumForName("ABOVEM5C") ;
			above  = W_GetNumForName("ABOVEM5")  ;


		//#endif

			bottom = W_GetNumForName("MULTI3");
			break;

		case mw_singlepane:

	//	#if (SHAREWARE == 1)
			side = W_GetNumForName("SIDE21");

	//	#else
	//		side	= W_GetNumForName("SIDE22") ;
	//	#endif

			middle = W_GetNumForName("ABOVEM4A") ;
			above  = W_GetNumForName("ABOVEM4")  ;
			bottom = W_GetNumForName("MASKED4");
			break;

		case mw_normal1:
			side = W_GetNumForName("SIDE21");


	// #if (SHAREWARE == 1)
			middle = W_GetNumForName("ABOVEM4A") ;
			above  = W_GetNumForName("ABOVEM4")  ;

		//#else
		//  middle = W_GetNumForName("ABOVEM1A") ;
		//  above  = W_GetNumForName("ABOVEM1")  ;


		//#endif

			bottom = W_GetNumForName("MASKED1");
			break;

		case mw_normal2:
			side = W_GetNumForName("SIDE21");

		//#if (SHAREWARE == 1)
			middle = W_GetNumForName("ABOVEM4A") ;
			above  = W_GetNumForName("ABOVEM4")  ;

		//#else
		//	middle = W_GetNumForName("ABOVEM2A") ;
		//	above  = W_GetNumForName("ABOVEM2")  ;

		//#endif

			bottom = W_GetNumForName("MASKED2");
			break;

		case mw_normal3:
			side = W_GetNumForName("SIDE21");

		//#if (SHAREWARE == 1)
			middle = W_GetNumForName("ABOVEM4A") ;
			above  = W_GetNumForName("ABOVEM4")  ;

		//#else
		//	middle = W_GetNumForName("ABOVEM3A") ;
		//	above  = W_GetNumForName("ABOVEM3")  ;

		//#endif

			bottom = W_GetNumForName("MASKED3");
			break;

		case mw_exitarch:

			side = W_GetNumForName("SIDE21");

		//#if (SHAREWARE == 1)
			middle = W_GetNumForName("ABOVEM4A") ;
			above  = W_GetNumForName("ABOVEM4")  ;

		//#else
		//	middle = W_GetNumForName("ABOVEM6A") ;
		//	above  = W_GetNumForName("ABOVEM6")  ;

		//#endif

			bottom = W_GetNumForName("EXITARCH");
			break;

		case mw_secretexitarch:

			side = W_GetNumForName("SIDE21");

		//#if (SHAREWARE == 1)
			middle = W_GetNumForName("ABOVEM4A") ;
			above  = W_GetNumForName("ABOVEM4")  ;

		//#else
		//	middle = W_GetNumForName("ABOVEM8A") ;
		//	above  = W_GetNumForName("ABOVEM8")  ;

		//#endif

			bottom = W_GetNumForName("EXITARCA");
			break;

		case mw_railing:
			sidepic = false;
			middle = -1;
			above  = -1;
			bottom = W_GetNumForName("RAILING");
			break;

		case mw_hiswitchon:
			sidepic = false;
			middle = himask+1;
			above = himask+3;
			bottom = himask;
			break;

		case mw_hiswitchoff:
			sidepic = false;
			middle = himask+1;
			above = himask+2;
			bottom = himask;
			break;

		case mw_entrygate:
			side = W_GetNumForName("SIDE21");

		//#if (SHAREWARE == 1)
			//side = W_GetNumForName("SIDE21");
			middle = W_GetNumForName("ABOVEM4A") ;
			above  = W_GetNumForName("ABOVEM4")  ;

		//#else
			//side	= W_GetNumForName("SIDE20") ;
		//	middle = W_GetNumForName("ABOVEM7A") ;
		//	above  = W_GetNumForName("ABOVEM7")  ;


		//#endif

			bottom = W_GetNumForName("ENTRARCH");
			break;

		case mw_platform1:
			sidepic = false;
			bottom = -1;
			middle = -1;
			above  = himask+10;
			if (metal==true)
				{
				bottom = -1;
				middle = -1;
				above  = himask+15;
				}
			break;
		case mw_platform2:
			sidepic = false;
			bottom = himask+8;
			middle = -1;
			above = -1;
			if (metal==true)
				{
				bottom = himask+14;
				middle = -1;
				above = -1;
				}
			else
				lastmaskobj->flags|=MW_BOTTOMFLIPPING;
			break;
		case mw_platform3:
			sidepic = false;
			bottom = himask+8;
			middle = -1;
			above = himask+10;
			if (metal==true)
				{
				bottom = himask+14;
				middle = -1;
				above = himask+15;
				}
			else
				lastmaskobj->flags|=MW_BOTTOMFLIPPING;
			break;
		case mw_platform4:
			sidepic = false;
			bottom = himask+12;
			middle = himask+7;
			above = himask+7;
			if (metal==true)
				{
				bottom = -1;
				middle = himask+15;
				above = himask+15;
				}
			break;
		case mw_platform5:
			sidepic = false;
			bottom = himask+12;
			middle = himask+7;
			above = himask+5;
			if (metal==true)
				{
				bottom = -1;
				middle = himask+15;
				above = -1;
				}
			else
				lastmaskobj->flags|=MW_TOPFLIPPING;
			break;
		case mw_platform6:
			sidepic = false;
			bottom = himask+4;
			middle = himask+7;
			above = himask+5;
			if (metal==true)
				{
				bottom = himask+14;
				middle = himask+15;
				above = -1;
				}
			else
				lastmaskobj->flags|=MW_TOPFLIPPING;
			break;
		case mw_platform7:
			sidepic = false;
			bottom = himask+4;
			middle = himask+7;
			above = himask+5;
			if ((up==1) || (dn==1))
				lastmaskobj->vertical=true;
			else if ((lt==1) || (rt==1))
				lastmaskobj->vertical=false;
			else
				Error("Perpendicular platform used with no wall near it\n");
			if (metal==true)
				{
				bottom = himask+14;
				middle = himask+15;
				above = -1;
				}
			else
				lastmaskobj->flags|=MW_TOPFLIPPING;
			break;
		}

	switch (which)
		{
		case mw_multi1:
		case mw_multi2:
		case mw_multi3:
		case mw_singlepane:
		case mw_normal1:
		case mw_normal2:
		case mw_normal3:
			if (!(flags & MW_SHOOTABLE))
				bottom+=9;
			break;
		}
	lastmaskobj->midtexture=middle;
	lastmaskobj->toptexture=above;
	lastmaskobj->bottomtexture=bottom;

	if (sidepic == true)
		{
		lastmaskobj->sidepic=side;
		if (lastmaskobj->vertical==true)
			{
			if (up==1)
				tilemap[tilex][tiley-1] |= 0x4000;
			if (dn==1)
				tilemap[tilex][tiley+1] |= 0x4000;
			}
		else
			{
			if (lt==1)
				tilemap[tilex-1][tiley] |= 0x4000;
			if (rt==1)
				tilemap[tilex+1][tiley] |= 0x4000;
			}
		}

	// Cache in the broken version

	if (lastmaskobj->flags & MW_SHOOTABLE)
		{
		int i;

		for (i=1;i<AMW_NUMFRAMES;i++)
			{
			PreCacheLump(lastmaskobj->bottomtexture+i,PU_CACHEWALLS);
			}
		SD_PreCacheSound(SD_GLASSBREAKSND);
		}
	if (sidepic==true)
		{
		PreCacheLump(lastmaskobj->sidepic,PU_CACHEWALLS);
		}
	if (lastmaskobj->bottomtexture>=0)
		PreCacheLump(lastmaskobj->bottomtexture,PU_CACHEWALLS);
	if (lastmaskobj->toptexture>=0)
		PreCacheLump(lastmaskobj->toptexture,PU_CACHEWALLS);
	if (lastmaskobj->midtexture>=0)
		PreCacheLump(lastmaskobj->midtexture,PU_CACHEWALLS);
	maskednum++;
	lastmaskobj++;
	if (maskednum==MAXMASKED)
		Error ("Too many masked walls\n");
}

/*
===============
=
= FixMaskedWallAreaNumbers
=
===============
*/
void FixMaskedWallAreaNumbers ( void )
{
	int i;
	int up,dn,lt,rt;
	int tilex,tiley;

	for (i=0;i<maskednum;i++)
		{
		int tile;
		tilex=maskobjlist[i]->tilex;
		tiley=maskobjlist[i]->tiley;
		tile=MAPSPOT(tilex,tiley,0)-AREATILE;
		if ((tile<=NUMAREAS) && (tile>0))
			{
			maskobjlist[i]->areanumber = tile;
			continue;
			}
		up=MAPSPOT(tilex,tiley-1,0)-AREATILE;
		dn=MAPSPOT(tilex,tiley+1,0)-AREATILE;
		lt=MAPSPOT(tilex-1,tiley,0)-AREATILE;
		rt=MAPSPOT(tilex+1,tiley,0)-AREATILE;



		up = ((up>0) && (up<=NUMAREAS));
		dn = ((dn>0) && (dn<=NUMAREAS));
		lt = ((lt>0) && (lt<=NUMAREAS));
		rt = ((rt>0) && (rt<=NUMAREAS));

		if (maskobjlist[i]->vertical==true)
			{
			if (rt)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex+1,tiley,0);
			else if (lt)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex-1,tiley,0);
			else if (up)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex,tiley-1,0);
			else if (dn)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex,tiley+1,0);
			else
				Error("FixMaskedWalls: Couldn't fix up area at x=%ld y=%ld\n",tilex,tiley);
			}
		else
			{
			if (dn)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex,tiley+1,0);
			else if (up)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex,tiley-1,0);
			else if (rt)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex+1,tiley,0);
			else if (lt)
				MAPSPOT(tilex,tiley,0) = MAPSPOT(tilex-1,tiley,0);
			else
				Error("FixMaskedWalls: Couldn't fix up area at x=%ld y=%ld\n",tilex,tiley);
			}
		maskobjlist[i]->areanumber = MAPSPOT(tilex,tiley,0)-AREATILE;
		if ((maskobjlist[i]->areanumber <0) || (maskobjlist[i]->areanumber > NUMAREAS))
		Error("Bad masked wall areanumber of %d",maskobjlist[i]->areanumber);
		}
}


/*
===============
=
= CheckMaskedWall
=
===============
*/

int CheckMaskedWall( maskedwallobj_t * mw )
{
	int result;

	result=0;
	if (mw->flags & MW_SHOOTABLE)
		{
		if (mw->flags & MW_BLOCKINGCHANGES)
			{
			mw->flags&=~MW_BLOCKINGCHANGES;
			mw->flags&=~MW_BLOCKING;
			mw->flags|=MW_BOTTOMPASSABLE;
			}
		mw->flags&=~MW_SHOOTABLE;
//		mw->bottomtexture++;
		result=1;
		}
	return result;
}


/*
===============
=
= UpdateMaskedWall
=
===============
*/

int UpdateMaskedWall (int num)
{
	maskedwallobj_t * mw;
	int result;


	mw=maskobjlist[num];
	result=CheckMaskedWall(mw);
	if (result==1)
		{
		SpawnAnimatedMaskedWall(num);
		if (loadedgame==false)
			SD_PlaySoundRTP(SD_GLASSBREAKSND,mw->tilex<<16,mw->tiley<<16);
		if (mw->flags&MW_MULTI)
			{
			int i;
			int dx,dy;
			int r;
			maskedwallobj_t * mw2;

			dx=0;dy=0;
			if (mw->vertical==true)
				dy=1;
			else
				dx=1;
			i=1;
			while (M_ISMWALL(mw->tilex+(dx*i),mw->tiley+(dy*i)))
				{
				int num;

				num=tilemap[mw->tilex+(dx*i)][mw->tiley+(dy*i)]&0x3ff;
				mw2=maskobjlist[num];
				if (!(mw2->flags&MW_MULTI))
					break;
				r=CheckMaskedWall(mw2);
				if (r==1)
					{
					SpawnAnimatedMaskedWall(num);
					if (loadedgame==false)
						SD_PlaySoundRTP(SD_GLASSBREAKSND,mw2->tilex<<16,mw2->tiley<<16);
					}
				i++;
				}
			i=1;
			while (M_ISMWALL(mw->tilex-(dx*i),mw->tiley-(dy*i)))
				{
				int num;

				num=tilemap[mw->tilex-(dx*i)][mw->tiley-(dy*i)]&0x3ff;
				mw2=maskobjlist[num];
				if (!(mw2->flags&MW_MULTI))
					break;
				r=CheckMaskedWall(mw2);
				if (r==1)
					{
					SpawnAnimatedMaskedWall(num);
					if (loadedgame==false)
						SD_PlaySoundRTP(SD_GLASSBREAKSND,mw2->tilex<<16,mw2->tiley<<16);
					}
				i++;
				}
			}
		}
	return result;
}



/*
============================
=
= ExecuteElevatorStopActions
=
============================
*/


void ExecuteElevatorStopActions(elevator_t *eptr, int teleport_location,
										int desttilex,int desttiley)
	{
	eptr->state = ev_doorclosing;
	eptr->doorclosing = eptr->doortoopen;
	doorobjlist[eptr->doortoopen]->flags &= ~DF_ELEVLOCKED;
	OpenDoor(eptr->doortoopen);
	SD_PlaySoundRTP(SD_ELEVATORENDSND,desttilex,desttiley);
	Teleport(eptr,teleport_location);
	eptr->ticcount = OPENTICS;
	eptr->doortoopen = -1;
	if (MISCVARS->elevatormusicon == true)
		{
		MU_StartSong(song_level);
		MU_RestoreSongPosition();
		MISCVARS->elevatormusicon = false;

		}
	}


boolean PlayerInElevator(elevator_t *eptr)
	{
	if (eptr->state == ev_mts)
		{
		if ((eptr->dx == player->tilex) && (eptr->dy == player->tiley))
			return true;
		}
	else if (eptr->state == ev_mtd)
		{
		if ((eptr->sx == player->tilex) && (eptr->sy == player->tiley))
			return true;
		}

	return false;

	}

#define SHOULD_START_ELEVATOR_MUSIC(eptr)										\
		((demoplayback == false) && (demorecord == false) &&			\
			(MusicStarted() == true) &&											\
			(!BATTLEMODE) && \
			(!(player->flags & FL_GODMODE)) &&\
			(GameRandomNumber("elevator music",0) < 25) && \
			(PlayerInElevator(eptr))												\
		)																				\


/*
==========================
=
= SetElevatorOperationTime
=
==========================
*/


void SetElevatorOperationTime(elevator_t*eptr)
	{
	if (SHOULD_START_ELEVATOR_MUSIC(eptr))
		{
		MU_StoreSongPosition();
		MU_StartSong(song_elevator);
		MISCVARS->elevatormusicon = true;
		eptr->ticcount = ELEVATORMUSICTIME;
		}

	else if (AREANUMBER(eptr->sx,eptr->sy) == AREANUMBER(eptr->dx,eptr->dy))
		eptr->ticcount = 70;
	else
		eptr->ticcount = 170;

	}


/*
=====================
=
= CheckElevatorStart
=
=====================
*/

void CheckElevatorStart (elevator_t*eptr)
	{
	doorobj_t *dptr = doorobjlist[eptr->doorclosing];

	if (dptr->action == dr_closed)
		{

		if (eptr->nextaction!=-1)
			{
			eptr->state = eptr->nextaction;
			eptr->nextaction = -1;
			switch (eptr->state)
				{
				case ev_mtd:
					eptr->doortoopen = eptr->door2;
					SD_PlaySoundRTP(SD_ELEVATORONSND,eptr->sx<<16,eptr->sy<<16);
					//eptr->doorclosing = eptr->door1;

					SetElevatorOperationTime(eptr);
					break;

				case ev_mts:
					eptr->doortoopen = eptr->door1;

					SD_PlaySoundRTP(SD_ELEVATORONSND,eptr->dx<<16,eptr->dy<<16);

					SetElevatorOperationTime(eptr);
					break;
				}
			}

		else if (eptr->doorclosing == eptr->door1)
			eptr->state = ev_ras;


		else if (eptr->doorclosing == eptr->door2)
			eptr->state = ev_rad;


		eptr->doorclosing = -1;
		}
	}


/*
=====================
=
= ProcessElevators
=
= Called from PlayLoop
=
=====================
*/

void ProcessElevators (void)
	{
	int		ectr;
	elevator_t *eptr;

	for (ectr = 0 ; ectr < _numelevators ; ectr++)
		{
		eptr = &ELEVATOR[ectr];
		if (eptr->ticcount)
			eptr->ticcount --;
		else
			{
			switch (eptr->state)
				{
				/*
				case ev_ras:
					break;

				case ev_rad:
					break;
				*/
				case ev_mts:
					ExecuteElevatorStopActions(eptr,0,(eptr->sx << 16),(eptr->sy << 16));
					break;

				case ev_mtd:
					ExecuteElevatorStopActions(eptr,1,(eptr->dx << 16),(eptr->dy << 16));
					break;

				case ev_doorclosing:
					CheckElevatorStart(eptr);
					break;
				}
			}
		}
	}



void Teleport(elevator_t*eptr,int destination)
{statobj_t*tstat;
 objtype*temp;
 int startx,starty,destx,desty;

 if (destination) // move to dest
	{startx = eptr->sx;
	starty = eptr->sy;
	destx = eptr->dx;
	desty = eptr->dy;
	tilemap[eptr->esx][eptr->esy] = (elevatorstart + 5|0x2000);

	}
 else
	{startx = eptr->dx;
	starty = eptr->dy;
	destx = eptr->sx;
	desty = eptr->sy;
	tilemap[eptr->edx][eptr->edy] = (elevatorstart + 5|0x2000);
	}

 for(tstat=firstactivestat;tstat;tstat=tstat->nextactive)
	{if ((tstat->tilex == startx) && (tstat->tiley == starty))
		{
		tstat->x += ((destx - tstat->tilex) << TILESHIFT);
		tstat->y += ((desty - tstat->tiley) << TILESHIFT);
		tstat->tilex = tstat->x >> TILESHIFT;
		tstat->tiley = tstat->y >> TILESHIFT;
		tstat->visspot = &spotvis[tstat->tilex][tstat->tiley];
		if (sprites[startx][starty] == tstat)
			{sprites[startx][starty] = NULL;
			sprites[destx][desty] = tstat;

			}

		}
	}

 for(temp=firstactive;temp;temp=temp->nextactive)
	{if ((temp->tilex == startx) && (temp->tiley == starty))
		{temp->x += ((destx - temp->tilex) << TILESHIFT);
		temp->y += ((desty - temp->tiley) << TILESHIFT);
		temp->tilex = temp->x >> TILESHIFT;
		temp->tiley = temp->y >> TILESHIFT;
		if (temp->obclass!=inertobj)
			{
			RemoveFromArea (temp);
			temp->areanumber = AREANUMBER(temp->tilex,temp->tiley);
			MakeLastInArea (temp);
			}
		if (temp == player)
			SHAKETICS = 10;
		}
	}



}



void OperateElevatorDoor(int dnum)
{
 elevator_t*eptr;
 doorobj_t *dptr,*door1,*door2;

 dptr = doorobjlist[dnum];
 eptr = &ELEVATOR[dptr->eindex];
 door1 = doorobjlist[eptr->door1];
 door2 = doorobjlist[eptr->door2];

 switch(eptr->state)
	{/*
	case ev_mtd:					// if already on the way to request,
										// ignore; else, put request in
		if (dnum == eptr->door1)
		{eptr->nextaction = ev_mts;
			//eptr->doortoopen = eptr->door1;
			#if (DEVELOPMENT == 1)
			#if (ELEVATORTEST == 1)
			Debug("\nplayer at source requesting elev %d mtd",dptr->eindex);
			#endif
			#endif
		}
		break;

	case ev_mts:
		if (dnum == eptr->door2)
		{eptr->nextaction = ev_mtd;
			//eptr->doortoopen = eptr->door2;
			#if (DEVELOPMENT == 1)
			#if (ELEVATORTEST == 1)
			Debug("\nplayer at dest requesting elev %d mts",dptr->eindex);
			#endif
			#endif
		}
		break;
	*/
	case ev_rad:								// if ready at other place,
		if ((dnum == eptr->door1) && (eptr->nextaction != ev_mts))  // process request, lock doors,

			{
			#if (DEVELOPMENT == 1)
			#if (ELEVATORTEST == 1)
			Debug("\nplayer at source requesting elev %d rad",dptr->eindex);
			#endif
			#endif
												// start moving to current loc;
			SetNextAction(eptr,0);		// if already there, do nothing

			}
		break;

	case ev_ras:
		if ((dnum == eptr->door2) && (eptr->nextaction != ev_mtd))
			{
			#if (DEVELOPMENT == 1)
			#if (ELEVATORTEST == 1)
			Debug("\nplayer at dest requesting elev %d ras",dptr->eindex);
			#endif
			#endif
			SetNextAction(eptr,1);

			}
		break;

	case ev_doorclosing:
		if (eptr->doorclosing == dnum)		// if opening door at current loc,
														// reset elev state to ready
		{//if (eptr->door1 == dnum)
			// eptr->nextaction = ev_ras;
			//else
			//eptr->nextaction = ev_rad;
		}
		else										//else prepare for movement
		{if ((eptr->door1 == dnum) && (eptr->nextaction != ev_mts))
			{
				#if ((DEVELOPMENT == 1))
				#if ((ELEVATORTEST == 1))
				Debug("\nplayer at source requesting elev %d dc",dptr->eindex);
				#endif
				#endif
				SetNextAction(eptr,0);

			}
			else if ((eptr->door2 == dnum) && (eptr->nextaction != ev_mtd))
			{
				#if ((DEVELOPMENT == 1))
				#if ((ELEVATORTEST == 1))
				Debug("\nplayer at dest requesting elev %d dc",dptr->eindex);
				#endif
				#endif
				SetNextAction(eptr,1);

			}
		}
	break;


	}

}


int SetNextAction(elevator_t*eptr,int action)
{int dn;

 if (action)
	{if (!DoorReadyToClose(eptr->door1))
	return false;

	eptr->nextaction = ev_mtd;
	dn = eptr->door1;
	}
 else
	{if (!DoorReadyToClose(eptr->door2))
	return false;

	eptr->nextaction = ev_mts;
	dn = eptr->door2;
	}
 eptr->state = ev_doorclosing;

 eptr->doorclosing = dn;
 #if (DEVELOPMENT == 1)
 #if (ELEVATORTEST == 1)
	Debug("\nCloseDoor %d",dn);
 #endif
 #endif
 if (doorobjlist[dn]->action != dr_closed)
  CloseDoor(dn);
 doorobjlist[dn]->flags |= DF_ELEVLOCKED;

 return true;
}


void OperateElevatorSwitch(objtype*ob,int elevnum,int checkx,int checky)
{elevator_t*eptr;
 doorobj_t *door1,*door2;

 eptr = &ELEVATOR[elevnum];

 if ((eptr->state == ev_mts) ||
	(eptr->state == ev_mtd))
	{
	#if (DEVELOPMENT == 1)
	#if (ELEVATORTEST == 1)
	Debug("\nobj %d tried to use elevator %d switch while in use",ob->obclass,elevnum);
	#endif
	#endif
	return;
	}

 door1 = doorobjlist[eptr->door1];
 door2 = doorobjlist[eptr->door2];

 if ((abs(ob->tilex-door1->tilex)<=1) && //switch at source
	(abs(ob->tiley-door1->tiley)<=1))
	{if (!SetNextAction(eptr,1)) // set next to dest
		return;
	#if (DEVELOPMENT == 1)
	#if (ELEVATORTEST == 1)
	Debug("\nswitch at src %d flipped",elevnum);
	#endif
	#endif
	eptr->ticcount = 0;
	}
 else //switch at dest
	{if (!SetNextAction(eptr,0)) // set next to src
		return;
	#if (DEVELOPMENT == 1)
	#if (ELEVATORTEST == 1)
	Debug("\nswitch at dest %d flipped",elevnum);
	#endif
	#endif
	eptr->ticcount = 0;
	}

 tilemap[checkx][checky] = (elevatorstart + 6|0x2000);
 SD_PlaySoundRTP(SD_TOUCHPLATESND,ob->x,ob->y);

}




/*
=====================
=
= MoveDoors
=
= Called from PlayLoop
=
=====================
*/

void MoveDoors (void)
{
	int		door;

	for (door = 0 ; door < doornum ; door++)
		switch (doorobjlist[door]->action)
		{
		case dr_open:
			DoorOpen (door);
			break;

		case dr_opening:
			DoorOpening(door);
			SD_PanRTP ( doorobjlist[door]->soundhandle, doorobjlist[door]->tilex<<16, doorobjlist[door]->tiley<<16 );
			break;

		case dr_closing:
			DoorClosing(door);
			SD_PanRTP ( doorobjlist[door]->soundhandle, doorobjlist[door]->tilex<<16, doorobjlist[door]->tiley<<16 );
			break;
		}
}


//===========================================================
//
//						PUSHWALLS
//
//===========================================================


/*
===============
=
= GetAreaNumber
=
===============
*/
int GetAreaNumber ( int tilex, int tiley, int dir )
{
	int up,dn,lt,rt;

	up=MAPSPOT(tilex,tiley-1,0)-AREATILE;
	dn=MAPSPOT(tilex,tiley+1,0)-AREATILE;
	lt=MAPSPOT(tilex-1,tiley,0)-AREATILE;
	rt=MAPSPOT(tilex+1,tiley,0)-AREATILE;
	if ((up<=0) || (up>NUMAREAS)) up=0;
	if ((dn<=0) || (dn>NUMAREAS)) dn=0;
	if ((lt<=0) || (lt>NUMAREAS)) lt=0;
	if ((rt<=0) || (rt>NUMAREAS)) rt=0;
	switch (dir)
		{
		case north:
			if (up)
				return up;
			else if (dn)
				return dn;
			break;
		case south:
			if (dn)
				return dn;
			else if (up)
				return up;
			break;
		case east:
			if (rt)
				return rt;
			else if (lt)
				return lt;
			break;
		case west:
			if (lt)
				return lt;
			else if (rt)
				return rt;
			break;
		}
	if (up)
		return up;
	else if (dn)
		return dn;
	else if (lt)
		return lt;
	else if (rt)
		return rt;
	else
		Error("Cannot find an area number for tile at x=%ld y=%ld\n",tilex,tiley);
	return -1;
}

/*
===============
=
= SpawnPushWall
=
===============
*/

void SpawnPushWall (int tilex, int tiley, int lock, int texture, int dir, int type)
{
	pwallobj_t * lastpwallobj;
	int area;

	if (pwallnum==MAXPWALLS)
	{
//		Error ("MAXPWALLS on level!");

		printf ("MAXPWALLS on level!\n");

		//BGB: just sorta remove the pushwall...
		area = GetAreaNumber(tilex,tiley,dir);
		MAPSPOT (tilex, tiley, 0)=(word)(area+AREATILE);
		return;
	}

	pwallobjlist[pwallnum]=(pwallobj_t*)Z_LevelMalloc(sizeof(pwallobj_t),PU_LEVELSTRUCT,NULL);
	memset(pwallobjlist[pwallnum],0,sizeof(pwallobj_t));
	lastpwallobj=pwallobjlist[pwallnum];

	lastpwallobj->x = (tilex<<16)+0x8000;
	lastpwallobj->y = (tiley<<16)+0x8000;
	lastpwallobj->momentumx=0;
	lastpwallobj->momentumy=0;
	lastpwallobj->tilex = tilex;
	lastpwallobj->tiley = tiley;
	lastpwallobj->lock = lock;
	lastpwallobj->action = pw_npushed;
	lastpwallobj->which = PWALL;
	lastpwallobj->dir = dir;
	lastpwallobj->num = pwallnum;
	actorat[tilex][tiley] = (pwallobj_t*)(lastpwallobj);	// consider it a solid wall

	if ( (MAPSPOT(tilex,tiley,0)==44) ||
		(MAPSPOT(tilex,tiley,0)==233)
		)
		lastpwallobj->flags=PW_DAMAGE;

	lastpwallobj->texture = texture;
	if (!texture&0x1000)
		PreCacheLump(texture,PU_CACHEWALLS);
	lastpwallobj->areanumber = GetAreaNumber(tilex,tiley,lastpwallobj->dir);

	MAPSPOT (tilex, tiley, 0)=(word)(lastpwallobj->areanumber+AREATILE);

	switch(type)
		{
		case 0:
		case 1:
		case 3:
			lastpwallobj->speed = 2;
			break;
		case 2:
		case 4:
			lastpwallobj->speed = 4;
			break;
		default:
			Error("Illegal PushWall type passed into SpawnPushWall\n");
			break;
		}
	if (type>2)
		{
		tilemap[tilex][tiley] = 0;
		ActivateMoveWall(pwallnum);
		}
	else
		{
		tilemap[tilex][tiley] = texture|0x800;
		if ((loadedgame==false) && (type==0))
			gamestate.secrettotal++;
		}

	pwallnum++;
	lastpwallobj++;

	SD_PreCacheSoundGroup(SD_PUSHWALLSND,SD_TURBOWALLSND);
}



/*
=====================
=
= OperatePushWall
=
= The player wants to change the pushwall's direction
=
=====================
*/
void OperatePushWall (int pwall, int dir, boolean localplayer )
{
	pwallobj_t * pw;

	pw=pwallobjlist[pwall];

	if (pw->lock)
		{
		if ( localplayer )
			{
			// Can't push
			AddMessage("This push wall appears to be locked...",MSG_DOOR);
			PlayNoWaySound();
			}
		return;
		}
	switch (pw->action)
		{
		case pw_npushed:
			if ((dir!=pw->dir) && (pw->dir!=nodir))
				{
				// Can't push
				if ( localplayer )
					{
					PlayNoWaySound();
					}
				return;
				}
			else if (localplayer && (gamestate.difficulty == gd_baby))
				AddMessage("Push Wall Activated.",MSG_GAME);

			pw->action=pw_pushing;
			pw->dir=dir;
			SD_PlaySoundRTP ( SD_TOUCHPLATESND, pw->x, pw->y );
			ConnectPushWall(pwall);
			SetupPushWall(pwall);
			gamestate.secretcount++;
			break;
		default:
			// Can't push
			if ( localplayer )
				{
				PlayNoWaySound();
				}
			break;
		}
}

/*
=====================
=
= ActivateAllPushWalls
=
= A Push wall has beeen activated by a touch plate
=
=====================
*/

void ActivateAllPushWalls(void)
	{
	int i;

	for(i=0;i<pwallnum;i++)
		{
		if (pwallobjlist[i]->dir != nodir)
			{
			ActivatePushWall(i);
			}
		}
	}

/*
=====================
=
= ActivatePushWall
=
= A Push wall has beeen activated by a touch plate
=
=====================
*/

void ActivatePushWall (int pwall)
{
	pwallobj_t * pw;

	pw=pwallobjlist[pwall];

	switch (pw->action)
	{
	case pw_npushed:
		pw->action=pw_pushing;
		ConnectPushWall(pwall);
		SetupPushWall(pwall);
		gamestate.secretcount++;
		break;
	default:
		// Can't push
		SD_Play( SD_BADTOUCHSND );
		break;
	}
}

/*
=====================
=
= ActivateMoveWall
=
= A Push wall has beeen activated by a touch plate
=
=====================
*/

void ActivateMoveWall (int pwall)
{
	pwallobj_t * pw;

	pw=pwallobjlist[pwall];

	switch (pw->action)
	{
	case pw_npushed:
		pw->action=pw_moving;
		SetupPushWall(pwall);
		break;
	default:
		SD_Play( SD_BADTOUCHSND );
		break;
	}
}



/*
===============
=
= ConnectPushWall
=
===============
*/

void ConnectPushWall (int pwall)
{
	int		checkx;
	int		checky;
	int		area1,area2;
	int		area3,area4;
	word  	*map;
	pwallobj_t * pw;

	pw=pwallobjlist[pwall];

	checkx=pw->tilex;
	checky=pw->tiley;
	tilemap[checkx][checky] = 0;
	map = &MAPSPOT (checkx, checky, 0);

	area1 =	*(map-mapwidth);
	area2 =	*(map+mapwidth);
	area3 =  *(map+1);
	area4 =  *(map-1);

	area1 -= AREATILE;
	area2 -= AREATILE;
	area3 -= AREATILE;
	area4 -= AREATILE;
	if (((area1>0) && (area1<NUMAREAS)) &&
		((area2>0) && (area2<NUMAREAS)))
		{
		areaconnect[area1][area2]++;
		areaconnect[area2][area1]++;

		if ((insetupgame==false) && (loadedgame==false))
			ConnectAreas ();
		}
	if (((area3>0) && (area3<NUMAREAS)) &&
		((area4>0) && (area4<NUMAREAS)))
		{
		areaconnect[area3][area4]++;
		areaconnect[area4][area3]++;

		if ((insetupgame==false) && (loadedgame==false))
			ConnectAreas ();
		}
}

/*
===============
=
= SetupPushWall
=
===============
*/

void SetupPushWall (int pwall)
{
	pwallobj_t * pw;
	int speed;

	pw=pwallobjlist[pwall];
	speed=pw->speed<<PUSHWALLSPEED;
	switch (pw->dir)
	{
	case north:
		pw->momentumx=0;
		pw->momentumy=-speed;
		break;

	case east:
		pw->momentumx=speed;
		pw->momentumy=0;
		break;

	case northeast:
		pw->momentumx=speed;
		pw->momentumy=-speed;
		break;

	case southeast:
		pw->momentumx=speed;
		pw->momentumy=speed;
		break;

	case south:
		pw->momentumx=0;
		pw->momentumy=speed;
		break;

	case west:
		pw->momentumx=-speed;
		pw->momentumy=0;
		break;

	case northwest:
		pw->momentumx=-speed;
		pw->momentumy=-speed;
		break;

	case southwest:
		pw->momentumx=-speed;
		pw->momentumy=speed;
		break;
	}
	if (pw->action==pw_pushing)
		{
		if (loadedgame==false)
			pw->soundhandle=SD_PlaySoundRTP ( SD_PUSHWALLSND, pw->x, pw->y );
		pw->state=(0x20000L/speed);
		}
	if (pw->action==pw_moving)
		pw->state=(0x10000L/speed);
}


/*
=====================
=
= MovePWalls
=
= Called from PlayLoop
=
=====================
*/

void MovePWalls (void)
{
	int		pwall;

	for (pwall = 0 ; pwall < pwallnum ; pwall++)
		{
		if (pwallobjlist[pwall]->action==pw_pushing)
			{
			WallPushing (pwall);
			SD_PanRTP (pwallobjlist[pwall]->soundhandle, pwallobjlist[pwall]->x, pwallobjlist[pwall]->y );
			}
		if (pwallobjlist[pwall]->action==pw_moving)
			{
			WallMoving (pwall);
			SD_PanRTP (pwallobjlist[pwall]->soundhandle, pwallobjlist[pwall]->x, pwallobjlist[pwall]->y );
			}
		}
}


void ClearActorat(pwallobj_t*pw)
{int txhigh,txlow,tyhigh,tylow;
 int tryx,tryy,x,y;
 int pwrad = 0x6fff;


 tryx = pw->x;
 tryy = pw->y;
 txlow = (tryx - pwrad) >> 16;
 txhigh = (tryx + pwrad) >> 16;
 tylow = (tryy - pwrad) >> 16;
 tyhigh = (tryy + pwrad) >> 16;
 for(y=tylow;y<=tyhigh;y++)
	for(x=txlow;x<=txhigh;x++)
		{if (actorat[x][y] == pw)
			actorat[x][y] = NULL;
		}
}

void SetActorat(pwallobj_t*pw)
{int txhigh,txlow,tyhigh,tylow;
 int tryx,tryy,x,y;
 int pwrad = 0x6fff;

 tryx = pw->x;
 tryy = pw->y;
 txlow = (tryx - pwrad) >> 16;
 txhigh = (tryx + pwrad) >> 16;
 tylow = (tryy - pwrad) >> 16;
 tyhigh = (tryy + pwrad) >> 16;

 for(y=tylow;y<=tyhigh;y++)
	for(x=txlow;x<=txhigh;x++)
		actorat[x][y] = pw;
}

/*
=================
=
= FinishPushWall
=
=================
*/
void FinishPushWall (pwallobj_t * pw)
{
	pw->action = pw_pushed;
	actorat[pw->tilex][pw->tiley] = (wall_t*)&walls[GetWallIndex(pw->texture)];
	tilemap[pw->tilex][pw->tiley] = pw->texture;
}

/*
=================
=
= ResetPushWall
=
=================
*/
void ResetPushWall (pwallobj_t * pw)
{
	SetActorat(pw);
	tilemap[pw->tilex][pw->tiley] = pw->texture|0x800;
}

/*
=================
=
= WallPushing
=
=================
*/
void WallPushing (int pwall)
{
	int		checkx,checky;
	int		spot;
	pwallobj_t * pw;

	pw=pwallobjlist[pwall];

	ClearActorat(pw);

	PushWallMove(pwall);
	pw->x+=pw->momentumx;
	pw->y+=pw->momentumy;

	pw->state--;

	checkx=pw->tilex;
	checky=pw->tiley;

	pw->tilex=pw->x>>16;
	pw->tiley=pw->y>>16;

	if ((pw->tilex!=checkx) || (pw->tiley!=checky))
		{
		int x,y;
		int area = MAPSPOT(pw->tilex,pw->tiley,0)-AREATILE;

		if ((area<=0) || (area>NUMAREAS))
			{
			area=pw->areanumber;
			MAPSPOT (pw->tilex, pw->tiley, 0)=(word)(pw->areanumber+AREATILE);
			}
		// block crossed into a new block
		//
		// the tile can now be walked into
		//
		mapseen[checkx][checky] = 0;
		pw->areanumber = area;
		if (pw->momentumx>0)
			x=1;
		else if (pw->momentumx<0)
			x=-1;
		else
			x=0;
		if (pw->momentumy>0)
			y=1;
		else if (pw->momentumy<0)
			y=-1;
		else
			y=0;
		if (tilemap[pw->tilex+x][pw->tiley+y])
			{
			pw->state=(0x8000L/(pw->speed<<PUSHWALLSPEED));
			}
		if (actorat[pw->tilex+x][pw->tiley+y])
		ResolveDoorSpace(pw->tilex+x,pw->tiley+y);
		}


	if (pw->state==0)
		{
		pw->x=(pw->tilex<<16)+0x8000;
		pw->y=(pw->tiley<<16)+0x8000;
		spot = MAPSPOT(pw->tilex,pw->tiley,1)-ICONARROWS;
		if ((spot >= 0) && (spot <= 7))
			{
			pw->action = pw_npushed;
			pw->dir = spot;
			ResetPushWall (pw);
			if (pw->lock)
				{
				pw->action=pw_pushing;
				ConnectPushWall(pwall);
				SetupPushWall(pwall);
				}
			else
				{
				gamestate.secrettotal++;
				}
			}
		else
			{
			FinishPushWall (pw);
			}
		}
	else
		SetActorat(pw);
}


/*
=================
=
= WallMoving
=
=================
*/
void WallMoving (int pwall)
{
	int		checkx,checky;
	int		spot;
	pwallobj_t * pw;

	pw=pwallobjlist[pwall];

	ClearActorat(pw);

	PushWallMove(pwall);
	pw->x+=pw->momentumx;
	pw->y+=pw->momentumy;

	pw->state--;

	checkx=pw->tilex;
	checky=pw->tiley;

	pw->tilex=pw->x>>16;
	pw->tiley=pw->y>>16;

	if ((pw->tilex!=checkx) || (pw->tiley!=checky))
		{
		int area = MAPSPOT(pw->tilex,pw->tiley,0)-AREATILE;

		if ((area<=0) || (area>NUMAREAS))
			{
			area=pw->areanumber;
			MAPSPOT (pw->tilex, pw->tiley, 0)=(word)(pw->areanumber+AREATILE);
			}
		// block crossed into a new block
		//
		// the tile can now be walked into
		//
		if (areabyplayer[area])
			{
			if (pw->speed==2)
				pw->soundhandle=SD_PlaySoundRTP ( SD_GOWALLSND, pw->x, pw->y );
			else
				pw->soundhandle=SD_PlaySoundRTP ( SD_TURBOWALLSND, pw->x, pw->y );
			}

		if (actorat[pw->tilex][pw->tilex])
		ResolveDoorSpace(pw->tilex,pw->tiley);
		mapseen[checkx][checky] = 0;
		pw->areanumber = MAPSPOT (pw->tilex, pw->tiley, 0)-AREATILE;
		//actorat[pw->tilex][pw->tiley]=pw;
		if ( (pw->tilex==0) || (pw->tilex==127) ||
			(pw->tiley==0) || (pw->tiley==127) )
			{
			if (W_CheckNumForName("imfree")>=0)
				{
				lbm_t *LBM;

				LBM = (lbm_t *) W_CacheLumpNum (W_GetNumForName ("imfree"), PU_CACHE);
				VL_DecompressLBM (LBM,true);
				VW_UpdateScreen ();
				I_Delay (2000);
				}
			Error ("PushWall Attempting to escape off the edge of the map\nIt is located at x=%ld y=%ld\nI'm Free!!!!\n",
					pw->tilex, pw->tiley);
			}
		}
	if (pw->state==0)
		{
		pw->x=(pw->tilex<<16)+0x8000;
		pw->y=(pw->tiley<<16)+0x8000;
		spot = MAPSPOT(pw->tilex,pw->tiley,1)-ICONARROWS;
		if ((spot >= 0) && (spot <= 7))
			{
			int area = MAPSPOT(pw->tilex,pw->tiley,0)-AREATILE;

			if ((area<=0) || (area>NUMAREAS))
				{
				area=pw->areanumber;
				MAPSPOT (pw->tilex, pw->tiley, 0)=(word)(pw->areanumber+AREATILE);
				}

			if (areabyplayer[area] && (abs(spot-pw->dir)==4))
				SD_PlaySoundRTP ( SD_PUSHWALLHITSND, pw->x, pw->y );
			pw->dir = spot;
			}
		SetupPushWall(pwall);
		}
	else
		SetActorat(pw);
}



/*
=================
=
= SavePushWalls
=
=================
*/
void SavePushWalls(byte ** buf, int * sz)
{
  int unitsize;
  pwallobj_t * pw;
  byte * bufptr;
  int i;
  int size;

  if (pwallnum==0)
	{
	*sz=0;
	*buf=SafeMalloc(16);
	return;
	}
  pw=pwallobjlist[0];
  unitsize=0;
  unitsize+=sizeof(pw->state);
  unitsize+=sizeof(pw->x);
  unitsize+=sizeof(pw->y);
  unitsize+=sizeof(pw->dir);
  unitsize+=sizeof(pw->speed);
  unitsize+=sizeof(pw->action);

  *sz=pwallnum*unitsize;

  *buf=SafeMalloc(*sz);
  bufptr=*buf;

  for (i=0;i<pwallnum;i++)
	{
	pw=pwallobjlist[i];
	size=sizeof(pw->state);
	memcpy(bufptr,&(pw->state),size);
	bufptr+=size;

	size=sizeof(pw->x);
	memcpy(bufptr,&(pw->x),size);
	bufptr+=size;

	size=sizeof(pw->y);
	memcpy(bufptr,&(pw->y),size);
	bufptr+=size;

	size=sizeof(pw->dir);
	memcpy(bufptr,&(pw->dir),size);
	bufptr+=size;

	size=sizeof(pw->speed);
	memcpy(bufptr,&(pw->speed),size);
	bufptr+=size;

	size=sizeof(pw->action);
	memcpy(bufptr,&(pw->action),size);
	bufptr+=size;
	}
}

/*
=================
=
= LoadPushWalls
=
=================
*/
void LoadPushWalls(byte * bufptr, int sz)
{
  int unitsize;
  pwallobj_t * pw;
  pwallobj_t new;
  int i;
  int num;
  int size;
  int area;

  if (sz==0)
	return;
  SetupPushWalls();
  pw=pwallobjlist[0];
  unitsize=0;
  unitsize+=sizeof(pw->state);
  unitsize+=sizeof(pw->x);
  unitsize+=sizeof(pw->y);
  unitsize+=sizeof(pw->dir);
  unitsize+=sizeof(pw->speed);
  unitsize+=sizeof(pw->action);

  num=sz/unitsize;
  if (pwallnum!=num)
	Error("Different number of Push Walls when trying to load a game\npwallnum=%ld num=%ld",pwallnum,num);

  for (i=0;i<pwallnum;i++)
	{
	pw=pwallobjlist[i];

	size=sizeof(new.state);
	memcpy(&(new.state),bufptr,size);
	bufptr+=size;

	size=sizeof(new.x);
	memcpy(&(new.x),bufptr,size);
	bufptr+=size;

	size=sizeof(new.y);
	memcpy(&(new.y),bufptr,size);
	bufptr+=size;

	size=sizeof(new.dir);
	memcpy(&(new.dir),bufptr,size);
	bufptr+=size;

	size=sizeof(new.speed);
	memcpy(&(new.speed),bufptr,size);
	bufptr+=size;

	size=sizeof(new.action);
	memcpy(&(new.action),bufptr,size);
	bufptr+=size;

	actorat[pw->tilex][pw->tiley] = 0;
	mapseen[pw->tilex][pw->tiley] = 0;

	new.tilex=new.x>>16;
	new.tiley=new.y>>16;

	if ((new.tilex!=pw->tilex) || (new.tiley!=pw->tiley))
		{
		ClearActorat(pw);
		tilemap[pw->tilex][pw->tiley] = 0;
		if (pw->state!=pw_moving)
			{
#if 0
			if (pw->dir==nodir)
				{
				if (tilemap[pw->tilex+1][pw->tiley]==0)
					pw->dir=east;
				else if (tilemap[pw->tilex-1][pw->tiley]==0)
					pw->dir=west;
				else if (tilemap[pw->tilex][pw->tiley+1]==0)
					pw->dir=south;
				else
					pw->dir=north;
				}
#endif
			ConnectPushWall(i);
			}
		}

//	fixup area if needed

	area = MAPSPOT(new.tilex,new.tiley,0)-AREATILE;
	if ((area<=0) || (area>NUMAREAS))
		{
		MAPSPOT (new.tilex, new.tiley, 0)=(word)(pw->areanumber+AREATILE);
		}

	pw->tilex=new.tilex;
	pw->tiley=new.tiley;
	pw->x=new.x;
	pw->y=new.y;
	pw->action=new.action;
	pw->dir=new.dir;
	pw->speed=new.speed;
	SetupPushWall(i);
	pw->state=new.state;

	pw->areanumber = MAPSPOT (pw->tilex, pw->tiley, 0)-AREATILE;

	if (pw->action==pw_pushed)
		{
		FinishPushWall (pw);
		}
	else if (pw->action==pw_npushed)
		{
		ResetPushWall (pw);
		}
	else
		{
		SetActorat(pw);
		}
	}
}





/*
=================
=
= SaveMaskedWalls
=
=================
*/
void SaveMaskedWalls(byte ** buf, int * size)
{
  int unitsize;
  maskedwallobj_t * mw;
  byte * bufptr;
  int i;
  int sz;

  if (maskednum==0)
	{
	*size=0;
	*buf=SafeMalloc(16);
	return;
	}
  mw=maskobjlist[0];
  unitsize=0;
  unitsize+=sizeof(mw->flags);

  *size=maskednum*unitsize;

  *buf=SafeMalloc(*size);
  bufptr=*buf;

  for (i=0;i<maskednum;i++)
	{
	mw=maskobjlist[i];
	sz=sizeof(mw->flags);
	memcpy(bufptr,&(mw->flags),sz);
	bufptr+=sz;
	}
}

/*
=================
=
= LoadMaskedWalls
=
=================
*/
void LoadMaskedWalls(byte * bufptr, int sz)
{
  int unitsize;
  maskedwallobj_t * mw;
  int i;
  int size;
  int num;

  if (sz==0)
	return;

  SetupMaskedWalls();
  FixMaskedWallAreaNumbers();

  mw=maskobjlist[0];
  unitsize=0;
  unitsize+=sizeof(mw->flags);

  num=sz/unitsize;
  if (maskednum!=num)
	Error("Different number of Masked Walls when trying to load a game\nmaskednum=%ld num=%ld",maskednum,num);

  for (i=0;i<maskednum;i++)
	{
	byte flags;

	mw=maskobjlist[i];
	size=sizeof(mw->flags);
	memcpy(&flags,bufptr,size);
	bufptr+=size;
	if (flags!=mw->flags)
		UpdateMaskedWall(i);
	if (mw->flags&MW_SWITCHON)
		mw->toptexture--;
	}
}


/*
=================
=
= SaveDoors
=
=================
*/

void SaveDoors (byte ** buf, int * size)
{
	int door;
	int doorsave;
	byte doorflag;
	byte doorlocked;
	signed char dooreindex;
	short int doortime;
	int unitsize;
	byte *ptr;

	if (doornum==0)
		{
		*size=0;
		*buf=SafeMalloc(16);
		return;
		}

	//
	// Size = (int + byte + byte) * numdoors
	//

	unitsize=0;
	unitsize+=sizeof(doorsave);
	unitsize+=sizeof(doorflag);
	unitsize+=sizeof(doorlocked);
	unitsize+=sizeof(doortime);
	unitsize+=sizeof(dooreindex);

	*size = unitsize*doornum;
	*buf = (byte *) SafeMalloc (*size);

	ptr = *buf;

	for (door = 0; door < doornum ; door++)
	{
		doorsave	= doorobjlist[door]->position & ~3;
		doorsave  |= doorobjlist[door]->action;
		doorflag	= doorobjlist[door]->flags;
		doorlocked = doorobjlist[door]->lock;
		doortime	= doorobjlist[door]->ticcount;
		dooreindex = doorobjlist[door]->eindex;

		memcpy (ptr, &doorsave, sizeof (doorsave));
		ptr += sizeof (doorsave);
		memcpy (ptr, &doorflag, sizeof (doorflag));
		ptr += sizeof (doorflag);
		memcpy (ptr, &doorlocked, sizeof (doorlocked));
		ptr += sizeof (doorlocked);
		memcpy (ptr, &doortime, sizeof (doortime));
		ptr += sizeof (doortime);
		memcpy (ptr, &dooreindex, sizeof (dooreindex));
		ptr += sizeof (dooreindex);
	}
}


/*
=================
=
= LoadDoors
=
=================
*/

void LoadDoors (byte * buf, int size)
{
	int door;
	int doorsave;
	byte doorflag;
	byte doorlocked;
	signed char dooreindex;
	short int doortime;
	byte *ptr;
	int unitsize;
	int num;

	SetupDoors ();
	FixDoorAreaNumbers();
	ptr  = buf;

	unitsize=0;
	unitsize+=sizeof(doorsave);
	unitsize+=sizeof(doorflag);
	unitsize+=sizeof(doorlocked);
	unitsize+=sizeof(doortime);
	unitsize+=sizeof(dooreindex);

	num=size/unitsize;
	if (doornum!=num)
		Error("Different number of Doors when trying to load a game\ndoornum=%ld num=%ld",doornum,num);

	for (door = 0; door < doornum; door++)
	{
		memcpy (&doorsave, ptr, sizeof (doorsave));
		ptr += sizeof (doorsave);
		memcpy (&doorflag, ptr, sizeof (doorflag));
		ptr += sizeof (doorflag);
		memcpy (&doorlocked, ptr, sizeof (doorlocked));
		ptr += sizeof (doorlocked);
		memcpy (&doortime, ptr, sizeof (doortime));
		ptr += sizeof (doortime);
		memcpy (&dooreindex, ptr, sizeof (dooreindex));
		ptr += sizeof (dooreindex);

		doorobjlist[door]->action	= doorsave & 3;

		// Update Areas

		if (doorobjlist[door]->action != dr_closed)
			DoorOpening(door);

		doorobjlist[door]->action	= doorsave & 3;
		doorobjlist[door]->position = doorsave;
		doorobjlist[door]->flags	= doorflag;
		doorobjlist[door]->lock		= doorlocked;
		doorobjlist[door]->ticcount  = doortime;
		doorobjlist[door]->eindex	= dooreindex;

		if (doorobjlist[door]->action == dr_open)
			doorobjlist[door]->position = 0xFFFF;

		else if (doorobjlist[door]->action == dr_closed)
			doorobjlist[door]->position = 0;

		if (
			(doorobjlist[door]->action == dr_closing) ||
			(doorobjlist[door]->action == dr_closed)
			)
			{
			actorat[doorobjlist[door]->tilex][doorobjlist[door]->tiley] = doorobjlist[door];
			}
		doorobjlist[door]->texture = doorobjlist[door]->basetexture +
											((doorobjlist[door]->position+1)>>13);
	}
}


/*
=====================
=
= SaveElevators
=
=
=====================
*/

void SaveElevators(byte ** buffer,int *size)
{int i;
 byte * tptr;

 *size = _numelevators*sizeof(elevator_t);

 *buffer = (byte *)SafeMalloc(*size);
 tptr = *buffer;

 for(i=0;i<_numelevators;i++)
  {memcpy(tptr,&ELEVATOR[i],sizeof(elevator_t));
	tptr += sizeof(elevator_t);
  }
}


/*
=====================
=
= LoadElevators
=
=
=====================
*/

void LoadElevators(byte * buffer,int size)
{int i;

 _numelevators = size/sizeof(elevator_t);


 for(i=0;i<_numelevators;i++)
  {memcpy(&ELEVATOR[i],buffer,sizeof(elevator_t));
	buffer += sizeof(elevator_t);
  }
}

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// RT_DRAW.C

#include "profile.h"
#include "rt_def.H"
#include <string.h>
// #include <DOS.H>
#include "watcom.h"
#include "sprites.h"
#include "rt_actor.h"
#include "rt_stat.h"
#include "rt_draw.h"
#include "_rt_draw.h"
#include "rt_dr_a.h"
#include "rt_fc_a.h"
#include "rt_scale.h"
#include "rt_floor.h"
#include "rt_main.h"
#include "rt_playr.h"
#include "rt_door.h"
#include "rt_ted.h"
#include "isr.h"
#include "rt_util.h"
#include "engine.h"
#include "z_zone.h"
#include "w_wad.h"
#include "lumpy.h"
#include "rt_menu.h"
#include "rt_game.h"
#include "rt_vid.h"
#include "rt_view.h"
#include <stdio.h>
#include <stdlib.h>
// #include <conio.h>
#include "rt_cfg.h"
#include "rt_str.h"
#include "develop.h"
#include "rt_sound.h"
#include "rt_msg.h"
#include "modexlib.h"
#include "rt_rand.h"
#include "rt_net.h"
#include "rt_sc_a.h"
//MED
// #include "memcheck.h"

/*
=============================================================================

Global Variables																																											GLOBAL VARIABLES

=============================================================================
*/

int whereami=-1;

byte * shadingtable;

word	tilemap[MAPSIZE][MAPSIZE]; // wall values only
byte	spotvis[MAPSIZE][MAPSIZE];
byte	mapseen[MAPSIZE][MAPSIZE];
unsigned long * lights;

// int			wstart;


int  dirangle8[9] = {0,FINEANGLES/8,2*FINEANGLES/8,3*FINEANGLES/8,4*FINEANGLES/8,
							5*FINEANGLES/8,6*FINEANGLES/8,7*FINEANGLES/8,8*FINEANGLES/8};

int  dirangle16[16] = {0,FINEANGLES/16,2*FINEANGLES/16,3*FINEANGLES/16,
							4*FINEANGLES/16,5*FINEANGLES/16,6*FINEANGLES/16,
							7*FINEANGLES/16,8*FINEANGLES/16,9*FINEANGLES/16,
							10*FINEANGLES/16,11*FINEANGLES/16,12*FINEANGLES/16,
							13*FINEANGLES/16,14*FINEANGLES/16,15*FINEANGLES/16};

//
// math tables
//

short	tantable[FINEANGLES];
fixed	sintable[FINEANGLES+FINEANGLEQUAD+1];
fixed	*costable = sintable+(FINEANGLES/4);

//
// refresh variables
//

fixed	viewx,viewy;																	// the focal point
int	viewangle;
int	c_startx, c_starty;
fixed	viewsin,viewcos;
int	tics;

//
// ray tracing variables
//

long	xintercept,yintercept;

int doublestep=0;
int hp_startfrac;
int hp_srcstep;

int levelheight;

int actortime=0;
int drawtime=0;

visobj_t vislist[MAXVISIBLE],*visptr,*visstep,*farthest;

int firstcoloffset=0;

/*
==================
=
= Local Variables
=
==================
*/
static int nonbobpheight;

static visobj_t * sortedvislist[MAXVISIBLE];

static fixed mindist = 0x1000;

static int walltime=0;

static int weaponbobx, weaponboby;

static int		pretics[3];
static int		preindex;
static int		netlump;
static int		gmasklump;

static int weaponshape[NUMWEAPGRAPHICS] =
	{
#if (SHAREWARE == 0)

		W_KNIFE,
#endif

		W_MALEPISTOL1,
		W_MRIGHTPISTOL1,
		W_MP40,
		W_BAZOOKA,
		W_HEATSEEKER,
		W_DRUNK,
		W_FIREBOMB,
		W_FIREWALL,
		W_GODHAND,


#if (SHAREWARE == 0)
		W_SPLIT,
		W_KES,
		W_BAT,
		W_DOG,
		W_FEMALEPISTOL1,
		W_BMALEPISTOL1
#endif
		};

void SetColorLightLevel (int x, int y, visobj_t * sprite, int dir, int color, int fullbright);

/*
==================
=
= BuildTables
=
==================
*/

void BuildTables (void)
{
  byte * table;
  byte * ptr;
  int	length;
  int	i;

//
// load in tables file
//

	table=W_CacheLumpName("tables",PU_STATIC);
	ptr=table;

//
// get size of first table
//

	memcpy(&length,ptr,sizeof(int));

//
// skip first table
//

	ptr+=(length+1)*sizeof(int);

//
// get size of sin/cos table
//

	memcpy(&length,ptr,sizeof(int));
	ptr+=sizeof(int);
//
// get sin/cos table
//
	memcpy(&sintable[0],ptr,length*sizeof(long));

	ptr+=(length)*sizeof(int);

//
// get size of tangent table
//

	memcpy(&length,ptr,sizeof(int));
	ptr+=sizeof(int);

//
// get tangent table
//
	memcpy(tantable,ptr,length*sizeof(short));

	ptr+=(length)*sizeof(short);

//
// get size of gamma table
//

	memcpy(&length,ptr,sizeof(int));
	ptr+=sizeof(int);

//
// get gamma table
//
	memcpy(&gammatable[0],ptr,length*sizeof(byte));
	table=W_CacheLumpName("tables",PU_CACHE);

	costable = (fixed *)&(sintable[FINEANGLES/4]);

//	wstart=W_GetNumForName("WALLSTRT");
#if (SHAREWARE==0)
	netlump=W_GetNumForName("net1");
#endif
	gmasklump=W_GetNumForName("p_gmask");

	preindex=0;
	pretics[0]=0x10000;
	pretics[2]=0x10000;
	pretics[1]=0x10000;

	for(i=0;i<ANGLES;i++)
	{angletodir[i] = (i + (ANGLES/16))/(ANGLES/8);
	if (angletodir[i] == 8)
		angletodir[i] = 0;
	}

	// Check out VENDOR.DOC file
//	CheckVendor();

	if (!quiet)
		printf("RT_DRAW: Tables Initialized\n");
}


/*
========================
=
= TransformObject
=
========================
*/

boolean TransformObject (int x, int y, int *dispx, int *dispheight)
{

  fixed gx,gy,gxt,gyt,nx,ny;


//
// translate point to view centered coordinates
//
  gx = x-viewx;
  gy = y-viewy;

//
// calculate newx
//
  gxt = FixedMul(gx,viewcos);
  gyt = FixedMul(gy,viewsin);
  nx = gxt-gyt;

  if (nx<MINZ)
	return false;

  // the midpoint could put parts of the shape
  // into an adjacent wall
  //
  // calculate newy
  //
  gxt = FixedMul(gx,viewsin);
  gyt = FixedMul(gy,viewcos);
  ny = gyt+gxt;


//
// calculate perspective ratio
//

  *dispx = centerx + ny*scale/nx;				// DEBUG: use assembly divide

  *dispheight = heightnumerator/nx;

  return true;
}


/*
========================
=
= TransformPoint
=
========================
*/

void TransformPoint (int x, int y, int * screenx, int * height, int * texture, int vertical)
{

  fixed gxt,gyt,nx,ny;
  fixed gxtt,gytt;
  int gx,gy;
  int vx,vy;
  int svs,svc;


//
// translate point to view centered coordinates
//
  gx = x-viewx;
  gy = y-viewy;

//
// calculate newx
//
  gxt = FixedMul(gx,viewcos);
  gyt = FixedMul(gy,viewsin);
  nx =gxt-gyt;

  if (nx<10)
	nx=10;


//
// calculate newy
//
  gxtt = FixedMul(gx,viewsin);
  gytt = FixedMul(gy,viewcos);
  ny = gytt+gxtt;

// too close, don't overflow the divid'


  *screenx = centerx + ((ny*scale)/nx);				// DEBUG: use assembly divide

  *height = heightnumerator/nx;


  if (*screenx<0)
	{
	svc=(-centerx)*viewcos;
	svs=(-centerx)*viewsin;
	vx=(scale*viewcos)+svs;
	vy=(-scale*viewsin)+svc;
	if (vertical)
		{
		if ((viewcos-viewsin)==0)
			{
			*height=20000<<HEIGHTFRACTION;
			return;
			}
		gy=FixedScale(gx,vy,vx);
		y=gy+viewy;
		gyt = FixedMul(gy,viewsin);
		nx =gxt-gyt;
		if (nx<10)
			nx=10;
		*screenx = 0;
		*height = heightnumerator/nx;
		}
	else
		{
		if ((-viewsin-viewcos)==0)
			{
			*height=20000<<HEIGHTFRACTION;
			return;
			}
		gx=FixedScale(gy,vx,vy);
		x=gx+viewx;
		gxt = FixedMul(gx,viewcos);
		nx =gxt-gyt;
		if (nx<10)
			nx=10;
		*screenx = 0;
		*height = heightnumerator/nx;
		}
	}
  else if (*screenx>=viewwidth)
	{
	svc=(centerx)*viewcos;
	svs=(centerx)*viewsin;
	vx=(scale*viewcos)+svs;
	vy=(-scale*viewsin)+svc;
	if (vertical)
		{
		if ((viewcos+viewsin)==0)
			{
			*height=20000<<HEIGHTFRACTION;
			return;
			}
		gy=FixedScale(gx,vy,vx);
		y=gy+viewy;
		gyt = FixedMul(gy,viewsin);
		nx =gxt-gyt;
		if (nx<10)
			nx=10;
		*screenx = viewwidth-1;
		*height = heightnumerator/nx;
		}
	else
		{
		if ((-viewsin+viewcos)==0)
			{
			*height=20000<<HEIGHTFRACTION;
			return;
			}
		gx=FixedScale(gy,vx,vy);
		x=gx+viewx;
		gxt = FixedMul(gx,viewcos);
		nx =gxt-gyt;
		if (nx<10)
			nx=10;
		*screenx = viewwidth-1;
		*height = heightnumerator/nx;
		}
	}
  if (vertical)
	*texture=(y-*texture)&0xffff;
  else
	*texture=(x-*texture)&0xffff;
}

/*
========================
=
= TransformSimplePoint
=
========================
*/

boolean TransformSimplePoint (int x, int y, int * screenx, int * height, int * texture, int vertical)
{

  fixed gxt,gyt,nx,ny;
  fixed gxtt,gytt;
  int gx,gy;


//
// translate point to view centered coordinates
//
  gx = x-viewx;
  gy = y-viewy;

//
// calculate newx
//
  gxt = FixedMul(gx,viewcos);
  gyt = FixedMul(gy,viewsin);
  nx =gxt-gyt;

  if (nx<MINZ)
	return false;


//
// calculate newy
//
  gxtt = FixedMul(gx,viewsin);
  gytt = FixedMul(gy,viewcos);
  ny = gytt+gxtt;

// too close, don't overflow the divid'


  *screenx = centerx + ((ny*scale)/nx);				// DEBUG: use assembly divide

  *height = heightnumerator/nx;

  if (vertical)
	*texture=(y-*texture)&0xffff;
  else
	*texture=(x-*texture)&0xffff;

  return true;
}


/*
========================
=
= TransformPlane
=
========================
*/

boolean TransformPlane (int x1, int y1, int x2, int y2, visobj_t * plane)
{
  boolean result2;
  boolean result1;
  boolean vertical;
  int txstart,txend;

  vertical=((x2-x1)==0);
  plane->viewx=vertical;
  txstart=plane->texturestart;
  txend=plane->textureend;
  result1=TransformSimplePoint(x1,y1,&(plane->x1),&(plane->h1),&(plane->texturestart),vertical);
  result2=TransformSimplePoint(x2,y2,&(plane->x2),&(plane->h2),&(plane->textureend),vertical);
  if (result1==true)
	{
	if (plane->x1>=viewwidth)
		return false;
	if (result2==false)
		{
		plane->textureend=txend;
		TransformPoint(x2,y2,&(plane->x2),&(plane->h2),&(plane->textureend),vertical);
		}
	}
  else
	{
	if (result2==false)
		return false;
	else
		{
		if (plane->x2<0)
			return false;
		plane->texturestart=txstart;
		TransformPoint(x1,y1,&(plane->x1),&(plane->h1),&(plane->texturestart),vertical);
		}
	}
  if (plane->x1<0)
	{
	plane->texturestart=txstart;
	TransformPoint(x1,y1,&(plane->x1),&(plane->h1),&(plane->texturestart),vertical);
	}
  if (plane->x2>=viewwidth)
	{
	plane->textureend=txend;
	TransformPoint(x2,y2,&(plane->x2),&(plane->h2),&(plane->textureend),vertical);
	}

  plane->viewheight=(plane->h1+plane->h2)>>1;

  if ((plane->viewheight>=(2000<<HEIGHTFRACTION)) || (plane->x1>=viewwidth-1) || (plane->x2<=0))
	return false;

  return true;
}

//==========================================================================

/*
====================
=
= CalcHeight
=
= Calculates the height of xintercept,yintercept from viewx,viewy
=
====================
*/

int		CalcHeight (void)
{
		fixed  gxt,gyt,nx;
	long				gx,gy;

	whereami=0;

	gx = xintercept-viewx;
	gxt = FixedMul(gx,viewcos);

	gy = yintercept-viewy;
	gyt = FixedMul(gy,viewsin);

	nx = gxt-gyt;

	if(nx<0)
		return(0);

	if (nx<mindist)
		nx=mindist; // don't let divide overflo'

	return (heightnumerator/nx);
}



#if 0
//==========================================================================

//******************************************************************************
//
// NextPlaneptr
//
//******************************************************************************

void NextPlaneptr ( void )
{
	if (planeptr < &planelist[MAXPLANES-1]) // don't let it overflo'
  		planeptr++;
}

//******************************************************************************
//
// RestPlaneptr
//
//******************************************************************************

void ResetPlaneptr ( void )
{
	planeptr = &planelist[0];
}

//******************************************************************************
//
// NextVisptr
//
//******************************************************************************

void NextVisptr ( void )
{
	if (visptr < &vislist[MAXVISIBLE-1]) // don't let it overflo'
  		visptr++;
}

//******************************************************************************
//
// ResetVisptr
//
//******************************************************************************

void ResetVisptr ( void )
{
	visptr = &vislist[0];
}

#endif

//==========================================================================



/*
=====================
=
= StatRotate
=
=====================
*/

int  StatRotate (statobj_t *temp)
{
	int	angle;
	int	dx,dy;

	whereami=2;

	dx = temp->x - player->x;
	dy = player->y - temp->y;
	angle = atan2_appx(dx,dy);

	angle = angle-VANG180-dirangle8[temp->count];
	angle+=ANGLES/16;
	while (angle>=ANGLES)
		angle-=ANGLES;
	while (angle<0)
		angle+=ANGLES;

	return angle/(ANGLES/8);

}




/*
=====================
=
= CalcRotate
=
=====================
*/

int	CalcRotate (objtype *ob)
{
	int	angle,viewangle;
	int	dx,dy;
	int	rotation;

	whereami=1;

	// this isn't exactly correct, as it should vary by a trig value'
	// but it is close enough with only eight rotations
	/*
	if (ob->obclass == b_robobossobj)
		viewangle = player->angle;
	else
		viewangle = player->angle + (centerx - ob->viewx)/8;*/
	dx = ob->x - player->x;
	dy = player->y - ob->y;
	viewangle = atan2_appx(dx,dy);

	if ((ob->obclass >= p_bazookaobj) || (ob->obclass == missileobj))
	{angle = viewangle - ob->angle;
		#if (0)
		Debug("\nviewangle: %d, angle: %d",viewangle,angle);
		#endif
	}
	else if ((ob->obclass > wallopobj) && (ob->obclass != b_darksnakeobj))
		angle =  (viewangle-ANG180)- ob->angle;
	else if (ob->state->rotate == 16)
		angle =  (viewangle-ANG180)- dirangle16[ob->dir];
	else
		angle =  (viewangle-ANG180)- dirangle8[ob->dir];

	if (ob->state->rotate == true)
	angle += ANGLES/16;
	else if (ob->state->rotate == 16)
	angle += ANGLES/32;

	while (angle>=ANGLES)
		angle-=ANGLES;
	while (angle<0)
		angle+=ANGLES;

	if (ob->state->rotate == 2)		// 2 rotation pain frame
		{rotation = 4*(angle/(ANG180));
		return rotation;
		}

	if (ob->state->rotate == 16)
	{rotation = angle/(ANGLES/16);
		#if (0)
		Debug("\nrotation: %d", rotation);
		#endif
		return rotation;
	}
	rotation = angle/(ANGLES/8);
	return rotation;

}



#if 0
/*
=====================
=
= DrawMaskedWalls
=
=====================
*/

void DrawMaskedWalls (void)
{


  int	i,numvisible;
  int	gx,gy;
  unsigned short int  *tilespot;
  byte	*visspot;
  boolean result;
  statobj_t *statptr;
  objtype	*obj;
  maskedwallobj_t* tmwall;

	whereami=6;

//
// place maskwall objects
//
  for(tmwall=FIRSTMASKEDWALL;tmwall;tmwall=tmwall->next)
	{
	if (spotvis[tmwall->tilex][tmwall->tiley])
		{
		mapseen[tmwall->tilex][tmwall->tiley]=1;
		if (tmwall->vertical)
			{
			gx=(tmwall->tilex<<16)+0x8000;
			gy=(tmwall->tiley<<16);
			visptr->texturestart=0;
			visptr->textureend=0;
			if (viewx<gx)
				result=TransformPlane(gx,gy,gx,gy+0xffff,visptr);
			else
				result=TransformPlane(gx,gy+0xffff,gx,gy,visptr);
			visptr->shapenum=tmwall->bottomtexture;
			visptr->altshapenum=tmwall->midtexture;
			visptr->viewx=tmwall->toptexture;
			visptr->shapesize=2;
			}
		else
			{
			gx=(tmwall->tilex<<16);
			gy=(tmwall->tiley<<16)+0x8000;
			visptr->texturestart=0;
			visptr->textureend=0;
			if (viewy<gy)
				result=TransformPlane(gx+0xffff,gy,gx,gy,visptr);
			else
				result=TransformPlane(gx,gy,gx+0xffff,gy,visptr);
			visptr->shapenum=tmwall->bottomtexture;
			visptr->altshapenum=tmwall->midtexture;
			visptr->viewx=tmwall->toptexture;
			visptr->shapesize=2;
			}
		if ((tmwall->flags&MW_TOPFLIPPING) &&
				(nonbobpheight>64)
			)
			{
			visptr->viewx++;
			}
		else if ((tmwall->flags&MW_BOTTOMFLIPPING) &&
					(nonbobpheight>maxheight-32)
					)
			{
			visptr->shapenum++;
			}
		if ((visptr < &vislist[MAXVISIBLE-1]) && (result==true)) // don't let it overflo'
			visptr++;
		}
	}
}
#endif

/*
======================
=
= SortScaleds
= Sort the scaleds using a HEAPSORT
=
======================
*/

#define SGN(x)			((x>0) ? (1) : ((x==0) ? (0) : (-1)))

/*--------------------------------------------------------------------------*/
int CompareHeights(s1p,s2p) visobj_t **s1p,**s2p;
{
	whereami=3;
	return SGN((*s1p)->viewheight-(*s2p)->viewheight);
}

void SwitchPointers(s1p,s2p) visobj_t **s1p,**s2p;
{
	visobj_t * temp;

	whereami=4;
	temp=*s1p;
	*s1p=*s2p;
	*s2p=temp;
}


void SortVisibleList( int numvisible, visobj_t * vlist )
{
	int i;

	whereami=5;
	for (i=0;i<numvisible;i++)
		sortedvislist[i]=&(vlist[i]);
	hsort((char *)&(sortedvislist[0]),numvisible,sizeof(visobj_t *),&CompareHeights,&SwitchPointers);
}

/*
=====================
=
= DrawScaleds
=
= Draws all objects that are visible
=
=====================
*/

#define HF_1 (24)
#define HF_2 (72)

void DrawScaleds (void)
{


  int	i,numvisible;
  int	gx,gy;
  unsigned short int  *tilespot;
  byte	*visspot;
  boolean result;
  statobj_t *statptr;
  objtype	*obj;
  maskedwallobj_t* tmwall;

	whereami=6;

//
// place maskwall objects
//
  for(tmwall=FIRSTMASKEDWALL;tmwall;tmwall=tmwall->next)
	{
	if (spotvis[tmwall->tilex][tmwall->tiley])
		{
		mapseen[tmwall->tilex][tmwall->tiley]=1;
		if (tmwall->vertical)
			{
			gx=(tmwall->tilex<<16)+0x8000;
			gy=(tmwall->tiley<<16);
			visptr->texturestart=0;
			visptr->textureend=0;
			if (viewx<gx)
				result=TransformPlane(gx,gy,gx,gy+0xffff,visptr);
			else
				result=TransformPlane(gx,gy+0xffff,gx,gy,visptr);
			visptr->shapenum=tmwall->bottomtexture;
			visptr->altshapenum=tmwall->midtexture;
			visptr->viewx=tmwall->toptexture;
			visptr->shapesize=2;
			}
		else
			{
			gx=(tmwall->tilex<<16);
			gy=(tmwall->tiley<<16)+0x8000;
			visptr->texturestart=0;
			visptr->textureend=0;
			if (viewy<gy)
				result=TransformPlane(gx+0xffff,gy,gx,gy,visptr);
			else
				result=TransformPlane(gx,gy,gx+0xffff,gy,visptr);
			visptr->shapenum=tmwall->bottomtexture;
			visptr->altshapenum=tmwall->midtexture;
			visptr->viewx=tmwall->toptexture;
			visptr->shapesize=2;
			}
		if ((tmwall->flags&MW_TOPFLIPPING) &&
				(nonbobpheight>64)
			)
			{
			visptr->viewx++;
			}
		else if ((tmwall->flags&MW_BOTTOMFLIPPING) &&
					(nonbobpheight>maxheight-32)
					)
			{
			visptr->shapenum++;
			}
		if ((visptr < &vislist[MAXVISIBLE-1]) && (result==true)) // don't let it overflo'
			visptr++;
		}
	}
//
// place static objects
//
  UpdateClientControls();
  for (statptr = firstactivestat ; statptr; statptr=statptr->nextactive)
  {  //redraw:
			if((visptr->shapenum = statptr->shapenum) == NOTHING)
				continue;

			visptr->shapenum += shapestart;
			if ((visptr->shapenum <= shapestart) ||
				(visptr->shapenum >= shapestop))
			Error("actor shapenum %d out of range (%d-%d)",visptr->shapenum,shapestart,shapestop);

			visspot = statptr->visspot;
			if (!((*(visspot-0)) ||
					(*(visspot-1)) ||
					(*(visspot+1)) ||
					(*(visspot-129)) ||
					(*(visspot-128)) ||
					(*(visspot-127)) ||
					(*(visspot+129)) ||
					(*(visspot+128)) ||
					(*(visspot+127))))
					{statptr->flags &= ~FL_VISIBLE;
					continue;	// not visible
					}

			result = TransformObject (statptr->x,statptr->y,&(visptr->viewx),&(visptr->viewheight));

			if ((result==false) || (visptr->viewheight< (1<<(HEIGHTFRACTION+2))))
				continue;								// to close to the object
			statptr->flags |= FL_SEEN;

			statptr->flags |= FL_VISIBLE;

			if (statptr->flags & FL_ROTATING)
				visptr->shapenum += StatRotate(statptr);

			if (statptr->flags&FL_TRANSLUCENT)
				{
				visptr->shapesize=1;
				if (statptr->flags&FL_FADING)
					visptr->h2=transparentlevel;
				else
					visptr->h2=FIXEDTRANSLEVEL;
				SetSpriteLightLevel(statptr->x,statptr->y,visptr,0,(statptr->flags&FL_FULLLIGHT));
				}
			else if (statptr->flags&FL_SOLIDCOLOR)
				{
				visptr->shapesize=4;
				visptr->h2=statptr->hitpoints;
				}
			else if (statptr->flags&FL_COLORED)
				{
				visptr->shapesize=0;
#if (DEVELOPMENT == 1)
				if ((statptr->hitpoints>=0) &&
					(statptr->hitpoints<MAXPLAYERCOLORS))
					{
#endif
					SetColorLightLevel(statptr->x,statptr->y,visptr,
											0,statptr->hitpoints,
											(statptr->flags&FL_FULLLIGHT));
#if (DEVELOPMENT == 1)
					}
				else
					{
					Error("Illegal color map for sprite type %d\n",statptr->itemnumber);
					}
#endif
				}
			else
				{
				visptr->shapesize=0;
				SetSpriteLightLevel(statptr->x,statptr->y,visptr,0,(statptr->flags&FL_FULLLIGHT));
				}

			visptr->h1=pheight-statptr->z;

			if ((statptr->itemnumber != -1) &&
				(statptr->flags&FL_HEIGHTFLIPPABLE)
				)
				{
				if (statptr->itemnumber==stat_disk)
					{
					int value;
					value=nonbobpheight-statptr->z-32;
					if ((value<=HF_2) && (value>HF_1))
						{
						visptr->shapenum++;
						}
					else if ((value<=HF_1) && (value>=-HF_1))
						{
						visptr->shapenum+=2;
						}
					else if ((value<-HF_1) && (value>=-HF_2))
						{
						visptr->shapenum+=3;
						}
					else if (value<-HF_2)
						{
						visptr->shapenum+=4;
						}
					}
				else if ((nonbobpheight-statptr->z)<-16)
					{
					visptr->shapenum++;
					}
				}

			if (visptr < &vislist[MAXVISIBLE-1]) // don't let it overflo'
				visptr++;


  }
//
// place active objects
//
  UpdateClientControls();
  for (obj = firstactive;obj;obj=obj->nextactive)
	{
	if (obj==player)
		continue;

	if ((visptr->shapenum = obj->shapenum) == NOTHING)
		continue;								// no shape

	visptr->shapenum += shapestart;
	if ((visptr->shapenum <= shapestart) ||
				(visptr->shapenum >= shapestop))
		Error("actor shapenum %d out of range (%d-%d)",visptr->shapenum,shapestart,shapestop);
	visspot = &spotvis[obj->tilex][obj->tiley];
	tilespot = &tilemap[obj->tilex][obj->tiley];

	//
	// could be in any of the nine surrounding tiles
	//
	if (*visspot
		|| ( *(visspot-1))
		|| ( *(visspot+1))
		|| ( *(visspot-129))
		|| ( *(visspot-128))
		|| ( *(visspot-127))
		|| ( *(visspot+129))
		|| ( *(visspot+128))
		|| ( *(visspot+127)) )
		{

//		result = TransformObject (obj->drawx, obj->drawy,&(visptr->viewx),&(visptr->viewheight));
		result = TransformObject (obj->x, obj->y,&(visptr->viewx),&(visptr->viewheight));
		if ((result==false) || (visptr->viewheight< (1<<(HEIGHTFRACTION+2))))
			continue;								// to close to the object
		if (obj->state->rotate)
			visptr->shapenum += CalcRotate (obj);

		visptr->shapesize=0;

		if (player->flags&FL_SHROOMS)
			{
			visptr->shapesize=4;
			visptr->h2=(ticcount&0xff);
			}
		if (obj->obclass==playerobj)
			{
			if (obj->flags&FL_GODMODE)
				{
				visptr->shapesize=4;
				visptr->h2=240+(ticcount&0x7);
				}
			else if (obj->flags & FL_COLORED)
				{
				playertype *pstate;

				M_LINKSTATE(obj,pstate);
#if (DEVELOPMENT == 1)
				if ((pstate->uniformcolor>=0) &&
					(pstate->uniformcolor<MAXPLAYERCOLORS))
					{
#endif
					SetColorLightLevel(obj->x,obj->y,visptr,
												obj->dir,pstate->uniformcolor,
												(obj->flags&FL_FULLLIGHT) );
#if (DEVELOPMENT == 1)
					}
				else
					{
					Error("Illegal color map for players\n");
					}
#endif
				}
			else
				SetSpriteLightLevel(obj->x,obj->y,visptr,obj->dir,(obj->flags&FL_FULLLIGHT));

			}
		else
			{
			if ((obj->obclass >= b_darianobj) && (obj->obclass <= b_robobossobj) &&
				MISCVARS->redindex)
				{
				visptr->colormap=redmap+((MISCVARS->redindex-1)<<8);
				}
			else
				{
				SetSpriteLightLevel(obj->x,obj->y,visptr,obj->dir,(obj->flags&FL_FULLLIGHT));
				}
			}

		visptr->h1= pheight - obj->z;

		if (obj->obclass==diskobj)
			{
			int value;
			value=nonbobpheight-obj->z-32;
			if ((value<=HF_2) && (value>HF_1))
				{
				visptr->shapenum++;
				}
			else if ((value<=HF_1) && (value>=-HF_1))
				{
				visptr->shapenum+=2;
				}
			else if ((value<-HF_1) && (value>=-HF_2))
				{
				visptr->shapenum+=3;
				}
			else if (value<-HF_2)
				{
				visptr->shapenum+=4;
				}
			}
		else if ( (obj->obclass==pillarobj) &&
						((nonbobpheight-obj->z)<-16)
					)
			{
			visptr->shapenum++;
			}

		if (visptr < &vislist[MAXVISIBLE-1]) // don't let it overflo'
			visptr++;
		obj->flags |= FL_SEEN;
		obj->flags |= FL_VISIBLE;
		}
	else
		obj->flags &= ~FL_VISIBLE;
	}
//
// draw from back to front
//
	numvisible = visptr-&vislist[0];
	if (!numvisible)
		return;												// no visible objects
	SortVisibleList( numvisible, &vislist[0] );
	UpdateClientControls();
	for (i = 0; i<numvisible; i++)
		{
		//
		// draw farthest
		//

		if (sortedvislist[i]->shapesize==4)

			ScaleSolidShape(sortedvislist[i]);

		else if (sortedvislist[i]->shapesize==3)

			InterpolateDoor (sortedvislist[i]);

		else if (sortedvislist[i]->shapesize==2)

			InterpolateMaskedWall (sortedvislist[i]);

		else if (sortedvislist[i]->shapesize==1)

			ScaleTransparentShape(sortedvislist[i]);

		else

			ScaleShape(sortedvislist[i]);

		}
}

//==========================================================================





/*
==============
=
= DrawPlayerWeapon
=
= Draw the player's hand'
=
==============
*/

void DrawPlayerWeapon (void)
{
 int shapenum,index;
 int xdisp=0;
 int ydisp=0;
 int female,black;
 int altshape=0;

	whereami=7;

 SoftError("\n attackframe: %d, weaponframe: %d, weapondowntics: %d"
			" weaponuptics: %d",locplayerstate->attackframe,
			locplayerstate->weaponframe,locplayerstate->weapondowntics,
			locplayerstate->weaponuptics);

 if ((locplayerstate->NETCAPTURED == 1) && (!locplayerstate->HASKNIFE))
  return;

 if (locplayerstate->weapon != -1)
  {female = ((locplayerstate->player == 1) || (locplayerstate->player == 3));
	black = (locplayerstate->player == 2);

	if (((locplayerstate->NETCAPTURED >= 1) || (locplayerstate->NETCAPTURED == -2)) && (locplayerstate->HASKNIFE == 1)) // if raising or lowering
		{index = 0;
		shapenum = gunsstart + weaponshape[index] + locplayerstate->weaponframe;
		}
	else if  (locplayerstate->weapon != wp_twopistol)
		{if (locplayerstate->weapon==wp_pistol)
			{if (female)
			index = NUMWEAPGRAPHICS-2;
			else if (black)
			index = NUMWEAPGRAPHICS-1;
			else
#if (SHAREWARE == 0)
			index = 1;
#else
			index = 0;
#endif
			}
		else
#if (SHAREWARE == 0)

			index = locplayerstate->weapon + 1;
#else
			index = locplayerstate->weapon;
#endif

		if ((index<0) || (index>=NUMWEAPGRAPHICS))
			Error ("Weapon shapenum out of range\n");
		shapenum = gunsstart + weaponshape[index] + locplayerstate->weaponframe;

#if (SHAREWARE == 0)
		if ((shapenum < W_GetNumForName("KNIFE1")) ||
				(shapenum > W_GetNumForName("DOGPAW4"))
			)
#else
		if ((shapenum < W_GetNumForName("MPIST11")) ||
				(shapenum > W_GetNumForName("GODHAND8"))
			)
#endif
			Error("\n illegal weapon shapenum %d, index %d, weaponframe %d",
						shapenum,index,locplayerstate->weaponframe);
		}

	else
	{
#if (SHAREWARE == 0)
	if (female)
		{altshape = W_FLEFTPISTOL1;
		shapenum = W_FRIGHTPISTOL1;
		}
	else if (black)
		{altshape = W_BMLEFTPISTOL1;
		shapenum = W_BMRIGHTPISTOL1;
		}
	else
#endif
		{altshape = W_MLEFTPISTOL1;
		shapenum = W_MRIGHTPISTOL1;
		}

	altshape += gunsstart;
	shapenum += gunsstart;
	if (locplayerstate->weaponframe > 2)
			altshape += (locplayerstate->weaponframe - 3);
	else
			shapenum += locplayerstate->weaponframe;
	}

	if (!(locplayerstate->NETCAPTURED) ||
		(locplayerstate->NETCAPTURED == -1) ||
		(locplayerstate->HASKNIFE == 0))
	{switch (locplayerstate->weapon)
		{

		case wp_godhand:
			break;

		case wp_mp40:
			break;

		case wp_firewall:
			ydisp = 10;
			break;

		case wp_bazooka:
			break;

		case wp_heatseeker:
			ydisp = 20;
			break;

		case wp_pistol:
			break;

		case wp_twopistol:
			xdisp = 80;
			break;

		case wp_drunk:
			ydisp = 10;
			break;

		case wp_firebomb:
			break;



#if (SHAREWARE == 0)

		case wp_kes:
			break;

		case wp_bat:
			xdisp = 20;
			break;

		case wp_split:
			ydisp = 20;
			break;


		case wp_dog:
			break;


#endif

		default:
			Error("Illegal weapon value = %ld\n",locplayerstate->weapon);
			break;
		}
	}
  else
	xdisp = 60;




  if (altshape)
	{
	int temp;
	int delta;

	temp = weaponscale;
	delta = FixedMul((weaponbobx<<9),weaponscale);
	weaponscale += delta;
	ScaleWeapon(xdisp - weaponbobx,ydisp + weaponboby + locplayerstate->weaponheight,shapenum);
	weaponscale -= delta;
	ScaleWeapon(weaponbobx - 80,ydisp + weaponboby + locplayerstate->weaponheight,altshape);
	weaponscale = temp;
	}
  else
	{
	int temp;
	int delta;

	temp = weaponscale;
	delta = FixedMul((weaponbobx<<9),weaponscale);
	weaponscale -= delta;
	ScaleWeapon(xdisp + weaponbobx,ydisp + weaponboby + locplayerstate->weaponheight,shapenum);
	weaponscale = temp;
	}
  }
}

void AdaptDetail ( void )
{
#if PROFILE
	return;
#else

	whereami=8;
	if ((preindex<0) || (preindex>2))
		Error("preindex out of range\n");
	pretics[preindex]=(pretics[0]+pretics[1]+pretics[2]+(tics<<16)+0x8000)>>2;
	if (pretics[preindex]>GOLOWER)
		{
		pretics[0]=GOHIGHER;
		pretics[1]=GOHIGHER;
		pretics[2]=GOHIGHER;
		doublestep++;
		if (doublestep>2) doublestep=2;
		}
	else if (pretics[preindex]<GOHIGHER)
		{
		if (doublestep>0)
			doublestep--;
		}
	preindex++;
	if (preindex>2)
		preindex=0;
#endif
}



/*
=====================
=
= CalcTics
=
=====================
*/

void CalcTics (void)
{

#if PROFILE
	tics=PROFILETICS;
	ticcount+=PROFILETICS;
	oldtime=ticcount;
	return;
#else
#if (DEVELOPMENT == 1)
	int i;
#endif
	volatile int tc;

	whereami=9;
//	SoftError("InCalcTics\n");
//	SoftError("CT ticcount=%ld\n",ticcount);
//	SoftError("CT oldtime=%ld\n",oldtime);

//
// calculate tics since last refresh for adaptive timing
//

	I_PollTimer();
	tc=ticcount;
	while (tc==oldtime)
	{
		I_PollTimer();
		tc=ticcount;
	} /* endwhile */
	tics=tc-oldtime;

//	SoftError("CT ticcount=%ld\n",ticcount);
//	if (tics>MAXTICS)
//		{
//		tc-=(tics-MAXTICS);
//		ticcount = tc;
//	tics = MAXTICS;
//		}

	if (demoplayback || demorecord)
		{
		if (tics>MAXTICS)
			{
			tc=oldtime+MAXTICS;
			tics=MAXTICS;
			ISR_SetTime(tc);
			}
		}
	oldtime=tc;
#if (DEVELOPMENT == 1)
	if (graphicsmode==true)
		{
		int drawntics;

		VGAWRITEMAP(1);
		drawntics=tics;
		if (drawntics>MAXDRAWNTICS)
			drawntics=MAXDRAWNTICS;
		for (i=0;i<drawntics;i++)
			*((byte *)displayofs+screenofs+(SCREENBWIDE*3)+i)=egacolor[15];
		}
/*
		if (drawtime>MAXDRAWNTICS)
			drawtime=MAXDRAWNTICS;
		for (i=0;i<drawtime;i++)
			*((byte *)displayofs+screenofs+(SCREENBWIDE*5)+i)=egacolor[2];
		if (walltime>MAXDRAWNTICS)
			walltime=MAXDRAWNTICS;
		for (i=0;i<walltime;i++)
			*((byte *)displayofs+screenofs+(SCREENBWIDE*7)+i)=egacolor[14];
		if (actortime>MAXDRAWNTICS)
			actortime=MAXDRAWNTICS;
		for (i=0;i<actortime;i++)
			*((byte *)displayofs+screenofs+(SCREENBWIDE*9)+i)=egacolor[4];
		}
*/
#endif
#endif

}

/*
==========================
=
= SetSpriteLightLevel
=
==========================
*/

void SetSpriteLightLevel (int x, int y, visobj_t * sprite, int dir, int fullbright)
{
	int i;
	int lv;
	int intercept;

	whereami=10;

	if (MISCVARS->GASON==1)
		{
		sprite->colormap=greenmap+(MISCVARS->gasindex<<8);
		return;
		}

	if (fulllight || fullbright)
		{
		sprite->colormap=colormap+(1<<12);
		return;
		}

	if (fog)
		{
		i=(sprite->viewheight>>normalshade)+minshade;
		if (i>maxshade) i=maxshade;
		sprite->colormap=colormap+(i<<8);
		}
	else
		{
		if (lightsource)
			{
			if (dir==east || dir==west)
				intercept=(x>>11)&0x1c;
			else
				intercept=(y>>11)&0x1c;

			lv=(((LightSourceAt(x>>16,y>>16)>>intercept)&0xf)>>1);
			i=maxshade-(sprite->viewheight>>normalshade)-lv;
			if (i<minshade) i=minshade;
			sprite->colormap=colormap+(i<<8);
			}
		else
			{
			i=maxshade-(sprite->viewheight>>normalshade);
			if (i<minshade) i=minshade;
			sprite->colormap=colormap+(i<<8);
			}
		}
}

/*
==========================
=
= SetColorLightLevel
=
==========================
*/

void SetColorLightLevel (int x, int y, visobj_t * sprite, int dir, int color, int fullbright)
{
	int i;
	int lv;
	int intercept;
	int height;
	byte * map;


	whereami=11;
	height=sprite->viewheight<<1;
	map=playermaps[color];
	if (MISCVARS->GASON==1)
		{
		sprite->colormap=greenmap+(MISCVARS->gasindex<<8);
		return;
		}

	if ((fulllight) || (fullbright))
		{
		sprite->colormap=map+(1<<12);
		return;
		}

	if (fog)
		{
		i=(height>>normalshade)+minshade;
		if (i>maxshade) i=maxshade;
		sprite->colormap=map+(i<<8);
		}
	else
		{
		if (lightsource)
			{
			if (dir==east || dir==west)
				intercept=(x>>11)&0x1c;
			else
				intercept=(y>>11)&0x1c;

			lv=(((LightSourceAt(x>>16,y>>16)>>intercept)&0xf)>>1);
			i=maxshade-(height>>normalshade)-lv;
			if (i<minshade) i=minshade;
			sprite->colormap=map+(i<<8);
			}
		else
			{
			i=maxshade-(height>>normalshade);
			if (i<minshade) i=minshade;
			sprite->colormap=map+(i<<8);
			}
		}
}

/*
==========================
=
= SetWallLightLevel
=
==========================
*/

void SetWallLightLevel (wallcast_t * post)
{
	int la;
	int lv;
	int i;

	whereami=12;
	if (MISCVARS->GASON==1)
		{
		shadingtable=greenmap+(MISCVARS->gasindex<<8);
		return;
		}

	switch (post->posttype)
		{
		case 0:
			la=0;
			break;
		case 1:
			la=4;
			break;
		case 2:
			la=(4-gamestate.difficulty);
			break;
		case 3:
			la=3+(4-gamestate.difficulty);
			break;
		}

	if (lightsource)
		{
		int x,y;
		int intercept;

		x=post->offset>>7;
		y=post->offset&0x7f;
		intercept=(post->texture>>11)&0x1c;
		lv=(((LightSourceAt(x,y)>>intercept)&0xf)>>1);
		}
	else
		lv=0;
	if (fulllight)
		{
		if (fog)
			{
			i =16+minshade-lv+la;
			if (i>maxshade+la) i=maxshade+la;
			shadingtable=colormap+(i<<8);
			}
		else
			{
			i =maxshade-16-lv+la;
			if (i>=maxshade) i=maxshade;
			if (i<minshade+la) i=minshade+la;
			shadingtable=colormap+(i<<8);
			}
		return;
		}
	if (fog)
		{
		i =(post->wallheight>>normalshade)+minshade-lv+la;
		if (i>maxshade+la) i=maxshade+la;
		shadingtable=colormap+(i<<8);
		}
	else
		{
		i =maxshade-(post->wallheight>>normalshade)-lv+la;
		if (i>=maxshade) i=maxshade;
		if (i<minshade+la) i=minshade+la;
		shadingtable=colormap+(i<<8);
		}
}



/*
====================
=
= DrawWallPost
=
====================
*/

// void DrawWallPost ( wallcast_t * post, byte * buf)
void DrawWallPost ( wallcast_t * post, unsigned buf)
{
	int ht;
	int topscreen;
	int bottomscreen;
	byte * src;
	byte * src2;

	whereami=42;
	if (post->lump)
//		src=W_CacheLumpNum(post->lump,PU_CACHE);
		src=W_CacheWallLumpNum(post->lump,PU_CACHE);
	if (post->alttile!=0)
		{
		if (post->alttile==-1)
			{
			ht=maxheight+32;
			dc_invscale	= post->wallheight<<(10-HEIGHTFRACTION);
			dc_texturemid = (pheight<<SFRACBITS)+(SFRACUNIT>>1);
			topscreen	= centeryfrac - FixedMul(dc_texturemid,dc_invscale);
			bottomscreen  = topscreen + (dc_invscale*ht);
			dc_yh = ((bottomscreen-1)>>SFRACBITS)+1;
			if (dc_yh < 0)
				{
				post->floorclip=-1;
				post->ceilingclip=0;
				}
			else if (dc_yh >= viewheight)
				{
				post->floorclip=viewheight-1;
				post->ceilingclip=viewheight;
				}
			else
				{
				post->floorclip=dc_yh-1;
				post->ceilingclip=dc_yh;
				}
			return;
			}
		else
			{
			ht=nominalheight;
//			src2=W_CacheLumpNum(post->alttile,PU_CACHE);
			src2=W_CacheWallLumpNum(post->alttile,PU_CACHE);
			}
		}
	else
		{
		ht=maxheight+32;
		src2=src;
		}

	dc_invscale	= post->wallheight<<(10-HEIGHTFRACTION);
	dc_texturemid = (pheight<<SFRACBITS)+(SFRACUNIT>>1);
	topscreen	= centeryfrac - FixedMul(dc_texturemid,dc_invscale);
	bottomscreen  = topscreen + (dc_invscale*ht);
	dc_yl = (topscreen+SFRACUNIT-1)>>SFRACBITS;
	dc_yh = ((bottomscreen-1)>>SFRACBITS)+1;

	if (dc_yl >= viewheight)
		{
		post->ceilingclip=viewheight;
		post->floorclip=viewheight-1;
		return;
		}
	else if (dc_yl < 0)
		dc_yl = 0;

	if(post->wallheight>0)
		dc_iscale	= (64<<(16+HEIGHTFRACTION)) / post->wallheight;

	if (dc_yh < 0)
	{
		post->floorclip=-1;
		post->ceilingclip=0;
		goto bottomcheck;
	}
	else if (dc_yh > viewheight)
		dc_yh = viewheight;

	post->ceilingclip=dc_yl;
	post->floorclip=dc_yh-1;
	dc_source=src2+((post->texture>>4)&0xfc0);
	R_DrawWallColumn (buf);

bottomcheck:

	if (ht!=nominalheight)
		return;

	dc_texturemid-=(nominalheight<<SFRACBITS);
	topscreen	= centeryfrac - FixedMul(dc_texturemid,dc_invscale);
	bottomscreen  = topscreen + (dc_invscale<<6);
	dc_yl = (topscreen+SFRACUNIT-1)>>SFRACBITS;
	dc_yh = ((bottomscreen-1)>>SFRACBITS);

	if (dc_yl >= viewheight)
		return;
	else if (dc_yl < 0)
		dc_yl = 0;
	if (dc_yh < 0)
		return;
	else if (dc_yh > viewheight)
		dc_yh = viewheight;
	post->floorclip=dc_yh-1;
	dc_source=src+((post->texture>>4)&0xfc0);
	R_DrawWallColumn (buf);
}

/*
====================
=
= DrawWalls
=
====================
*/

void	DrawWalls (void)
{
//	char * buf;
	unsigned buf;
	int plane;
	wallcast_t * post;

	whereami=13;
	if (doublestep>1)
		{
		for (plane=0;plane<4;plane+=2)
			{
			VGAMAPMASK((1<<plane)+(1<<(plane+1)));
//			buf=(byte *)(bufferofs);
			buf=bufferofs;
			for (post=&posts[plane];post<&posts[viewwidth];post+=4,buf++)
				{
				SetWallLightLevel(post);
				DrawWallPost(post,buf);
				(post+1)->ceilingclip=post->ceilingclip;
				(post+1)->floorclip=post->floorclip;
				}
			}
		}
	else
		{
		for (plane=0;plane<4;plane++)
			{
			VGAWRITEMAP(plane);
//			buf=(byte *)(bufferofs);
			buf=bufferofs;
			for (post=&posts[plane];post<&posts[viewwidth];post+=4,buf++)
				{
				SetWallLightLevel(post);
				DrawWallPost(post,buf);
				}
			}
		}
}


/*
====================
=
= TransformDoors
=
====================
*/

void TransformDoors( void )
{
	int i;
	int numvisible;
	boolean result;
	int gx,gy;
	visobj_t visdoorlist[MAXVISIBLEDOORS],*doorptr;

	whereami=14;
	doorptr=&visdoorlist[0];
//
// place door objects
//

  for (i = 0;i<doornum;i++)
	{
	if (spotvis[doorobjlist[i]->tilex][doorobjlist[i]->tiley])
		{
		mapseen[doorobjlist[i]->tilex][doorobjlist[i]->tiley]=1;
		doorptr->texturestart=0;
		doorptr->textureend=0;
		if (doorobjlist[i]->vertical)
			{
			gx=(doorobjlist[i]->tilex<<16)+0x8000;
			gy=(doorobjlist[i]->tiley<<16);
			if (viewx<gx)
				result=TransformPlane(gx,gy,gx,gy+0xffff,doorptr);
			else
				result=TransformPlane(gx,gy+0xffff,gx,gy,doorptr);
			}
		else
			{
			gx=(doorobjlist[i]->tilex<<16);
			gy=(doorobjlist[i]->tiley<<16)+0x8000;
			if (viewy<gy)
				result=TransformPlane(gx+0xffff,gy,gx,gy,doorptr);
			else
				result=TransformPlane(gx,gy,gx+0xffff,gy,doorptr);
			}
		if (result==true)
			{
			doorptr->viewx=0;
			doorptr->shapenum=doorobjlist[i]->texture;
			doorptr->altshapenum=doorobjlist[i]->alttexture;
			if (doorobjlist[i]->texture==doorobjlist[i]->basetexture)
				{
				doorptr->shapesize=(doorobjlist[i]->tilex<<7)+doorobjlist[i]->tiley;
				if (doorptr < &visdoorlist[MAXVISIBLEDOORS-1]) // don't let it overflo'
					doorptr++;
				}
			else
				{
				doorptr->shapesize=3;
				memcpy(visptr,doorptr,sizeof(visobj_t));
				if (visptr < &vislist[MAXVISIBLE-1])
					visptr++;
				}
			}
		}
	}
//
// draw from back to front
//
	numvisible = doorptr-&visdoorlist[0];
	if (!numvisible)
		return;
	SortVisibleList( numvisible, &visdoorlist[0] );
	for (i = 0; i<numvisible; i++)
		{
		//
		// draw farthest
		//
		InterpolateWall (sortedvislist[i]);
		}
}


/*
====================
=
= TransformPushWalls
=
====================
*/

void TransformPushWalls( void )
{
  int	i;
  int	gx,gy;
  byte	*visspot;
  visobj_t *savedptr;
  int numvisible;
  boolean result;

	whereami=15;
  savedptr=visptr;
  //
  // place pwall objects
  //
  for (i = 0;i<pwallnum;i++)
	{
	if ((pwallobjlist[i]->action==pw_pushed) || (pwallobjlist[i]->action==pw_npushed))
		continue;
	visspot = &spotvis[pwallobjlist[i]->x>>16][pwallobjlist[i]->y>>16];
	if (*visspot
		|| ( *(visspot-1))
		|| ( *(visspot+1))
		|| ( *(visspot-128))
		|| ( *(visspot+128)))
		{
		gx=pwallobjlist[i]->x;
		gy=pwallobjlist[i]->y;
		mapseen[gx>>16][gy>>16]=1;
		if (viewx<gx)
			{
			if (viewy<gy)
				{
				visptr->texturestart=(gx-0x8000)&0xffff;
				visptr->textureend=visptr->texturestart;
				result=TransformPlane(gx+0x7fff,gy-0x8000,gx-0x8000,gy-0x8000,visptr);
				visptr->texturestart^=0xffff;
				visptr->textureend^=0xffff;
				visptr->shapenum=pwallobjlist[i]->texture;
				visptr->shapesize=((pwallobjlist[i]->x>>16)<<7)+(pwallobjlist[i]->y>>16);
				visptr->viewx+=2;
				if ((visptr < &vislist[MAXVISIBLE-1]) && (result==true)) // don't let it overflo'
					visptr++;
				visptr->texturestart=(gy-0x8000)&0xffff;
				visptr->textureend=visptr->texturestart;//-0xffff;
				result=TransformPlane(gx-0x8000,gy-0x8000,gx-0x8000,gy+0x7fff,visptr);
				}
			else
				{
				visptr->texturestart=(gy-0x8000)&0xffff;
				visptr->textureend=visptr->texturestart;//-0xffff;
				result=TransformPlane(gx-0x8000,gy-0x8000,gx-0x8000,gy+0x7fff,visptr);
				visptr->shapenum=pwallobjlist[i]->texture;
				visptr->shapesize=((pwallobjlist[i]->x>>16)<<7)+(pwallobjlist[i]->y>>16);
				visptr->viewx+=2;
				if ((visptr < &vislist[MAXVISIBLE-1]) && (result==true)) // don't let it overflo'
					visptr++;
				visptr->texturestart=(gx-0x8000)&0xffff;
				visptr->textureend=visptr->texturestart;//-0xffff;
				result=TransformPlane(gx-0x8000,gy+0x7fff,gx+0x7fff,gy+0x7fff,visptr);
				}
			}
		else
			{
			if (viewy<gy)
				{
				visptr->texturestart=(gy-0x8000)&0xffff;
				visptr->textureend=visptr->texturestart;
				result=TransformPlane(gx+0x7fff,gy+0x7fff,gx+0x7fff,gy-0x8000,visptr);
				visptr->texturestart^=0xffff;
				visptr->textureend^=0xffff;
				visptr->shapenum=pwallobjlist[i]->texture;
				visptr->shapesize=((pwallobjlist[i]->x>>16)<<7)+(pwallobjlist[i]->y>>16);
				visptr->viewx+=2;
				if ((visptr < &vislist[MAXVISIBLE-1]) && (result==true)) // don't let it overflo'
					visptr++;
				visptr->texturestart=(gx-0x8000)&0xffff;
				visptr->textureend=visptr->texturestart;
				result=TransformPlane(gx+0x7fff,gy-0x8000,gx-0x8000,gy-0x8000,visptr);
				visptr->texturestart^=0xffff;
				visptr->textureend^=0xffff;
				}
			else
				{
				visptr->texturestart=(gx-0x8000)&0xffff;
				visptr->textureend=visptr->texturestart;//-0xffff;
				result=TransformPlane(gx-0x8000,gy+0x7fff,gx+0x7fff,gy+0x7fff,visptr);
				visptr->shapenum=pwallobjlist[i]->texture;
				visptr->shapesize=((pwallobjlist[i]->x>>16)<<7)+(pwallobjlist[i]->y>>16);
				visptr->viewx+=2;
				if ((visptr < &vislist[MAXVISIBLE-1]) && (result==true)) // don't let it overflo'
					visptr++;
				visptr->texturestart=(gy-0x8000)&0xffff;
				visptr->textureend=visptr->texturestart;
				result=TransformPlane(gx+0x7fff,gy+0x7fff,gx+0x7fff,gy-0x8000,visptr);
				visptr->texturestart^=0xffff;
				visptr->textureend^=0xffff;
				}
			}
		visptr->viewx+=2;
		visptr->shapenum=pwallobjlist[i]->texture;
		visptr->shapesize=((pwallobjlist[i]->x>>16)<<7)+(pwallobjlist[i]->y>>16);
		if ((visptr < &vislist[MAXVISIBLE-1]) && (result==true)) // don't let it overflo'
			visptr++;
		}
	}


//
// draw from back to front
//
	numvisible = visptr-savedptr;
	if (!numvisible)
		return;
	SortVisibleList( numvisible, savedptr );
	for (i = 0; i<numvisible; i++)
		{
		//
		// draw farthest
		//
		if (sortedvislist[i]->shapenum & 0x1000)
			sortedvislist[i]->shapenum=animwalls[sortedvislist[i]->shapenum&0x3ff].texture;
		sortedvislist[i]->altshapenum=0;
		InterpolateWall (sortedvislist[i]);
		}
	visptr=savedptr;
}

/*
====================
=
= WallRefresh
=
====================
*/

void WallRefresh (void)
{
	volatile int dtime;
	int mag;
	int yzangle;

	whereami=16;
	firstcoloffset=(firstcoloffset+(tics<<8))&65535;

	dtime=fasttics;
	if (missobj)
		{
		viewangle=missobj->angle;
		viewx=missobj->x-costable[viewangle];
		viewy=missobj->y+sintable[viewangle];
		pheight = missobj->z + 32;
		nonbobpheight=pheight;
		spotvis[missobj->tilex][missobj->tiley]=1;
		yzangle=missobj->yzangle;
		}
	else
		{
		if (player->flags&FL_SHROOMS)
			{
			viewangle = (player->angle + FixedMulShift(FINEANGLES,sintable[(ticcount<<5)&(FINEANGLES-1)],(16+4)))&(FINEANGLES-1);
			ChangeFocalWidth(FixedMulShift(40,sintable[(ticcount<<5)&(FINEANGLES-1)],16));
			}
		else
			viewangle = player->angle;
		if ((viewangle<0) && (viewangle>=FINEANGLES))
			Error ("View angle out of range = %ld\n",viewangle);
		viewx = player->x;
		viewy = player->y;
		pheight = player->z + locplayerstate->playerheight + locplayerstate->heightoffset;
		nonbobpheight=pheight;
		if (
			(
				(player->z == nominalheight) ||
				(IsPlatform(player->tilex,player->tiley)) ||
				(DiskAt(player->tilex,player->tiley))
			) &&
			(!(player->flags & FL_DOGMODE)) &&
			(BobbinOn==true) &&
			(GamePaused==false)
			)
			{
			int mag;

			mag=(player->speed>MAXBOB ? MAXBOB : player->speed);

			pheight+=FixedMulShift(mag,sintable[(ticcount<<7)&2047],28);

			weaponbobx=FixedMulShift(mag,costable[((ticcount<<5))&(FINEANGLES-1)],27);
			weaponboby=FixedMulShift(mag,sintable[((ticcount<<5))&((FINEANGLES/2)-1)],26);
			}
		else
			{
			weaponbobx=0;
			weaponboby=0;
			}
		yzangle=player->yzangle;
		spotvis[player->tilex][player->tiley]=1;
		}

	if (yzangle > ANG180)
		pheight -= (sintable[yzangle&2047] >> 14);
	else
		pheight += (sintable[yzangle&2047] >> 14);

	viewx -= (FixedMul(sintable[yzangle&2047],costable[viewangle&2047])>>1);
	viewy += (FixedMul(sintable[yzangle&2047],sintable[viewangle&2047])>>1);

// Set YZ angle

	centery=viewheight>>1;

	if (yzangle>ANG180)
		centery-=FixedMul(FINEANGLES-yzangle,yzangleconverter);
	else
		centery+=FixedMul(yzangle,yzangleconverter);

	centeryfrac=(centery<<16);

	if (pheight < 1)
		pheight = 1;
	else if (pheight > maxheight+30)
		pheight = maxheight+30;

	if (nonbobpheight < 1)
		nonbobpheight = 1;
	else if (nonbobpheight > maxheight+30)
		nonbobpheight = maxheight+30;

	// Set light level of touchplates etc.

	mag=7+((3-gamestate.difficulty)<<2);

	transparentlevel=FixedMul(mag,sintable[(ticcount<<5)&(FINEANGLES-1)])+mag;

	viewsin = sintable[viewangle];
	viewcos = costable[viewangle];
	c_startx=(scale*viewcos)-(centerx*viewsin);
	c_starty=(-scale*viewsin)-(centerx*viewcos);
	Refresh ();
	UpdateClientControls();
	TransformPushWalls();
	TransformDoors();
	UpdateClientControls();
	DrawWalls();
	UpdateClientControls();
	walltime=fasttics-dtime;

}


/*
====================
=
= GetRainBoundingBox
=
====================
*/

void GetRainBoundingBox (int * xmin, int * xmax, int * ymin, int * ymax)
{
	wallcast_t * post;
	int x,y;

	// zero out all boundaries by default

	*xmax=0;
	*ymax=0;
	*xmin=127<<16;
	*ymin=127<<16;

	// check player's x and y

	if (viewx<(*xmin))
		(*xmin)=viewx;
	else if (viewx>(*xmax))
		(*xmax)=viewx;

	if (viewy<(*ymin))
		(*ymin)=viewy;
	else if (viewy>(*ymax))
		(*ymax)=viewy;

	for (post=&posts[0];post<&posts[viewwidth];post+=(viewwidth>>2))
		{
		x=(post->offset>>7)<<16;
		y=(post->offset&0x7f)<<16;

		if (x<(*xmin))
			(*xmin)=x;
		else if (x>(*xmax))
			(*xmax)=x;

		if (y<(*ymin))
			(*ymin)=y;
		else if (y>(*ymax))
			(*ymax)=y;
		}
}

/*
========================
=
= InterpolateWall
=
========================
*/

void InterpolateWall (visobj_t * plane)
{
	int d1,d2;
	int top;
	int topinc;
	int bot;
	int botinc;
	int i;
	int texture;
	int dh;
	int dx;
	int height;
//	byte * buf;
	unsigned buf;

	whereami=17;
	dx=(plane->x2-plane->x1+1);
	if (plane->h1<=0 || plane->h2<=0 || dx==0)
		return;
	d1=(1<<(16+HEIGHTFRACTION)) / plane->h1;
	d2=(1<<(16+HEIGHTFRACTION)) / plane->h2;
	dh=(((plane->h2-plane->h1)<<DHEIGHTFRACTION)+(1<<(DHEIGHTFRACTION-1)))/dx;
	top=0;
	topinc=FixedMulShift(d1,plane->textureend-plane->texturestart,4);
	bot=d2*dx;
	botinc=d1-d2;
	height=plane->h1<<DHEIGHTFRACTION;
//	buf=(byte *)bufferofs;
	buf=bufferofs;
	if (plane->x1>=viewwidth)
		return;
	for (i=plane->x1;i<=plane->x2;i++)
	{
		if ((i>=0 && i<viewwidth)&&(posts[i].wallheight<=(height>>DHEIGHTFRACTION)))
		{
			if (bot)
			{
				texture=((top/bot)+(plane->texturestart>>4))&0xfc0;
				posts[i].texture=texture<<4;
				posts[i].lump=plane->shapenum;
				posts[i].alttile=plane->altshapenum;
				posts[i].posttype=plane->viewx;
				posts[i].offset=plane->shapesize;
				posts[i].wallheight=height>>DHEIGHTFRACTION;
			}
		}
		top+=topinc;
		bot+=botinc;
		height+=dh;
	}
}


/*
========================
=
= InterpolateDoor
=
========================
*/

void InterpolateDoor (visobj_t * plane)
{
	int d1,d2;
	int top;
	int topinc;
	int bot;
	int botinc;
	int i;
	int texture;
	int dh;
	int dx;
	int height;
	int bottomscreen;
	byte * shape;
	byte * shape2;
//	byte * buf;
	unsigned buf;
	patch_t *p;
	int pl;

	whereami=18;
	dx=(plane->x2-plane->x1+1);
	if (plane->h1<=0 || plane->h2<=0 || dx==0)
		return;
//	shape=W_CacheLumpNum(plane->shapenum,PU_CACHE);
	shape=W_CacheWallLumpNum(plane->shapenum,PU_CACHE);
//	shape2=W_CacheLumpNum(plane->altshapenum,PU_CACHE);
	shape2=W_CacheWallLumpNum(plane->altshapenum,PU_CACHE);
	p=(patch_t *)shape;
	d1=(1<<(16+HEIGHTFRACTION)) / plane->h1;
	d2=(1<<(16+HEIGHTFRACTION)) / plane->h2;
	dh=(((plane->h2-plane->h1)<<DHEIGHTFRACTION)+(1<<(DHEIGHTFRACTION-1)))/dx;
	topinc=FixedMulShift(d1,plane->textureend-plane->texturestart,4);
	botinc=d1-d2;
	if (plane->x1>=viewwidth)
		return;
	for (pl=0;pl<4;pl++)
		{
		top=topinc*pl;
		bot=(d2*dx)+(pl*botinc);
		height=(plane->h1<<DHEIGHTFRACTION)+(dh*pl);
//		buf=(byte *)bufferofs+((pl+plane->x1)>>2);
		buf=bufferofs+((pl+plane->x1)>>2);
		VGAWRITEMAP((plane->x1+pl)&3);
		for (i=plane->x1+pl;i<=plane->x2;i+=4,buf++)
		{
			if ((i>=0 && i<viewwidth) && (bot!=0) && (posts[i].wallheight<=(height>>DHEIGHTFRACTION)) )
			{
//				dc_invscale=height<<(10-HEIGHTFRACTION-DHEIGHTFRACTION);
//				dc_invscale=height<<((10-HEIGHTFRACTION-DHEIGHTFRACTION)&31);
				dc_invscale=height>>4;		//BGB: ?...
				dc_iscale = 0xffffffffu/(unsigned)dc_invscale;
				dc_texturemid=((pheight-nominalheight+p->topoffset)<<SFRACBITS)+(SFRACUNIT>>1);
				sprtopoffset=centeryfrac - FixedMul(dc_texturemid,dc_invscale);

				texture=((top/bot)+(plane->texturestart>>4))>>6;
				SetLightLevel(height>>DHEIGHTFRACTION);
				ScaleMaskedPost (p->collumnofs[texture]+shape,buf);

				if (levelheight>1)
				{
					sprtopoffset-=(dc_invscale<<6)*(levelheight-1);
					bottomscreen =sprtopoffset + (dc_invscale*nominalheight);
					dc_yl = (sprtopoffset+SFRACUNIT-1)>>SFRACBITS;
					dc_yh = ((bottomscreen-1)>>SFRACBITS)+1;
					if (dc_yl >= viewheight)
						continue;
					else if (dc_yl < 0)
						dc_yl = 0;
					if (dc_yh > viewheight)
						dc_yh = viewheight;

					dc_source=shape2+((texture<<6)&0xfc0);
					R_DrawWallColumn (buf);
				}
			}
			top+=topinc<<2;
			bot+=botinc<<2;
			height+=dh<<2;
		}
	}
}


/*
========================
=
= InterpolateMaskedWall
=
========================
*/

void InterpolateMaskedWall (visobj_t * plane)
{
	int d1,d2;
	int top;
	int topinc;
	int bot;
	int botinc;
	int i;
	int j;
	int texture;
	int dh;
	int dx;
	int height;
	byte * shape;
	byte * shape2;
	byte * shape3;
//	byte * buf;
	unsigned buf;
	transpatch_t *p;
	patch_t *p2;
	patch_t *p3;
	int pl;
	boolean drawbottom,drawmiddle,drawtop;
	int topoffset;

	whereami=19;
	dx=(plane->x2-plane->x1+1);
	if (plane->h1<=0 || plane->h2<=0 || dx==0)
		return;
	if (plane->altshapenum>=0)
		{
		drawmiddle=true;
//		shape2=W_CacheLumpNum(plane->altshapenum,PU_CACHE);
		shape2=W_CacheWallLumpNum(plane->altshapenum,PU_CACHE);
		p2=(patch_t *)shape2;
		topoffset=p2->topoffset;
		}
	else
		{
		drawmiddle=false;
		}
	if (plane->viewx>=0)
		{
		drawtop=true;
//		shape3=W_CacheLumpNum(plane->viewx,PU_CACHE);
		shape3=W_CacheWallLumpNum(plane->viewx,PU_CACHE);
		p3=(patch_t *)shape3;
		topoffset=p3->topoffset;
		}
	else
		{
		drawtop=false;
		}
	if (plane->shapenum>=0)
		{
		drawbottom=true;
//		shape=W_CacheLumpNum(plane->shapenum,PU_CACHE);
		shape=W_CacheWallLumpNum(plane->shapenum,PU_CACHE);
		p = (transpatch_t *)shape;
		topoffset=p->topoffset;
		}
	else
		{
		drawbottom=false;
		}

	d1=(1<<(16+HEIGHTFRACTION)) / plane->h1;
	d2=(1<<(16+HEIGHTFRACTION)) / plane->h2;
	dh=(((plane->h2-plane->h1)<<DHEIGHTFRACTION)+(1<<(DHEIGHTFRACTION-1)))/dx;
	topinc=FixedMulShift(d1,plane->textureend-plane->texturestart,4);
	botinc=d1-d2;
	if (plane->x1>=viewwidth)
		return;
	for (pl=0;pl<4;pl++)
		{
		int planenum;

		top=topinc*pl;
		bot=(d2*dx)+(pl*botinc);
		height=(plane->h1<<DHEIGHTFRACTION)+(dh*pl);
//		buf=(byte *)bufferofs+((pl+plane->x1)>>2);
		buf=bufferofs+((pl+plane->x1)>>2);
		planenum=((plane->x1+pl)&3);
		VGAWRITEMAP(planenum);
		VGAREADMAP(planenum);
		for (i=plane->x1+pl;i<=plane->x2;i+=4,buf++)
			{
			if ((i>=0 && i<viewwidth) && (bot!=0) && (posts[i].wallheight<=(height>>DHEIGHTFRACTION)) )
				{
//				dc_invscale=height<<(10-HEIGHTFRACTION-DHEIGHTFRACTION);
//				dc_invscale=height<<((10-HEIGHTFRACTION-DHEIGHTFRACTION)&31);
				dc_invscale=height>>4;		//BGB: ?...
				dc_iscale = 0xffffffffu/(unsigned)dc_invscale;
				dc_texturemid=((pheight-nominalheight+topoffset)<<SFRACBITS)+(SFRACUNIT>>1);
				sprtopoffset=centeryfrac - FixedMul(dc_texturemid,dc_invscale);

				texture=((top/bot)+(plane->texturestart>>4))>>6;
				SetLightLevel(height>>DHEIGHTFRACTION);
				if (drawbottom==true)
					ScaleTransparentPost (p->collumnofs[texture]+shape,buf,(p->translevel+8));
				for (j=0;j<levelheight-2;j++)
					{
					sprtopoffset-=(dc_invscale<<6);
					dc_texturemid+=(1<<22);
					if (drawmiddle==true)
						ScaleMaskedPost (p2->collumnofs[texture]+shape2,buf);
					}
				if (levelheight>1)
					{
					sprtopoffset-=(dc_invscale<<6);
					dc_texturemid+=(1<<22);
					if (drawtop==true)
						ScaleMaskedPost (p3->collumnofs[texture]+shape3,buf);
					}
				}
			top+=topinc<<2;
			bot+=botinc<<2;
			height+=dh<<2;
			}
		}
}

/*
========================
=
= DrawPlayerLocation
=
========================
*/
#define PLX  (320-24)
#define PLY  16
void DrawPlayerLocation ( void )
{
	int i;
	char buf[30];

	CurrentFont=tinyfont;

	whereami=20;
	VGAMAPMASK(15);
	for (i=0;i<18;i++)
//		memset((byte *)bufferofs+(ylookup[i+PLY])+(PLX>>2),0,6);
		VGAMEMSET(bufferofs+(ylookup[i+PLY])+(PLX>>2),0,6);
	px=PLX;
	py=PLY;
	VW_DrawPropString(strupr(itoa(player->x,&buf[0],16)));
	px=PLX;
	py=PLY+6;
	VW_DrawPropString(strupr(itoa(player->y,&buf[0],16)));
	px=PLX;
	py=PLY+12;
	VW_DrawPropString(strupr(itoa(player->angle,&buf[0],16)));
}



/*
========================
=
= ThreeDRefresh
=
========================
*/


int playerview=0;
void		ThreeDRefresh (void)
{
	objtype * tempptr;

	whereami=21;
	tempptr=player;
#if (DEVELOPMENT == 1)
	if (Keyboard[sc_9])
		{
		while (Keyboard[sc_9])
			{
			IN_UpdateKeyboard();
			}
		playerview++;
		if (playerview>numplayers)
			playerview=1;
		}
	if (playerview!=0)
		{
		player=PLAYER[playerview-1];
		}
#endif

//
// Erase old messages
//

  RestoreMessageBackground();

  bufferofs += screenofs;

  RefreshClear();

  UpdateClientControls ();

//
// follow the walls from there to the right, drawwing as we go
//

	visptr = &vislist[0];
	WallRefresh ();

	UpdateClientControls ();

	if (fandc)
		DrawPlanes();

	UpdateClientControls ();

//
// draw all the scaled images
//
	DrawScaleds();													// draw scaled stuff

	UpdateClientControls ();

	if (!missobj)
		{
		if (locplayerstate->NETCAPTURED && (locplayerstate->NETCAPTURED != -2))
			{
			int value;

			if (locplayerstate->NETCAPTURED < 0)
			value = -locplayerstate->NETCAPTURED;
			else
			value = locplayerstate->NETCAPTURED;
			DrawScreenSizedSprite(netlump+value-1);
			}
		DrawPlayerWeapon ();	// draw player's hand'

		if (SCREENEYE)
		DrawScreenSprite(SCREENEYE->targettilex,SCREENEYE->targettiley,SCREENEYE->state->condition + GIBEYE1 + shapestart);
		UpdateClientControls ();

		if (player->flags&FL_GASMASK)
			DrawScreenSizedSprite(gmasklump);


		if ( SHOW_PLAYER_STATS() )
			{
			DrawStats ();
			}

		DoBorderShifts ();

		UpdateClientControls ();
		}

	bufferofs -= screenofs;
	DrawMessages();
	bufferofs += screenofs;

	if ( ((GamePaused==true) && (!Keyboard[sc_LShift])) ||
		(controlupdatestarted==0)
		)
		DrawPause ();

//
// show screen and time last cycle
//
	if ((fizzlein==true) && (modemgame==false))
	{
		if (newlevel==true)
			ShutdownClientControls();
		bufferofs-=screenofs;
		DrawPlayScreen (true);
		RotateBuffer(0,FINEANGLES,FINEANGLES*8,FINEANGLES,(VBLCOUNTER*3)/4);
		bufferofs+=screenofs;
		fizzlein = false;
		StartupClientControls();
	}

	bufferofs -= screenofs;

	UpdateClientControls ();

	if (HUD == true)
		DrawPlayerLocation();

	FlipPage();
	gamestate.frame++;

	player=tempptr;
}


//******************************************************************************
//
// FlipPage
//
//******************************************************************************

#if 0
void FlipPage ( void )
{
	unsigned displaytemp;

	whereami=22;
	displayofs = bufferofs;

	displaytemp = displayofs;
	if ( ( SHAKETICS != 0xFFFF ) && ( !inmenu ) && ( !GamePaused ) &&
		( !fizzlein ) )
		{
		ScreenShake ();
		}


//	_disable();
	OUTP(CRTC_INDEX,CRTC_STARTHIGH);
	OUTP(CRTC_DATA,((displayofs&0x0000ffff)>>8));


	if (SHAKETICS != 0xFFFF)
	{
		if (SHAKETICS > 0)
		{
			OUTP (CRTC_INDEX, CRTC_STARTLOW);
			OUTP (CRTC_DATA, (displayofs&0x000000FF));
			displayofs = displaytemp;
		}
		else
		{
			displayofs = displaytemp;
			OUTP(CRTC_INDEX,CRTC_STARTHIGH);
			OUTP(CRTC_DATA,((displayofs&0x0000ffff)>>8));
			OUTP (CRTC_INDEX, CRTC_STARTLOW);
			OUTP (CRTC_DATA, (displayofs&0x000000FF));
			SHAKETICS = 0xFFFF;
		}
	}
//	_enable();

	bufferofs += screensize;
	if (bufferofs > page3start)
		bufferofs = page1start;
}
#endif


//******************************************************************************
//
// TurnShakeOff
//
//******************************************************************************

#if 0
void TurnShakeOff
	(
	void
	)

	{
//	_disable();
	OUTP (CRTC_INDEX, CRTC_STARTHIGH );
	OUTP (CRTC_DATA, ( ( displayofs & 0x0000ffff ) >> 8 ) );
	OUTP (CRTC_INDEX, CRTC_STARTLOW);
	OUTP (CRTC_DATA, (displayofs&0x000000FF));
//	_enable();
	}
#endif


//******************************************************************************
//
// DrawScaledScreen
//
//******************************************************************************

void DrawScaledScreen(int x, int y, int step, byte * src)
{
	int	xfrac;
	int	yfrac;
	int	plane;
	int	i,j;
	byte	* p;
//	byte	* buf;
	unsigned buf;
	int	xsize;
	int	ysize;

	xsize=(320<<16)/step;
	if (xsize>320) xsize=320;
	ysize=(200<<16)/step;
	if (ysize>200) ysize=200;

	for (plane=x;plane<x+4;plane++)
	{
		yfrac=0;
		VGAWRITEMAP(plane&3);
		for (j=y;j<y+ysize;j++)
		{
			p=src+(320*(yfrac>>16));
//			buf=(byte *)bufferofs+ylookup[j]+(plane>>2);
			buf=bufferofs+ylookup[j]+(plane>>2);
			xfrac=(plane-x)*step;
			yfrac+=step;
			for (i=plane;i<x+xsize;i+=4)
			{
//				*buf=*(p+(xfrac>>16));
				VGAWRITE(buf, *(p+(xfrac>>16)));
				buf++;
				xfrac+=(step<<2);
			}
		}
	}
}


//******************************************************************************
//
// DoLoadGameSequence
//
//******************************************************************************

void DoLoadGameSequence ( void )
{
	int x;
	int y;
	int dx;
	int dy;
	int s;
	int ds;
	int time;
	int i;
	byte * destscreen;

	fizzlein=false;
	x=(18+SaveGamePicX)<<16;
	y=(30+SaveGamePicY)<<16;
	time=VBLCOUNTER;
	s=0x2000000;
	dx=(-x)/time;
	dy=(-y)/time;
	ds=-((s-0x1000000)/time);

	destscreen=SafeMalloc(64000);

	SetupScreen(false);
	ThreeDRefresh();
	FlipPage();
	FlipPage();

//	VL_CopyPlanarPageToMemory ( (byte *)bufferofs,  destscreen );
	VL_CopyPlanarPageToMemory ( bufferofs, destscreen );
	VL_CopyDisplayToHidden ();

	CalcTics();
	for (i=0;i<time;i+=tics)
	{
		CalcTics();
		DrawScaledScreen((x>>16),(y>>16),(s>>8),destscreen);
		FlipPage();
		x+=(dx*tics);
		if (x<0) x=0;
		y+=(dy*tics);
		if (y<0) y=0;
		s+=(ds*tics);
	}
	DrawScaledScreen(0,0,0x10000,destscreen);
	FlipPage();
	VL_CopyDisplayToHidden ();
	SafeFree(destscreen);
	CalcTics();
	CalcTics();
}

//******************************************************************************
//
// StartupRotateBuffer
//
//******************************************************************************
byte * RotatedImage;
boolean RotateBufferStarted = false;
void StartupRotateBuffer ( int masked)
{
	int i,a,b;

	if (RotateBufferStarted == true)
		return;

	RotateBufferStarted = true;

	RotatedImage=SafeMalloc(131072);
	if (masked==0)
		memset(RotatedImage,0,131072);
	else
		memset(RotatedImage,0xff,131072);
	for (i=0;i<4;i++)
		{
		VGAREADMAP(i);
		for (a=0;a<200;a++)
			for (b=0;b<80;b++)
//				*(RotatedImage+99+i+((a+28)<<9)+(b<<2))=*((byte *)bufferofs+(a*linewidth)+b);
				*(RotatedImage+99+i+((a+28)<<9)+(b<<2))=
					VGAREAD(bufferofs+(a*linewidth)+b);
		}
}

//******************************************************************************
//
// ShutdownRotateBuffer
//
//******************************************************************************

void ShutdownRotateBuffer ( void )
{
	if (RotateBufferStarted == false)
		return;

	RotateBufferStarted = false;
	SafeFree(RotatedImage);
}

//******************************************************************************
//
// ScaleAndRotateBuffer
//
//******************************************************************************

void ScaleAndRotateBuffer (int startangle, int endangle, int startscale, int endscale, int time)
{
	int anglestep;
	int scalestep;
	int angle;
	int scale;
	int i;

	anglestep=((endangle-startangle)<<16)/time;
	scalestep=((endscale-startscale)<<6)/time;

	angle=(startangle<<16);
	scale=(startscale<<6);

	CalcTics();
	CalcTics();
	for (i=0;i<time;i+=tics)
	{
		DrawRotatedScreen(160,100, bufferofs,(angle>>16)&(FINEANGLES-1),scale>>6,0);
		FlipPage();
		scale+=(scalestep*tics);
		angle+=(anglestep*tics);
		CalcTics();
	}
	DrawRotatedScreen(160,100, bufferofs,endangle&(FINEANGLES-1),endscale,0);
	FlipPage();
	DrawRotatedScreen(160,100, bufferofs,endangle&(FINEANGLES-1),endscale,0);
	FlipPage();
	DrawRotatedScreen(160,100, bufferofs,endangle&(FINEANGLES-1),endscale,0);
	CalcTics();
	CalcTics();
}

//******************************************************************************
//
// RotateBuffer
//
//******************************************************************************

void RotateBuffer (int startangle, int endangle, int startscale, int endscale, int time)
{
	int savetics;

	//save off fastcounter

	savetics=fasttics;

	StartupRotateBuffer (0);

	ScaleAndRotateBuffer (startangle, endangle, startscale, endscale, time);

	ShutdownRotateBuffer ();

	// restore fast counter
	fasttics=savetics;
}


//******************************************************************************
//
// DrawRotatedScreen
//
//******************************************************************************

void DrawRotatedScreen(int cx, int cy, unsigned destscreen, int angle, int scale, int masked)
{
	int	c, s;
	int	xst, xct;
	int	y;
	int	plane;
//	byte	* screen;
	unsigned screen;

	c = FixedMulShift(scale,costable[angle],11);
	s = FixedMulShift(scale,sintable[angle],11);
	xst = (((-cx)*s)+(128<<16))-(cy*c);
	xct = (((-cx)*c)+(256<<16)+(1<<18)-(1<<16))+(cy*s);
	mr_xstep=s<<2;
	mr_ystep=c<<2;
	screen=destscreen;

	if (masked==0)
		{
		for (plane=0;plane<4;plane++,xst+=s,xct+=c)
			{
			mr_yfrac=xct;
			mr_xfrac=xst;
			VGAWRITEMAP(plane);
			for (y=0; y<200; y++,mr_xfrac+=c,mr_yfrac-=s)
				DrawRotRow(((320-plane)>>2)+1,screen+ylookup[y]+(plane>>2),RotatedImage);
			}
		}
	else
		{
		for (plane=0;plane<4;plane++,xst+=s,xct+=c)
			{
			mr_yfrac=xct;
			mr_xfrac=xst;
			VGAWRITEMAP(plane);
			for (y=0; y<200; y++,mr_xfrac+=c,mr_yfrac-=s)
				DrawMaskedRotRow(((320-plane)>>2)+1,screen+ylookup[y]+(plane>>2),RotatedImage);
			}
		}
}


//******************************************************************************
//
// DrawScaledPost
//
//******************************************************************************

void DrawScaledPost ( int height, byte * src, int offset, int x)
{
	patch_t *p;

	p=(patch_t *)src;
	dc_invscale=(height<<16)/p->origsize;
	dc_iscale=(p->origsize<<16)/height;
	dc_texturemid=(((p->origsize>>1)+p->topoffset)<<SFRACBITS)+(SFRACUNIT>>1);
	sprtopoffset=centeryfrac - FixedMul(dc_texturemid,dc_invscale);
	shadingtable=colormap+(1<<12);
	VGAWRITEMAP(x&3);
//	ScaleMaskedPost(((p->collumnofs[offset])+src), (byte *)bufferofs+(x>>2));
	ScaleMaskedPost(((p->collumnofs[offset])+src), bufferofs+(x>>2));
}



void ApogeeTitle (void)
{
	byte pal[768];
	int	angle;
	int	scale;
	int	x,y;
	int	danglex;
	int	anglex;
	int	dy,dangle,dscale;
	int	time;

	CalcTics();
	CalcTics();
	IN_ClearKeysDown();
	viewwidth=320;
	viewheight=200;
	memcpy(&pal[0],W_CacheLumpName("ap_pal",PU_CACHE),768);
	shadingtable=colormap+(1<<12);
	VL_NormalizePalette(&pal[0]);
	SwitchPalette(&pal[0],35);
//	DrawWorld();
//	RotateBuffer(0,FINEANGLES*6,FINEANGLES*48,FINEANGLES,(VBLCOUNTER*2));
//	DoLaserShoot("apogee");
//	DoZIntro();

	VL_ClearBuffer (bufferofs, 255);
	DrawNormalSprite (0, 0, W_GetNumForName("ap_titl"));

	StartupRotateBuffer (1);

	//save off fastcounter

#define APOGEEXANGLE 913
#define APOGEEXMAG	180
#define APOGEESTARTY 0
#define APOGEEENDY	100

#define APOGEESCALESTART (FINEANGLES<<4)
#define APOGEESCALEEND (FINEANGLES)
#define APOGEESONGTIME (124-1)

	time = APOGEESONGTIME;

	anglex=0;
	danglex=(APOGEEXANGLE<<16)/time;

	y=APOGEESTARTY<<16;
	dy=((APOGEEENDY-APOGEESTARTY)<<16)/time;

	dscale=((APOGEESCALEEND-APOGEESCALESTART)<<16)/time;
	scale=APOGEESCALESTART<<16;

	angle=0;
	dangle=(FINEANGLES<<17)/time;

	MU_StartSong(song_apogee);

	CalcTics();

	while (time>=0)
		{
		VL_DrawPostPic (W_GetNumForName("ap_wrld"));

		x=100+FixedMul(APOGEEXMAG,sintable[anglex>>16]);

		DrawRotatedScreen(x,y>>16,bufferofs,(angle>>16)&(FINEANGLES-1),scale>>16,1);
		FlipPage();
		CalcTics();
		angle+=dangle*tics;
		scale+=dscale*tics;
		y+=dy*tics;
		anglex+=danglex*tics;
		time-=tics;
		if ((LastScan) || IN_GetMouseButtons())
			goto apogeeexit;
		}
	CalcTics();
	CalcTics();
	VL_DrawPostPic (W_GetNumForName("ap_wrld"));
	DrawRotatedScreen(x,y>>16,bufferofs,0,APOGEESCALEEND,1);
	FlipPage();

	while (MU_SongPlaying())
		{
		if ((LastScan) || IN_GetMouseButtons())
			goto apogeeexit;
		}

apogeeexit:
	ShutdownRotateBuffer ();
}

#if (SHAREWARE==0)

void DopefishTitle (void)
{
	int shapenum;
	int height;

	shapenum=W_GetNumForName("scthead1");
	CalcTics();
	CalcTics();
	IN_ClearKeysDown();
	MU_StartSong( song_secretmenu);
	viewwidth=320;
	viewheight=200;
	SwitchPalette(origpal,35);
	oldtime=ticcount;
	FlipPage();
	for (height=1;height<200;height+=(tics<<2))
		{
		DrawPositionedScaledSprite (160, 100, shapenum, height, 0);
		FlipPage();
		CalcTics();
		if ((LastScan) || IN_GetMouseButtons())
			break;
		}
	SD_Play ( SD_DOPEFISHSND );
	oldtime=ticcount;
	for (height=0;height<FINEANGLES<<1;height+=(tics<<5))
		{
		DrawPositionedScaledSprite (160+FixedMul(60,costable[height&(FINEANGLES-1)]), 100+FixedMul(60,sintable[height&(FINEANGLES-1)]), shapenum, 200, 0);
		FlipPage();
		VL_CopyPlanarPage ( displayofs, bufferofs );
		CalcTics();
		if ((LastScan) || IN_GetMouseButtons())
			break;
		}
	SD_Play ( SD_DOPEFISHSND );
	FlipPage();
}

#endif

//******************************************************************************
//
// RotationFun
//
//******************************************************************************

void RotationFun ( void )
{
	int	angle;
	int	scale;
	int	x,y;
	word  buttons;

	//save off fastcounter


	angle=0;
	scale=FINEANGLES;

	StartupRotateBuffer (0);

	CalcTics();
	CalcTics();
	while (!Keyboard[sc_Escape])
	{
		IN_UpdateKeyboard ();
		DrawRotatedScreen(160,100, bufferofs,angle,scale,0);
		FlipPage();
		CalcTics();
		INL_GetMouseDelta(&x, &y);
		buttons=IN_GetMouseButtons ();
		angle=(angle-x)&(FINEANGLES-1);
		if (buttons & (1 << 0))
		{
			if (scale>0)
				scale-=30;
		}
		else if (buttons & (1 << 1))
		{
			scale+=30;
		}
	}
	CalcTics();
	CalcTics();
	Keyboard[sc_Escape]=0;

	ShutdownRotateBuffer ();
}

boolean ScreenSaverStarted=false;
screensaver_t * ScreenSaver;
#define PAUSETIME  (70)

//******************************************************************************
//
// SetupScreenSaverPhase
//
//******************************************************************************
void SetupScreenSaverPhase ( void )
{
	if (ScreenSaverStarted==false)
		return;

	if (ScreenSaver->phase==0)
	{
		ScreenSaver->x=160;
		ScreenSaver->y=100;
		ScreenSaver->angle=0;
		ScreenSaver->scale=FINEANGLES;
		ScreenSaver->dangle=FINEANGLES/VBLCOUNTER;
		ScreenSaver->dx=0;
		ScreenSaver->dy=0;
		ScreenSaver->dscale=((FINEANGLES<<2)-(FINEANGLES))/VBLCOUNTER;
		ScreenSaver->time=VBLCOUNTER;
	}
	else if (ScreenSaver->phase==1)
	{
		ScreenSaver->x=160;
		ScreenSaver->y=100;
		ScreenSaver->angle=0;
		ScreenSaver->scale=FINEANGLES<<2;
		ScreenSaver->dangle=FINEANGLES/VBLCOUNTER;
		ScreenSaver->dx=RandomNumber("StartupScreen",0)>>5;
		ScreenSaver->dy=RandomNumber("StartupScreen",0)>>5;
		ScreenSaver->dscale=0;
		ScreenSaver->time=-1;
	}
}

//******************************************************************************
//
// StartupScreenSaver
//
//******************************************************************************
void StartupScreenSaver ( void )
{
	if (ScreenSaverStarted==true)
		return;

	ScreenSaverStarted=true;

	StartupRotateBuffer (0);

	ScreenSaver=(screensaver_t *)SafeMalloc(sizeof(screensaver_t));
	ScreenSaver->phase=0;
	ScreenSaver->pausetime=PAUSETIME;
	ScreenSaver->pausex=120;
	ScreenSaver->pausey=84;
	SetupScreenSaverPhase();
}

//******************************************************************************
//
// ShutdownScreenSaver
//
//******************************************************************************
void ShutdownScreenSaver ( void )
{
	if (ScreenSaverStarted==false)
		return;

	ScreenSaverStarted=false;

	ShutdownRotateBuffer ();
	SafeFree(ScreenSaver);
}

//******************************************************************************
//
// UpdateScreenSaver
//
//******************************************************************************

#define SPINSIZE  40
#define MAXSPEED  8
void UpdateScreenSaver ( void )
{
	if (ScreenSaver->time!=-1)
	{
		ScreenSaver->time-=tics;
		if (ScreenSaver->time<0)
		{
			ScreenSaver->phase++;
			SetupScreenSaverPhase();
		}
	}
	ScreenSaver->x+=ScreenSaver->dx*tics;
	ScreenSaver->y+=ScreenSaver->dy*tics;
	ScreenSaver->angle=(ScreenSaver->angle+(ScreenSaver->dangle*tics))&(FINEANGLES-1);
	ScreenSaver->scale+=ScreenSaver->dscale*tics;
	if (ScreenSaver->x<SPINSIZE)
	{
		ScreenSaver->x=SPINSIZE;
		ScreenSaver->dx=abs(ScreenSaver->dx);
		ScreenSaver->dy+=(RandomNumber("Rotate",0)>>6)-2;
	}
	else if (ScreenSaver->x>320-SPINSIZE)
	{
		ScreenSaver->x=320-SPINSIZE;
		ScreenSaver->dx=-(abs(ScreenSaver->dx));
		ScreenSaver->dy+=(RandomNumber("Rotate",0)>>6)-2;
	}
	if (ScreenSaver->y<SPINSIZE)
	{
		ScreenSaver->y=SPINSIZE;
		ScreenSaver->dy=abs(ScreenSaver->dy);
		ScreenSaver->dx+=(RandomNumber("Rotate",0)>>6)-2;
	}
	else if (ScreenSaver->y>200-SPINSIZE)
	{
		ScreenSaver->y=200-SPINSIZE;
		ScreenSaver->dy=-(abs(ScreenSaver->dy));
		ScreenSaver->dx+=(RandomNumber("Rotate",0)>>6)-2;
	}

	if (abs(ScreenSaver->dx)>MAXSPEED)
		ScreenSaver->dx=SGN(ScreenSaver->dx)*MAXSPEED;

	if (abs(ScreenSaver->dy)>MAXSPEED)
		ScreenSaver->dy=SGN(ScreenSaver->dy)*MAXSPEED;

	DrawRotatedScreen(ScreenSaver->x,ScreenSaver->y,
		bufferofs,ScreenSaver->angle,ScreenSaver->scale,0);

	ScreenSaver->pausetime-=tics;
	if (ScreenSaver->pausetime<=0)
	{
		ScreenSaver->pausetime=PAUSETIME;
		ScreenSaver->pausex=RandomNumber ("pausex",0)%240;
		ScreenSaver->pausey=RandomNumber ("pausey",0)%168;
	}
	DrawPauseXY (ScreenSaver->pausex, ScreenSaver->pausey);

	FlipPage();
}
#if 0

//******************************************************************************
//
// DoLaserShoot
//
//******************************************************************************
void DoLaserShoot (char * name)
{

	int sourcex;
	int lastx;
	int sourceheight;
	int destheight;
	int sourcestep;
	int xstep;
	int hstep;
	int midx;
	int startx;
	int dx;
	int f;
	int s;
	int height;
	int x;
	int sx;
	int size;
	patch_t *p;
	byte * shape;

	DrawWorld();
	midx=160;
	shape=W_CacheLumpName(name,PU_CACHE);
	p=(patch_t *)shape;
	size=p->origsize;

	startx=midx-(size>>1)-(p->leftoffset);

	sourcex=0;
	lastx=startx+p->width;
	sourcestep=(320*65536)/p->width;
	sourceheight=p->origsize<<3;
	destheight=p->origsize;
	CalcTics();
	CalcTics();


	for (x=startx;x<lastx;x+=tics,sourcex+=(sourcestep*tics))
		{
		for (f=startx;f<=x;f++)
			DrawScaledPost(destheight,shape,f-startx,f);
		height=sourceheight<<16;
		if (x<=midx)
			{
			dx=x-(sourcex>>16);
			xstep=1;
			}
		else
			{
			dx=(sourcex>>16)-x;
			xstep=-1;
			}
		sx=sourcex>>16;
		if (dx)
			hstep=((-destheight+sourceheight)<<16)/dx;
		else
			hstep=0;
		for (s=0;s<dx;s++,height-=hstep,sx+=xstep)
			DrawScaledPost(height>>16,shape,x-startx,sx);
		FlipPage();
		CalcTics();
		DrawWorld();
			break;
		}

	// Write out one more time so that the rest of the screen is clear

	for (f=startx;f<lastx;f++)
		DrawScaledPost(destheight,shape,f-startx,f);
	FlipPage();
}

//******************************************************************************
//
// DoIntro
//
//******************************************************************************

#define MAXMAG (80)
#define OSCTIME (5*VBLCOUNTER)
#define OSCXSHIFT (4)
#define OSCTSHIFT (4)

void DoIntro (void)
{
	byte * shape;
	byte * origshape;
	int mag;
	int currentmag;
	int magstep;
	int time;
	int x;
	int t;

	shadingtable=colormap+(1<<12);

	origshape=W_CacheLumpName("ap_wrld",PU_CACHE);

	mag=MAXMAG<<16;
	magstep = (MAXMAG<<16)/OSCTIME;
	time = OSCTIME;
	t=0;

	CalcTics();

	while (time>0)
		{
		int yoffset;
		int ylow;
		int yhigh;
		int offset;
		int postheight;
		byte * src;

		shape=origshape;
		VL_ClearBuffer (bufferofs, 0);
		currentmag=mag>>16;
		for (x=0;x<320;x++,shape+=200)
			{
			VGAWRITEMAP(x&3);
			src=shape;
			offset=(t+(x<<OSCXSHIFT))&(FINEANGLES-1);
			yoffset=FixedMul(currentmag,sintable[offset]);
			ylow=yoffset;
			if (ylow<0)
				{
				src-=ylow;
				ylow=0;
				}
			if (ylow>199)
				ylow=199;
			yhigh=yoffset+200;
			if (yhigh>199)
				{
				yhigh=199;
				}
			if (yhigh<0)
				yhigh=0;
			postheight=yhigh-ylow+1;
			if (postheight>0)
				DrawSkyPost((byte *)bufferofs + (x>>2) + ylookup[ylow],src,postheight);
			}
		FlipPage();
		CalcTics();
		mag  -= (magstep * tics);
		time -= tics;
		t	+= (tics<<OSCTSHIFT);
		if (mag<0) mag = 0;
		}
}


//******************************************************************************
//
// DoZIntro
//
//******************************************************************************

#define ZMAXMAG (199)
#define ZOSCTIME (3*VBLCOUNTER)
#define ZOSCXSHIFT (2)
#define ZOSCXSTEP ( (FINEANGLES<<(ZOSCXSHIFT+16))/320 )
#define ZOSCTSHIFT (2)

void DoZIntro (void)
{
	byte * shape;
	int mag;
	int currentmag;
	int magstep;
	int time;
	int x;
	int t;

	SetViewSize (MAXVIEWSIZES-1);

	shadingtable=colormap+(1<<12);

	shape=W_CacheLumpName("ap_wrld",PU_CACHE);

	mag=ZMAXMAG<<16;
	magstep = (ZMAXMAG<<16)/ZOSCTIME;
	time = ZOSCTIME;
	t=0;

	CalcTics();


	while (time>0)
		{
		int zoffset;
		int hoffset;
		int offset;
		int srcoffset;
		int bottomscreen;
		int src;
//		int i;


		VL_ClearBuffer (bufferofs, 0);
		currentmag=mag>>16;

		srcoffset=0;
		for (x=0;x<320;)
			{
			VGAWRITEMAP(x&3);

			offset=(t+(FixedMul(x,ZOSCXSTEP)))&(FINEANGLES-1);
			zoffset=FixedMul(currentmag,sintable[offset]);
//			hoffset=FixedMulShift(currentmag,sintable[offset],17);
			hoffset=0;
			dc_texturemid=((100+hoffset)<<SFRACBITS)+(SFRACUNIT>>1);

			dc_invscale=((200+zoffset)<<16)/200;
			dc_iscale=0xffffffffu/(unsigned)dc_invscale;

			srcoffset+=dc_invscale;
			sprtopoffset=centeryfrac -  FixedMul(dc_texturemid,dc_invscale);
			bottomscreen = sprtopoffset + (dc_invscale*200);
			dc_yl = (sprtopoffset+SFRACUNIT-1)>>SFRACBITS;
			dc_yh = ((bottomscreen-1)>>SFRACBITS);
			if (dc_yh >= viewheight)
				dc_yh = viewheight-1;
			if (dc_yl < 0)
				dc_yl = 0;
			if (dc_yl <= dc_yh)
				{
				src=srcoffset>>16;
				if (src>319)
					src=319;
				if (src<0)
					src=0;
				dc_source=shape+(src * 200);
//				if (RandomNumber("hello",0)<128)
				R_DrawColumn ((byte *)bufferofs+(x>>2));
				}
//			srcoffset+=0x10000;
			x++;
			if ((LastScan) || IN_GetMouseButtons())
				return;
			}
		FlipPage();
		CalcTics();
		mag  -= (magstep * tics);
//		mag  += FixedMulShift((magstep * tics),sintable[time&(FINEANGLES-1)],19);
		time -= tics;
		t	+= (tics<<ZOSCTSHIFT);
		if (mag<0) mag = 0;
		}
}
#endif



// Old Stuff

/*
	int y1;
	int y2;

	if (post->alttile!=0)
		{
		ht=nominalheight;
//		src2=W_CacheLumpNum(1+post->alttile,PU_CACHE);
//		src2+=8;
		}
	else
		{
		ht=maxheight;
		src2=src;
		}
	hp_srcstep=(64<<(16+HEIGHTFRACTION))/post->wallheight;
	y1 = (((centery<<HFRACTION)-(post->wallheight*pheight)+(1<<(HFRACTION-1))));
	y2 = (((post->wallheight*ht)+y1)>>HFRACTION);

	if ((y1>>HFRACTION)>=viewheight)
		{
		post->ceilingclip=viewheight-1;
		post->floorclip=viewheight-1;
		return;
		}
	else if (y1<0)
		{
		hp_startfrac=FixedMulShift(-y1,hp_srcstep,HFRACTION);
		y1=0;
		post->ceilingclip=0;
		}
	else
		{
		hp_startfrac=FixedMulShift(255-(y1&0xff),hp_srcstep,HFRACTION);
		y1>>=HFRACTION;
		post->ceilingclip=y1;
		}
	if (y2<0)
		{
		post->floorclip=0;
		post->ceilingclip=0;
		}
	else if (y2>viewheight)
		{
		DrawHeightPost(viewheight-y1, src2+((post->texture>>4)&0xfc0), buf+ylookup[y1]);
		post->floorclip=viewheight-1;
		}
	else
		{
		DrawHeightPost(y2-y1, src2+((post->texture>>4)&0xfc0), buf+ylookup[y1]);
		post->floorclip=y2-1;
		}

	if (ht==maxheight)
		return;

	y1 = (((centery<<HFRACTION)-(post->wallheight*(pheight-ht))+(1<<(HFRACTION-1))));
	y2 = (((post->wallheight<<6)+y1)>>HFRACTION);

	if ((y1>>HFRACTION)>=viewheight)
		return;
	else if (y1<0)
		{
		hp_startfrac=FixedMulShift(-y1,hp_srcstep,HFRACTION);
		y1=0;
		}
	else
		{
		hp_startfrac=FixedMulShift(255-(y1&0xff),hp_srcstep,HFRACTION);
		y1>>=HFRACTION;
		}
	if (y2<0)
		return;
	else if (y2>viewheight)
		{
		DrawHeightPost(viewheight-y1, src+((post->texture>>4)&0xfc0), buf+ylookup[y1]);
		post->floorclip=viewheight-1;
		}
	else
		{
		DrawHeightPost(y2-y1, src+((post->texture>>4)&0xfc0), buf+ylookup[y1]);
		post->floorclip=y2-1;
		}
}
*/






//******************************************************************************
//
// DrawBackground
//
//******************************************************************************

void DrawBackground ( byte * bkgnd )
{
	int plane;
	int size;

	size=linewidth*200;

	for (plane=0;plane<4;plane++)
	{
		VGAWRITEMAP(plane);
//		memcpy((byte *)bufferofs,bkgnd,size);
		VGAWRITEBUF(bufferofs, bkgnd, size);
		bkgnd+=size;
	}
}


//******************************************************************************
//
// PrepareBackground
//
//******************************************************************************

void PrepareBackground ( byte * bkgnd )
{
	int plane;
	int size;

	size=linewidth*200;

	for (plane=0;plane<4;plane++)
		{
		VGAREADMAP(plane);
//		memcpy(bkgnd,(byte *)bufferofs,size);
		VGAREADBUF(bkgnd, bufferofs, size);
		bkgnd+=size;
		}
}

//******************************************************************************
//
// WarpString
//
//******************************************************************************

void WarpString (
						int x, int y, int endx, int endy,
						int time, byte * back, char * str
					)
{
	int dx;
	int dy;
	int cx;
	int cy;
	int starttime;


	LastScan = 0;


	dx=((endx-x)<<16)/time;
	dy=((endy-y)<<16)/time;
	cx=x<<16;
	cy=y<<16;
	starttime=time;

	CalcTics();

	while (time>0)
		{

		DrawBackground ( back );
		US_ClippedPrint (cx>>16, cy>>16, str);
		FlipPage();

		CalcTics();
		cx+=dx*tics;
		cy+=dy*tics;
		time-=tics;
		if (LastScan != 0)
			break;
		}

  // DrawBackground ( back );
  // US_ClippedPrint (endx, endy, str);
  // FlipPage();

}


#if (SHAREWARE==1)
//******************************************************************************
//
// DoEndCinematic
//
//******************************************************************************

//******************************************************************************
//
// WarpSprite
//
//******************************************************************************

void WarpSprite (
						int x, int y, int endx, int endy,
						int time, byte * back, int shape
					)
{
	int dx;
	int dy;
	int cx;
	int cy;
	int starttime;

	LastScan = 0;

	dx=((endx-x)<<16)/time;
	dy=((endy-y)<<16)/time;
	cx=x<<16;
	cy=y<<16;
	starttime=time;

	CalcTics();

	while (time>0)
		{
		DrawBackground ( back );
		DrawUnScaledSprite (cx>>16, cy>>16, shape, 16);
		FlipPage();
		CalcTics();
		cx+=dx*tics;
		cy+=dy*tics;
		time-=tics;
		if (LastScan != 0)
			break;
		}
}


char *EndCinematicPicNames[5] =
			{
			"lwgshoo2",
			"hg2shoo2",
			"ankshoo1",
			"ligrise4",
			"tritoss5",

			};

#define NUMENDMESSAGES 24


char *EndCinematicText[NUMENDMESSAGES] =
  {
  "You've won the battle, Cassatt.\n"
  "But when the Oscuridos return,\n"
  "will you be ready as they wage\n"
  "their Dark War?",

  "Armed with only a pistol and 30\n"
  "bucks, you must stop the minions of\n"
  "El Oscuro before they kill millions\n"
  "of innocent people.",

  "But for now, hey, enjoy the medal\n"
  "you received and take a vacation.\n"
  "You've earned it. Maybe on \n"
  "San Nicolas Island . . ." ,

  "Thanks for playing. If you liked\n"
  "\"The HUNT Begins\", check Ordering\n"
  "Info for information about \n"
  "continuing your adventure.",

  "Okay, you can stop reading now.",

  "Press a key. That's all there is.\n"
  "Thanks.",

  "Are you lazy, or illiterate?\n"
  "PRESS A KEY.",

  "Look, this is pointless. You\n"
  "are done. Push off.",

  "Okay, show's over.  Nothing\n"
  "more to see here.",

  "Wow, you must like this fine\n"
  "background screen.",

  "For waiting this long, you get . . .\n"
  "nothing!  Go away!",

  "I mean, I like you as a friend,\n"
  "but . . .",

  "\"Bob\"",

  "All right, um . . . you found the\n"
  "secret message! Congratulations!",

  "Didn't work, huh?  Okay, how about\n"
  "this . . .",

  "THE END",

  "Dang. Thought I had you there.",

  "Stop watching.",

  "You know that if you registered,\n"
  "there would be a lot more cool\n"
  "stuff happening right now.",

  "Episode IV: A New Hope\n",

  "Just think of all the new secret\n"
  "messages you could find hidden\n"
  "in the registered version!",

  "Someone right now is probably\n"
  "enjoying the really exciting\n"
  "ending of the registered version.",

  "ROTT was filmed before\n"
  "a live audience.",

  "No animals were harmed during the\n"
  "creation of this video game, although\n"
  "one dog did get its butt spanked\n"
  "when it peed on the carpet.\n",


  };
char NextGameString1[] = "The Developers of Incredible Power";
char NextGameString2[] = "shall return";

void DoEndCinematic ( void )
{
	int trilogo;
	int group;
	int world;
	int width;
	int height;
	int x,y;
	int shape;
	int time1,time2;
	byte * tmp;
	byte * sky;
	byte * bkgnd;
	int i;

	byte pal[768];


	viewwidth = MAXSCREENWIDTH;
	viewheight = MAXSCREENHEIGHT;

	MU_StartSong(song_youwin);

	bkgnd=SafeMalloc(800*linewidth);

	trilogo=W_GetNumForName("trilogo");
	world=W_GetNumForName("ap_wrld");
	group=W_GetNumForName("mmbk");
	VL_DrawPostPic (trilogo);
	PrepareBackground ( bkgnd );

	WarpSprite (160, -100, 160, 100, (VBLCOUNTER*3), bkgnd, W_GetNumForName("youwin"));
	if (LastScan !=0)
		goto fadelogo;

	I_Delay(30);
fadelogo:
	MenuFadeOut();
	ClearGraphicsScreen();
	memcpy(&pal[0],W_CacheLumpName("ap_pal",PU_CACHE),768);
	VL_NormalizePalette(&pal[0]);
	SwitchPalette(&pal[0],35);

	VL_DrawPostPic (world);
	PrepareBackground ( bkgnd );

	WarpSprite (160, 250, 160, 100, (VBLCOUNTER*3), bkgnd, W_GetNumForName("wrldsafe"));
	if (LastScan !=0)
		goto fadeworld;

	I_Delay(10);
	if (LastScan !=0)
		goto fadeworld;

	WarpSprite (160, 100, 160, -50, (VBLCOUNTER*3), bkgnd, W_GetNumForName("wrldsafe"));
	if (LastScan !=0)
		goto fadeworld;

	I_Delay(20);

fadeworld:
	MenuFadeOut();
	ClearGraphicsScreen();
	MenuFadeIn();


	sky=W_CacheLumpNum(W_GetNumForName("SKYSTART")+2,PU_CACHE);
	tmp=sky;
	for (x=0;x<256;x++)
		{
		VGAWRITEMAP(x&3);
		for (y=0;y<200;y++)
			{
			*((byte *)bufferofs+ylookup[y]+(x>>2))=*tmp++;
			}
		}
	tmp=sky;
	for (x=256;x<320;x++)
		{
		VGAWRITEMAP(x&3);
		for (y=0;y<200;y++)
			{
			*((byte *)bufferofs+ylookup[y]+(x>>2))=*tmp++;
			}
		}

	for(i=0;i<5;i++)
		{
		int tx,ty;

		tx = 32 + (i << 6);
		ty = 100;
		shape = W_GetNumForName(EndCinematicPicNames[i]);
		DrawUnScaledSprite (tx, ty, shape,16);
		}

	PrepareBackground ( bkgnd );

	//CurrentFont = (font_t *)W_CacheLumpName ("newfnt1", PU_CACHE);
	CurrentFont = smallfont;
	LastScan = 0;

	for(i=0;i<NUMENDMESSAGES;i++)
		{
		if (i>3)
			I_Delay(50);

		US_MeasureStr (&width, &height, &(EndCinematicText[i][0]));
		if (LastScan !=0)
			break;

		x=(320-width)>>1;
		y=(200-height)>>1;
		time1 = (300 - y)*(VBLCOUNTER*4)/300;
		time2 = VBLCOUNTER*4-time1;

		WarpString (x, 250, x, y-50,time1, bkgnd, EndCinematicText[i]);
		if (LastScan !=0)
			break;
		I_Delay(40);
		if (LastScan !=0)
			break;

		if (i<=3)
			I_Delay(40);
		if (LastScan !=0)
			break;

		WarpString (x, y-50, x, -50, time2, bkgnd, EndCinematicText[i]);
		if (LastScan !=0)
			break;


		}

	if (LastScan!=0)
	goto finalfade;

	sky=W_CacheLumpNum(W_GetNumForName("SKYSTART")+2,PU_CACHE);
	tmp=sky;
	for (x=0;x<256;x++)
		{
		VGAWRITEMAP(x&3);
		for (y=0;y<200;y++)
			{
			*((byte *)bufferofs+ylookup[y]+(x>>2))=*tmp++;
			}
		}
	tmp=sky;
	for (x=256;x<320;x++)
		{
		VGAWRITEMAP(x&3);
		for (y=0;y<200;y++)
			{
			*((byte *)bufferofs+ylookup[y]+(x>>2))=*tmp++;
			}
		}

	for(i=0;i<5;i++)
		{
		int tx,ty;

		tx = 32 + (i << 6);
		ty = 100;
		shape = W_GetNumForName(EndCinematicPicNames[i]);
		DrawUnScaledSprite (tx, ty, shape,16);
		}


	shape = W_GetNumForName("robogrd3");
	PrepareBackground ( bkgnd );
	WarpSprite (420,100,300,100,VBLCOUNTER*3,bkgnd,shape);
	if (LastScan !=0)
		goto finalfade;

	PrepareBackground ( bkgnd );
	WarpString (200,80,200,80,VBLCOUNTER*3,bkgnd, "Am I late?");
	if (LastScan !=0)
		goto finalfade;


	I_Delay(20);
finalfade:

	MenuFadeOut();
	VL_ClearVideo (0);
	I_Delay(10);

	if (LastScan == 0)
		{
		US_MeasureStr (&width, &height, NextGameString1);
		x=(320-width)>>1;
		y=(200-height)>>1;
		US_ClippedPrint (x,y-6, NextGameString1);
		US_MeasureStr (&width, &height, NextGameString2);
		x=(320-width)>>1;
		y=(200-height)>>1;
		US_ClippedPrint (x,y+6, NextGameString2);
		FlipPage();
		VL_FadeIn(0,255,origpal,150);
		I_Delay(50);
		VL_FadeOut(0,255,0,0,0,150);
		VL_ClearVideo (0);
		I_Delay(10);
		}

	SafeFree(bkgnd);
}
#else

// REGISTERED VERSION ======================================================

static char	burnCastle1Msg []=
		"The monastery burns.\n"
		"\n"
		"El Oscuro is dead.\n"
		"\n"
		"The world is safe.\n";

// If all Snake Eggs not destroyed on final level:


static char	notDoneMsg[] =
			"Unfortunately not all\n"
			"of El Oscuro's larvae\n"
			"were destroyed.\n"
			"\n"
			"Thirty years later,\n"
			"a descendant of\n"
			"El Oscuro wiped out\n"
			"the entire world,\n"
			"but nice job anyway.\n";

static char	tryAgainMsg[] =
			"Try Again.\n"
			"\n"
			"The world will not be\n"
			"safe until all of El\n"
			"Oscuro's larvae are\n"
			"destroyed. Find them.\n";

// If all snake eggs destroyed:
static char	doneMsg[] =
			"You have destroyed\n"
			"El Oscuro and all his\n"
			"descendants.  Well done!\n";

// On Triad background, in bigger font.
static char	youWin1Msg[] =
		"So, HUNT Members, how\n"
		"do you think the\n"
		"mission went?\n";

// Place menu pix of characters here (maybe modem frame too?)
static char	youWin2Msg[] =
		"Barrett: Well, I think\n"
		"I got shin splints from\n"
		"all those jump pads.\n"
		"But hey, action-wise,\n"
		"I've been in tougher\n"
		"bar fights, for crying\n"
		"out loud.\n";

static char	youWin3Msg[] =
		"Cassatt: Apart from\n"
		"the other HUNT members\n"
		"saying I look like\n"
		"Richard Mulligan, it\n"
		"was quite a success.\n"
		"And some of the\n"
		"monastery's ironwork\n"
		"was very nice.\n";

static char	youWin4Msg[] =
		"Ni: it was quite easy,\n"
		"actually.  I just\n"
		"pictured the enemy\n"
		"having the face of\n"
		"my ex-husband, and\n"
		"man, I was a force\n"
		"of Nature.\n";

static char	youWin5Msg[] =
		"Wendt: I was kind of\n"
		"disappointed. I think\n"
		"I used the missile\n"
		"weapons way too much.\n"
		"Next time, bullets\n"
		"only.  Nothing sweeter\n"
		"than a head shot from\n"
		"a hundred feet.\n";

static char	youWin6Msg[] =
		"Freeley: I'm still\n"
		"trying to adjust in\n"
		"the aftermath.  It's\n"
		"kinda tough.  I mean,\n"
		"I save the damn world,\n"
		"and all people ask\n"
		"about is my name.\n"
		"Sheesh.\n";

// On caching screen

static char	youWin7Msg[] =
			"The HUNT is victorious!\n"
			"\n"
			"			THE END\n";


static char	youWin8Msg[] =
			"Now go and celebrate!\n"
			"\n"
			"		THE REAL END";

#define NUMEXPLOSIONTYPES 4

typedef struct {
  char  name[11];
  byte  numframes;
} ExplosionInfoType;

ExplosionInfoType ExplosionInfo[NUMEXPLOSIONTYPES]=
{
  {"EXPLOS1\0",20},
  {"EXP1\0",20},
  {"GREXP1\0",25},
  {"PART1\0",12},
#if 0
  {"GUTS1\0",12},
  {"ORGAN1\0",12},
  {"RIB1\0",12},
  {"GPINK1\0",12},
  {"GHEAD1\0",12},
  {"GARM1\0",12},
  {"GLEG1\0",12},
  {"GHUM1\0",12},
  {"GHIP1\0",12},
  {"GLIMB1\0",12},
#endif
};


typedef struct {
  byte  which;
  byte  frame;
  byte  x;
  byte  y;
} ExplosionType;

#define MAXTRANSMITTEREXPLOSIONS 30

static ExplosionType Explosions[MAXTRANSMITTEREXPLOSIONS];

void ResetTransmitterExplosion ( ExplosionType * Explosion )
{
	Explosion->which=RandomNumber("Explosion",0)%NUMEXPLOSIONTYPES;
	Explosion->frame=0;
	Explosion->x=(RandomNumber("Explosion",2)>>1)+(160-64);
	Explosion->y=(RandomNumber("Explosion",3)>>1);
}

void CacheTransmitterExplosions ( void )
{
	int i,j,num;

	for (i=0;i<NUMEXPLOSIONTYPES;i++)
		{
		num=W_GetNumForName(ExplosionInfo[i].name);
		for (j=0;j<ExplosionInfo[i].numframes;j++)
			{
			W_CacheLumpNum(num+j,PU_CACHE);		//explosions
			}
		}
}

void SetupTransmitterExplosions ( void )
{
	int i;

	for (i=0;i<MAXTRANSMITTEREXPLOSIONS;i++)
		{
		ResetTransmitterExplosion(&Explosions[i]);
		}
}
void UpdateTransmitterExplosions ( void )
{
	int i;
	for (i=0;i<MAXTRANSMITTEREXPLOSIONS;i++)
		{
		Explosions[i].frame+=tics;
		if (Explosions[i].frame>=(ExplosionInfo[Explosions[i].which].numframes<<1))
			{
			ResetTransmitterExplosion(&Explosions[i]);
			SD_Play(SD_EXPLODEFLOORSND+(RandomNumber("Explosion",4)>>7));
			}
		}
}

void DrawTransmitterExplosions ( void )
{
	int i;
	for (i=0;i<MAXTRANSMITTEREXPLOSIONS;i++)
		{
		DrawUnScaledSprite (
							Explosions[i].x,
							Explosions[i].y,
//							(W_GetNumForName(&ExplosionInfo[Explosions[i].which].name) +
							(W_GetNumForName(ExplosionInfo[Explosions[i].which].name) +
							(Explosions[i].frame>>1)),
							16
							);
		}
}

void DoTransmitterExplosion ( void )
{
	byte * back;
	int i;

	VL_ClearVideo(0);
	back=SafeMalloc(800*linewidth);

	CalcTics();
	CalcTics();
	DrawNormalSprite(0,0,W_GetNumForName("transmit"));
	PrepareBackground ( back );
	SetupTransmitterExplosions ();
	CacheTransmitterExplosions ();
	DrawBackground ( back );
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	SHAKETICS=VBLCOUNTER*15;
	for (i=0;i<(VBLCOUNTER*15);i+=tics)
		{
		DrawBackground ( back );
		DrawTransmitterExplosions ();
		FlipPage();
		CalcTics();
		UpdateTransmitterExplosions ();
		}
	VL_FadeOut (0, 255, 63, 63, 63, 150);
	screenfaded=false;
	SD_Play(SD_PLAYERTCSND);
	SD_Play(SD_PLAYERTBSND);
	SD_Play(SD_PLAYERDWSND);
	SD_Play(SD_PLAYERLNSND);
	SD_Play(SD_PLAYERIPFSND);
	VL_FadeOut (0, 255, 0, 0, 0, 30);
	TurnShakeOff();

	SafeFree(back);
}

void ShowTransmitter ( void )
{
	MenuFadeOut();
	DrawNormalSprite(0,0,W_GetNumForName("transmit"));
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	I_Delay(30);
	VL_FadeOut (0, 255, 0, 0, 0, 30);
}

void ShowFinalDoor ( void )
{
	byte pal[768];

	MenuFadeOut();

	VL_ClearBuffer (bufferofs, 0);
	DrawNormalSprite (0, (200-120)>>1, W_GetNumForName("finldoor"));
	FlipPage();
	memcpy(&pal[0],W_CacheLumpName("findrpal",PU_CACHE),768);
	VL_NormalizePalette(&pal[0]);
	SD_Play(SD_OPENDOORSND);
	VL_FadeIn (0, 255, pal, 30);
	I_Delay(30);
	VL_FadeOut (0, 255, 0, 0, 0, 30);
}

void ShowFinalFire ( void )
{
	byte pal[768];

	MenuFadeOut();

	VL_ClearBuffer (bufferofs, 0);
	DrawNormalSprite (0, (200-120)>>1, W_GetNumForName("finlfire"));
	FlipPage();
	memcpy(&pal[0],W_CacheLumpName("finfrpal",PU_CACHE),768);
	VL_NormalizePalette(&pal[0]);
	SD_Play(SD_BAZOOKAFIRESND);
	VL_FadeIn (0, 255, pal, 30);
	SD_Play(SD_FIREBOMBFIRESND);
	I_Delay(2);
	SD_Play(SD_HEATSEEKFIRESND);
	I_Delay(2);
	SD_Play(SD_DRUNKFIRESND);
	SD_Play(SD_HEATSEEKFIRESND);
	I_Delay(2);
	SD_Play(SD_ATKMP40SND);
	SD_Play(SD_ATKMP40SND);
	I_Delay(2);
	SD_Play(SD_HEATSEEKFIRESND);
	SD_Play(SD_FIREBOMBFIRESND);
	I_Delay(2);
	SD_Play(SD_ATKMP40SND);
	SD_Play(SD_HEATSEEKFIRESND);
	I_Delay(2);
	SD_Play(SD_DRUNKFIRESND);
	I_Delay(2);
	SD_Play(SD_FIREBOMBFIRESND);
	I_Delay(2);
	SD_Play(SD_HEATSEEKFIRESND);
	SD_Play(SD_ATKMP40SND);
	I_Delay(2);
	SD_Play(SD_DRUNKFIRESND);
	SD_Play(SD_HEATSEEKFIRESND);
	I_Delay(2);
	SD_Play(SD_FIREBOMBFIRESND);
	SD_Play(SD_ATKMP40SND);
	I_Delay(2);
	SD_Play(SD_DRUNKFIRESND);
	I_Delay(2);
	SD_Play(SD_HEATSEEKFIRESND);
	SD_Play(SD_FIREBOMBFIRESND);
	I_Delay(2);
	SD_Play(SD_ATKMP40SND);
	SD_Play(SD_HEATSEEKFIRESND);
	I_Delay(2);
	SD_Play(SD_DRUNKFIRESND);
	SD_Play(SD_FIREBOMBFIRESND);
	I_Delay(2);
	SD_Play(SD_HEATSEEKFIRESND);
	SD_Play(SD_DRUNKFIRESND);
	SD_Play(SD_BAZOOKAFIRESND);
	I_Delay(4);
	VL_FadeOut (0, 255, 0, 0, 0, 30);
}

void ScrollString ( int cy, char * string, byte * bkgnd, int scrolltime, int pausetime )
{
	int x,y;
	int width,height;
	int time1,time2;

	LastScan=0;
	US_MeasureStr (&width, &height, string);

	x=(320-width)>>1;
	y=cy-(height>>1);
	time1 = ((220 - y)*scrolltime)/(220+height);
	time2 = scrolltime-time1;

	WarpString (x, 210, x, y, time1, bkgnd, string);

	if (LastScan !=0)
		return;

	I_Delay(pausetime);

	if (LastScan !=0)
		return;

	WarpString (x, y, x, -10-height, time2, bkgnd, string);
}

void DoBurningCastle ( void )
{
	byte * back;

	LastScan=0;
	VL_ClearVideo(0);
	back=SafeMalloc(800*linewidth);

	DrawNormalSprite(0,0,W_GetNumForName("finale"));
	PrepareBackground ( back );
	CurrentFont = smallfont;
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	CurrentFont = (font_t *)W_CacheLumpName ("newfnt1", PU_STATIC);
	ScrollString ( 150, &burnCastle1Msg[0], back, 4*VBLCOUNTER, 80);
	W_CacheLumpName ("newfnt1", PU_CACHE);
	VL_FadeOut (0, 255, 0, 0, 0, 80);
	SafeFree(back);
}

void DoFailedScreen ( void )
{
	byte * back;

	back=SafeMalloc(800*linewidth);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	PrepareBackground ( back );
	CurrentFont = smallfont;
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	ScrollString ( 100, &notDoneMsg[0], back, 4*VBLCOUNTER, 100);
	VL_FadeOut (0, 255, 0, 0, 0, 80);
	SafeFree(back);
}

void DoTryAgainScreen ( void )
{
	byte * back;

	back=SafeMalloc(800*linewidth);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	PrepareBackground ( back );
	CurrentFont = smallfont;
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	ScrollString ( 100, tryAgainMsg, back, 4*VBLCOUNTER, 80);
	VL_FadeOut (0, 255, 0, 0, 0, 80);
	SafeFree(back);
}

void ResetWorldExplosion ( ExplosionType * Explosion )
{
	Explosion->which=RandomNumber("Explosion",0)%NUMEXPLOSIONTYPES;
	Explosion->frame=0;
//	RandomNumber("Explosion",1)%ExplosionInfo[Explosions[i].which].numframes;
	Explosion->x=(RandomNumber("Explosion",2))+64;
	Explosion->y=(RandomNumber("Explosion",3)%180);
}

void SetupWorldExplosions ( void )
{
	int i;

	for (i=0;i<MAXTRANSMITTEREXPLOSIONS;i++)
		{
		ResetWorldExplosion(&Explosions[i]);
		}
}
void UpdateWorldExplosions ( void )
{
	int i;
	for (i=0;i<MAXTRANSMITTEREXPLOSIONS;i++)
		{
		Explosions[i].frame+=tics;
		if (Explosions[i].frame>=(ExplosionInfo[Explosions[i].which].numframes<<1))
			{
			ResetWorldExplosion(&Explosions[i]);
			SD_Play(SD_EXPLODEFLOORSND+(RandomNumber("Explosion",4)>>7));
			}
		}
}

void DestroyEarth ( void )
{
	byte * back;
	int i;

	VL_ClearVideo(0);
	back=SafeMalloc(800*linewidth);

	CalcTics();
	CalcTics();
	DrawNormalSprite(0,0,W_GetNumForName("ourearth"));
	PrepareBackground ( back );
	SetupWorldExplosions ();
	CacheTransmitterExplosions ();
	DrawBackground ( back );
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	SHAKETICS=VBLCOUNTER*10;
	for (i=0;i<(VBLCOUNTER*10);i+=tics)
		{
		DrawBackground ( back );
		DrawTransmitterExplosions ();
		FlipPage();
		CalcTics();
		UpdateWorldExplosions ();
		}
	VL_FadeOut (0, 255, 63, 63, 63, 150);
	screenfaded=false;
	if (gamestate.violence==vl_excessive)
		SD_Play(SD_YOUSUCKSND);
	VL_FadeOut (0, 255, 0, 0, 0, 50);
	TurnShakeOff();

	SafeFree(back);
}

boolean DestroyedAllEggs ( void )
{
	statobj_t * temp;

	for(temp=FIRSTSTAT;temp;temp=temp->statnext)
		{
		if (temp->itemnumber==stat_tomlarva)
			return false;
		}
	return true;
}

void DoSanNicolas ( void )
{
	byte pal[768];

	LastScan=0;
	VL_ClearVideo(0);
	DrawNormalSprite(0,16,W_GetNumForName("nicolas"));
	DrawNormalSprite(10,200-58,W_GetNumForName("budgcut"));
	FlipPage();
	memcpy(&pal[0],W_CacheLumpName("nicpal",PU_CACHE),768);
	VL_NormalizePalette(&pal[0]);
	VL_FadeIn (0, 255, pal, 30);
	I_Delay(60);
	VL_FadeOut (0, 255, 0, 0, 0, 80);
}

void PlayerQuestionScreen ( void )
{
	byte * back;

	back=SafeMalloc(800*linewidth);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	PrepareBackground ( back );
	CurrentFont = smallfont;
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	CurrentFont = (font_t *)W_CacheLumpName ("newfnt1", PU_STATIC);
	ScrollString ( 100, &doneMsg[0], back, 4*VBLCOUNTER, 40);
	ScrollString ( 100, &youWin1Msg[0], back, 4*VBLCOUNTER, 50);
	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawXYPic ( 8, 100-24, W_GetNumForName("player2"));
	PrepareBackground ( back );
	CurrentFont = smallfont;
	SD_Play(SD_PLAYERTBSND);
	ScrollString ( 100, &youWin2Msg[0], back, 4*VBLCOUNTER, 100);
	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawXYPic ( 8, 100-24, W_GetNumForName("player1"));
	PrepareBackground ( back );
	SD_Play(SD_PLAYERTCSND);
	ScrollString ( 100, &youWin3Msg[0], back, 4*VBLCOUNTER, 100);
	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawXYPic ( 8, 100-24, W_GetNumForName("player4"));
	PrepareBackground ( back );
	SD_Play(SD_PLAYERLNSND);
	ScrollString ( 100, &youWin4Msg[0], back, 4*VBLCOUNTER, 100);
	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawXYPic ( 8, 100-24, W_GetNumForName("player3"));
	PrepareBackground ( back );
	SD_Play(SD_PLAYERDWSND);
	ScrollString ( 100, &youWin5Msg[0], back, 4*VBLCOUNTER, 100);
	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawXYPic ( 8, 100-24, W_GetNumForName("player5"));
	PrepareBackground ( back );
	SD_Play(SD_PLAYERIPFSND);
	ScrollString ( 100, &youWin6Msg[0], back, 4*VBLCOUNTER, 100);
	W_CacheLumpName ("newfnt1", PU_CACHE);
	VL_FadeOut (0, 255, 0, 0, 0, 80);
	SafeFree(back);
}

void DoYouWin ( void )
{
	pic_t * pic;
	byte * back;

	back=SafeMalloc(800*linewidth);
	LastScan=0;
	VL_ClearVideo(0);
	pic = (pic_t *) W_CacheLumpNum (W_GetNumForName ("mmbk"), PU_CACHE);
	VWB_DrawPic (0, 0, pic);
	PrepareBackground ( back );
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	CurrentFont = (font_t *)W_CacheLumpName ("newfnt1", PU_STATIC);
	ScrollString ( 100, &youWin7Msg[0], back, 4*VBLCOUNTER, 300);
	W_CacheLumpName ("newfnt1", PU_CACHE);
	VL_FadeOut (0, 255, 0, 0, 0, 80);
	SafeFree(back);
}

void DoFinalEnd ( void )
{
	pic_t * pic;
	byte * back;

	back=SafeMalloc(800*linewidth);
	LastScan=0;
	VL_ClearVideo(0);
	pic = (pic_t *) W_CacheLumpNum (W_GetNumForName ("mmbk"), PU_CACHE);
	VWB_DrawPic (0, 0, pic);
	DrawNormalSprite(0,0,W_GetNumForName("sombrero"));
	DrawNormalSprite(0,0,W_GetNumForName("amflag"));
	DrawNormalSprite(0,0,W_GetNumForName("witchhat"));
	DrawNormalSprite(0,0,W_GetNumForName("esterhat"));
	DrawNormalSprite(0,0,W_GetNumForName("santahat"));
	PrepareBackground ( back );
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	CurrentFont = (font_t *)W_CacheLumpName ("newfnt1", PU_STATIC);
	ScrollString ( 100, &youWin8Msg[0], back, 4*VBLCOUNTER, 100);
	W_CacheLumpName ("newfnt1", PU_CACHE);
	VL_FadeOut (0, 255, 0, 0, 0, 80);
	SafeFree(back);
	VL_ClearVideo(0);
}

static char	dipMsg[] =
			"The Developers of Incredible Power!\n"
			"\n"
			"Susan  Tom  Jim  Stephen\n"
			"Mark  William  Chuck\n";

static char	creditsMsg[] =
			"Rise of the Triad Credits\n";

static char	credits1Msg[] =
			"Programmers\n"
			"\n"
			"Mark Dochtermann\n"
			"William Scarboro\n"
			"Jim Dose'\n"
			"Nolan Martin\n";

static char	credits2Msg[] =
			"Creative Director\n"
			"\n"
			"Tom Hall\n";

static char	credits3Msg[] =
			"Artists\n"
			"\n"
			"Stephen Hornback\n"
			"Tim Neveu\n"
			"Chuck Jones\n"
			"Susan Singer\n"
			"James Storey\n"
			"Cygnus Multimedia\n";

static char	credits4Msg[] =
			"Level Designers\n"
			"\n"
			"Tom Hall\n"
			"Joseph Selinske\n"
			"Marianna Vayntrub\n"
			"Joe Siegler\n";
static char	credits5Msg[] =
			"Music\n"
			"\n"
			"Lee Jackson\n"
			"Bobby Prince\n";

static char	credits6Msg[] =
			"Robot Models\n"
			"\n"
			"Gregor Punchatz\n";

static char	credits7Msg[] =
			"Special Thanks\n"
			"\n"
			"George Broussard\n"
			"Scott Miller\n"
			"Steven Blackburn\n"
			"Apogee Technical Support\n"
			"Apogee Support Staff\n"
			"John Carmack\n"
			"Ken Silverman\n";

static char	credits8Msg[] =
			"The Hand of God\n"
			"\n"
			"Tim Neveu's Hand\n";

static char	credits9Msg[] =
			"Dog Snout and Paw\n"
			"\n"
			"Loki\n"
			"The Carpet Wetting Maestro\n";

static char	credits10Msg[] =
			"Krist's chair\n"
			"\n"
			"Stephen Blackburn's Comfy Chair\n"
			"Marianna's Paper and Glue\n";

static char	credits11Msg[] =
			"Character Voices\n"
			"\n"
			"Darian - Mark Dochtermann\n"
			"Krist - Joe Siegler\n"
			"NME - Sound CD#4005\n"
			"Oscuro - Tom Hall\n"
			"Low Guard - Steve Quarrella\n"
			"High Guard - Steven Blackburn\n"
			"Over Patrol - Chuck Jones\n";

static char	credits12Msg[] =
			"Character Voices Continued\n"
			"\n"
			"Strike Team - Scott Miller\n"
			"Lightning Guard - William Scarboro\n"
			"Triad Enforcer - George Broussard\n"
			"All Monks - Tom Hall\n"
			"Taradino - Joe Selinske\n"
			"Lorelei - Pau Suet Ying\n"
			"Ian Paul - Jim Dose'\n"
			"Doug - Lee Jackson\n"
			"Thi - Susan Singer\n";

static char	actorsMsg[] =
			"The Actors\n";

static char	actors1Msg[] =
			"Low Guard\n"
			"\n"
			"Steve Quarrella\n";

static char	actors2Msg[] =
			"High Guard\n"
			"\n"
			"Steven Blackburn\n";

static char	actors3Msg[] =
			"Over Patrol\n"
			"\n"
			"Nolan Martin\n";

static char	actors4Msg[] =
			"Strike Team\n"
			"\n"
			"Scott Miller\n";

static char	actors5Msg[] =
			"Lightning Guard\n"
			"\n"
			"Kevin Green\n";

static char	actors6Msg[] =
			"Triad Enforcer\n"
			"\n"
			"George Broussard\n";

static char	actors7Msg[] =
			"Death Monk\n"
			"\n"
			"Lee Jackson\n";

static char	actors8Msg[] =
			"Deathfire Monk\n"
			"\n"
			"Allen Blum III\n";

static char	actors9Msg[] =
			"Robot Guard\n"
			"\n"
			"Himself\n";

static char	actors10Msg[] =
			"General Darian\n"
			"\n"
			"Steve Maines\n";

static char	actors11Msg[] =
			"Sebastian Krist\n"
			"\n"
			"Joe Siegler\n";

static char	actors12Msg[] =
			"The NME\n"
			"\n"
			"Himself\n";

static char	actors13Msg[] =
			"El Oscuro\n"
			"\n"
			"Tom Hall\n";


static char	cut1Msg[] =
			"Deathfire Monk\n"
			"\n"
			"Mark Dochtermann\n";


static char	cut2Msg[] =
			"Over Patrol\n"
			"\n"
			"Pat Miller\n";


static char	cut3Msg[] =
			"Low Guard\n"
			"\n"
			"Marianna Vayntrub\n";


static char	cut4Msg[] =
			"Strike Team\n"
			"\n"
			"Ann Grauerholz\n";

static char	cut5Msg[] =
			"Lightning Guard\n"
			"\n"
			"William Scarboro\n";


static char	cut6Msg[] =
			"High Guard\n"
			"\n"
			"Stephen Hornback\n";



static char	playersCutMsg[] =
			"Actors who were\n"
			"cut from the game\n";

void DIPCredits ( void )
{
	byte * back;

	back=SafeMalloc(800*linewidth);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	PrepareBackground ( back );
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	CurrentFont = (font_t *)W_CacheLumpName ("newfnt1", PU_STATIC);
	ScrollString ( 100, &creditsMsg[0], back, 4*VBLCOUNTER, 30);
	CurrentFont = smallfont;
	ScrollString ( 100, &credits1Msg[0], back, 4*VBLCOUNTER, 50);
	ScrollString ( 100, &credits2Msg[0], back, 4*VBLCOUNTER, 50);
	ScrollString ( 100, &credits3Msg[0], back, 4*VBLCOUNTER, 50);
	ScrollString ( 100, &credits4Msg[0], back, 4*VBLCOUNTER, 50);
	ScrollString ( 100, &credits5Msg[0], back, 4*VBLCOUNTER, 50);
	ScrollString ( 100, &credits6Msg[0], back, 4*VBLCOUNTER, 50);
	ScrollString ( 100, &credits7Msg[0], back, 4*VBLCOUNTER, 50);
	ScrollString ( 100, &credits8Msg[0], back, 4*VBLCOUNTER, 50);
	ScrollString ( 100, &credits9Msg[0], back, 4*VBLCOUNTER, 50);
	ScrollString ( 100, &credits10Msg[0], back, 4*VBLCOUNTER, 50);
	ScrollString ( 100, &credits11Msg[0], back, 4*VBLCOUNTER, 80);
	ScrollString ( 100, &credits12Msg[0], back, 4*VBLCOUNTER, 80);

	CurrentFont = (font_t *)W_CacheLumpName ("newfnt1", PU_STATIC);
	ScrollString ( 100, &actorsMsg[0], back, 4*VBLCOUNTER, 50);

	CurrentFont = smallfont;
	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("lwgshoo2"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors1Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("hg2shoo2"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors2Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("obpshoo1"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors3Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("ankshoo1"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors4Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("ligrise4"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors5Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("tritoss5"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors6Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("monkdr4"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors7Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("allksh4"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors8Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("robogrd1"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors9Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("darshoo1"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors10Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("hdope8"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors11Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("rbody101"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("rhead101"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("rsw01"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors12Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("tomfly21"));
	PrepareBackground ( back );
	ScrollString ( 100, &actors13Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	PrepareBackground ( back );
	CurrentFont = (font_t *)W_CacheLumpName ("newfnt1", PU_STATIC);
	ScrollString ( 100, &playersCutMsg[0], back, 4*VBLCOUNTER, 40);

	CurrentFont = smallfont;
	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("cutmark"));
	PrepareBackground ( back );
	ScrollString ( 100, &cut1Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("cutpat"));
	PrepareBackground ( back );
	ScrollString ( 100, &cut2Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("cutmari"));
	PrepareBackground ( back );
	ScrollString ( 100, &cut3Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("cutann"));
	PrepareBackground ( back );
	ScrollString ( 100, &cut4Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("cutwill"));
	PrepareBackground ( back );
	ScrollString ( 100, &cut5Msg[0], back, 4*VBLCOUNTER, 50);

	VL_DrawPostPic (W_GetNumForName("trilogo"));
	DrawNormalSprite(0,(200-128)>>1,W_GetNumForName("cutstev"));
	PrepareBackground ( back );
	ScrollString ( 100, &cut6Msg[0], back, 4*VBLCOUNTER, 50);

	VL_FadeOut (0, 255, 0, 0, 0, 80);

	DrawNormalSprite(0,0,W_GetNumForName("grouppic"));
	PrepareBackground ( back );
	FlipPage();
	VL_FadeIn (0, 255, origpal, 30);
	ScrollString ( 175, &dipMsg[0], back, 4*VBLCOUNTER, 140);
	VL_FadeOut (0, 255, 0, 0, 0, 80);

	W_CacheLumpName ("newfnt1", PU_CACHE);
	SafeFree(back);
}

void DoEndCinematic ( void )
{
	viewwidth = MAXSCREENWIDTH;
	viewheight = MAXSCREENHEIGHT;
	MU_FadeOut ( 1000 );
	MU_StopSong ();

	ShowFinalDoor();
	ShowTransmitter ();
	ShowFinalFire();
	DoTransmitterExplosion();
	MU_StartSong(song_youwin);
	DoBurningCastle ();
	DoSanNicolas();
	if (DestroyedAllEggs () == true)
		{
		PlayerQuestionScreen();
		DIPCredits();
		DoYouWin();
		if (LastScan !=0)
			{
			IN_UpdateKeyboard();
			return;
			}
		DoFinalEnd();
		}
	else
		{
		MU_StartSong(song_gameover);
		DoFailedScreen();
		DestroyEarth();
		DoTryAgainScreen ();
		playstate=ex_warped;
		gamestate.mapon=33;
		}
	IN_UpdateKeyboard();
}

void DoInBetweenCinematic (int yoffset, int lump, int delay, char * string )
{
	int width,height;
	int x,y;

	VL_FadeOut (0, 255, 0, 0, 0, 20);
	VL_ClearBuffer (bufferofs, 0);
	DrawNormalSprite(0,yoffset,lump);

	CurrentFont=smallfont;
	US_MeasureStr (&width, &height, string);
	x=(320-width)>>1;
	y=190-height;
	US_ClippedPrint (x, y, string);
	FlipPage();
	VL_FadeIn(0,255,origpal,20);
	I_Delay (delay);
	VL_FadeOut (0, 255, 0, 0, 0, 20);
}
#endif


//******************************************************************************
//
// DoCreditScreen
//
//******************************************************************************

#define NUMFIRSTCREDITMESSAGES 22
#define NUMSECONDCREDITMESSAGES 28

typedef struct CreditType {
  char  text[80];
  byte  font;
  byte  endy;
} CreditType;

CreditType FirstCredits[NUMFIRSTCREDITMESSAGES] =
  {
	{"Rise of the Triad Credits",0,0},
	{"COPYRIGHT (c) 1995 Apogee Software Ltd.",1,10},
	{"Apogee's Developers of Incredible Power",1,20},
	{"Creative Director",0,30},
	{"Tom Hall",1,40},
	{"Programmers",0,50},
	{"Mark Dochtermann  William Scarboro",1,60},
	{"Jim Dose'  Nolan Martin",1,66},
	{"Artists",0,76},
	{"Stephen Hornback  Chuck Jones",1,86},
	{"Susan Singer  Tim Neveu",1,92},
	{"James Storey  Cygnus Multimedia",1,98},
	{"Level Designers",0,108},
	{"Joseph Selinske  Tom Hall",1,118},
	{"Marianna Vayntrub  Joe Siegler",1,124},
	{"Musicians",0,134},
	{"Lee Jackson  Robert Prince",1,144},
	{"Uniforms",0,154},
	{"D.J. Goodwin  Matt McKinney",1,164},
	{"Special Thanks",0,174},
	{"John Carmack  Ken Silverman  Gregor Punchatz",1,184},
  };

CreditType SecondCredits[NUMSECONDCREDITMESSAGES] =
  {
	{"Rise of the Triad Credits",0,0},
	{"COPYRIGHT (c) 1995 Apogee Software Ltd.",1,10},
	{"Executive Producers",0,20},
	{"George Broussard  Scott Miller",1,30},
	{"Manual Design",0,40},
	{"Robert Atkins",1,50},
	{"Beta Testers",0,60},
	{"Steven Blackburn",1,70},
	{"Todd Aubin  Mike Bartelt",1,76},
	{"Wayne Benner  Neil Bonner",1,82},
	{"Glenn Brensinger  Douglas Brewer",1,88},
	{"David Butler  Daniel Creeron",1,94},
	{"Scott Darling  Jason Ewasiuk",1,100},
	{"Craig Hamilton  Ken Heckbert",1,106},
	{"Terry Herrin  Greg Hively",1,112},
	{"John Howard  Douglas Howell",1,118},
	{"Dennis Kurek  Hank Leukart",1,124},
	{"Jim Lietzan  Ken Mayer",1,130},
	{"Wayne Millard  Penny Plant",1,136},
	{"Brian Prinner  Jeff Rausch",1,142},
	{"Kelly Rogers  Neil Rubenking",1,148},
	{"Steven Salter  Chris White",1,154},
	{"Special Thanks",0,162},
	{"Apogee Technical Support  Pau Suet Ying",1,172},
	{"Anthony, Zach, Rajan, Miki, Loki",1,178},
	{"Nathan, Petro, Tim, Jake, MacKay",1,184},
	{"Loyal, Ric, Teller, Amano",1,190},
  };

void DrawPreviousCredits ( int num, CreditType * Credits )
{
	int width;
	int height;
	int x,y;
	int i;

	for(i=0;i<num;i++)
		{
		if (Credits[i].font==0)
			CurrentFont=smallfont;
		else
			CurrentFont=tinyfont;
		US_MeasureStr (&width, &height, &(Credits[i].text[0]));
		x=(320-width)>>1;
		y=Credits[i].endy;
		US_ClippedPrint (x, y+4, &Credits[i].text[0]);
		}
}

#define CREDITSTARTY 220
//******************************************************************************
//
// WarpCreditString
//
//******************************************************************************

extern boolean dopefish;
void WarpCreditString ( int time, byte * back, int num, CreditType * Credits)
{
	int dy;
	int cy;
	int x;
	int y;
	int width;
	int height;
	boolean soundplayed;


	LastScan = 0;

	if (Credits[num].font==0)
		CurrentFont=smallfont;
	else
		CurrentFont=tinyfont;
	US_MeasureStr (&width, &height, &(Credits[num].text[0]));

	x=(320-width)>>1;
	y=Credits[num].endy;
	dy=((y-CREDITSTARTY)<<16)/time;
	cy=CREDITSTARTY<<16;

	CalcTics();

	soundplayed=false;

	while (time>0)
		{
		DrawBackground ( back );
		DrawPreviousCredits ( num, Credits );
		if (Credits[num].font==0)
			CurrentFont=smallfont;
		else
			CurrentFont=tinyfont;
		US_ClippedPrint (x, (cy>>16)+4, &Credits[num].text[0]);
		if ( ((cy>>16)<196) && (soundplayed==false))
			{
			if ((dopefish==true) && (SD_Started==true))
				{
				int snd;

				do
					{
					snd=(RandomNumber("DoCredits",0)+RandomNumber("DoCredits",0))%MAXSOUNDS;
					}
				while (SD_SoundOkay ( snd ) == false);
				SD_Play ( snd );
				}
			else
				{
//				SD_Play ( SD_BAZOOKAFIRESND );
#if (SHAREWARE == 0)
				SD_Play ( SD_BAZOOKAFIRESND + (RandomNumber("DoCredits",1)%13) );
#else
				SD_Play ( SD_BAZOOKAFIRESND + (RandomNumber("DoCredits",1)%6) );
#endif
				soundplayed=true;
				}
			}
		FlipPage();
		CalcTics();
		cy+=dy*tics;
		time-=tics;
		if (LastScan != 0)
			break;
		}
}

void DoCreditScreen ( void )
{
	int trilogo;
	int time;
	byte * bkgnd;
	font_t * oldfont;
	int i;

	viewwidth = MAXSCREENWIDTH;
	viewheight = MAXSCREENHEIGHT;

	bkgnd=SafeMalloc(800*linewidth);
	trilogo=W_GetNumForName("trilogo");
	VL_DrawPostPic (trilogo);
	PrepareBackground ( bkgnd );

	oldfont=CurrentFont;

	for(i=0;i<NUMFIRSTCREDITMESSAGES;i++)
		{
		time = (CREDITSTARTY - FirstCredits[i].endy)*(VBLCOUNTER*1)/CREDITSTARTY;
//		time = VBLCOUNTER;
		WarpCreditString ( time, bkgnd, i, FirstCredits );
//		SD_Play ( SD_EXPLODESND );
		if (LastScan !=0)
			break;
		}
	i=NUMFIRSTCREDITMESSAGES;
	DrawBackground ( bkgnd );
	DrawPreviousCredits ( i, FirstCredits );
	FlipPage();

	I_Delay(40);

	for(i=0;i<NUMSECONDCREDITMESSAGES;i++)
		{
		time = (CREDITSTARTY - SecondCredits[i].endy)*(VBLCOUNTER/2)/CREDITSTARTY;
//		time = VBLCOUNTER;
		WarpCreditString ( time, bkgnd, i, SecondCredits );
//		SD_Play ( SD_EXPLODESND );
		if (LastScan !=0)
			break;
		}
	i=NUMSECONDCREDITMESSAGES;
	DrawBackground ( bkgnd );
	DrawPreviousCredits ( i, SecondCredits );
	FlipPage();

	I_Delay(40);
	MenuFadeOut();
	VL_ClearVideo (0);

	SafeFree(bkgnd);
	CurrentFont=oldfont;
}


#define NUMSTORYLINES 16

char * MicroStory[NUMSTORYLINES] =
	{
	"You are a member of HUNT, the",
	"High-Risk United Nations Taskforce.",
	"Stranded on an island in the",
	"Pacific, you must battle a master",
	"of pyrotechnics, hundreds of",
	"members of a death cult, and their",
	"leader, El Oscuro.",
	"\0",
	"You must reach the transmitter",
	"that is signalling the systematic",
	"destruction of Los Angeles.",
	"\0",
	"If you fail, millions will die",
	"and you will be tortured.",
	"\0",
	"So, you know, don't fail."
	};

void DoMicroStoryScreen ( void )
{
	pic_t * pic;
	int x,y;
	int i;

	VL_FadeOut (0, 255, 0, 0, 0, 20);

	pic=(pic_t *)W_CacheLumpName("mmbk",PU_CACHE);
	VWB_DrawPic (0, 0, pic);
	CheckHolidays();

	x=15;
	y=30;

	IFont = ( cfont_t * )W_CacheLumpName( "sifont", PU_CACHE );
	for(i=0;i<NUMSTORYLINES;i++)
		{
		DrawIntensityString (x, y, MicroStory[i], 241);
		y += 9;
		}

	FlipPage();
	MenuFadeIn();
	I_Delay (280);

	VL_FadeOut (0, 255, 0, 0, 0, 20);
}




#if 0















































typedef struct {
  int	x;
  int	y;
  int	angle;
  int	speed;
  int	color;
  int	endx;
  int	endy;
  int	plane;
  int	time;
} ParticleType;

#define NUMPARTICLES 300
#define PARTICLETHINKTIME 5
#define Fix(a)		(a &= (FINEANGLES-1))
ParticleType * Particle;
int numparticles;

//******************************************************************************
//
// InitializeParticles
//
//******************************************************************************

void InitializeParticles (void)
{
	int i;
	ParticleType * part;

	Particle=(ParticleType *)SafeMalloc ( sizeof(ParticleType) * numparticles );
	memset ( Particle, 0, sizeof(ParticleType) * numparticles );

	for (i=0;i<numparticles;i++)
		{
		part=&Particle[i];
		part->x=((RandomNumber("hello",0)*RandomNumber("hello",0))%viewwidth)<<16;
		part->y=((RandomNumber("hello",0)*RandomNumber("hello",0))%viewheight)<<16;
//		part->x=(((RandomNumber("hello",0)*RandomNumber("hello",0))%(viewwidth-40)+20)<<16);
//		part->y=(((RandomNumber("hello",0)*RandomNumber("hello",0))%(viewheight-40)+20)<<16);
		part->angle=(RandomNumber("hello",0)*RandomNumber("hello",0))%FINEANGLES;
//		part->speed=(RandomNumber("hello",0)%2)<<16;
		part->speed=(1<<16)-1;
		part->color=RandomNumber("hello",0);
		part->endx=-1;
		part->endy=-1;
		part->plane=(part->x>>16)&3;
		part->time=(RandomNumber("",0)%PARTICLETHINKTIME)+1;
//		part->color=255;
		}
}

//******************************************************************************
//
// ShutdownParticles
//
//******************************************************************************

void ShutdownParticles (void)
{
	SafeFree(Particle);
}


void AdjustParticleAngle(int maxadjust, int *currangle,int targetangle)
	{
	int dangle,i,magangle;

	for(i=0;i<maxadjust;i++)
		{
		dangle = *currangle - targetangle;

		if (dangle)
			{
			magangle = abs(dangle);
			if (magangle > (ANGLES/2))
				{
				if (dangle > 0)
					(*currangle) ++;
				else
					(*currangle) --;
				}
			else
				{
				if (dangle > 0)
					(*currangle) --;
				else
					(*currangle) ++;
				}
			Fix(*currangle);
			}
		}
	}

//******************************************************************************
//
// UpdateParticles
//
//******************************************************************************

//#define MAXADJUST (FINEANGLES/40)
#define MAXADJUST (FINEANGLES/20)
void UpdateParticles (int type)
{
	int i;
	int dx,dy;
	ParticleType * target;
	ParticleType * part;

	if (type==0)
		{
		for (i=0;i<numparticles-1;i++)
			{
			int angle;

			part=&Particle[i];
//			target=&Particle[numparticles-1];
//			target=&Particle[i+1];
			target=&Particle[(RandomNumber("",0)*RandomNumber("",0))%numparticles];
			part->x+=-FixedMul (part->speed, costable[part->angle]);
			part->y+= FixedMul (part->speed, sintable[part->angle]);
			part->plane=(part->x>>16)&3;

			dx = part->x - target->x;
			dy = target->y - part->y;
			if (dx && dy)
				{
				angle = atan2_appx(dx,dy);
				AdjustParticleAngle(MAXADJUST,&(part->angle),angle);
				}
			}
		part=&Particle[numparticles-1];
		part->x+=-FixedMul (part->speed, costable[part->angle]);
		part->y+= FixedMul (part->speed, sintable[part->angle]);
		part->plane=(part->x>>16)&3;

		dx=part->x>>16;
		dy=part->y>>16;

		if ( (dx<20) || (dx>(viewwidth-20)) )
			{
			if ( part->angle < (FINEANGLES/2) )
				{
				part->angle=FINEANGLES/2-part->angle;
				Fix(part->angle);
				}
			else
				{
				part->angle=FINEANGLES-part->angle;
				Fix(part->angle);
				}
			}
		if ( (dy<20) || (dy>(viewheight-20)) )
			{
			part->angle=FINEANGLES-part->angle;
			Fix(part->angle);
			}
		}
	else
		{
		for (i=0;i<numparticles;i++)
			{
			int angle;

			part=&Particle[i];
			if ((part->x>>16)!=part->endx)
				part->x+=-FixedMul (part->speed, costable[part->angle]);
			else
				part->x=part->endx<<16;
			if ((part->y>>16)!=part->endy)
				part->y+= FixedMul (part->speed, sintable[part->angle]);
			else
				part->y=part->endy<<16;
			part->plane=(part->x>>16)&3;

			part->time--;
			if (part->time==0)
				{
				part->time=PARTICLETHINKTIME;
				dx = part->x - (part->endx<<16);
				dy = (part->endy<<16) - part->y;
				if (dx && dy)
					{
					angle = atan2_appx(dx,dy);
					AdjustParticleAngle(MAXADJUST,&(part->angle),angle);
					}
				}
			}
		}
}

//******************************************************************************
//
// DrawParticles
//
//******************************************************************************

void DrawParticles (void)
{
	int i;
	int dx,dy;
	int plane;
	ParticleType * part;

	VL_ClearBuffer (bufferofs, 0);
	for (plane=0;plane<4;plane++)
		{
		VGAWRITEMAP(plane);
		for (i=0;i<numparticles;i++)
			{
			part=&Particle[i];
			if (part->plane!=plane)
				continue;
			dx=part->x>>16;
			dy=part->y>>16;
			if (dx<0) dx=0;
			if (dx>=viewwidth) dx=viewwidth-1;
			if (dy<0) dy=0;
			if (dy>=viewheight) dy=viewheight-1;
			*( (byte *) bufferofs + (dx>>2) + ylookup[dy] ) = part->color;
			}
		}
}

void DrawParticleTemplate (void)
{
	byte pal[768];

	viewwidth=320;
	viewheight=200;
	memcpy(&pal[0],W_CacheLumpName("ap_pal",PU_CACHE),768);
	VL_NormalizePalette(&pal[0]);
	SwitchPalette(&pal[0],35);
	VL_ClearBuffer (bufferofs, 255);
	DrawNormalSprite (0, 0, W_GetNumForName("ap_titl"));
}

void DrawAlternateParticleTemplate (void)
{
	viewwidth=320;
	viewheight=200;
	VL_ClearBuffer (bufferofs, 255);
	DrawNormalSprite (0, 0, W_GetNumForName("LIFE_C1"));
}

int CountParticles (void)
{
	int plane,a,b;
	int count;

	count=0;
	for (plane=0;plane<4;plane++)
		{
		VGAREADMAP(plane);
		for (a=0;a<200;a++)
			{
			for (b=0;b<80;b++)
				{
				if (*((byte *)bufferofs+(a*linewidth)+b)!=255)
					count++;
				}
			}
		}
	return count;
}

void AssignParticles (void)
{
	int plane,a,b;
	byte pixel;
	ParticleType * part;

	part=&Particle[0];

	for (plane=0;plane<4;plane++)
		{
		VGAREADMAP(plane);
		for (a=0;a<200;a++)
			{
			for (b=0;b<80;b++)
				{
				pixel = *((byte *)bufferofs+(a*linewidth)+b);
				if (pixel!=255)
					{
					part->endx=plane+(b<<2);
					part->endy=a;
					part->color=pixel;
					part++;
					}
				}
			}
		}
}

//******************************************************************************
//
// ParticleIntro
//
//******************************************************************************

void ParticleIntro (void)
{
	int i,j;


	SetViewSize (MAXVIEWSIZES-1);
	numparticles=NUMPARTICLES;
	DrawAlternateParticleTemplate ();
//	DrawParticleTemplate ();
	numparticles=CountParticles ();
	InitializeParticles ();
	AssignParticles();
//	numparticles>>=1;

	CalcTics();
	CalcTics();
	LastScan=0;
	for (i=0;i<VBLCOUNTER*15;i+=tics)
		{
		DrawParticles();
		FlipPage();
		for (j=0;j<tics;j++)
			{
			UpdateParticles(0);
			}
		CalcTics();
		if ((LastScan) || IN_GetMouseButtons())
			break;;
		}
	LastScan=0;
	for (i=0;i<VBLCOUNTER*15;i+=tics)
		{
		DrawParticles();
		FlipPage();
		for (j=0;j<tics;j++)
			{
			UpdateParticles(1);
			}
		CalcTics();
		if ((LastScan) || IN_GetMouseButtons())
			break;;
		}
	ShutdownParticles ();
}

#endif

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// #include <dos.h>
#include <errno.h>
// #include <io.h>
#include <stdio.h>
// #include <conio.h>
#include <stdarg.h>
// #include <mem.h>
#include <ctype.h>
#include "rt_def.h"
#include "rt_str.h"
#include "rt_error.h"
#include "rt_menu.h"
#include "isr.h"
#include "w_wad.h"
#include "z_zone.h"
#include "rt_vid.h"
#include "rt_util.h"
#include "modexlib.h"
//MED
// #include "memcheck.h"


//*****************************************************************************
//
//                          HARD ERROR ROUTINES
//
//****************************************************************************

#define WINDOWUX           7
#define WINDOWUY           76
#define WINDOWLX           138
#define WINDOWLY           158

#define MESSAGEBOXCOLOR    166


#define DISKERROR          0x4000         // bit 15 (of deverr)
#define IGNOREAVAILABLE    0x1000         // bit 13   (bit 14 isn't used)
#define RETRYAVAILABLE     0x800          // bit 12
#define FAILAVAILABLE      0x400          // bit 11
#define LOCATION           0x300          // bit 10 and 9
#define READWRITEERROR     0x80           // bit 8
#define DRIVEOFERROR       0x0F           // low-order byte

#define DIVISIONINT                0x00

// Globals

boolean DivisionError = false;

// Statics


static char ErrorCodes[13][25] =
{
   "Write-protected disk\0",
   "Unknown unit\0",
   "Drive not ready\0",
   "Unknown command\0",
   "CRC error in data\0",
   "Bad drive struct length\0",
   "Seek error\0",
   "Unknown media type\0",
   "Sector not found\0",
   "Printer out of paper\0",
   "Write fault\0",
   "Read fault\0",
   "General failure\0"
};

static char Drives[7][3] =
{
   "A\0",
   "B\0",
   "C\0",
   "D\0",
   "E\0",
   "F\0",
   "G\0"
};

static char Locations[4][11] =
{
   "MS-DOS\0",
   "FAT\0",
   "Directory\0",
   "Data area\0"
};

static char ReadWrite[2][6] =
{
   "Read\0",
   "Write\0"
};

static boolean ErrorHandlerStarted=false;
void (*olddivisr) () = NULL;

//******************************************************************************
//
// UL_UserMessage ()
//
//******************************************************************************

void UL_UserMessage (int x, int y, char *str, ...)
{
   va_list strptr;
   char buf[128];
   int width, height;

//   memset (&buf[0], 0, sizeof (buf));
   memset (buf, 0, sizeof (buf));
   va_start (strptr, str);
//   vsprintf (&buf[0], str, strptr);
   vsprintf (buf, str, strptr);
   va_end (strptr);

	printf("%s\n", buf);

#if 0
	if ( *(byte *)0x449 == 0x13)
      {
      CurrentFont = tinyfont;

      WindowW=160;
      WindowH=100;
      WindowX=80;
      WindowY=50;

      US_MeasureStr (&width, &height, &buf[0]);

      width  += (CurrentFont->width[1] << 1);
      height += (CurrentFont->height << 1);

      VL_Bar (x, y, WindowW-2, WindowH, MESSAGEBOXCOLOR);

      PrintX = x+CurrentFont->width[1];
      PrintY = y+CurrentFont->height;

      US_CPrint (&buf[0]);

      displayofs=bufferofs;

//      OUTP(CRTC_INDEX, CRTC_STARTHIGH);
//      OUTP(CRTC_DATA,((displayofs&0x0000ffff)>>8));


      bufferofs += screensize;
      if (bufferofs > page3start)
         bufferofs = page1start;
      }
   else
      printf("%s\n",&buf[0]);
#endif
}

//****************************************************************************
//
// UL_GeneralError ()
//
//****************************************************************************

#if 0
int UL_GeneralError (int code)
{
	__debugbreak();
	return(0);

#if 0
   boolean done = false;
   int retval = 0;

   UL_UserMessage (80, 50, "Device Error!\n%s.\n \n(A)bort  (R)etry\n",
                   ErrorCodes[code]);

   if (KeyboardStarted==true)
      {
      while (!done)
      {
         if (Keyboard[sc_A])
         {
            retval = 1;
            done = true;

            while (Keyboard[sc_A])
               ;
         }
         else
            if (Keyboard[sc_R])
            {
               retval = 0;
               done = true;

               while (Keyboard[sc_R])
                  ;
            }
      }
      }
   else
      {
      while (!done)
      {
         if (kbhit())
         {
            char ch;

            ch=toupper(getchar());
            if (ch=='A')
               {
               retval = 1;
               done = true;
               }
            else if (ch=='R')
               {
               retval = 0;
               done = true;
               }
         }
      }
      }


   return (retval);
#endif

}
#endif


//****************************************************************************
//
// UL_DriveError ()
//
//****************************************************************************

#if 0
int UL_DriveError (int code, int location, int rwerror, int whichdrive)
{
#if 0
   boolean done = false;
   int retval   = 0;

   UL_UserMessage (80, 50,
                  "Drive Error!\n%s.\nOn drive %s.\nLocation: %s.\n%s error.\n(A)bort  (R)etry\n",
                    ErrorCodes[code], Drives[whichdrive],
                    Locations[location], ReadWrite[rwerror]);

   if (KeyboardStarted==true)
      {
      while (!done)
      {
         if (Keyboard[sc_A])
         {
            retval = 1;
            done = true;

            while (Keyboard[sc_A])
               ;
         }
         else
            if (Keyboard[sc_R])
            {
               retval = 0;
               done = true;

               while (Keyboard[sc_R])
                  ;
            }
      }
      }
   else
      {
      while (!done)
      {
         if (kbhit())
         {
            char ch;

            ch=toupper(getchar());
            if (ch=='A')
               {
               retval = 1;
               done = true;
               }
            else if (ch=='R')
               {
               retval = 0;
               done = true;
               }
         }
      }
      }

   return (retval);
#endif
}
#endif


//****************************************************************************
//
//	UL_harderr ()
//
//****************************************************************************

#if 0
int UL_harderr (unsigned deverr, unsigned errcode, unsigned *devhdr)
{
   int DiskError      = 0;    // Indicates if it was a disk error
   int IgnoreAvail    = 0;    // if "ignore" response is available
   int RetryAvail     = 0;    // if "retry" response is available
   int FailAvail      = 0;    // if "fail" response is available
   byte ErrorLocation = 0;    // Location of error
   byte RWerror       = 0;    // Read/Write error (0 == read, 1 == write)
   byte whichDrive    = 0;    // Drive the error is on (0 == A, 1 == B, ...)
   int action;

   unsigned temp;
   temp = *devhdr;

  // Check errors
   DiskError     = (deverr & DISKERROR);
   IgnoreAvail   = (deverr & IGNOREAVAILABLE);
   RetryAvail    = (deverr & RETRYAVAILABLE);
   FailAvail     = (deverr & FAILAVAILABLE);
   ErrorLocation = ((deverr & LOCATION) >> 8);
   RWerror       = (deverr & READWRITEERROR);

   if (DiskError == 0)
      action = UL_GeneralError (errcode);
   else
      action = UL_DriveError (errcode, ErrorLocation, RWerror, whichDrive);

   if (action)
      Error ("USER BREAK : ROTT aborted.\n");
   return (_HARDERR_RETRY);
}
#endif


//****************************************************************************
//
//	UL_DivisionISR ()
//
//****************************************************************************

extern byte * colormap;

void UL_DivisionISR ( void )
{
// acknowledge the interrupt

//   SetBorderColor (*(colormap+(((100-10)>>2)<<8)+160));
//   DivisionError = true;
//   OUTP (0x20, 0x20);
}


//****************************************************************************
//
//	UL_ErrorStartup ()
//
//****************************************************************************

void UL_ErrorStartup ( void )
{
   if (ErrorHandlerStarted==true)
      return;
   ErrorHandlerStarted=true;
//   _harderr (UL_harderr);     // Install hard error handler
//   UL_StartupDivisionByZero();
}

//****************************************************************************
//
//	UL_ErrorShutdown ()
//
//****************************************************************************

void UL_ErrorShutdown ( void )
{
   if (ErrorHandlerStarted==false)
      return;
   ErrorHandlerStarted=false;
//   UL_ShutdownDivisionByZero();
}

#if 0
/*
===============
=
= UL_StartupDivisionByZero
=
===============
*/

void UL_StartupDivisionByZero ( void )
{
//	olddivisr = _dos_getvect(DIVISIONINT);
//	_dos_setvect (DIVISIONINT, UL_DivisionISR);
}

/*
===============
=
= UL_ShutdownDivisionByZero
=
===============
*/

void UL_ShutdownDivisionByZero ( void )
{
//	_dos_setvect (DIVISIONINT, olddivisr);
}
#endif
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include <malloc.h>
#include <dos.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <io.h>
#include <conio.h>
#include <string.h>
#include "rt_def.h"
#include "scriplib.h"
#include "watcom.h"
#include "f_scale.h"
#include "_rt_film.h"
#include "rt_scale.h"
#include "z_zone.h"
#include "w_wad.h"
#include "rt_in.h"
#include "rt_film.h"
#include "modexlib.h"
#include "rt_util.h"
#include "rt_vid.h"
#include "lumpy.h"
//MED
#include "memcheck.h"

int dc_ycenter;

static byte * filmbuffer;
static event * events[MAXEVENTS];
static actortype * actors[MAXFILMACTORS];
static int eventindex;
static int currentevent;
static int dtime;
static int movielength;
static int filmtics;
static int lastfilmactor;
static byte firsttime=1;


/*
================
=
= FirstTimeInitialize
=
================
*/
void FirstTimeInitialize ( void )
{
   if (firsttime==0)
      return;

   memset(actors,NULL,sizeof(actors));
   memset(events,NULL,sizeof(events));

   firsttime=0;
}


/*
================
=
= InitializeFilmActors
=
================
*/
void InitializeFilmActors ( void )
{
   int i;

   for (i=0;i<MAXFILMACTORS;i++)
      {
      if (actors[i]!=NULL)
         SafeFree(actors[i]);
      }
   lastfilmactor=0;
}

/*
================
=
= InitializeEvents
=
================
*/
void InitializeEvents ( void )
{
   int i;

   for (i=0;i<MAXEVENTS;i++)
      {
      if (events[i]!=NULL)
         SafeFree(events[i]);
      }
   currentevent=0;
   eventindex=0;
}

/*
================
=
= CleanupEvents
=
================
*/
void CleanupEvents ( void )
{
   int i;

   for (i=0;i<MAXEVENTS;i++)
      if (events[i]!=NULL)
         {
         SafeFree(events[i]);
         events[i]=NULL;
         }
}

/*
================
=
= CleanupActors
=
================
*/
void CleanupActors ( void )
{
   int i;

   for (i=0;i<MAXFILMACTORS;i++)
      if (actors[i]!=NULL)
         {
         SafeFree(actors[i]);
         actors[i]=NULL;
         }
}

/*
================
=
= GetNewFilmEvent
=
================
*/
event * GetNewFilmEvent ( void )
{
   if (eventindex==MAXEVENTS)
      Error("No free Events in Cinematic engine\n");
   events[eventindex]=SafeMalloc(sizeof(event));
   eventindex++;
   return events[eventindex-1];
}

/*
================
=
= ParseMovieScript
=
================
*/

void ParseMovieScript (void)
{
   int time;
   event * newevent;

   time=0;
   do
      {
      //
      // get a command / lump name
      //
      GetToken (true);
      if (endofscript)
         break;
      newevent=GetNewFilmEvent();
      time+=ParseNum(token);
      GetToken (false);
      if (!strcmpi (token,"BACKGROUND"))
         {
         GetToken (false);
         newevent->time=time;
         strcpy(&(newevent->name[0]),token);
         GetToken (false);
         if (!strcmpi (token,"SCROLLRIGHT"))
            {
            newevent->dir=RIGHT;
            newevent->type=backgroundscroll;
            }
         else if (!strcmpi (token,"SCROLLLEFT"))
            {
            newevent->dir=LEFT;
            newevent->type=backgroundscroll;
            }
         else
            {
            newevent->type=background;
            }
         GetToken (false);
         newevent->dx=ParseNum(token);
         newevent->x=0;
         }
      else if (!strcmpi (token,"BACKDROP"))
         {
         GetToken (false);
         newevent->time=time;
         newevent->type=backdrop;
         strcpy(&(newevent->name[0]),token);
         GetToken (false);
         if (!strcmpi (token,"SCROLLRIGHT"))
            {
            newevent->dir=RIGHT;
            newevent->type=backdropscroll;
            }
         else if (!strcmpi (token,"SCROLLLEFT"))
            {
            newevent->dir=LEFT;
            newevent->type=backdropscroll;
            }
         else
            {
            newevent->type=backdrop;
            }
         GetToken (false);
         newevent->dx=ParseNum(token);
         newevent->x=0;
         }
      else if (!strcmpi (token,"BKGNDSPRITE"))
         {
         GetToken (false);
         newevent->time=time;
         newevent->type=bkgndsprite;
         strcpy(&(newevent->name[0]),token);
         GetToken (false);
         newevent->length=ParseNum(token);
         GetToken (false);
         newevent->origheight=ParseNum(token);
         GetToken (false);
         newevent->x=ParseNum(token);
         GetToken (false);
         newevent->y=ParseNum(token);
         GetToken (false);
         newevent->scale=ParseNum(token);
         GetToken (false);
         newevent->dx=ParseNum(token);
         GetToken (false);
         newevent->dy=ParseNum(token);
         GetToken (false);
         newevent->dscale=ParseNum(token);
         }
      else if (!strcmpi (token,"SPRITE"))
         {
         GetToken (false);
         newevent->time=time;
         newevent->type=sprite;
         strcpy(&(newevent->name[0]),token);
         GetToken (false);
         newevent->length=ParseNum(token);
         GetToken (false);
         newevent->origheight=ParseNum(token);
         GetToken (false);
         newevent->x=ParseNum(token);
         GetToken (false);
         newevent->y=ParseNum(token);
         GetToken (false);
         newevent->scale=ParseNum(token);
         GetToken (false);
         newevent->dx=ParseNum(token);
         GetToken (false);
         newevent->dy=ParseNum(token);
         GetToken (false);
         newevent->dscale=ParseNum(token);
         }
      else if (!strcmpi (token,"PALETTE"))
         {
         GetToken (false);
         newevent->time=time;
         newevent->type=palette;
         strcpy(&(newevent->name[0]),token);
         }
      else if (!strcmpi (token,"FADEOUT"))
         {
         newevent->time=time;
         newevent->type=fadeout;
         GetToken (false);
         newevent->length=ParseNum(token);
         }
      else if (!strcmpi (token,"MOVIEEND"))
         {
         movielength=time;
         eventindex--;
         }
      else
         Error("PARSE: Illegal Token %s\n",token);
//      eventindex++;
      }
   while (script_p < scriptend_p);
   if (movielength==0)
      Error("No end of movie marker\n");
}


/*
=================
=
= DumpMovie
=
=================
*/
void DumpMovie( void )
{
   int i;
   char typestring[45];

   if (eventindex==0)
      Error ("No events in movie");
   for (i=0;i<eventindex;i++)
      {
      printf("Event #%ld at %ld tics\n",i,events[i]->time);
      switch (events[i]->type)
         {
         case background:
            strcpy(&typestring[0],"BACKGROUND");
            break;
         case backdrop:
            strcpy(&typestring[0],"BACKDROP");
            break;
         case bkgndsprite:
            strcpy(&typestring[0],"BKGNDSPRITE");
            break;
         case sprite:
            strcpy(&typestring[0],"SPRITE");
            break;
         case palette:
            strcpy(&typestring[0],"PALLETE");
            break;
         default:
            Error("DUMP: Illegal event type\n");
            break;
         }
      printf("%s\n",typestring);
      switch (events[i]->type)
         {
         case background:
            printf("   NAME: %s\n",events[i]->name);
            break;
         case backdrop:
            printf("   NAME: %s\n",events[i]->name);
            break;
         case palette:
            printf("   NAME: %s\n",events[i]->name);
            break;
         case bkgndsprite:
            printf("   NAME: %s\n",events[i]->name);
            if (events[i]->length!=-1)
               printf(" LENGTH: %ld\n",events[i]->length);
            else
               printf(" LENGTH: INFINITE\n");
            printf("ORGHGHT: %ld\n",events[i]->origheight);
            printf("      X: %ld\n",events[i]->x);
            printf("      Y: %ld\n",events[i]->y);
            printf("  SCALE: %ld\n",events[i]->scale);
            if (events[i]->dx)
               printf("     DX: %ld\n",events[i]->dx);
            else
               printf("     DX: STATIC\n");
            if (events[i]->dy)
               printf("     DY: %ld\n",events[i]->dy);
            else
               printf("     DY: STATIC\n");
            if (events[i]->dscale)
               printf(" DSCALE: %ld\n",events[i]->dscale);
            else
               printf(" DSCALE: STATIC\n");
            break;
         case sprite:
            printf("   NAME: %s\n",events[i]->name);
            if (events[i]->length!=-1)
               printf(" LENGTH: %ld\n",events[i]->length);
            else
               printf(" LENGTH: INFINITE\n");
            printf("ORGHGHT: %ld\n",events[i]->origheight);
            printf("      X: %ld\n",events[i]->x);
            printf("      Y: %ld\n",events[i]->y);
            printf("  SCALE: %ld\n",events[i]->scale);
            if (events[i]->dx)
               printf("     DX: %ld\n",events[i]->dx);
            else
               printf("     DX: STATIC\n");
            if (events[i]->dy)
               printf("     DY: %ld\n",events[i]->dy);
            else
               printf("     DY: STATIC\n");
            if (events[i]->dscale)
               printf(" DSCALE: %ld\n",events[i]->dscale);
            else
               printf(" DSCALE: STATIC\n");
            break;
         default:
            Error("DUMP: Illegal event type\n");
            break;
         }
      }
}

/*
=================
=
= GetFreeActor
=
=================
*/
actortype * GetFreeActor ( void )
{
   int i;

   for (i=0;i<MAXFILMACTORS;i++)
      if (actors[i]==NULL)
         {
         actors[i]=SafeMalloc(sizeof(actortype));
         if (i>lastfilmactor)
            lastfilmactor=i;
         return actors[i];
         }
   Error ("No free spots in actorlist");
   return NULL;
}


/*
=================
=
= FreeActor
=
=================
*/
void FreeActor ( int i )
{
   SafeFree(actors[i]);
   actors[i]=NULL;
}

/*
=================
=
= UpdateEvents
=
=================
*/
void UpdateEvents ( void )
{
   int i,j;

   for (i=0;i<=lastfilmactor;)
      {
      if (actors[i]!=NULL)
         {
         for (j=0;j<dtime;j++)
            {
            if (actors[i]->tics!=-1)
               {
               actors[i]->tics--;
               if (actors[i]->tics<=0)
                  {
                  FreeActor(i);
                  goto continueloop;
                  }
               }
            switch (events[actors[i]->eventnumber]->type)
               {
               case background:
               case backdrop:
               case palette:
               case fadeout:
                  break;
               case backgroundscroll:
               case backdropscroll:
                  if (events[actors[i]->eventnumber]->dir==RIGHT)
                     actors[i]->curx-=events[actors[i]->eventnumber]->dx;
                  else if (events[actors[i]->eventnumber]->dir==LEFT)
                     actors[i]->curx+=events[actors[i]->eventnumber]->dx;
                  break;
               case bkgndsprite:
                  actors[i]->curx+=events[actors[i]->eventnumber]->dx;
                  actors[i]->cury+=events[actors[i]->eventnumber]->dy;
                  actors[i]->curscale+=events[actors[i]->eventnumber]->dscale;
                  break;
               case sprite:
                  actors[i]->curx+=events[actors[i]->eventnumber]->dx;
                  actors[i]->cury+=events[actors[i]->eventnumber]->dy;
                  actors[i]->curscale+=events[actors[i]->eventnumber]->dscale;
                  break;
               default:
                  Error("UPDATE: Illegal event type\n");
                  break;
               }
            }
         }
continueloop:
      i++;
      }
}

/*
=================
=
= DrawBackground
=
=================
*/
void DrawBackground (char * name)
{
   byte * shape;
   byte * buf;
   byte * src;
   lpic_t * p;
   int i;
   int plane;


   shape=W_CacheLumpName(name,PU_CACHE);
   p=(lpic_t *)shape;

   for (plane=0;plane<4;plane++)
      {
      buf=filmbuffer;
      src=shape+8+(plane*p->height);
      VGAWRITEMAP(plane);
      for (i=plane;i<p->width;i+=4,src+=(p->height<<2),buf++)
         DrawFilmPost(buf,src,p->height);
      }
}

/*
=================
=
= DrawScrollingBackground
=
=================
*/
int DrawScrollingBackground (char * name, int x)
{
   byte * shape;
   byte * buf;
   byte * src;
   lpic_t * p;
   int i;
   int xx;
   int plane;

   shape=W_CacheLumpName(name,PU_CACHE);
   p=(lpic_t *)shape;

   if (x<0)
      x+=(p->width<<8);
   if (x>=(p->width<<8))
      x-=(p->width<<8);

   xx=x>>8;
   for (plane=0;plane<4;plane++)
      {
      buf=filmbuffer;
      src=shape+8;
      VGAWRITEMAP(plane);
      for (i=plane+xx;i<(p->width+xx);i+=4,buf++)
         {
         if (i>=p->width)
            DrawFilmPost(buf,src + ((i-p->width)*p->height),p->height);
         else
            DrawFilmPost(buf,src + (i*p->height),p->height);
         }
      }
   return x;
}


/*
=================
=
= DrawBackdrop
=
=================
*/
void DrawBackdrop (char * name)
{
   byte * shape;
   patch_t * p;
   int i;
   int toppost;
   int offset;
   int length;
   byte * src;
   byte * buf;
   int plane;

   shape=W_CacheLumpName(name,PU_CACHE);
   p=(patch_t *)shape;

   toppost=-p->topoffset;
   for (plane=0;plane<4;plane++)
      {
      buf=filmbuffer;
      VGAWRITEMAP(plane);
      for (i=plane;i<p->width;i+=4,buf++)
         {
         src=p->collumnofs[i]+shape;
         offset=*(src++);
         for (;offset!=255;)
            {
            length=*(src++);
            DrawFilmPost(buf + ylookup[toppost+offset],src,length);
            src+=length;
            offset=*(src++);
            }
         }
      }
}

/*
=================
=
= DrawScrollingBackdrop
=
=================
*/
int DrawScrollingBackdrop (char * name, int x)
{
   byte * shape;
   patch_t * p;
   int i;
   int toppost;
   int xx;
   int offset;
   int length;
   byte * src;
   byte * buf;
   int plane;

   shape=W_CacheLumpName(name,PU_CACHE);
   p=(patch_t *)shape;

   if (x<0)
      x+=(p->width<<8);
   if (x>=(p->width<<8))
      x-=(p->width<<8);

   xx=x>>8;
   toppost=-p->topoffset;
   for (plane=0;plane<4;plane++)
      {
      VGAWRITEMAP(plane);
      buf=filmbuffer;
      for (i=plane+xx;(i<p->width+xx);i+=4,buf++)
         {
         if (i>=p->width)
            src=p->collumnofs[i-p->width]+shape;
         else
            src=p->collumnofs[i]+shape;
         offset=*(src++);
         for (;offset!=255;)
            {
            length=*(src++);
            DrawFilmPost(buf + ylookup[toppost+offset],src,length);
            src+=length;
            offset=*(src++);
            }
         }
      }
   return x;
}



/*
=================
=
= ScaleFilmPost
=
=================
*/
void ScaleFilmPost (byte * src, byte * buf)
{
   int  offset;
   int  length;
   int  topscreen;
   int  bottomscreen;


   offset=*(src++);
   for (;offset!=255;)
      {
      length=*(src++);
      topscreen = sprtopoffset + (dc_invscale*offset);
      bottomscreen = topscreen + (dc_invscale*length);
      dc_yl = (topscreen+SFRACUNIT-1)>>SFRACBITS;
      dc_yh = (bottomscreen-FRACUNIT)>>SFRACBITS;
      if (dc_yh >= 200)
         dc_yh = 199;
      if (dc_yl < 0)
         dc_yl = 0;
      if (dc_yl <= dc_yh)
         {
         dc_source=src-offset;
         R_DrawFilmColumn (buf);
         }
      src+=length;
      offset=*(src++);
      }

}


/*
=================
=
= DrawSprite
=
=================
*/
void DrawSprite (char * name, int x, int y, int height, int origheight)
{
   byte *shape;
   int      frac;
   patch_t *p;
   int      x1,x2;
   int      tx;
   int      xcent;
   byte *   buf;

//   SimpleScaleShape(x,y,W_GetNumForName(name),height,origheight);
//   return;

   height>>=1;
   if (!height)
      return;
   dc_invscale = (height<<17)/origheight;
   buf=(byte *)filmbuffer;
   shape=W_CacheLumpName(name,PU_CACHE);
   p=(patch_t *)shape;
   tx=-p->leftoffset;
   xcent=(x<<SFRACBITS)-(height<<SFRACBITS)+(SFRACBITS/2);
//
// calculate edges of the shape
//
        x1 = (xcent+(tx*dc_invscale))>>SFRACBITS;
        if (x1 >= 320)
                return;               // off the right side
        tx+=p->width;
        x2 = ((xcent+(tx*dc_invscale)) >>SFRACBITS) - 1 ;
        if (x2 < 0)
                return;         // off the left side

   dc_iscale=(origheight<<15)/height;

//
// store information in a vissprite
//
   if (x1<0)
      {
      frac=dc_iscale*(-x1);
      x1=0;
      }
   else
      frac=0;
   x2 = x2 >= 320 ? 319 : x2;

   dc_ycenter=y;
   dc_texturemid=(((origheight>>1)+p->topoffset)<<SFRACBITS)+(SFRACUNIT>>1);
   sprtopoffset=(y<<16) - FixedMul(dc_texturemid,dc_invscale);


   for (; x1<=x2 ; x1++, frac += dc_iscale)
     {
     VGAWRITEMAP(x1&3);
     ScaleFilmPost(((p->collumnofs[frac>>SFRACBITS])+shape),buf+(x1>>2));
     }
}

/*
=================
=
= DrawPalette
=
=================
*/
void DrawPalette (char * name)
{
   byte * pal;
   byte pal2[768];

   pal=W_CacheLumpName(name,PU_CACHE);
   memcpy(&pal2[0],pal,768);
   VL_NormalizePalette(&pal2[0]);
   SwitchPalette(&pal2[0],35);
}


/*
=================
=
= DrawFadeout
=
=================
*/
void DrawFadeout ( int time )
{
   VL_FadeOut (0, 255, 0, 0, 0, time);
   CalcTics();
   CalcTics();
   VL_ClearVideo (0);
}

/*
=================
=
= DrawEvents
=
=================
*/
void DrawEvents ( void )
{
   int i;
   int done;



   // ChangePalette

   for (i=0;i<=lastfilmactor;i++)
      if (actors[i]!=NULL)
         {
         if (events[actors[i]->eventnumber]->type==palette)
            {
            DrawPalette(&(events[actors[i]->eventnumber]->name[0]));
            FreeActor(i);
            break;
            }
         else if (events[actors[i]->eventnumber]->type==fadeout)
            {
            DrawFadeout(events[actors[i]->eventnumber]->length);
            FreeActor(i);
            break;
            }
         }

   done=0;
   for (i=0;i<=lastfilmactor;i++)
      if (actors[i]!=NULL)
         {
         switch (events[actors[i]->eventnumber]->type)
            {
            // Draw Background
            case background:
               DrawBackground(&(events[actors[i]->eventnumber]->name[0]));
               done=1;
               break;
            // Draw Scrolling Background
            case backgroundscroll:
               actors[i]->curx=DrawScrollingBackground(&(events[actors[i]->eventnumber]->name[0]),actors[i]->curx);
               done=1;
               break;
            }
         if (done==1)
            break;
         }

   // Draw Background Sprites

   for (i=0;i<=lastfilmactor;i++)
      if (actors[i]!=NULL)
         if (events[actors[i]->eventnumber]->type==bkgndsprite)
            {
            DrawSprite(&(events[actors[i]->eventnumber]->name[0]),
                       actors[i]->curx>>8,
                       actors[i]->cury>>8,
                       actors[i]->curscale>>8,
                       events[actors[i]->eventnumber]->origheight);
            }


   done=0;
   for (i=0;i<=lastfilmactor;i++)
      if (actors[i]!=NULL)
         {
         switch (events[actors[i]->eventnumber]->type)
            {
            // Draw Backdrop
            case backdrop:
               DrawBackdrop(&(events[actors[i]->eventnumber]->name[0]));
               done=1;
               break;
            // Draw Scrolling Backdrop
            case backdropscroll:
               actors[i]->curx=DrawScrollingBackdrop(&(events[actors[i]->eventnumber]->name[0]),actors[i]->curx);
               done=1;
               break;
            }
         if (done==1)
            break;
         }

   // Draw foreground Sprites

   for (i=0;i<=lastfilmactor;i++)
      if (actors[i]!=NULL)
         if (events[actors[i]->eventnumber]->type==sprite)
            {
            DrawSprite(&(events[actors[i]->eventnumber]->name[0]),
                       actors[i]->curx>>8,
                       actors[i]->cury>>8,
                       actors[i]->curscale>>8,
                       events[actors[i]->eventnumber]->origheight);
            }

}

/*
=================
=
= DeleteEvent
=
=================
*/
void DeleteEvent( eventtype type, actortype * actor )
{
   int i;

   for (i=0;i<=lastfilmactor;i++)
      if (actors[i]!=NULL)
         if ((events[actors[i]->eventnumber]->type==type) && (actors[i]!=actor))
            {
            FreeActor(i);
            if (i==lastfilmactor)
               lastfilmactor--;
            }
}


/*
=================
=
= AddEvents
=
=================
*/
void AddEvents( void )
{
   actortype * actor;

   while ((events[currentevent]->time<=filmtics) && (currentevent<eventindex))
      {
      actor=GetFreeActor();
      actor->eventnumber=currentevent;
      switch (events[actor->eventnumber]->type)
         {
         case palette:
            actor->tics=-1;
            break;
         case fadeout:
            actor->tics=-1;
            break;
         case background:
            DeleteEvent (background, actor);
            actor->tics=-1;
            break;
         case backdrop:
            DeleteEvent (backdrop, actor);
            actor->tics=-1;
            break;
         case backgroundscroll:
            DeleteEvent (backgroundscroll, actor);
            actor->curx=0;
            actor->tics=-1;
            break;
         case backdropscroll:
            DeleteEvent (backdropscroll, actor);
            actor->curx=0;
            actor->tics=-1;
            break;
         case bkgndsprite:
            actor->tics=events[actor->eventnumber]->length;
            actor->curx=events[actor->eventnumber]->x<<8;
            actor->cury=events[actor->eventnumber]->y<<8;
            actor->curscale=events[actor->eventnumber]->scale<<8;
            break;
         case sprite:
            actor->tics=events[actor->eventnumber]->length;
            actor->curx=events[actor->eventnumber]->x<<8;
            actor->cury=events[actor->eventnumber]->y<<8;
            actor->curscale=events[actor->eventnumber]->scale<<8;
            break;
         default:
            Error("ADD: Illegal event type\n");
            break;
         }
      currentevent++;
      }
}


/*
==============
=
= CacheScriptFile
=
==============
*/

void CacheScriptFile (char *filename)
{
	long            size;
   int lump;

   lump=W_GetNumForName(filename)+1;

   scriptbuffer=W_CacheLumpNum(lump,PU_CACHE);
	size = W_LumpLength(lump);

	script_p = scriptbuffer;
	scriptend_p = script_p + size;
	scriptline = 1;
	endofscript = false;
	tokenready = false;
}


/*
=================
=
= GrabMovieScript
=
=================
*/

void GrabMovieScript (char const *basename)
{
        char            script[256];

//
// read in the script file
//
        strcpy (script, basename);
        strcat (script,".ms");
//        LoadScriptFile (script);
        CacheScriptFile ((char *)basename);
        ParseMovieScript ();

}
void InitializeMovie ( void )
{
   FirstTimeInitialize();
   movielength=0;
   InitializeFilmActors();
   InitializeEvents();
}

void CleanupMovie ( void )
{
   CleanupEvents();
   CleanupActors();
}

void PlayMovie ( char * name )
{
   InitializeMovie();
   GrabMovieScript (name);
   filmbuffer=(byte *)bufferofs;
   IN_ClearKeysDown();
   for (filmtics=0;filmtics<movielength;filmtics+=dtime)
      {
      AddEvents();
      DrawEvents();
      UpdateEvents();
      FlipPage();
      CalcTics();
      dtime=tics;
      filmbuffer=(byte *)bufferofs;
      if ((LastScan) || IN_GetMouseButtons())
         break;
      }
   CleanupMovie();
}



/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// RT_FLOOR.C

// #include <conio.h>
#include "rt_def.h"
#include "watcom.h"
#include "rt_floor.h"
#include "rt_fc_a.h"
#include "_rt_floo.h"
#include "rt_draw.h"
#include "rt_util.h"
#include "engine.h"
#include "rt_main.h"
#include "w_wad.h"
#include "z_zone.h"
#include "rt_view.h"
#include "rt_ted.h"
#include "rt_cfg.h"
#include "rt_actor.h"
#include <string.h>
#include "isr.h"
#include "modexlib.h"
#include "rt_playr.h"
#include "rt_sound.h"
#include "rt_rand.h"
//MED
// #include "memcheck.h"

/*
=============================================================================

Global Variables																																											GLOBAL VARIABLES

=============================================================================
*/

int		sky;
int		mr_rowofs;
int		mr_count;
int		mr_xstep;
int		mr_ystep;
int		mr_xfrac;
int		mr_yfrac;
// byte *	mr_dest;
unsigned	mr_dest;
byte *	mr_src;

/*
==================
=
= Local Variables
=
==================
*/

static byte	*rt_floor;
static byte	*ceiling;
static int xstarts[MAXVIEWHEIGHT];
static byte * skysegs[MAXSKYSEGS];
static byte * skydata[MAXSKYDATA];
static int		horizonheight;
static int		centerskypost;
static int		oldsky=-1;

void DrawSky( void )
{

	byte * src;
	int dest;
	int plane;
	int height;
	int height2;
	int ang;
	int angle;
	int ofs;

	angle=viewangle;

	if ((fog==0) && (lightning==true))
		shadingtable=colormap+((basemaxshade-6-lightninglevel)<<8);
	else
		shadingtable=colormap+(1<<12);

	ofs=(((maxheight)-(player->z))>>3)+(centery-(viewheight>>1));
	if (ofs>centerskypost)
		{
		ofs=centerskypost;
		}
	else if (((centerskypost-ofs)+viewheight)>399)
		{
		ofs=-(399-(centerskypost+viewheight));
		}

	if (doublestep>0)
		{
		for (plane=0;plane<4;plane+=2)
			{
			VGAMAPMASK((1<<plane)+(1<<(plane+1)));
			for (dest=plane;dest<viewwidth;dest+=4)
				{
				height=posts[dest].ceilingclip;
				height2=posts[dest+1].ceilingclip;
				if (height<height2)
					height=height2;
				if (height<=0)
					continue;
				ang=(angle+pixelangle[dest])&(FINEANGLES-1);
				src=skysegs[ang]-ofs;
				DrawSkyPost(bufferofs + (dest>>2),src,height);
				}
			}
		}
	else
		{
		for (plane=0;plane<4;plane++)
			{
			VGAWRITEMAP(plane);
			for (dest=plane;dest<viewwidth;dest+=4)
				{
				if ((height=posts[dest].ceilingclip)<=0)
					continue;
				ang=(angle+pixelangle[dest])&(FINEANGLES-1);
				src=skysegs[ang]-ofs;
				DrawSkyPost(bufferofs + (dest>>2),src,height);
				}
			}
		}
}

/*
===================
=
= DrawFullSky
=
===================
*/
void DrawFullSky( void )
{

	byte * src;
	int dest;
	int plane;
	int ang;
	int angle;
	int ofs;

	angle=viewangle;

	if ((fog==0) && (lightning==true))
		shadingtable=colormap+((basemaxshade-5-lightninglevel)<<8);
	else
		shadingtable=colormap+(1<<12);

	ofs=(((maxheight)-(player->z))>>3)+(centery-(viewheight>>1));
	if (ofs>centerskypost)
		{
		ofs=centerskypost;
		}
	else if (((centerskypost-ofs)+viewheight)>399)
		{
		ofs=-(399-(centerskypost+viewheight));
		}

	bufferofs+=screenofs;

	for (plane=0;plane<4;plane++)
		{
		VGAWRITEMAP(plane);
		for (dest=plane;dest<viewwidth;dest+=4)
			{
			ang=(angle+pixelangle[dest])&(FINEANGLES-1);
			src=skysegs[ang]-ofs;
			DrawSkyPost(bufferofs + (dest>>2),src,viewheight);
			}
		}

	bufferofs-=screenofs;
}

/*
===================
=
= MakeSkyTile
=
===================
*/
void MakeSkyTile (byte * tile)
{
	int i,j;
	int srcstep;
	int src;

	srcstep=200<<10;
	for (i=0;i<64;i++)
		{
		src=0;
		for (j=0;j<64;j++)
			{
			*(tile + (i<<6) + j)=*(skysegs[(i<<2)]+(src>>16));
			src+=srcstep;
			}
		}
}

/*
===================
=
= MakeSkyData
=
===================
*/
void MakeSkyData ( void )
{
	byte * temp;
	byte * ptr;
	int c;

	temp=SafeMalloc(256*400);

	ptr=temp;

	for (c=0;c<256;c++)
		{
		memcpy(ptr,skydata[1]+(c*200),200);
		ptr+=200;
		memcpy(ptr,skydata[0]+(c*200),200);
		ptr+=200;
		}
	skydata[0]=temp;
}

/*
===================
=
= GetFloorCeilingLump
=
===================
*/

int GetFloorCeilingLump ( int num )
{
	int lump;

	switch (num)
		{
		case 1:
			lump=W_GetNumForName("FLRCL1\0");
			break;
		case 2:
			lump=W_GetNumForName("FLRCL2\0");
			break;
		case 3:
			lump=W_GetNumForName("FLRCL3\0");
			break;
		case 4:
			lump=W_GetNumForName("FLRCL4\0");
			break;
		case 5:
			lump=W_GetNumForName("FLRCL5\0");
			break;
		case 6:
			lump=W_GetNumForName("FLRCL6\0");
			break;
		case 7:
			lump=W_GetNumForName("FLRCL7\0");
			break;
		case 8:
			lump=W_GetNumForName("FLRCL8\0");
			break;
		case 9:
			lump=W_GetNumForName("FLRCL9\0");
			break;
		case 10:
			lump=W_GetNumForName("FLRCL10\0");
			break;
		case 11:
			lump=W_GetNumForName("FLRCL11\0");
			break;
		case 12:
			lump=W_GetNumForName("FLRCL12\0");
			break;
		case 13:
			lump=W_GetNumForName("FLRCL13\0");
			break;
		case 14:
			lump=W_GetNumForName("FLRCL14\0");
			break;
		case 15:
			lump=W_GetNumForName("FLRCL15\0");
			break;
		case 16:
			lump=W_GetNumForName("FLRCL16\0");
			break;
		default:
			Error("Illegal Floor/Ceiling Tile = %ld\n",num);
			break;
		}
	return lump;
}

/*
===================
=
= SkyExists
=
===================
*/

boolean SkyExists (void)
{
	if (MAPSPOT(1,0,0) >= 234)
		{
		return true;
		}
	else
		{
		return false;
		}

}

/*
===================
=
= SetPlaneViewSize
=
===================
*/

boolean rott_iswolf;

void SetPlaneViewSize (void)
{
	int		x;
	int		i;
	int		s;
	int		floornum;
	int		ceilingnum;
	int		skytop;
	int		skybottom;

	sky=0;

	if (oldsky>0)
		{
		SafeFree(skydata[0]);
		oldsky=-1;
		}

	lightning=false;
//	rott_iswolf=false;

	if (MAPSPOT(1,0,0) >= 234)
	{
	word crud;
	sky = (MAPSPOT(1,0,0) - 233);
	if ((sky<1) || (sky>6))
		Error("Illegal Sky Tile = %ld\n",sky);
	ceilingnum=1;
	crud=(word)MAPSPOT(1,0,1);
	if ((crud>=90) && (crud<=97))
		horizonheight=crud-89;
	else if ((crud>=450) && (crud<=457))
		horizonheight=crud-450+9;
	else
		Error("You must specify a valid horizon height sprite icon over the sky at (2,0) on map %ld\n",gamestate.mapon);

	// Check for lightnign icon

	crud=(word)MAPSPOT(4,0,1);
	if (crud==377)
		lightning=true;
	}
	else
	ceilingnum = MAPSPOT(1,0,0)-197;

	floornum = MAPSPOT(0,0,0)-179;

	floornum = GetFloorCeilingLump ( floornum );
	//ceilingnum = GetFloorCeilingLump ( ceilingnum );

	rt_floor = W_CacheLumpNum(floornum,PU_LEVELSTRUCT);
	rt_floor +=8;

	if (sky==0)  // Don't cache in if not used
		{
		ceilingnum = GetFloorCeilingLump ( ceilingnum );
		ceiling = W_CacheLumpNum(ceilingnum,PU_LEVELSTRUCT);
		ceiling +=8;
		}

	s = W_GetNumForName("SKYSTART");

	switch (sky)
		{
		case 1:
			skytop=s+1;
			skybottom=s+2;
			break;
		case 2:
			skytop=s+3;
			skybottom=s+4;
			break;
		case 3:
			skytop=s+5;
			skybottom=s+6;
			break;
		case 4:
			skytop=s+7;
			skybottom=s+8;
			break;
		case 5:
			skytop=s+9;
			skybottom=s+10;
			break;
		case 6:
			skytop=s+11;
			skybottom=s+12;
			break;
		}
		if (sky!=0)
			{
			skydata[0]=W_CacheLumpNum(skytop,PU_STATIC);
			skydata[1]=W_CacheLumpNum(skybottom,PU_STATIC);
			centerskypost=MINSKYHEIGHT-(horizonheight*6);
			oldsky=sky;
			MakeSkyData();
			W_CacheLumpNum(skytop,PU_CACHE);
			W_CacheLumpNum(skybottom,PU_CACHE);
			x=511;
			for (i=0;i<MAXSKYSEGS;i++)
				{
				skysegs[i]=skydata[0]+((x>>1)*400)+centerskypost;
				x--;
				if (x==-1)
					{
					x=511;
					}
				} /* endfor */
			}
}

/*
==========================
=
= SetFCLightLevel
=
==========================
*/
void SetFCLightLevel (int height)
{
	int i;

	if (MISCVARS->GASON==1)
		{
		shadingtable=greenmap+(MISCVARS->gasindex<<8);
		return;
		}
	if (fulllight)
		{
		shadingtable=colormap+(1<<12);
		return;
		}
	if (fog)
		{
		i=(height>>normalshade)+minshade;
		if (i>maxshade) i=maxshade;
		shadingtable=colormap+(i<<8);
		}
	else
		{
		i=maxshade-(height>>normalshade);
		if (i<minshade) i=minshade;
		shadingtable=colormap+(i<<8);
		}
}



void DrawHLine (int xleft, int xright, int yp)
{
	int plane;
	byte * buf;
//	byte * dest;
	unsigned dest;
	int startxfrac;
	int startyfrac;
	int height;
//	int length;
	int ofs;

	if (yp==centery)
		return;
	if (yp>centery)
	{
		int hd;

		buf=rt_floor;
		hd=yp-centery;
		height=(hd<<13)/(maxheight-pheight+32);
	}
	else
	{
		int hd;

		buf=ceiling;
		hd=centery-yp;
		height=(hd<<13)/pheight;
	}
	
	if(!buf)
		return;
	
	SetFCLightLevel(height>>(8-HEIGHTFRACTION-1));
	mr_xstep = ((viewsin<<8)/(height));
	mr_ystep = ((viewcos<<8)/(height));

	startxfrac = ((viewx>>1) + FixedMulShift(mr_ystep,scale,2))-
					FixedMulShift(mr_xstep,(centerx-xleft),2);

	startyfrac = ((viewy>>1) - FixedMulShift(mr_xstep,scale,2))-
					FixedMulShift(mr_ystep,(centerx-xleft),2);

	dest=bufferofs+ylookup[yp];

	if (doublestep>0)
		{
		if (xleft&1)
			xleft--;
		for (plane=xleft;plane<xleft+4;plane+=2)
			{
			mr_dest=dest+(plane>>2);

			mr_xfrac = startxfrac;
			mr_yfrac = startyfrac;

			startxfrac+=mr_xstep>>1;
			startyfrac+=mr_ystep>>1;

			mr_count=((xright-plane)>>2)+1;
			if (mr_count)
				{
				int p;
				ofs=((plane&3)<<3)+(plane&3)+1;
//			VGAMAPMASK(*((byte *)mapmasks1+ofs));
				p=plane&3;
				VGAMAPMASK((1<<p) + (1<<(p+1)));

				DrawRow(mr_count,mr_dest,buf);
#if 0
				ofs=(byte)*((byte *)mapmasks2+ofs);
				if (ofs!=0)
					{
					VGAMAPMASK(ofs);
					DrawRow(mr_count,mr_dest+1,buf);
					}
#endif
				}
			}
		}
	else
		{
		for (plane=xleft;plane<xleft+4;plane++)
			{
			mr_dest=dest+(plane>>2);
			VGAWRITEMAP(plane&3);

			mr_xfrac = startxfrac;
			mr_yfrac = startyfrac;

			startxfrac+=mr_xstep>>2;
			startyfrac+=mr_ystep>>2;

			mr_count=((xright-plane)>>2)+1;
			if (mr_count)
				DrawRow(mr_count,mr_dest,buf);
			}
		}

}

void DrawPlanes( void )
{
	int x,y;
	int twall;
	int bwall;

	if (sky)
		DrawSky();
	else
		{
		y=0;
		for (x=0;x<viewwidth;x++)
			{
			twall=posts[x].ceilingclip;
			while (y<twall)
				{
				xstarts[y]=x;
				y++;
				}
			while (y>twall)
				{
				y--;
				DrawHLine(xstarts[y],x-1,y);
				}
			}
		while (y>0)
			{
			y--;
			DrawHLine(xstarts[y],viewwidth-1,y);
			}
		}
	y=viewheight-1;
	for (x=0;x<viewwidth;x++)
		{
		bwall=posts[x].floorclip;
		while (y>bwall)
			{
			xstarts[y]=x;
			y--;
			}
		while (y<bwall)
			{
			y++;
			DrawHLine(xstarts[y],x-1,y);
			}
		}
	while (y<viewheight-1)
		{
		y++;
		DrawHLine(xstarts[y],viewwidth-1,y);
		}
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// #include <dos.h>
// #include <io.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
// #include <conio.h>
#include <ctype.h>

#include "rt_def.h"
#include "rt_main.h"
#include "rt_game.h"
#include "_rt_game.h"
#include "rt_menu.h"
#include "z_zone.h"
#include "w_wad.h"
#include "lumpy.h"
#include "rt_playr.h"
#include "rt_util.h"
#include "rt_ted.h"
#include "rt_draw.h"
#include "rt_view.h"
#include "rt_vid.h"
#include "rt_door.h"
#include "rt_in.h"
#include "rt_str.h"
#include "isr.h"
#include "rt_build.h"
#include "rt_rand.h"
#include "rt_cfg.h"
#include "rt_sound.h"
#include "version.h"
#include "rt_crc.h"
#include "modexlib.h"
#include "engine.h"
#include "gmove.h"
#include "rt_com.h"
#include "rt_net.h"
#include "watcom.h"
#include "rt_floor.h"
#include "rt_msg.h"
#include "rt_scale.h"
#include "develop.h"
//MED
// #include "memcheck.h"


#if (SHAREWARE == 1)
#define NUMAMMOGRAPHICS 10
#else
#define NUMAMMOGRAPHICS 20
#endif

//******************************************************************************
//
// GLOBALS
//
//******************************************************************************

int PlayerSnds[5] = {SD_PLAYERTCSND, SD_PLAYERTBSND, SD_PLAYERDWSND,
							SD_PLAYERLNSND, SD_PLAYERIPFSND};


int SHAKETICS	= 0xFFFF;
int damagecount = 0;
HighScore	Scores[MaxScores] =
				{
					{"Tom",70000,7,1},
					{"Chuck",60000,6,1},
					{"Mark",50000,5,1},
					{"The Joes",40000,4,1},
					{"William",30000,3,1},
					{"Jim",20000,2,1},
					{"Steve",10000,1,1},
				};


//******************************************************************************
//
// LOCALS
//
//******************************************************************************

static int KeyX[4]  = {KEY1_X, KEY2_X, KEY3_X, KEY4_X};

// static char *Names[ 5 ] =
static char *Names[ 10 ] =
{
	"Taradino", "Thi",	  "Doug",  "Lorelei", "Ian Paul",
	"B.J.", NULL
};

//static char *LastNames[ 5 ] =
static char *LastNames[ 10 ] =
{
	"Cassatt",  "Barrett", "Wendt", "Ni",		"Freeley",
	"Blazkowicz", NULL
};

static STR ScoreStr;
static STR LivesStr;
static STR TriadStr;
static STR KillStr;

static pic_t *lifeptnums[10];
static pic_t *lifenums[10];
static pic_t *timenums[10];
static pic_t *scorenums[10];
static pic_t *keys[4];
static pic_t *men[5];

static pic_t *health[6];
static pic_t *ammo[26];
static pic_t *erase;
static pic_t *eraseb;
static pic_t *fragpic[ 5 ];
static pic_t *frag100pic[ 5 ];
static pic_t *negfragpic[ 5 ];
static pic_t *menneg[ 5 ];
static pic_t *blankfragpic;

static int powerpics;
static int poweradjust;

static int poweruptime;
static int powerupheight;
static int protectiontime;
static int protectionheight;


static boolean EndLevelStuff = false;
static boolean borderset	  = false;
static int oldsec				= -1;

static pic_t *BkPic;
int SaveTime = 0;
int oldhealth;

static int oldplayerhealth;
static int oldpercenthealth;

static int playeruniformcolor;

#define NUMBONUSES	11
#define BONUSBONUS	100000

//******************************************************************************
//
// V_ReDrawBkgnd ()
//
//******************************************************************************

void V_ReDrawBkgnd (int x, int y, int width, int height, boolean shade)
{
	byte *src;
//	byte *dest;
	unsigned dest;
//	byte *origdest;
	unsigned origdest;
	int j,
		 k,
		 planes,
		 mask,
		 m;

	m = (x&3);
	mask = (1 << m);

//	origdest = (byte *)(bufferofs+ylookup[y]+(x>>2));
	origdest = (bufferofs+ylookup[y]+(x>>2));


	if (VW_MarkUpdateBlock (x, y, x+width-1, y+height-1))
	{
		for (planes = 0; planes < 4; planes++)
		{
			src = (&(BkPic->data)+((80*200)*m)+(80*y)+(x>>2));
			dest = origdest;

			VGAMAPMASK (mask);

			for (j = 0; j < height; j++)
			{
				for (k = 0; k < (width/4); k++)
					if (shade)
//						*dest++ = *(colormap + ((MENUSHADELEVEL>>2)<<8) + *src++);
						VGAWRITE(dest++, *(colormap + ((MENUSHADELEVEL>>2)<<8) + *src++));
					else
//						*dest++ = *src++;
						VGAWRITE(dest++, *src++);

				src += (80-(width/4));
				dest += (linewidth-(width/4));
			}

			m++;
			mask <<= 1;
			if (mask == 16)
			{
				x+=4;
				mask = 1;
				m = 0;
				origdest++;
			}
		}
	}
}


//******************************************************************************
//
// CacheLumpGroup ()
//
//******************************************************************************
void CacheLumpGroup
	(
	char	*startlump,
	pic_t **lumparray,
	int	  numberoflumps
	)

	{
	int lumpnum;
	int i;

	lumpnum = W_GetNumForName( startlump );

	for( i = 0; i < numberoflumps; i++ )
		{
		lumparray[ i ] = ( pic_t * )W_CacheLumpNum( lumpnum + i, PU_LEVEL );
		}
	}

//******************************************************************************
//
// SetupPlayScreen ()
//
//******************************************************************************
void SetupPlayScreen
	(
	void
	)

	{
	int i;
	int j;
	int num;

	erase  = ( pic_t * )W_CacheLumpName( "erase", PU_LEVEL );
	eraseb = ( pic_t * )W_CacheLumpName( "eraseb", PU_LEVEL );

	CacheLumpGroup( "tmnum0", timenums, 10 );
	CacheLumpGroup( "lfnum0", lifeptnums, 10 );
	CacheLumpGroup( "lvnum0", lifenums, 10 );
	CacheLumpGroup( "health1b", health, 6 );
	CacheLumpGroup( "key1", keys, 4 );

	if ( !BATTLEMODE )
	{
		CacheLumpGroup( "scnum0", scorenums, 10 );

		num = locplayerstate->player;
		men[ num ] = ( pic_t * )W_CacheLumpNum( W_GetNumForName( "MAN1" ) +
			num, PU_LEVEL );
	}
	else
	{
		int  man;
		int  num100;
		int  negnum;
		int  negman;

		CacheLumpGroup( "kilnum0", scorenums, 10 );

		negnum  = W_GetNumForName( "botnpic1" );
		num	  = W_GetNumForName( "botpic0" );
		num100  = W_GetNumForName( "botopic1" );
		negman  = W_GetNumForName( "negman1" );
		man	  = W_GetNumForName( "man1" );

		blankfragpic = ( pic_t * )W_CacheLumpNum( num, PU_LEVEL );
		num++;

		for( i = 0; i < numplayers; i++ )
		{
			j = PLAYERSTATE[ i ].player;
			if ( !gamestate.teamplay )
			{
				fragpic[ j ]	 = ( pic_t * )W_CacheLumpNum( num + j, PU_LEVEL );
				frag100pic[ j ] = ( pic_t * )W_CacheLumpNum( num100 + j, PU_LEVEL );
				negfragpic[ j ] = ( pic_t * )W_CacheLumpNum( negnum + j, PU_LEVEL );
			}
			else
			{
				negfragpic[ j ] = ( pic_t * )W_CacheLumpName( "teamnpic", PU_LEVEL );
				fragpic[ j ]	 = ( pic_t * )W_CacheLumpName( "teampic", PU_LEVEL );
				frag100pic[ j ] = fragpic[ j ];
			}

			menneg[ j ]	  = ( pic_t * )W_CacheLumpNum( negman + j, PU_LEVEL );
			men[ j ]		  = ( pic_t * )W_CacheLumpNum( man + j, PU_LEVEL );
		}
	}

	powerpics	= W_GetNumForName( "GDMODEP" );
	poweradjust = POWERUPTICS / 16;

	num	= W_GetNumForName( "INF_B" );

	// bullet weapons
	ammo[0] = ( pic_t * )W_CacheLumpNum( num, PU_LEVEL );
	ammo[1] = ( pic_t * )W_CacheLumpNum( num, PU_LEVEL );
	ammo[2] = ( pic_t * )W_CacheLumpNum( num++, PU_LEVEL );

	for(i=3;i < 13; i++ )
	{
		ammo[ i ] = ( pic_t * )W_CacheLumpNum( num++, PU_LEVEL );
	}

	ammo[13] = ( pic_t * )W_CacheLumpNum( num, PU_LEVEL );
	ammo[14] = ( pic_t * )W_CacheLumpNum( num, PU_LEVEL );
	ammo[15] = ( pic_t * )W_CacheLumpNum( num++, PU_LEVEL );


	for(i=16;i < 26; i++ )
	{
		ammo[ i ] = ( pic_t * )W_CacheLumpNum( num++, PU_LEVEL );
	}


	oldplayerhealth  = -1;
	oldpercenthealth = -1;
}


//******************************************************************************
//
// GameMemToScreen()
//
//******************************************************************************

void GameMemToScreen
	(
	pic_t *source,
	int	x,
	int	y,
	int	bufferofsonly
	)

{
	if ( bufferofsonly )
	{
		VL_MemToScreen( ( byte * )&source->data, source->width,
			source->height, x, y );
	}
	else
	{
		GM_MemToScreen( ( byte * )&source->data, source->width,
			source->height, x, y );
	}
}


//******************************************************************************
//
// DrawPlayScreen ()
//
//******************************************************************************
void DrawPlayScreen
	(
	boolean bufferofsonly
	)

{
	pic_t *shape;
	int	 shapenum;

	if ( SHOW_TOP_STATUS_BAR() )
	{
		shape = W_CacheLumpName( "stat_bar", PU_CACHE );
		GameMemToScreen( shape, 0, 0, bufferofsonly );
	}

	if ( BATTLEMODE )
	{
		DrawKills( bufferofsonly );
	}

	if ( SHOW_BOTTOM_STATUS_BAR() )
	{
		shape = ( pic_t * ) W_CacheLumpName( "bottbar", PU_CACHE );

		if ( SHOW_KILLS() )
		{
			GameMemToScreen( shape, 0, 160, bufferofsonly );
		}
		else
		{
			GameMemToScreen( shape, 0, 184, bufferofsonly );
		}

		DrawBarAmmo( bufferofsonly );
		DrawBarHealth( bufferofsonly );

		if ( demoplayback )
		{
			shape = ( pic_t * )W_CacheLumpName( "demo", PU_CACHE );
			DrawPPic( 148, 185, shape->width, shape->height,
				( byte * )&shape->data, 1, true, bufferofsonly );
		}
	}

	if ( !SHOW_TOP_STATUS_BAR() )
	{
		return;
	}


	oldsec = -1;

	DrawTime( bufferofsonly );

	if ( !BATTLEMODE )
	{
		int character;
		int width;
		int height;

		character = locplayerstate->player;
		if(rott_iswolf)
			character = 5;
		
		GameMemToScreen( men[ character ], MEN_X, MEN_Y,
			bufferofsonly );

		CurrentFont = tinyfont;

		// Draw player's name
		DrawGameString ( MEN_X + 3, MEN_Y + 2, Names[ character ], bufferofsonly );

		VW_MeasurePropString( LastNames[ character ], &width, &height );

		//BGB: ? Past end of array ?
//		DrawGameString ( MEN_X + 44 - width, MEN_Y + 8,
//			Names[ character + 5 ], bufferofsonly );
		DrawGameString ( MEN_X + 44 - width, MEN_Y + 8,
			LastNames[ character ], bufferofsonly );

		UpdateLives( locplayerstate->lives );
		UpdateScore( gamestate.score );
		DrawTriads( bufferofsonly );
		DrawLives( bufferofsonly );
		DrawScore( bufferofsonly );
	}

	DrawKeys( bufferofsonly );

	if ( locplayerstate->poweruptime )
	{
		if ( player->flags & FL_GODMODE )
		{
			shapenum = powerpics;
		}
		else if ( player->flags & FL_DOGMODE )
		{
			shapenum = powerpics + 1;
		}
		else if ( player->flags & FL_FLEET )
		{
			shapenum = powerpics + 2;
		}
		else if ( player->flags & FL_ELASTO )
		{
			shapenum = powerpics + 3;
		}
		else if ( player->flags & FL_SHROOMS )
		{
			shapenum = powerpics + 4;
		}

		shape = ( pic_t * )W_CacheLumpNum ( shapenum, PU_CACHE );

		GameMemToScreen( eraseb, POWERUP1X, POWERUPY, bufferofsonly );

		DrawMPPic( POWERUP1X, POWERUPY + powerupheight, shape->width,
			shape->height - powerupheight, powerupheight,
			( byte * )&shape->data, bufferofsonly );
	}


	if ( locplayerstate->protectiontime )
	{
		if ( player->flags & FL_BPV )
		{
			shapenum = powerpics + 6;
		}
		else if ( player->flags & FL_GASMASK )
		{
			shapenum = powerpics + 5;
		}
		else if ( player->flags & FL_AV )
		{
			shapenum = powerpics + 7;
		}

		shape = ( pic_t * )W_CacheLumpNum( shapenum, PU_CACHE );

		GameMemToScreen( eraseb, POWERUP2X, POWERUPY, bufferofsonly );

		DrawMPPic( POWERUP2X, POWERUPY + protectionheight, shape->width,
			shape->height - protectionheight, protectionheight,
			( byte * )&shape->data, bufferofsonly );
	}
}


//******************************************************************************
//
// ShortenCodeName()
//
//******************************************************************************
void GetShortCodeName
	(
	char *dest,
	char *source,
	int  maxwidth
	)

{
	int width;
	int height;
	int length;

	strcpy( dest, source );

	// Shorten name to fit
	length = strlen( dest );
	VW_MeasurePropString( dest, &width, &height );
	while( width > maxwidth )
	{
		dest[ length ] = 0;
		length--;
		VW_MeasurePropString( dest, &width, &height );
	}
}


//******************************************************************************
//
// DrawKills ()
//
//******************************************************************************
void DrawKills
	(
	boolean bufferofsonly
	)
{
	int  rank;
	int  xpos;
	char codename[ MAXCODENAMELENGTH ];
	int  width;
	int  playernum;
	int  playerimage;
	int  temp;
	pic_t *pic;

	CurrentFont = tinyfont;

	if ( SHOW_TOP_STATUS_BAR() )
	{
		playernum	= BATTLE_Team[ consoleplayer ];
		playerimage = BATTLE_TeamLeader[ playernum ];

		// Set uniformcolor
		playeruniformcolor = PLAYERSTATE[ playerimage ].uniformcolor;

		// Draw player's point box
		pic = men[ PLAYERSTATE[ playerimage ].player ];
		if ( ( gamestate.ShowScores ) && ( BATTLE_Points[ playernum ] < 0 ) )
		{
			pic = menneg[ PLAYERSTATE[ playerimage ].player ];
		}

		DrawPPic( MEN_X, MEN_Y, pic->width, pic->height,
			( byte * )&pic->data, 1, true, bufferofsonly );

		// Draw player's name
		if ( gamestate.teamplay )
		{
			GetShortCodeName( codename, colorname[ playeruniformcolor ],
				42 );
		}
		else
		{
			GetShortCodeName( codename, PLAYERSTATE[ playerimage ].codename,
				42 );
		}

		DrawGameString ( MEN_X + 2, MEN_Y + 2, codename, bufferofsonly );
		// Draw "It" if player is 'it'
		if ( ( ( gamestate.battlemode == battle_Tag ) ||
			( gamestate.battlemode == battle_Hunter ) ) &&
			( BATTLE_It == BATTLE_Team[ consoleplayer ] ) )
		{
			DrawGameString ( MEN_X + 22, MEN_Y + 8,
				"It", bufferofsonly);
		}

		// Draw triad if player is 'it' or has caught a triad
		if ( PLAYER[ consoleplayer ]->flags & FL_DESIGNATED )
		{
			pic = W_CacheLumpName( "smalltri", PU_CACHE );
			DrawPPic( TRIAD_X - 1, TRIAD_Y - 2, pic->width, pic->height,
				( byte * )&pic->data, 1, true, bufferofsonly );
		}
		else if ( ( gamestate.ShowScores ) &&
			( DisplayPoints != bo_kills_infinite ) )
		{
			// Draw Kill goal
			if ( ( gamestate.battlemode == battle_Collector ) ||
				( gamestate.battlemode == battle_StandAloneGame ) )
			{
				temp = BATTLE_NumCollectorItems;
			}
			else
			{
				temp = DisplayPoints;
			}

			ltoa ( temp % 1000, KillStr.str, 10);
			KillStr.length = strlen (KillStr.str);
			DrawNumber (TRIAD_X - 6, TRIAD_Y, 3, 5, bufferofsonly);
		}

		// Set uniformcolor
		playeruniformcolor = PLAYERSTATE[ consoleplayer ].uniformcolor;

		if ( gamestate.ShowScores )
		{
			// Draw local player's points
			temp = BATTLE_Points[ playernum ] % 1000;
			if ( temp < 0 )
			{
				temp = -temp;
			}
			ltoa ( temp, KillStr.str, 10);
			KillStr.length = strlen (KillStr.str);

			DrawNumber( LIVES_X - 12, LIVES_Y, 3, 4, bufferofsonly);
		}
		else
		{
			pic = W_CacheLumpName( "minus", PU_CACHE );
			StatusDrawColoredPic( LIVES_X - 12, LIVES_Y, pic, bufferofsonly, playeruniformcolor );
			StatusDrawColoredPic( LIVES_X - 4, LIVES_Y, pic, bufferofsonly, playeruniformcolor );
		}

		// Draw whoever is 'It'
		playernum	= BATTLE_It;
		playerimage = BATTLE_TeamLeader[ playernum ];

		// Set uniformcolor
		playeruniformcolor = PLAYERSTATE[ playerimage ].uniformcolor;

		// Draw player's point box
		pic = men[ PLAYERSTATE[ playerimage ].player ];
		if ( ( gamestate.ShowScores ) && ( BATTLE_Points[ playernum ] < 0 ) )
		{
			pic = menneg[ PLAYERSTATE[ playerimage ].player ];
		}

		DrawPPic( LEADER_X, LEADER_Y, pic->width, pic->height,
			(byte *)&pic->data, 1, true, bufferofsonly );

		if ( ( gamestate.battlemode == battle_Tag ) ||
			( gamestate.battlemode == battle_Hunter ) )
		{
			DrawGameString ( LEADER_X + 22, LEADER_Y + 8,
				"It", bufferofsonly);
		}

		if ( gamestate.ShowScores )
		{
			// Draw number of points
			temp = BATTLE_Points[ playernum ] % 1000;
			if ( temp < 0 )
			{
				temp = -temp;
			}
			ltoa ( temp, KillStr.str, 10);
			KillStr.length = strlen (KillStr.str);
			DrawNumber ( LEADER_NUM_X, LEADER_NUM_Y, 3, 4, bufferofsonly);
		}
		else
		{
			pic = W_CacheLumpName( "minus", PU_CACHE );
			StatusDrawColoredPic( LEADER_NUM_X, LEADER_NUM_Y, pic, bufferofsonly, playeruniformcolor );
			StatusDrawColoredPic( LEADER_NUM_X + 8, LEADER_NUM_Y, pic, bufferofsonly, playeruniformcolor );
		}

		// Draw name
		if ( gamestate.teamplay )
		{
			DrawGameString ( LEADER_NAME_X, LEADER_NAME_Y - 1,
				colorname[ playeruniformcolor ], bufferofsonly);
		}
		else
		{
			GetShortCodeName( codename, PLAYERSTATE[ playerimage ].codename,
				42 );
			DrawGameString ( LEADER_NAME_X - 1, LEADER_NAME_Y,
				codename, bufferofsonly);
		}
	}

	// Only draw the rest of the rifraff when the kill count is selected
	if ( !SHOW_KILLS() )
	{
		return;
	}

	// Draw all the other losers
	xpos = KILLS_X;
	for( rank = 0; rank < BATTLE_NumberOfTeams; rank++ )
	{
		playernum	= BATTLE_PlayerOrder[ rank ];
		playerimage = BATTLE_TeamLeader[ playernum ];

		if ( ( playernum == BATTLE_It ) && SHOW_TOP_STATUS_BAR() )
		{
			continue;
		}

		// Set uniformcolor
		playeruniformcolor = PLAYERSTATE[ playerimage ].uniformcolor;

		// Draw player's point box
		pic = fragpic[ PLAYERSTATE[ playerimage ].player ];
		if ( gamestate.ShowScores )
		{
			if ( BATTLE_Points[ playernum ] < 0 )
			{
				pic = negfragpic[ PLAYERSTATE[ playerimage ].player ];
			}
			else if ( BATTLE_Points[ playernum ] >= 100 )
			{
				pic = frag100pic[ PLAYERSTATE[ playerimage ].player ];
			}
		}
		DrawPPic( xpos, KILLS_Y, pic->width, pic->height,
			(byte *)&pic->data, 1, true, bufferofsonly );

		// Draw number of points
		if ( gamestate.ShowScores )
		{
			temp = BATTLE_Points[ playernum ] % 1000;
			if ( temp < 0 )
			{
				temp = -temp;
			}
			ltoa ( temp, KillStr.str, 10);
			KillStr.length = strlen (KillStr.str);
			width = 2;
			if ( temp > 99 )
			{
				width = 3;
			}
			DrawNumber( xpos + KILLS_OFFSET + 16 - ( 8 * width ),
				KILLS_Y, width, 4, bufferofsonly);
		}
		else
		{
			pic = W_CacheLumpName( "minus", PU_CACHE );
			StatusDrawColoredPic( ( xpos + KILLS_OFFSET ),
				KILLS_Y, pic, bufferofsonly, playeruniformcolor );
			StatusDrawColoredPic( ( xpos + KILLS_OFFSET + 8 ),
				KILLS_Y, pic, bufferofsonly, playeruniformcolor );
		}

		// Get codename
		if ( gamestate.teamplay )
		{
			GetShortCodeName( codename, colorname[ playeruniformcolor ],
				KILLS_WIDTH - 2 );
		}
		else
		{
			GetShortCodeName( codename, PLAYERSTATE[ playerimage ].codename,
				KILLS_WIDTH - 2 );
		}

		// Draw name
		DrawGameString (xpos + 1, KILLS_NAME_Y, codename, bufferofsonly);

		// Advance to next position
		xpos += KILLS_WIDTH;

		if ( xpos >= 320 )
		{
			break;
		}
	}

	for( rank = BATTLE_NumberOfTeams; rank <= MAXKILLBOXES; rank++ )
	{
		if ( xpos >= 320 )
		{
			break;
		}

		pic = blankfragpic;
		DrawPPic( xpos, KILLS_Y, pic->width, pic->height,
			(byte *)&pic->data, 1, true, bufferofsonly );

		// Advance to next position
		xpos += KILLS_WIDTH;
	}
}


//******************************************************************************
//
// DrawPlayers ()
//
//******************************************************************************
void DrawPlayers
	(
	void
	)

{
	int	 num;
	int	 xpos;
	char	codename[ MAXCODENAMELENGTH ];
	int	 length;
	int	 width;
	int	 height;
	int	 team;
	int	 player;
	int	 character;
	pic_t *pic;
	pic_t *enemy;
	pic_t *friend;

	num = W_GetNumForName( "botpic1" );

	scorenums[ 0 ]= ( pic_t * )W_CacheLumpName( "kilnum0", PU_CACHE );
	friend = ( pic_t * )W_CacheLumpName( "t_friend", PU_CACHE );
	enemy  = ( pic_t * )W_CacheLumpName( "t_enemy", PU_CACHE );

	// Draw all the losers
	CurrentFont = tinyfont;

	xpos = ( 320 - min( numplayers, MAXKILLBOXES ) * KILLS_WIDTH ) / 2;

	for( team = 0; team < BATTLE_NumberOfTeams; team++ )
	{
		for( player = 0; player < numplayers; player++ )
		{
			if ( BATTLE_Team[ player ] == team )
			{
				character = PLAYERSTATE[ player ].player;

				fragpic[ character ] = ( pic_t * )W_CacheLumpNum( num +
					character, PU_CACHE );

				if ( ( numplayers <= MAXKILLBOXES ) ||
					( player != consoleplayer ) )
				{
					// Set uniformcolor
					playeruniformcolor = PLAYERSTATE[ player ].uniformcolor;

					// Draw player's point box
					pic = fragpic[ PLAYERSTATE[ player ].player ];

					VWB_DrawPic ( xpos, PLAYERS_Y, pic );
					if ( gamestate.teamplay )
					{
						if ( BATTLE_Team[ player ] == BATTLE_Team[ consoleplayer ] )
						{
							VWB_DrawPic ( xpos, PLAYERS_TEAM_Y, friend );
						}
						else
						{
							VWB_DrawPic ( xpos, PLAYERS_TEAM_Y, enemy );
						}
					}

					strcpy( KillStr.str, "00" );
					KillStr.length = strlen ( KillStr.str );
					DrawNumber( xpos + KILLS_OFFSET, PLAYERS_Y, 2, 4, true );

					// Get codename
					strcpy( codename, PLAYERSTATE[ player ].codename );

					// Shorten name to fit into point count
					length = strlen( codename );
					US_MeasureStr( &width, &height, codename );
					while( width > KILLS_WIDTH )
					{
						codename[ length ] = 0;
						length--;
						US_MeasureStr( &width, &height, codename );
					}

					// Draw name
					PrintX = xpos;
					PrintY = PLAYERS_NAME_Y;
					US_Print( codename );

					// Advance to next position
					xpos += KILLS_WIDTH;
				}
			}
			if ( xpos >= 320 )
			{
				break;
			}
		}
		if ( xpos >= 320 )
		{
			break;
		}
	}
}

//******************************************************************************
//
// StatusDrawPic ()
//
//******************************************************************************

void StatusDrawPic (unsigned x, unsigned y, pic_t *nums, boolean bufferofsonly)
{
	DrawMPPic (x, y, nums->width, nums->height, 0,
				 (byte *)&nums->data, bufferofsonly);
}

//******************************************************************************
//
// StatusDrawColoredPic ()
//
//******************************************************************************

void StatusDrawColoredPic (unsigned x, unsigned y, pic_t *nums, boolean bufferofsonly, int color)
{
	DrawColoredMPPic (x, y, nums->width, nums->height, 0,
				 (byte *)&nums->data, bufferofsonly, color);
}

//******************************************************************************
//
// DrawGameString ()
//
// draw string to game screen at x,y
//
//******************************************************************************

void DrawGameString (int x, int y, char * str, boolean bufferofsonly)
{
	unsigned tempbuf;

	px=x;
	py=y;

	VW_DrawPropString (str);

#if 0
	if (bufferofsonly==true)
		VW_DrawPropString (str);
	else
	{
		tempbuf=bufferofs;
		bufferofs=page1start;
		VW_DrawPropString (str);
		px=x;
		py=y;
		bufferofs=page2start;
		VW_DrawPropString (str);
		px=x;
		py=y;
		bufferofs=page3start;
		VW_DrawPropString (str);
		bufferofs=tempbuf;
	}
#endif
}


//******************************************************************************
//
// DrawNumber ()
//
// right justifies and pads with zeros
//
//******************************************************************************

void DrawNumber (int x, int y, int width, int which, boolean bufferofsonly)
{
	unsigned length,c;
	char  *str;
	byte z;

	switch (which)
	{
		case 1:
			str = ScoreStr.str;
			length = ScoreStr.length;
		break;

		case 2:
			str = LivesStr.str;
			length = LivesStr.length;
		break;

		case 3:
			str = TriadStr.str;
			length = TriadStr.length;
		break;

		case 4:
		case 5:
		case 6:
			str = KillStr.str;
			length = KillStr.length;
		break;
	}

	z = width - length;	  // Num zeros

	while (z)
	{
		switch (which)
		{
			case 1: StatusDrawPic (x, y, scorenums[0], bufferofsonly);  x+=8; break;
			case 2: StatusDrawPic (x, y, lifenums[0], bufferofsonly);	x+=8; break;
			case 3: StatusDrawPic (x, y, lifeptnums[0], bufferofsonly); x+=6; break;
			case 4: StatusDrawColoredPic (x, y, scorenums[0], bufferofsonly, playeruniformcolor);	x+=8; break;
			case 5: StatusDrawPic (x, y, lifeptnums[0], bufferofsonly); x+=6; break;
			case 6: StatusDrawPic (x, y, lifenums[0], bufferofsonly);	x+=8; break;
		}
		z--;
	}

	c = length <= width ? 0 : length-width;
	while (c < length)
	{
		switch (which)
		{
			case 1: StatusDrawPic (x, y, scorenums[str[c]-'0'], bufferofsonly);  x+=8; break;
			case 2: StatusDrawPic (x, y, lifenums[str[c]-'0'], bufferofsonly);	x+=8; break;
			case 3: StatusDrawPic (x, y, lifeptnums[str[c]-'0'], bufferofsonly); x+=6; break;
			case 4: StatusDrawColoredPic (x, y, scorenums[str[c]-'0'], bufferofsonly, playeruniformcolor);	x+=8; break;
			case 5: StatusDrawPic (x, y, lifeptnums[str[c]-'0'], bufferofsonly); x+=6; break;
			case 6: StatusDrawPic (x, y, lifenums[str[c]-'0'], bufferofsonly);	x+=8; break;
		}
		c++;
	}
}



//******************************************************************************
//
// HealPlayer ()
//
//******************************************************************************

void HealPlayer
	(
	int		points,
	objtype *ob
	)
{
	playertype *pstate;
	int maxhitpoints;

	M_LINKSTATE( ob, pstate );

	pstate->health += points;
	maxhitpoints = MaxHitpointsForCharacter( pstate );
	if ( pstate->health > maxhitpoints )
	{
		pstate->health = maxhitpoints;
	}

	if ( ( SHOW_BOTTOM_STATUS_BAR() ) && ( ob == player ) )
	{
		DrawBarHealth( false );
	}
}

//******************************************************************************
//
// DrawLives ()
//
//******************************************************************************

void DrawLives
	(
	boolean bufferofsonly
	)

{
	if ( !SHOW_TOP_STATUS_BAR() )
	{
		return;
	}

	if ( !EndLevelStuff )
	{
		DrawNumber( LIVES_X, LIVES_Y, 2, 2, bufferofsonly );
	}
}


//******************************************************************************
//
// GiveExtraMan ()
//
//******************************************************************************

void  GiveExtraMan (void)
{
	if (locplayerstate->lives < 99)
		locplayerstate->lives++;
	UpdateLives (locplayerstate->lives);
	DrawLives (false);
//	SD_PlaySound (BONUS1UPSND);
}



//******************************************************************************
//
// DrawScore ()
//
//******************************************************************************

void DrawScore
	(
	boolean bufferofsonly
	)
{
	if ( !SHOW_TOP_STATUS_BAR() )
	{
		return;
	}

	if ( !BATTLEMODE )
	{
		DrawNumber( SCORE_X, SCORE_Y, 10, 1, bufferofsonly );
	}
}


//******************************************************************************
//
// GivePoints ()
//
//******************************************************************************

void  GivePoints (long points)
{
	gamestate.score += points;

	UpdateScore (gamestate.score);

	if (!EndLevelStuff)
		DrawScore (false);
}


//******************************************************************************
//
// GiveKey ()
//
//******************************************************************************

void GiveKey (int key)
{
	locplayerstate->keys |= (1<<key);
	DrawKeys (false);
}


//******************************************************************************
//
// GiveLives ()
//
//******************************************************************************

void GiveLives (int newlives)
{
	if ((locplayerstate->lives + newlives) <= 99)
		locplayerstate->lives += newlives;
	else
		locplayerstate->lives = 99;
	UpdateLives (locplayerstate->lives);
	DrawLives (false);
}


#define EnableOldWeapon(pstate)	 \
	{										 \
	LASTSTAT->flags |= FL_ABP;		\
	LASTSTAT->flags &= ~FL_RESPAWN; \
	MakeStatActive(LASTSTAT);		 \
	pstate->weaponx = ob->tilex;	 \
	pstate->weapony = ob->tiley;	 \
	}


//******************************************************************************
//
// GiveWeapon ()
//
//******************************************************************************

void GiveWeapon
	(
	objtype *ob,
	int weapon
	)
{
	playertype *pstate;

	M_LINKSTATE( ob, pstate );

	if ( pstate->weapon == weapon )
	{
		return;
	}

	pstate->HASBULLETWEAPON[ weapon ] = 1;
	if ( ( pstate->weapon == pstate->bulletweapon ) &&
		( pstate->weapon < weapon ) )
	{
		pstate->new_weapon = weapon;
		pstate->weapondowntics = WEAPONS[ pstate->weapon ].screenheight / GMOVE;
		if ( ( ob == player ) && ( SHOW_BOTTOM_STATUS_BAR() ) )
		{
			DrawBarAmmo( false );
		}
	}

	if ( gamestate.BattleOptions.WeaponPersistence )
	{
		SpawnStatic(ob->tilex,ob->tiley,GetItemForWeapon(weapon),9);
		EnableOldWeapon(pstate);
	}

	if ( weapon > pstate->bulletweapon )
	{
		pstate->bulletweapon = weapon;
	}
}


//******************************************************************************
//
// GiveMissileWeapon ()
//
//******************************************************************************

void GiveMissileWeapon(objtype * ob, int which)
{
	playertype * pstate;


	//pstate = (ob==player)?(&playerstate):(&remoteplayerstate);
	M_LINKSTATE(ob,pstate);

	if (!gamestate.BattleOptions.WeaponPersistence)
	{
		if (pstate->ammo &&
			 (pstate->missileweapon != -1) &&
			 (!(WEAPON_IS_MAGICAL(which))) &&
			 (!(WEAPON_IS_MAGICAL(pstate->missileweapon)))
			)
		{
			int nx,ny;

			nx = ob->tilex;
			ny = ob->tiley;
			//FindEmptyTile(&nx,&ny);

			if (IsPlatform(nx,ny))
				SpawnStatic(nx,ny,GetItemForWeapon(pstate->missileweapon),9);
			else
			{
				int newz = sprites[ob->tilex][ob->tiley]->z;
				SpawnStatic(nx,ny,GetItemForWeapon(pstate->missileweapon),-1);
				LASTSTAT->z = newz;
			}
			LASTSTAT->ammo = pstate->ammo;
			EnableOldWeapon(pstate);

		}
	}
	else if (!WEAPON_IS_MAGICAL(which))
	{
		int newz = sprites[ob->tilex][ob->tiley]->z;
		SpawnStatic(ob->tilex,ob->tiley,GetItemForWeapon(which),9);
		LASTSTAT->z = newz;
		EnableOldWeapon(pstate);

	}
	pstate->new_weapon = pstate->missileweapon = which;
	pstate->weapondowntics = WEAPONS[pstate->weapon].screenheight/GMOVE;
}


//******************************************************************************
//
// DrawKeys ()
//
//******************************************************************************

void DrawKeys
	(
	boolean bufferofsonly
	)

{
	if ( !SHOW_TOP_STATUS_BAR() )
	{
		return;
	}

	if ( locplayerstate->keys & 1 )
	{
		GameMemToScreen( keys[ 0 ], KeyX[ 0 ], KEY_Y, bufferofsonly );
	}

	if ( locplayerstate->keys & 2 )
	{
		GameMemToScreen( keys[ 1 ], KeyX[ 1 ], KEY_Y, bufferofsonly );
	}

	if ( locplayerstate->keys & 4 )
	{
		GameMemToScreen( keys[ 2 ], KeyX[ 2 ], KEY_Y, bufferofsonly );
	}

	if ( locplayerstate->keys & 8 )
	{
		GameMemToScreen( keys[ 3 ], KeyX[ 3 ], KEY_Y, bufferofsonly );
	}
}


//******************************************************************************
//
// StatusDrawTime ()
//
//******************************************************************************

void StatusDrawTime
	(
	unsigned x,
	unsigned y,
	unsigned num,
	boolean  bufferofsonly
	)
{
	DrawMPPic( x, y, timenums[ num ]->width, timenums[ num ]->height, 0,
		( byte * )&timenums[ num ]->data, bufferofsonly );
}


//******************************************************************************
//
// DrawTimeNumber ()
//
// right justifies and pads with blanks
//
//******************************************************************************

void DrawTimeNumber (
	int x, int y, int number,
	boolean seconds, boolean bufferofsonly)
{
	char  str[20];

	ltoa (number,str,10);

	if (seconds)
	{
		if (number < 10)
		{
			StatusDrawTime (x,	y, 0, bufferofsonly);
			StatusDrawTime (x+8, y, str[0]-'0', bufferofsonly);
		}
		else
		{
			StatusDrawTime (x,	y, str[0]-'0', bufferofsonly);
			StatusDrawTime (x+8, y, str[1]-'0', bufferofsonly);
		}
	}
	else
	{
		if (number < 10)
			StatusDrawTime (x+8, y, str[0]-'0', bufferofsonly);
		else
		{
			StatusDrawTime (x,	y, str[0]-'0', bufferofsonly);
			StatusDrawTime (x+8, y, str[1]-'0', bufferofsonly);
		}
	}
}


//******************************************************************************
//
// DrawTimeXY ()
//
//******************************************************************************

void DrawTimeXY
	(
	int x,
	int y,
	int sec,
	boolean bufferofsonly
	)

{
	int min;
	int hour;

	while (sec > ( ( 9 * 3600 ) + 3599 ) )
	{
		sec -= ( ( 9 * 3600 ) + 3599 );
	}

	hour  = sec / 3600;
	min	= ( sec / 60 ) - ( hour * 60 );
	sec  %= 60;

	DrawTimeNumber ( x + HOUR_X, y, hour, false, bufferofsonly );
	DrawTimeNumber ( x + MIN_X, y, min, true, bufferofsonly );
	DrawTimeNumber ( x + SEC_X, y, sec, true, bufferofsonly );
}


//******************************************************************************
//
// DrawTime ()
//
//******************************************************************************

void DrawTime
	(
	boolean bufferofsonly
	)

{
	int sec;

	if ( !SHOW_TOP_STATUS_BAR() )
	{
		return;
	}

	if (timelimitenabled == true)
	{
		sec = (timelimit-gamestate.TimeCount) / VBLCOUNTER;
	}
	else
	{
		sec = gamestate.TimeCount / VBLCOUNTER;
	}

	if ( oldsec != sec )
	{
		oldsec = sec;
		DrawTimeXY( GAMETIME_X, GAMETIME_Y, sec, bufferofsonly) ;
	}
}


//******************************************************************************
//
// DrawMPPic ()
//
// Purpose
//	 Draws a masked, planer pic at xpos, ypos.
//
// Parms
//	 xpos	- x position.
//	 ypos	- y position.
//	 width  - width of pic : should be << 2.
//	 height - height of pic.
//	 src	 - data to draw.
//
// Returns
//	 Nothing.
//
//******************************************************************************

void DrawMPPic (int xpos, int ypos, int width, int height, int heightmod, byte *src, boolean bufferofsonly)
{
//	byte *olddest;
	unsigned olddest;
//	byte *dest;
	unsigned dest;
	int x;
	int y;
	int planes;
	byte mask;
	byte pixel;

	mask = 1 << (xpos&3);

//	olddest = (byte *)(ylookup[ypos] + (xpos>>2));
	olddest = (ylookup[ypos] + (xpos>>2));

	for (planes = 0; planes < 4; planes++)
	{
		VGAMAPMASK (mask);

//		olddest = (byte *)(ylookup[ypos] + (xpos>>2));

		dest = olddest;

		for (y = 0; y < height; y++)
		{
			for (x = 0; x < width; x++)
			{
				pixel = *src++;

				if (pixel != 255)
				{
//					*(dest+bufferofs) = pixel;

#if 1
					if (bufferofsonly)
						VGAWRITE(dest+bufferofs, pixel);
					else
					{
						VGAWRITE(dest+page1start, pixel);
						VGAWRITE(dest+page2start, pixel);
						VGAWRITE(dest+page3start, pixel);
					}
#endif
				}

				dest++;
			}

			dest += (linewidth-width);
		}

		if (heightmod)
			src += (heightmod*width);

		mask <<= 1;
		if (mask == 16)
		{
			mask = 1;
			olddest++;
		}
	}
}


//******************************************************************************
//
// DrawColoredMPPic ()
//
// Purpose
//	 Draws a masked, planer pic at xpos, ypos.
//
// Parms
//	 xpos	- x position.
//	 ypos	- y position.
//	 width  - width of pic : should be << 2.
//	 height - height of pic.
//	 src	 - data to draw.
//
// Returns
//	 Nothing.
//
//******************************************************************************

void DrawColoredMPPic (int xpos, int ypos, int width, int height, int heightmod, byte *src, boolean bufferofsonly, int color)
{
//	byte *olddest;
	unsigned olddest;
//	byte *dest;
	unsigned dest;
	int x;
	int y;
	int planes;
	byte mask;
	byte pixel;
	byte * cmap;

	cmap=playermaps[color]+(1<<12);

	mask = 1 << (xpos&3);

//	olddest = (byte *)(ylookup[ypos] + (xpos>>2));
	olddest = (ylookup[ypos] + (xpos>>2));

	for (planes = 0; planes < 4; planes++)
	{
		VGAMAPMASK (mask);

//		olddest = (byte *)(ylookup[ypos] + (xpos>>2));
		dest = olddest;

		for (y = 0; y < height; y++)
		{
			for (x = 0; x < width; x++)
			{
				pixel = *src++;

				pixel = *(cmap+pixel);

				if (pixel != 255)
				{
//					*(dest+bufferofs) = pixel;

#if 1
					if (bufferofsonly)
						VGAWRITE(dest+bufferofs, pixel);
					else
					{
						VGAWRITE(dest+page1start, pixel);
						VGAWRITE(dest+page2start, pixel);
						VGAWRITE(dest+page3start, pixel);
					}
#endif
				}

				dest++;
			}

			dest += (linewidth-width);
		}

		if (heightmod)
			src += (heightmod*width);

		mask <<= 1;
		if (mask == 16)
		{
			mask = 1;
			olddest++;
		}
	}
}


//******************************************************************************
//
// UpdateScore ()
//
//******************************************************************************

void UpdateScore (int num)
{
	if (num > 999999999)
	{
		num = 999999999;
		gamestate.score = 999999999;
	}

	ltoa (num, ScoreStr.str, 10);
	ScoreStr.length = strlen (ScoreStr.str);
}


//******************************************************************************
//
// UpdateLives ()
//
//******************************************************************************

void UpdateLives (int num)
{
	ltoa (num, LivesStr.str, 10);
	LivesStr.length = strlen (LivesStr.str);
}

//****************************************************************************
//
// ClearTriads ()
//
//****************************************************************************
void ClearTriads (playertype * pstate)
{
	pstate->triads = 0;
	ltoa (pstate->triads, TriadStr.str, 10);
	TriadStr.length = strlen (TriadStr.str);
}

//****************************************************************************
//
// UpdateTriads ()
//
//****************************************************************************

void UpdateTriads (objtype * ob, int num)
{
	playertype * pstate;

	M_LINKSTATE(ob,pstate);

	pstate->triads += num;

	if (pstate->triads >= 100)
	{
		GiveLives(1);
		if (ob==player)
		{
			AddMessage("100 Life Item Points!  Extra Life!\n",MSG_BONUS);
			SD_PlaySoundRTP (SD_GET1UPSND, player->x, player->y);
		}
		pstate->triads -= 100;
	}

	if (ob==player)
	{
		ltoa (pstate->triads, TriadStr.str, 10);
		TriadStr.length = strlen (TriadStr.str);
	}
}

//****************************************************************************
//
// DrawTriads ()
//
//****************************************************************************

void DrawTriads
	(
	boolean bufferofsonly
	)

{
	if ( !SHOW_TOP_STATUS_BAR() )
	{
		return;
	}

	if ( !EndLevelStuff )
	{
		DrawNumber( TRIAD_X, TRIAD_Y, 2, 3, bufferofsonly );
	}
}


//******************************************************************************
//
// DrawPPic ()
//
//******************************************************************************

void DrawPPic (int xpos, int ypos, int width, int height, byte *src, int num, boolean up, boolean bufferofsonly)
{
//	byte *olddest;
	unsigned olddest;
//	byte *dest;
	unsigned dest;
	int x;
	int y;
	int planes;
	byte mask;
	byte pixel;
	int k;
	int amt;

	if (up)
		amt = 2;
	else
		amt = -2;

	mask = 1;

//	olddest = (byte *)(ylookup[ypos] + (xpos>>2));
	olddest = (ylookup[ypos] + (xpos>>2));

	for (planes = 0; planes < 4; planes++)
	{
		VGAMAPMASK (mask);

//		olddest = (byte *)(ylookup[ypos] + (xpos>>2));
		dest = olddest;

		for (y = 0; y < height; y++)
		{
			for (x = 0; x < width; x++)
			{
				pixel = *src++;

				if (pixel != 255)
				{
					for (k = 0; k < num; k++)
					{
//						*(dest+bufferofs+(amt*k)) = pixel;

#if 1
						if (bufferofsonly)
							VGAWRITE(dest+bufferofs+(amt*k), pixel);
						else
						{
							VGAWRITE(dest+page1start+(amt*k), pixel);
							VGAWRITE(dest+page2start+(amt*k), pixel);
							VGAWRITE(dest+page3start+(amt*k), pixel);
						}
#endif
					}
				}

				dest++;
			}

			dest += (linewidth-width);
		}

		mask <<= 1;
	}
}


//****************************************************************************
//
// DrawBarHealth ()
//
//****************************************************************************

void DrawBarHealth
	(
	boolean bufferofsonly
	)

{
	int percenthealth;
	int health_y;

	if ( !SHOW_BOTTOM_STATUS_BAR() )
	{
		return;
	}

	health_y = HEALTH_Y;
	if ( SHOW_KILLS() )
	{
		health_y -= KILLS_HEIGHT;
	}

	percenthealth = ( locplayerstate->health * 10 ) /
		MaxHitpointsForCharacter( locplayerstate );

	oldpercenthealth = percenthealth + 1;

	if ( playstate == ex_died )
	{
		DrawPPic( HEALTH_X, health_y, 8 >> 2, 16, ( byte * )&erase->data,
			10, true, bufferofsonly );

		return;
	}

	if ( locplayerstate->health <= 0 )
	{
		oldpercenthealth = 0;
	}

	if ( oldpercenthealth >= 11 )
	{
		oldpercenthealth = 10;
	}

	if ( oldpercenthealth < 4 )
	{
		DrawPPic( HEALTH_X, health_y, 8 >> 2, 16,
			( byte * )&health[ 0 ]->data, oldpercenthealth,
			true, bufferofsonly );
	}
	else if ( oldpercenthealth < 5 )
	{
		DrawPPic( HEALTH_X, health_y, 8 >> 2, 16,
			(byte *)&health[ 1 ]->data, oldpercenthealth,
			true, bufferofsonly );
	}
	else
	{
		DrawPPic( HEALTH_X, health_y, 8 >> 2, 16,
			( byte * )&health[ 2 ]->data, oldpercenthealth,
			true, bufferofsonly );
	}

	if ( oldpercenthealth < 10 )
	{
		DrawPPic( HEALTH_X + ( 8 * oldpercenthealth ), health_y,
			8 >> 2, 16, ( byte * )&erase->data, 10 - oldpercenthealth,
			true, bufferofsonly );
	}
}


//****************************************************************************
//
// DrawBarAmmo ()
//
//****************************************************************************

void DrawBarAmmo
	(
	boolean bufferofsonly
	)
{
	int ammo_y;

	if ( ( !SHOW_BOTTOM_STATUS_BAR() ) || ( playstate == ex_died ) )
	{
		return;
	}

	ammo_y = AMMO_Y;
	if ( SHOW_KILLS() )
	{
		ammo_y -= KILLS_HEIGHT;
	}

	DrawPPic ( AMMO_X, ammo_y + 1, 8 >> 2, 16, ( byte * )&erase->data,
		10, false, bufferofsonly );

	if ( !ARMED( player->dirchoosetime ) )
	{
		return;
	}
	if ((locplayerstate->new_weapon < wp_bazooka) ||
		 (locplayerstate->new_weapon == wp_godhand) ||
		 ( gamestate.BattleOptions.Ammo == bo_infinite_shots )
		)
	{
		DrawPPic( AMMO_X - 16, ammo_y, 24 >> 2, 16,
			( byte * )&ammo[ 0 ]->data, 1, true, bufferofsonly);

		DrawPPic( AMMO_X - 32, ammo_y + 1, 8 >> 2, 16,
			( byte * )&erase->data, 2, true, bufferofsonly );
	}
#if (SHAREWARE == 0)
	else if ( locplayerstate->new_weapon == wp_dog )
	{
		DrawPPic( AMMO_X - 16, ammo_y, 24 >> 2, 16,
			( byte * )&ammo[12]->data, 1, true, bufferofsonly );

		DrawPPic( AMMO_X - 32, ammo_y + 1, 8 >> 2, 16,
			( byte * )&erase->data, 2, true, bufferofsonly );
	}
#endif
	else
	{
		DrawPPic( AMMO_X, ammo_y + 1, 8 >> 2, 16,
			( byte * )&ammo[ locplayerstate->new_weapon]->data,
			locplayerstate->ammo, false, bufferofsonly );
	}
}


//******************************************************************************
//
// SingleDrawPPic ()
//
//******************************************************************************

void SingleDrawPPic (
	int xpos, int ypos, int width, int height,
	byte *src, int num, boolean up)
{
//	byte *olddest;
	unsigned olddest;
//	byte *dest;
	unsigned dest;
	int x;
	int y;
	int planes;
	byte mask;
	byte pixel;
	int k;
	int amt;

	if (up)
		amt = 2;
	else
		amt = -2;

	mask = 1;

//	olddest = (byte *)(bufferofs - screenofs + ylookup[ypos] + (xpos>>2));
	olddest = (bufferofs - screenofs + ylookup[ypos] + (xpos>>2));

	for (planes = 0; planes < 4; planes++)
	{
		VGAMAPMASK (mask);

		dest = olddest;

		for (y = 0; y < height; y++)
		{
			for (x = 0; x < width; x++)
			{
				pixel = *src++;

				if (pixel != 255)
				{
					for (k = 0; k < num; k++)
					{
//						*(dest+(amt*k)) = pixel;
						VGAWRITE(dest+(amt*k), pixel);
					}
				}

				dest++;
			}

			dest += (linewidth-width);
		}

		mask <<= 1;
	}
}



//****************************************************************************
//
// DrawStats ()
//
//****************************************************************************

void DrawStats( void )
{
	int percenthealth;
	int health_y;
	int ammo_y;

	if ( ( !SHOW_PLAYER_STATS() ) || ( playstate == ex_died ) ||
		( locplayerstate->health <= 0 ) )
	{
		return;
	}

// Uncomment this if we want transparent health only on sizes < 16
//	if ( viewsize < 16 )
//		{
//		pic_t *shape;
//
//		shape = W_CacheLumpName( "backtile", PU_CACHE );
//		DrawTiledRegion( 0, 160, 320, 24, shape );
//		}

	health_y = HEALTH_Y;
	ammo_y	= AMMO_Y;

	if ( SHOW_KILLS() )
	{
		health_y -= KILLS_HEIGHT;
		ammo_y	-= KILLS_HEIGHT;
	}

	if ( oldplayerhealth != locplayerstate->health )
	{
		oldplayerhealth = locplayerstate->health;

		percenthealth = ( locplayerstate->health * 10 ) /
			MaxHitpointsForCharacter( locplayerstate );

		oldpercenthealth = percenthealth + 1;
	}

	if ( oldpercenthealth > 10 )
	{
		oldpercenthealth = 10;
	}

	if ( oldpercenthealth < 4 )
	{
		SingleDrawPPic( HEALTH_X - 16, health_y, 8 >> 2, 16,
			( byte * )&health[ 3 ]->data, oldpercenthealth, true);
	}
	else if ( oldpercenthealth < 5 )
	{
		SingleDrawPPic( HEALTH_X - 16, health_y, 8 >> 2, 16,
			( byte * )&health[ 4 ]->data, oldpercenthealth, true );
	}
	else
	{
		SingleDrawPPic( HEALTH_X - 16, health_y, 8 >> 2, 16,
			( byte * )&health[ 5 ]->data, oldpercenthealth, true );
	}

	if ( ARMED( consoleplayer ) )
	{
		if ((locplayerstate->new_weapon < wp_bazooka) ||
			 (locplayerstate->new_weapon == wp_godhand) ||
			 (gamestate.BattleOptions.Ammo == bo_infinite_shots )
			)
		{
			SingleDrawPPic( AMMO_X - 16, ammo_y, 24 >> 2, 16,
				( byte * )&ammo[13]->data, 1, true );
		}
#if (SHAREWARE == 0)
		else if ( locplayerstate->new_weapon == wp_dog )
		{
			SingleDrawPPic( AMMO_X - 16, ammo_y + 1, 24 >> 2, 16,
				( byte * )&ammo[25]->data, 1, true );
		}
#endif
		else
		{
			SingleDrawPPic( AMMO_X, ammo_y + 1, 8 >> 2, 16,
				( byte * )&ammo[13 + locplayerstate->new_weapon]->data,
				locplayerstate->ammo, false );
		}
	}
}


//****************************************************************************
//
// DrawPauseXY ()
//
//****************************************************************************

void DrawPauseXY (int x, int y)
{
	pic_t *p;

	if (GamePaused == true)
	{
		p = (pic_t *) W_CacheLumpNum (W_GetNumForName ("paused"), PU_CACHE);
		VWB_DrawPic (x, y, p);
		DrawEpisodeLevel (x,y);
	}
	else
	{
		p = (pic_t *) W_CacheLumpNum (W_GetNumForName ("wait"), PU_CACHE);
		VWB_DrawPic (x, y, p);
	}
}

//****************************************************************************
//
// DrawPause ()
//
//****************************************************************************

void DrawPause (void)
{
	pic_t *p;
	int bufftemp = bufferofs;

	bufferofs -= screenofs;

	if (GamePaused == true)
	{
		p = (pic_t *) W_CacheLumpNum (W_GetNumForName ("paused"), PU_CACHE);
		DrawPauseXY( (320-(p->width<<2) ) >>1, (200-p->height)>>1);
	}
	else
	{
		p = (pic_t *) W_CacheLumpNum (W_GetNumForName ("wait"), PU_CACHE);
		DrawPauseXY( (320-(p->width<<2) ) >>1, (200-p->height)>>1);
	}

	bufferofs = bufftemp;
}

//****************************************************************************
//
// GM_DrawBonus ()
//
//****************************************************************************

void GM_DrawBonus( int which )
{
	int	 x;

	if ( which < stat_gasmask )
	{
		x = POWERUP1X;
		poweruptime = GetBonusTimeForItem(which);
		poweradjust = (poweruptime >> 4);
		powerupheight  = 0;
		GM_UpdateBonus(poweruptime-poweradjust - 1,true);
	}
	else
	{
		x = POWERUP2X;
		protectiontime = GetBonusTimeForItem(which);
		poweradjust = (protectiontime >> 4);
		protectionheight = 0;
		GM_UpdateBonus(protectiontime-poweradjust-1,false);
	}
}


//******************************************************************************
//
// GM_UpdateBonus ()
//
//******************************************************************************

void GM_UpdateBonus
	(
	int time,
	int powerup
	)
{
	pic_t *shape;
	int	 shapenum;

	if ( powerup )
	{
		if ( time < ( poweruptime - poweradjust ) )
		{
			powerupheight++;
			if ( !SHOW_TOP_STATUS_BAR() )
			{
				poweruptime = time;
			}
		}
	}
	else
	{
		if ( time < ( protectiontime - poweradjust ) )
		{
			protectionheight++;
			if ( !SHOW_TOP_STATUS_BAR() )
			{
				protectiontime = time;
			}
		}
	}


	if ( !SHOW_TOP_STATUS_BAR() )
	{
		return;
	}

	if ( !time )
	{
		if ( powerup == 1 )
		{
			shapenum = POWERUP1X;
		}
		else
		{
			shapenum = POWERUP2X;
		}

		GM_MemToScreen( ( byte * )&eraseb->data, eraseb->width,
			eraseb->height, shapenum, POWERUPY );

		return;
	}

	if ( powerup )
	{
		if ( time < ( poweruptime - poweradjust ) )
		{
			if ( player->flags & FL_GODMODE )
			{
				shapenum = powerpics;
			}
			else if ( player->flags & FL_DOGMODE )
			{
				shapenum = powerpics + 1;
			}
			else if ( player->flags & FL_FLEET )
			{
				shapenum = powerpics + 2;
			}
			else if ( player->flags & FL_ELASTO )
			{
				shapenum = powerpics + 3;
			}
			else if ( player->flags & FL_SHROOMS )
			{
				shapenum = powerpics + 4;
			}
			else
			{
				GM_MemToScreen( ( byte * )&eraseb->data,
					eraseb->width, eraseb->height, POWERUP1X, POWERUPY );
				return;
			}

			poweruptime = time;

			shape = ( pic_t * )W_CacheLumpNum( shapenum, PU_CACHE );

			GM_MemToScreen( ( byte * )&eraseb->data, eraseb->width,
				eraseb->height, POWERUP1X, POWERUPY );

			DrawMPPic( POWERUP1X, POWERUPY + powerupheight, shape->width,
				shape->height - powerupheight, powerupheight,
				( byte * )&shape->data, false );
		}
	}
	else
	{
		if ( time < ( protectiontime - poweradjust ) )
		{
			if ( player->flags & FL_BPV )
			{
				shapenum = powerpics + 6;
			}
			else if ( player->flags & FL_GASMASK )
			{
				shapenum = powerpics + 5;
			}
			else if ( player->flags & FL_AV )
			{
				shapenum = powerpics + 7;
			}

			protectiontime = time;

			shape = ( pic_t * )W_CacheLumpNum( shapenum, PU_CACHE );

			GM_MemToScreen( ( byte * )&eraseb->data, eraseb->width,
				eraseb->height, POWERUP2X, POWERUPY );

			DrawMPPic( POWERUP2X, POWERUPY + protectionheight,
				shape->width, shape->height - protectionheight,
				protectionheight, ( byte * )&shape->data, false );
		}
	}
}


//******************************************************************************
//
// Drawpic ()
//
// Purpose
//	 Draws a masked, planer pic at xpos, ypos.
//
// Parms
//	 xpos	- x position.
//	 ypos	- y position.
//	 width  - width of pic : should be << 2.
//	 height - height of pic.
//	 src	 - data to draw.
//
// Returns
//	 Nothing.
//
//******************************************************************************

void Drawpic (int xpos, int ypos, int width, int height, byte *src)
{
//	byte *olddest;
	unsigned olddest;
//	byte *dest;
	unsigned dest;
	int x;
	int y;
	int planes;
	byte mask;
	byte pixel;

	mask = 1 << (xpos&3);

//	olddest = (byte *)(bufferofs + ylookup[ypos] + (xpos>>2));
	olddest = (bufferofs + ylookup[ypos] + (xpos>>2));

	for (planes = 0; planes < 4; planes++)
	{
		VGAMAPMASK (mask);

		dest = olddest;

		for (y = 0; y < height; y++)
		{
			for (x = 0; x < width; x++)
			{
				pixel = *src++;

				if (pixel != 255)
//					*(dest) = pixel;
					VGAWRITE(dest, pixel);

				dest++;
			}

			dest += (linewidth-width);
		}

		mask <<= 1;
		if (mask == 16)
		{
			mask = 1;
			olddest++;
		}
	}
}


//******************************************************************************
//
// DrawEpisodeLevel ()
//
// right justifies and pads with blanks
//
//******************************************************************************

void  DrawEpisodeLevel (int x, int y)
{
	int level;
	char  str[20];
	pic_t *p;

	if (!BATTLEMODE)
	{
		ltoa (gamestate.episode, str, 10);

		Drawpic (x+29, y+16, 8>>2, 16, (byte *)&timenums[str[0]-'0']->data);

		if ((gamestate.mapon == 6) || (gamestate.mapon == 14) ||
			 (gamestate.mapon == 22) || (gamestate.mapon == 32) ||
			 (gamestate.mapon == 33))
		{
			p = (pic_t *) W_CacheLumpName ("tnumb", PU_CACHE);
			Drawpic (x+40, y+16, 8>>2, 16, (byte *)&p->data);

			if (gamestate.mapon == 6)
				level = 1;
			else
				if (gamestate.mapon == 14)
					level = 2;
				else
					if (gamestate.mapon == 22)
						level = 3;
					else
						if (gamestate.mapon == 32)
							level = 4;
						else
							level = 5;
		}
		else
			level = GetLevel (gamestate.episode, gamestate.mapon);

		level = abs(level);
		ltoa (level, str, 10);

		if (level < 10)
			Drawpic (x+49, y+16, 8>>2, 16, (byte *)&timenums[str[0]-'0']->data);
		else
		{
			Drawpic (x+49, y+16, 8>>2, 16, (byte *)&timenums[str[0]-'0']->data);
			Drawpic (x+57, y+16, 8>>2, 16, (byte *)&timenums[str[1]-'0']->data);
		}
	}
	else
	{
		p = (pic_t *) W_CacheLumpName ("battp", PU_CACHE);
		Drawpic (x+16, y+15, 32>>2, 16, (byte *)&p->data);

		level = abs(gamestate.mapon + 1);
		ltoa (level, str, 10);

		if (level < 10)
			Drawpic (x+49, y+16, 8>>2, 16, (byte *)&timenums[str[0]-'0']->data);
		else
		{
			Drawpic (x+49, y+16, 8>>2, 16, (byte *)&timenums[str[0]-'0']->data);
			Drawpic (x+57, y+16, 8>>2, 16, (byte *)&timenums[str[1]-'0']->data);
		}
	}
}


//******************************************************************************
//
// GM_MemToScreen ()
//
//******************************************************************************

void GM_MemToScreen (byte *source, int width, int height, int x, int y)
{
#if 1
	unsigned dest, dest1, dest2, dest3, mask;
	unsigned screen1, screen2, screen3;
	int  plane;

	dest = (ylookup[y]+(x>>2));
	mask = 1 << (x&3);

#if 1
	dest1 = (dest+page1start);
	dest2 = (dest+page2start);
	dest3 = (dest+page3start);
#endif

	for (plane = 0; plane<4; plane++)
	{
		VGAMAPMASK (mask);

		screen1 = dest1;
		screen2 = dest2;
		screen3 = dest3;
		for (y = 0; y < height; y++,
			screen1 += linewidth,
			screen2 += linewidth,
			screen3 += linewidth,
			source += width)
		{
			VGAWRITEBUF (screen1, source, width);
			VGAWRITEBUF (screen2, source, width);
			VGAWRITEBUF (screen3, source, width);
		}

		mask <<= 1;

		if (mask == 16)
		{
			mask = 1;
			dest1++;
			dest2++;
			dest3++;
		}
	}
#endif

//	__debugbreak();
}


//==========================================================================

/*
==================
=
= ScreenShake
=
==================
*/

void ScreenShake (void)
{
	static int which = 0;

	if (SHAKETICS != 0xFFFF)
	{
		SHAKETICS -= tics;

		which = (RandomNumber ("ScreenShake",0) & 3);

		switch (which)
		{
			case 0:
				displayofs += 1;
			break;

			case 1:
				displayofs -= 1;
			break;

			case 2:
				displayofs += 3*SCREENBWIDE;
			break;

			case 3:
				displayofs -= 3*SCREENBWIDE;
			break;
		}
	}
}

//******************************************************************************
//
// DoBorderShifts ()
//
//******************************************************************************

void DoBorderShifts (void)
{
	if (damagecount)
	{
		if (damagecount > 100)
			damagecount = 100;

		damagecount -= 6;

		if (damagecount < 0)
			damagecount = 0;

		SetBorderColor (*(colormap+(((100-damagecount)>>2)<<8)+48));

		borderset = true;
	}
	else
		if (borderset)
		{
			SetBorderColor (0);
			borderset = false;
		}
}


//******************************************************************************
//
// DrawHighScores ()
//
//******************************************************************************

void DrawHighScores (void)
{
	char buffer[16];
#if (SHAREWARE == 0)
	char buffer1[5];
#endif
	int  i,
		  w,
		  h;
	HighScore *s;

	for (i = 0, s = Scores; i < MaxScores; i++, s++)
	{
		PrintY = 25 + (16 * i);

		//
		// name
		//
		PrintX = 3*8;
		DrawMenuBufPropString (PrintX, PrintY, s->name);

		//
		// level
		//
		ultoa (s->completed, buffer, 10);

		PrintX = (17 * 8)-10;
#if (SHAREWARE == 0)
		itoa (s->episode, buffer1, 10);

		DrawMenuBufPropString (PrintX, PrintY, buffer1);
#else
		DrawMenuBufPropString (PrintX, PrintY, "S");
#endif

		DrawMenuBufPropString (PrintX, PrintY, "-");

#if (SHAREWARE == 0)
		if (s->completed == 7)
			DrawMenuBufPropString (PrintX, PrintY, "B");
		else if (s->completed == 8)
			DrawMenuBufPropString (PrintX, PrintY, "S");
		else if (s->completed == 9)
			DrawMenuBufPropString (PrintX, PrintY, "C");
		else if (s->completed == 10)
			DrawMenuBufPropString (PrintX, PrintY, "D");
		else
			DrawMenuBufPropString (PrintX, PrintY, buffer);
#else
		DrawMenuBufPropString (PrintX, PrintY, buffer);
#endif

		//
		// score
		//
		ultoa(s->score,buffer,10);

		VW_MeasurePropString (buffer, &w, &h);
		PrintX = (33 * 8) - w;
		DrawMenuBufPropString (PrintX, PrintY, buffer);
	}
}



//******************************************************************************
//
// CheckHighScore ()
//
//******************************************************************************

void CheckHighScore (long score, word other, boolean INMENU)
{
	word		  i,j;
	int			n;
	HighScore	myscore;
	int			level;

	MenuFadeIn();
	if (!INMENU)
		SetupMenuBuf ();

	strcpy (myscore.name,"");
	myscore.score	  = score;

	level = GetLevel (gamestate.episode, other-1);

	myscore.episode	= gamestate.episode;
	myscore.completed = level;

	CurrentFont = smallfont;

	for (i = 0, n = -1; i < MaxScores; i++)
	{
		if ((myscore.score > Scores[i].score)  ||
			((myscore.score == Scores[i].score) &&
			 (myscore.completed > Scores[i].completed)))
		{
			for (j = MaxScores; --j > i;)
				Scores[j] = Scores[j - 1];
			Scores[i] = myscore;
			n = i;
			break;
		}
	}

	if (INMENU)
	{
		SetAlternateMenuBuf();
		SetMenuTitle ("High Scores");
		ClearMenuBuf();
		DrawHighScores ();
		if (n != -1)
			DisplayInfo (6);
		else
			DisplayInfo (5);
		FlipMenuBuf ();
	}
	else
	{
		ClearMenuBuf ();
		SetMenuTitle ("High Scores");
		DrawHighScores ();
		if (n != -1)
			DisplayInfo (6);
		else
			DisplayInfo (5);
		RefreshMenuBuf (0);
	}

	if (n != -1)
	{
		PrintY = 25 + (16 * n);
		PrintX = 3*8;
		US_LineInput (PrintX, PrintY, Scores[n].name, NULL,
						  true, 10, 98, 0);
	}
	else
	{
		IN_ClearKeysDown ();
		if ( INMENU )
		{
			while( !IN_CheckAck () )
			{
				RefreshMenuBuf (0);
			}
		}
		else
		{
			for( i = 0; i <= 150; i += tics )
			{
				RefreshMenuBuf (0);
				if (IN_CheckAck ())
				{
					break;
				}
			}
		}
	}

	if (INMENU)
	{
		SD_Play (SD_ESCPRESSEDSND);
	}
	else
	{
		ShutdownMenuBuf ();
	}
}


//===========================================================================

//#define HEADERX		140
//#define BONERNAMEX	170
#define HEADERX		152
#define BONERNAMEX	166


/*
==================
=
= DrawEOLHeader ()
=
==================
*/
void DrawEOLHeader( int playstate )
{
	int  health;
	char tempstr[ 15 ];
	char *string;
	int  level;
	int  w;
	int  h;

	VWB_TBar( 30, 5, 250, 75 );

	switch( playstate )
	{
		case ex_skiplevel :
			if ( ( gamestate.violence >= vl_high ) &&
				( gamestate.difficulty >= gd_hard ) )
			{
				string = "LEVEL WUSSED OUT ON!";
			}
			else
			{
				string = "LEVEL SKIPPED.";
			}
			break;

		case ex_secretdone :
			string = "SECRET LEVEL COMPLETED!";
			break;

		case ex_secretlevel :
			string = "SECRET EXIT TAKEN!";
			break;

		case ex_gameover :
			string = "GAME COMPLETED!";
			break;

		case ex_bossdied :
			string = "BOSS DEFEATED!";
			break;

		default :
			string = "LEVEL COMPLETED!";
			break;
	}

	VW_MeasurePropString( string, &w, &h );

	px = ( 320 - w ) / 2;
	py = 10;
	VWB_DrawPropString( string );

	// draw episode number
	string = "EPISODE";
	VW_MeasurePropString( string, &w, &h );
	px = HEADERX - w;
	py = 25;
	VWB_DrawPropString( string );

	itoa( gamestate.episode, tempstr, 10 );
	px = BONERNAMEX;
	VWB_DrawPropString( tempstr );

	// draw area number
	level = GetLevel( gamestate.episode, gamestate.mapon );
	itoa( level, tempstr, 10 );

	py = 35;

	if ( playstate == ex_secretdone )
	{
		string = "SECRET AREA";
	}
	else if ( playstate == ex_bossdied )
	{
		string = "BOSS AREA";
	}
	else if ( gamestate.mapon == 32 )
	{
		string = "CHASE AREA";
	}
	else
	{
		string = "AREA";
	}

	VW_MeasurePropString( string, &w, &h);
	px = HEADERX - w;
	VWB_DrawPropString( string );

	if ( gamestate.mapon != 33 )
	{
		px = BONERNAMEX;
		VWB_DrawPropString( tempstr );
	}

	string = "SCORE";
	VW_MeasurePropString( string, &w, &h);
	px = HEADERX - w;
	py = 45;
	VWB_DrawPropString( string );

	px = BONERNAMEX;
	itoa( gamestate.score, tempstr, 10 );
	VWB_DrawPropString( tempstr );

	string = "HEALTH";
	VW_MeasurePropString( string, &w, &h );
	px = HEADERX - w;
	py = 55;
	VWB_DrawPropString( string );

	px = BONERNAMEX;
	health = ( ( locplayerstate->health * 100 ) /
		MaxHitpointsForCharacter( locplayerstate ) );

	itoa( health, tempstr, 10 );
	VWB_DrawPropString( tempstr );
	VWB_DrawPropString( "%" );

	//
	// Secret count
	//

	{
		char str1[10];
		char str2[10];

		itoa(gamestate.secretcount,&(str1[0]),10);
		strcat(str1," / ");
		itoa(gamestate.secrettotal,&(str2[0]),10);
		strcat(str1,str2);
		string = "SECRET WALLS";
		VW_MeasurePropString( string, &w, &h );
		px = HEADERX - w;
		py = 65;
		VWB_DrawPropString( string );

		px = BONERNAMEX;
		VWB_DrawPropString( str1 );
	}

	VW_UpdateScreen ();
}

boolean EndBonusFirst;
boolean EndBonusSkip;
int	  EndBonusNumBonuses;
int	  EndBonusVoice;
int	  EndBonusStartY;

void DrawEndBonus
	(
	char *string,
	char *bonusstring,
	int	type
	)

{
	int w;
	int h;
	int  health;
	char tempstr[ 15 ];

	if ( EndBonusFirst )
	{
		VWB_TBar( 5, EndBonusStartY - 2, 310, 4 );
		EndBonusFirst = false;
	}

	VWB_TBar( 5, EndBonusStartY + 2, 310, 10 );
	VW_MeasurePropString( string, &w, &h );

	py = EndBonusStartY;
	if ( bonusstring == NULL )
	{
		px = ( 320 - w ) / 2;
		VWB_DrawPropString( string );
	}
	else
	{
		px = BONERNAMEX - w;
		VWB_DrawPropString( string );

		EndBonusNumBonuses++;
		VW_MeasurePropString( bonusstring, &w, &h );
		px = 310 - w;
		py = EndBonusStartY;
		VWB_DrawPropString( bonusstring );
	}

	// Update Score
	py = 45;
	px = BONERNAMEX;
	V_ReDrawBkgnd( px, py, 107, 11, false );
	VWB_TBar( px, py, 107, 11 );
	itoa( gamestate.score, tempstr, 10 );
	VWB_DrawPropString( tempstr );

	// Update Health
	py = 55;
	px = BONERNAMEX;
	V_ReDrawBkgnd( px, py, 107, 11, false );
	VWB_TBar( px, py, 107, 11 );
	health = ( ( locplayerstate->health * 100 ) /
		MaxHitpointsForCharacter( locplayerstate ) );
	itoa( health, tempstr, 10 );
	VWB_DrawPropString( tempstr );
	VWB_DrawPropString( "%" );

	switch( type )
	{
		case 0 :
			EndBonusVoice = SD_Play( SD_ENDBONUS1SND );
			break;

		case 1 :
			EndBonusVoice = SD_Play( SD_NOBONUSSND );
			break;

		case 2 :
			VL_FillPalette(255,255,255);
			VW_UpdateScreen();
			VL_FadeIn(0,255,origpal,10);
			EndBonusVoice = SD_Play( SD_LIGHTNINGSND );
			break;
	}

	EndBonusStartY += 10;

	VW_UpdateScreen();
	while( SD_SoundActive( EndBonusVoice ) && !EndBonusSkip )
	{
		VW_UpdateScreen();
		if ( IN_CheckAck() )
		{
//			__debugbreak();
			EndBonusSkip = true;
		}
	}
}



/*
==================
=
= LevelCompleted
=
= Exit with the screen faded out
=
==================
*/

extern int OLDLMWEAPON;
extern int OLDLWEAPON;

void LevelCompleted
	(
	exit_t playstate
	)

{
	objtype *obj;
	boolean dobonus;
	int i;
	int kr;
	int sr;
	int tr;
	int missileratio;
	int superratio;
	int healthratio;
	int democraticratio;
	int plantratio;
	int cnt;

	EndBonusNumBonuses	= 0;
	EndBonusFirst		= true;
	EndBonusSkip		= false;
	EndBonusStartY		= 90;

	IN_StartAck();
	EndBonusVoice = 0;
	if ( playstate != ex_bossdied )
	{
		EndBonusVoice = SD_Play( SD_LEVELDONESND );
		VL_FillPalette( 255, 255, 255 );
		VL_FadeIn( 0, 255, origpal, 10 );
		if ( player->flags & FL_DOGMODE )
		{
			MU_StartSong( song_dogend );
		}
		else
		{
			MU_StartSong( song_endlevel );
		}
	}

	BkPic = ( pic_t * )W_CacheLumpName( "mmbk", PU_CACHE );
	VWB_DrawPic( 0, 0, BkPic );

	CheckHolidays();
	CurrentFont = smallfont;

	// Kill powerups
	if ( player->flags & FL_ELASTO )
	{
		player->flags &= ~FL_NOFRICTION;
	}

	player->flags &= ~( FL_FLEET | FL_SHROOMS | FL_ELASTO | FL_GODMODE |
		FL_DOGMODE | FL_BPV | FL_AV | FL_GASMASK );

	// Turn off quickload for next level
	pickquick = false;

	//
	// FIGURE RATIOS OUT BEFOREHAND
	//
	kr = 0;
	tr = 0;
	tr = 0;
	superratio		= 0;
	missileratio	 = 0;
	healthratio	  = 0;
	democraticratio = 0;
	plantratio		= 0;

	if ( gamestate.killtotal )
	{
		kr = ( int )( ( ( int )gamestate.killcount ) * 100 ) /
			( ( int )gamestate.killtotal );
	}

	if ( gamestate.secrettotal )
	{
		sr = ( int )( ( ( int )gamestate.secretcount ) * 100 ) /
			( ( int )gamestate.secrettotal );
	}

	if ( gamestate.treasuretotal )
	{
		tr = ( int )( ( ( int )gamestate.treasurecount ) * 100 ) /
			( ( int )gamestate.treasuretotal );
	}

	if ( gamestate.supertotal )
	{
		superratio = ( int )( ( ( int )gamestate.supercount ) * 100 ) /
			( ( int )gamestate.supertotal );
	}

	if ( gamestate.missiletotal )
	{
		missileratio = ( int )( ( ( int )gamestate.missilecount ) * 100 ) /
			( ( int )gamestate.missiletotal );
	}

	if ( gamestate.healthtotal )
	{
		healthratio = ( int )( ( ( int )gamestate.healthcount ) * 100 ) /
			( ( int )gamestate.healthtotal );
	}

	if ( gamestate.democratictotal )
	{
		democraticratio = ( int )( ( ( int )gamestate.democraticcount ) *
			100 ) / ( ( int )gamestate.democratictotal );
	}

	if ( gamestate.planttotal )
	{
		plantratio = ( int )( ( ( int )gamestate.plantcount ) * 100 ) /
			( ( int )gamestate.planttotal );
	}

	DrawEOLHeader( playstate );

	while( SD_SoundActive( EndBonusVoice ) && !EndBonusSkip )
	{
		VW_UpdateScreen();
		if ( IN_CheckAck() )
		{
//			__debugbreak();
			EndBonusSkip = true;
		}
	}

	if ( GetNextMap(player->tilex,player->tiley) == -1)
	{
		if ( gamestate.dipballs == 3 )
		{
			gamestate.score += 100000;
			DrawEndBonus( "DIP BONUS", "100000 POINTS", 0 );
			EndBonusStartY += 10;
		}

		if ( locplayerstate->lives > 0 )
		{
			char str[20];
			char str2[60];

			DrawEndBonus( "EXTRA LIVES BONUS", "\0", 0 );
			itoa(locplayerstate->lives,str,10);
			strcpy(str2,str);
			strcat(str2," EXTRA LIVES =");
			DrawEndBonus( "\0", str2, 0 );
			itoa(locplayerstate->lives,str,10);
			strcpy(str2,str);
			strcat(str2," X 10000 = ");
			itoa(locplayerstate->lives*10000,str,10);
			strcat(str2,str);
			strcat(str2," POINTS");
			gamestate.score += 10000*locplayerstate->lives;
			DrawEndBonus( "\0", str2, 0 );
		}
	}
	else
	{
		//
		// Check for SKIN OF YO TEETH
		//
		if ( locplayerstate->health <= 10 )
		{
			locplayerstate->health = MaxHitpointsForCharacter( locplayerstate );
			DrawEndBonus( "SKIN OF YOUR TEETH", "100% HEALTH", 0 );
		}

		// BULL IN CHINA SHOP BONUS
		if ( tr == 100 )
		{
			gamestate.score += 10000;
			DrawEndBonus( "BULL IN CHINA SHOP", "10000 POINTS", 0 );
		}

		// SUPERCHARE BONUS
		if ( superratio == 100 )
		{
			gamestate.score += 10000;
			DrawEndBonus( "SUPERCHARGE BONUS", "10000 POINTS", 0 );
		}

		// BLEEDER BONUS
		if ( healthratio == 100 )
		{
			gamestate.score += 10000;
			DrawEndBonus( "BLEEDER BONUS", "10000 POINTS", 0 );
		}

		// ADRENALINE BONUS
		if ( kr == 100 )
		{
			gamestate.score += 10000;
			DrawEndBonus( "ADRENALINE BONUS", "10000 POINTS", 0 );
		}

		// CURIOSITY BONUS
		dobonus = true;

		//
		// Check switches
		cnt = lastswitch - &switches[ 0 ];
		if ( cnt != 0 )
		{
			for ( i = 0; i < cnt; i++ )
			{
				if ( ( switches[ i ].flags & FL_S_FLIPPED ) == 0 )
				{
					dobonus = false;
					break;
				}
			}
		}

		//
		// Check pillars
		for ( obj = FIRSTACTOR; obj != NULL; obj = obj->next )
		{
			if ( ( obj->obclass == pillarobj ) &&
				( ( obj->flags & FL_FLIPPED ) == 0 ) )
			{
				dobonus = false;
			}
		}

		if ( ( gamestate.secrettotal ) && ( sr != 100 ) )
		{
			dobonus = false;
		}

		if ( dobonus )
		{
			gamestate.score += 10000;
			DrawEndBonus( "CURIOSITY BONUS", "10000 POINTS", 0 );
		}

		// GROUND ZERO BONUS
		if ( gamestate.DOGROUNDZEROBONUS )
		{
			gamestate.score += 10000;
			DrawEndBonus( "GROUND ZERO BONUS", "10000 POINTS", 0 );
		}

		// REPUBLICAN BONUS 1
		if ( missileratio == 100 )
		{
			gamestate.score += 5000;
			DrawEndBonus( "REPUBLICAN BONUS 1", " 5000 POINTS", 0 );
		}

		// REPUBLICAN BONUS 2
		if (plantratio == 100)
		{
			gamestate.score += 5000;
			DrawEndBonus( "REPUBLICAN BONUS 2", " 5000 POINTS", 0 );
		}

		// DEMOCRATIC BONUS 1
		if ( gamestate.DODEMOCRATICBONUS1 )
		{
			gamestate.score += 5000;
			DrawEndBonus( "DEMOCRATIC BONUS 1", " 5000 POINTS", 0 );
		}

		// DEMOCRATIC BONUS 2
		if (democraticratio == 100)
		{
			gamestate.score += 5000;
			DrawEndBonus( "DEMOCRATIC BONUS 2", " 5000 POINTS", 0 );
		}
	}

	if ( EndBonusNumBonuses == 0 )
	{
		DrawEndBonus( "NO BONUS!", NULL, 1 );
	}

	if ( ( EndBonusNumBonuses != 0 ) || ( playstate == ex_gameover ) )
	{
		SD_Play( PlayerSnds[ locplayerstate->player ] );

		// DO BONUS BONUS
		if ( EndBonusNumBonuses == NUMBONUSES )
		{
			IN_StartAck();
			while( !IN_CheckAck() )
			{
				VW_UpdateScreen();
			}

			BkPic = ( pic_t * )W_CacheLumpName( "mmbk", PU_CACHE );
			VWB_DrawPic( 0, 0, BkPic );

			gamestate.score += BONUSBONUS;
			DrawEOLHeader( playstate );
			EndBonusFirst = true;
			EndBonusStartY = 110;
			EndBonusSkip = true;
			DrawEndBonus( "BONUS BONUS!  1,000,000 POINTS!", NULL, 2 );
			}
		else if ( ( kr == 100 ) && ( dobonus ) )
		{
			IN_StartAck();
			while( !IN_CheckAck() )
			{
				VW_UpdateScreen();
			}

			BkPic = ( pic_t * )W_CacheLumpName( "mmbk", PU_CACHE );
			VWB_DrawPic( 0, 0, BkPic );

			DrawEOLHeader( playstate );
			EndBonusFirst = true;
			EndBonusStartY = 110;
			DrawEndBonus( "You have done well.", NULL, 3 );
#if (SHAREWARE==1)
			EndBonusVoice = SD_Play( SD_RICOCHET3SND );
#else
			EndBonusVoice = SD_Play( SD_PERCENT100SND );
#endif
			EndBonusSkip = false;
			DrawEndBonus( "This level is toast.", NULL, 3 );
		}
	}

	IN_StartAck();
	while( !IN_CheckAck() )
	{
		VW_UpdateScreen();
	}

	EndLevelStuff = false;
	CurrentFont = smallfont;
}


void DrawTallyHeader
	(
	int which
	)

	{
	pic_t *Name;
	pic_t *KillCount;
	pic_t *TimesYouKilledPerson;
	pic_t *TimesPersonKilledYou;
	pic_t *Suicides;
	pic_t *Score;
	pic_t *Blank;
	pic_t *TopBar;

	Name					  = ( pic_t * )W_CacheLumpName( "t_name",	 PU_CACHE );
	Blank					 = ( pic_t * )W_CacheLumpName( "t_blnk",	 PU_CACHE );
	KillCount				= ( pic_t * )W_CacheLumpName( "t_kcount",  PU_CACHE );
	TimesYouKilledPerson = ( pic_t * )W_CacheLumpName( "t_kilper",  PU_CACHE );
	TimesPersonKilledYou = ( pic_t * )W_CacheLumpName( "t_perkil" , PU_CACHE );
	Suicides				 = ( pic_t * )W_CacheLumpName( "t_suicid",  PU_CACHE );
	Score					 = ( pic_t * )W_CacheLumpName( "t_score",	PU_CACHE );
	TopBar					= ( pic_t * )W_CacheLumpName( "t_bar",	  PU_CACHE );

	IFont = ( cfont_t * )W_CacheLumpName( "sifont", PU_CACHE );

	switch( which )
		{
		case 0 :
			VWB_DrawPic (	8,  8, TopBar );
			DrawIntensityString( 12, 11, "FINAL SCORE", 20 );
			VWB_DrawPic (	8, 24, Name );
			VWB_DrawPic ( 136, 24, KillCount );
			VWB_DrawPic ( 184, 24, Suicides );
			VWB_DrawPic ( 272, 24, Score );
			break;

		case 1 :
			VWB_DrawPic (	8,  8, TopBar );
			DrawIntensityString( 12, 11, "FINAL SCORE", 20 );
			VWB_DrawPic (	8, 24, Name );
			VWB_DrawPic ( 136, 24, Blank );
			VWB_DrawPic ( 272, 24, Score );
			break;

		case 2 :
			VWB_DrawPic (	8,  8, TopBar );
			DrawIntensityString( 12, 11, "YOUR KILLS", 20 );
			VWB_DrawPic (	8, 24, Name );
			VWB_DrawPic ( 136, 24, KillCount );
			VWB_DrawPic ( 184, 24, TimesYouKilledPerson );
			break;

		case 3 :
			VWB_DrawPic (	8,  8, TopBar );
			DrawIntensityString( 12, 11, "YOUR DEATHS", 20 );
			VWB_DrawPic (	8, 24, Name );
			VWB_DrawPic ( 136, 24, TimesPersonKilledYou );
			break;
		}

	DrawTimeXY( TALLYTIME_X, TALLYTIME_Y, gamestate.TimeCount / VBLCOUNTER,
		true );
	}


#define BT_RANK_X	 23
#define BT_PLAYER_X  30
#define BT_KILLS_X	( 139 + ( ( 40 + 20 ) / 2 ) )
#define BT_DEATHS_X  ( 193 + ( ( 56 + 20 ) / 2 ) )
//#define BT_SCORE_X	( 263 + ( ( 46 + 20 ) / 2 ) )
#define BT_SCORE_X	( 273 + ( ( 46 + 20 ) / 2 ) )


void ShowKills( int localplayer )
{
	int  w;
	int  h;
	int  i;
	int  j;
	int  temp;
	int  rank;
	int  player;
	int  killer;
	int  victim;
	int  color;
	char tempstr[15];
	int  KillCount[ MAXPLAYERS ];
	int  Order[ MAXPLAYERS ];
	int  NumPlayers;

	// show at the most 11 players
	NumPlayers = min( numplayers, 11 );

	// Count kills
	for( killer = 0; killer < NumPlayers; killer++ )
		{
		Order[ killer ] = killer;
		KillCount[ killer ] = 0;
		for( victim = 0; victim < NumPlayers; victim++ )
			{
			if ( BATTLE_Team[ victim ] != BATTLE_Team[ killer ] )
				{
				KillCount[ killer ] += WhoKilledWho[ killer ][ victim ];
				}
			}
		}

	for( i = 0; i < NumPlayers - 1; i++ )
		{
		for( j = i + 1; j < NumPlayers; j++ )
			{
			if ( KillCount[ Order[ i ] ] < KillCount[ Order[ j ] ] )
				{
				temp = Order[ i ];
				Order[ i ] = Order[ j ];
				Order[ j ] = temp;
				}
			}
		}

	DrawTallyHeader( 2 );

	IFont = (cfont_t * )W_CacheLumpNum (W_GetNumForName ("sifont"), PU_CACHE);
	CurrentFont = smallfont;
	py = 43;

	for( rank = 0; rank < NumPlayers; rank++ )
		{
		player = Order[ rank ];

		color = 21;

		// Highlight the your score
		if ( player == localplayer )
			{
			// Change to Intensity
			color = 241;
			}

		// Draw rank if not tied with previous rank
		if ( ( rank == 0 ) || ( KillCount[ player ] !=
			KillCount[ Order[ rank - 1 ] ] ) )
			{
			itoa( rank + 1, tempstr, 10 );
			}
		else
			{
			strcpy( tempstr, "Tie" );
			}

		VW_MeasureIntensityPropString ( tempstr, &w, &h);
		DrawIntensityString( BT_RANK_X - w, py, tempstr, color );

		// Draw name
		DrawIntensityString( BT_PLAYER_X, py, PLAYERSTATE[ player ].codename, color );

		// Draw kills
		itoa( KillCount[ player ], tempstr, 10 );
		VW_MeasureIntensityPropString ( tempstr, &w, &h);
		DrawIntensityString( BT_KILLS_X - w, py, tempstr, color );

		// Draw times you killed that person
		if ( player != localplayer )
			{
			itoa( WhoKilledWho[ localplayer ][ player ], tempstr, 10 );
			}
		else
			{
			strcpy( tempstr, "-" );
			}

		VW_MeasureIntensityPropString ( tempstr, &w, &h);
		DrawIntensityString( BT_DEATHS_X - w, py, tempstr, color );

		if ( gamestate.teamplay )
			{
			DrawIntensityString( BT_DEATHS_X + 16, py,
				colorname[ PLAYERSTATE[ player ].uniformcolor ], color );
			}

		py += h;
		}
	}


void ShowDeaths( int localplayer )
	{
	int  w;
	int  h;
	int  i;
	int  j;
	int  temp;
	int  rank;
	int  player;
	int  killer;
	int  victim;
	int  color;
	char tempstr[15];
	int  DeathCount[ MAXPLAYERS ];
	int  Order[ MAXPLAYERS ];
	int  NumPlayers;

	// show at the most 11 players
	NumPlayers = min( numplayers, 11 );

	// Count Deaths
	for( victim = 0; victim < NumPlayers; victim++ )
		{
		Order[ victim ] = victim;
		DeathCount[ victim ] = 0;
		for( killer = 0; killer < NumPlayers; killer++ )
			{
			DeathCount[ victim ] += WhoKilledWho[ killer ][ victim ];
			}
		}

	for( i = 0; i < NumPlayers - 1; i++ )
		{
		for( j = i + 1; j < NumPlayers; j++ )
			{
			if ( DeathCount[ Order[ i ] ] < DeathCount[ Order[ j ] ] )
				{
				temp = Order[ i ];
				Order[ i ] = Order[ j ];
				Order[ j ] = temp;
				}
			}
		}

	DrawTallyHeader( 3 );

	IFont = (cfont_t * )W_CacheLumpNum (W_GetNumForName ("sifont"), PU_CACHE);
	CurrentFont = smallfont;
	py = 43;

	for( rank = 0; rank < NumPlayers; rank++ )
		{
		player = Order[ rank ];
		color = 21;

		// Highlight the your score
		if ( player == localplayer )
			{
			// Change to Intensity
			color = 241;
			}

		// Draw rank if not tied with previous rank
		if ( ( rank == 0 ) || ( DeathCount[ player ] !=
			DeathCount[ Order[ rank - 1 ] ] ) )
			{
			itoa( rank + 1, tempstr, 10 );
			}
		else
			{
			strcpy( tempstr, "Tie" );
			}

		VW_MeasureIntensityPropString ( tempstr, &w, &h);
		DrawIntensityString( BT_RANK_X - w, py, tempstr, color );

		// Draw name
		DrawIntensityString( BT_PLAYER_X, py, PLAYERSTATE[ player ].codename, color );

		// Draw deaths
		itoa( DeathCount[ player ], tempstr, 10 );
		VW_MeasureIntensityPropString ( tempstr, &w, &h);
		DrawIntensityString( BT_KILLS_X - w, py, tempstr, color );

		// Draw times you were killed by that person
		itoa( WhoKilledWho[ player ][ localplayer ], tempstr, 10 );
		VW_MeasureIntensityPropString ( tempstr, &w, &h);
		DrawIntensityString( BT_DEATHS_X - w, py, tempstr, color );

		if ( gamestate.teamplay )
			{
			DrawIntensityString( BT_DEATHS_X + 16, py,
				colorname[ PLAYERSTATE[ player ].uniformcolor ], color );
			}

		py += h;
		}
	}


void ShowEndScore( int localplayer )
	{
	int  w;
	int  h;
	int  rank;
	int  leader;
	int  team;
	int  color;
	int  killer;
	int  victim;
	int  killcount;
	int  suicidecount;
	char tempstr[15];
	boolean dofullstats;
	int  NumPlayers;

	// show at the most 11 players
	NumPlayers = min( numplayers, 11 );

	dofullstats = false;
	switch( gamestate.battlemode )
		{
		case battle_Normal :
		case battle_ScoreMore :
		case battle_Hunter :
			dofullstats = true;
			DrawTallyHeader( 0 );
			break;

		case battle_Collector :
		case battle_Scavenger :
		case battle_Tag :
		case battle_Eluder :
		case battle_Deluder :
		case battle_CaptureTheTriad :
			dofullstats = false;
			DrawTallyHeader( 1 );
			break;
		}

	IFont = (cfont_t * )W_CacheLumpNum (W_GetNumForName ("sifont"), PU_CACHE);
	CurrentFont = smallfont;
	py = 43;

	for( rank = 0; rank < BATTLE_NumberOfTeams; rank++ )
		{
		team = BATTLE_PlayerOrder[ rank ];

		color = 21;
		if ( team == BATTLE_Team[ localplayer ] )
			{
			// Change to Intensity
			color = 241;
			}

		// Draw rank if not tied with previous rank
		if ( ( rank == 0 ) || ( BATTLE_Points[ team ] !=
			BATTLE_Points[ BATTLE_PlayerOrder[ rank - 1 ] ] ) )
			{
			itoa( rank + 1, tempstr, 10 );
			}
		else
			{
			strcpy( tempstr, "Tie" );
			}

		VW_MeasureIntensityPropString ( tempstr, &w, &h);
		DrawIntensityString( BT_RANK_X - w, py, tempstr, color );

		// Draw name of team leader
		leader = BATTLE_TeamLeader[ team ];
		if ( gamestate.teamplay )
			{
			DrawIntensityString( BT_PLAYER_X, py,
				colorname[ PLAYERSTATE[ leader ].uniformcolor ], color );
			}
		else
			{
			DrawIntensityString( BT_PLAYER_X, py,
				PLAYERSTATE[ leader ].codename, color );
			}

		if ( dofullstats )
			{
			// Count how many kills each person on the team got
			killcount = 0;
			suicidecount = 0;
			for( killer = 0; killer < NumPlayers; killer++ )
				{
				if ( BATTLE_Team[ killer ] == team )
					{
					for( victim = 0; victim < NumPlayers; victim++ )
						{
						if ( BATTLE_Team[ victim ] != team )
							{
							killcount += WhoKilledWho[ killer ][ victim ];
							}
						else
							{
							suicidecount += WhoKilledWho[ killer ][ victim ];
							}
						}
					}
				}

			// Draw kills
			itoa( killcount, tempstr, 10 );
			VW_MeasureIntensityPropString ( tempstr, &w, &h);
			DrawIntensityString( BT_KILLS_X - w, py, tempstr, color );

			// Draw suicides
			itoa( suicidecount, tempstr, 10 );
			VW_MeasureIntensityPropString ( tempstr, &w, &h);
			DrawIntensityString( BT_DEATHS_X - w, py, tempstr, color );
			}

		// Draw Score
		itoa( BATTLE_Points[ team ], tempstr, 10 );
		VW_MeasureIntensityPropString ( tempstr, &w, &h);
		DrawIntensityString( BT_SCORE_X - w, py, tempstr, color );

		py += h;
		}
	}


void BattleLevelCompleted ( int localplayer )
	{
	ControlInfo ci;
	int w;
	int h;
	int key;
	int Screen;
	int LastScreen;
	int Player;
	char text[80];

	IN_ClearKeysDown ();

	Player = localplayer;
	Screen = 1;
	LastScreen = 0;
	key = -1;
	while( 1 )
		{
		if ( Screen != LastScreen )
			{
			VL_DrawPostPic (W_GetNumForName("trilogo"));

			switch( Screen )
				{
				case 1 :
					ShowEndScore( Player );
					break;

				case 2 :
					ShowKills( Player );
					break;

				case 3 :
					ShowDeaths( Player );
					break;
				}

			CurrentFont = tinyfont;

			sprintf ( text, "Page %d of 3.  Use arrows to switch stats.  "
				"Press Esc to quit.", Screen );
			VW_MeasurePropString ( text, &w, &h);
			py = 192;
			px = ( 320 - w ) / 2;
			VWB_DrawPropString ( text );
			VW_UpdateScreen ();

			do
				{
				ReadAnyControl (&ci);
				}
			while( ci.dir == key );
			}

		LastScreen = Screen;
		ReadAnyControl ( &ci );
		key = ci.dir;
		if ( ( Screen > 1 ) && ( key == dir_West ) )
			{
			Screen--;
			MN_PlayMenuSnd (SD_MOVECURSORSND);
			}
		else if ( ( Screen < 3 ) && ( key == dir_East ) )
			{
			Screen++;
			MN_PlayMenuSnd (SD_MOVECURSORSND);
			}
		// Allow us to select which player to view
		if ( Keyboard[ sc_RShift ] && ( key == dir_South ) )
			{
			Player++;
			if ( Player >= numplayers )
				{
				Player = 0;
				}
			LastScreen = 0;
			MN_PlayMenuSnd (SD_SELECTSND);
			}

		if ( Keyboard[ sc_RShift ] && ( key == dir_North ) )
			{
			Player--;
			if ( Player < 0 )
				{
				Player = numplayers - 1;
				}
			LastScreen = 0;
			MN_PlayMenuSnd (SD_SELECTSND);
			}

		if ( Keyboard[sc_Escape] )
			{
			break;
			}
		}

	while ( Keyboard[sc_Escape] )
		{
		IN_UpdateKeyboard ();
		}

	MN_PlayMenuSnd (SD_ESCPRESSEDSND);

	CurrentFont = smallfont;
	}

//==========================================================================

/*
==================
=
= FindAngleToWindow
=
==================
*/
int FindAngleToWindow ( int tx, int ty )
{
	if (!IsWindow(tx+1,ty))
		return ANG180;
	else if (!IsWindow(tx-1,ty))
		return 0;
	else if (!IsWindow(tx,ty+1))
		return ANG90;
	else
		return ANG270;
}

#define STARTRADIUS (0xa000)
#define STOPRADIUS (0x14000)
#define DEATHRADIUS (STOPRADIUS-STARTRADIUS)
#define ROTRATE		(5)
#define TOTALDEATHROT (FINEANGLES<<1)
#define RADIUSINC	((DEATHRADIUS)/(TOTALDEATHROT))

/*
==================
=
= ZoomDeathOkay
=
==================
*/
boolean ZoomDeathOkay ( void )
{
	int x,y;
	int radius;

	if (
		  !(
		  (player->state==&s_ashwait) ||
		  ((player->flags & FL_HBM) && (gamestate.violence >= vl_high))
		  )
		)
		return false;

	radius=STOPRADIUS;
	x=player->x;
	y=player->y;
	while (radius>0)
		{
		if (tilemap[x>>16][(y+radius)>>16])
			return false;
		if (tilemap[x>>16][(y-radius)>>16])
			return false;
		if (tilemap[(x-radius)>>16][y>>16])
			return false;
		if (tilemap[(x+radius)>>16][y>>16])
			return false;
		if (tilemap[(x+radius)>>16][(y+radius)>>16])
			return false;
		if (tilemap[(x+radius)>>16][(y-radius)>>16])
			return false;
		if (tilemap[(x-radius)>>16][(y+radius)>>16])
			return false;
		if (tilemap[(x-radius)>>16][(y-radius)>>16])
			return false;
		radius-=0x10000;
		}
	return true;
}

/*
==================
=
= Died
=
==================
*/

#define DEATHROTATE 6

extern boolean dopefish;
void Died (void)
{
	long  dx,dy;
	int		iangle,curangle,clockwise,change;
	int	da;
	int	rate;
	lbm_t *LBM;
	int	slowrate;
	playertype *pstate;
	objtype * killerobj=(objtype *)player->target;


	if (killerobj == NULL)
		killerobj = player;

	if (CheckParm("slowdeath"))
		slowrate=3;
	else
		slowrate=0;

	M_LINKSTATE (player, pstate);

	if ( (ZoomDeathOkay()==true) && (pstate->falling==false))
		{
		int x,y,z,radius,heightoffset;
		int endangle,startangle,killangle;
		boolean deadflagset;
		objtype * dummy;

		x=player->x;
		y=player->y;
		z=player->z;
		dummy=player;
		SpawnPlayerobj (x>>16, y>>16, 0, 0);
		player=dummy;
		dummy=new;
		dummy->x=x;
		dummy->drawx=x;
		dummy->y=y;
		dummy->z=z;
		dummy->drawy=y;
		dummy->flags=player->flags;
		player->momentumx=0;
		player->momentumy=0;
		player->speed=0;
		radius=STARTRADIUS;
		heightoffset=pstate->heightoffset;
		deadflagset=false;
		startangle=(player->angle+ANG180)&(FINEANGLES-1);
		endangle=startangle+TOTALDEATHROT;
		killangle=startangle+(TOTALDEATHROT>>1);
		if (dopefish==true)
			{
			AddMessage("Dopefish Death Cam\n",MSG_SYSTEM);
			}
		for (iangle=startangle;;)
			{
			if ( iangle > killangle )
				{
				if ( deadflagset==false )
					{
					dummy->hitpoints=0;
					pstate->health=0;
					dummy->flags &= ~FL_DYING;
					dummy->flags |= FL_SHOOTABLE;
					if (player->state==&s_ashwait)
						dummy->flags |= FL_SKELETON;
					Collision(dummy,(objtype*)NULL,0,0);
					deadflagset=true;
					if ( ( killerobj==player ) && ( gamestate.violence >=
						vl_high ) && ( gamestate.difficulty >= gd_hard ) )
						{
						SD_Play( SD_YOUSUCKSND );
						}
					else
						{
						SD_Play (SD_PLAYERTCDEATHSND+(pstate->player));
						}
					}
				}
			else
				{
				dummy->flags &= ~FL_DYING;
				}
			if (dopefish==true)
				{
				dummy->momentumx+=(RandomNumber("Died",0)<<6)-(256<<5);
				dummy->momentumy+=(RandomNumber("Died",0)<<6)-(256<<5);
				}
			player->x=x+FixedMul(radius,costable[iangle&(FINEANGLES-1)]);
			player->y=y-FixedMul(radius,sintable[iangle&(FINEANGLES-1)]);
			player->z=dummy->z;
			player->angle=(iangle+ANG180)&(FINEANGLES-1);
			if (dopefish==true)
				{
				int dx,dy;

				dx = dummy->x - player->x;
				dy = player->y - dummy->y;

				if (dx && dy)
					player->angle = atan2_appx (dx,dy);
				}
			pstate->heightoffset=heightoffset;
			player->yzangle=0;
			UpdateGameObjects();
			player->momentumx=0;
			player->momentumy=0;
			player->speed=0;
			ThreeDRefresh ();
			AnimateWalls();
			DoSprites();
			DoAnimatedMaskedWalls();
			UpdatePlayers();
			UpdateLightLevel(player->areanumber);

			if (iangle<endangle)
				{
				iangle+=(tics<<ROTRATE);
				radius+=tics*(RADIUSINC<<ROTRATE);
				}
			if ( (dummy->state==dummy->state->next) && (iangle>=endangle) )
				break;
			}
		}
	else if (pstate->falling==false)
		{

		//
		// swing around to face attacker
		//

		rate=DEATHROTATE-slowrate;
			{
			if (killerobj==player)
				{
				iangle=player->angle;
				if ( ( gamestate.violence >= vl_high ) &&
					( gamestate.difficulty >= gd_hard ) )
					{
					SD_Play( SD_YOUSUCKSND );
					}
				}
			else
				{
				SD_Play (SD_PLAYERTCDEATHSND+(pstate->player));
				if (killerobj->which==PWALL)
				{
					dx = ((pwallobj_t *)killerobj)->x - player->x;
					dy = player->y - ((pwallobj_t *)killerobj)->y;
				}
				else
				{
					dx = killerobj->x - player->x;
					dy = player->y - killerobj->y;
				}

				iangle = atan2_appx (dx,dy);		 // returns -pi to pi
				}
			}

		da = iangle-player->angle;

		if (da>0)
			clockwise=1;
		else
			clockwise=0;
		da=abs(da);
		if (da>ANG180)
			{
			clockwise^=1;
			da=ANGLES-da;
			}

		curangle = player->angle;

		do
			{
			DoBorderShifts ();
			change = tics<<rate;
			if (clockwise==1)
				curangle+=change;
			else
				curangle-=change;
			da-=change;
			if (curangle >= ANGLES)
				curangle -= ANGLES;
			if (curangle < 0)
				curangle += ANGLES;
			player->angle = (curangle & (FINEANGLES-1));
			ThreeDRefresh ();
			CalcTics ();
			} while (da>0);
		}
	else
		{
		DrawFullSky();
		FlipPage();
		}

	while (damagecount)
		DoBorderShifts ();
	DoBorderShifts ();

	locplayerstate->weapon = -1;		  // take away weapon

	if (
		  (tedlevel == false) && // SO'S YA DON'T GET KILLED WHILE LAUNCHING!
		  (timelimitenabled == false)
		)
		locplayerstate->lives--;

	if (pstate->falling==false)
		{
		ThreeDRefresh ();
		}

	FlipPage();
	FlipPage();

	if (locplayerstate->lives > -1)
	{
		int rng;

		rng = RandomNumber ("Died",0);

		if (pstate->falling==true)
			{
			RotateBuffer (0, 0, (FINEANGLES), (FINEANGLES>>6), (VBLCOUNTER*(1+slowrate)));
			SD_Play (SD_PLAYERTCDEATHSND+(pstate->player));
			pstate->falling=false;
			}

		else if (rng < 64)
			RotateBuffer (0, 0, (FINEANGLES), (FINEANGLES*64), (VBLCOUNTER*(2+slowrate)));
		else if (rng < 128)
			{
			RotateBuffer (0, 0, (FINEANGLES), (FINEANGLES>>6), (VBLCOUNTER*(1+slowrate)));
			}
		else if (rng < 192)
			RotateBuffer(0, (FINEANGLES*4), (FINEANGLES), (FINEANGLES*64), (VBLCOUNTER*(3+slowrate)));
		else
			VL_FadeToColor (VBLCOUNTER*2, 100, 0, 0);

		screenfaded=false;

		VL_FadeOut (0, 255, 0,0,0,VBLCOUNTER>>1);
		gamestate.episode = 1;
		player->flags &= ~FL_DONE;

		InitializeWeapons (locplayerstate);
		ResetPlayerstate(locplayerstate);

		UpdateLives (locplayerstate->lives);
		UpdateScore (gamestate.score);

		DrawTriads(true);
		DrawLives (true);
		DrawKeys (true);
		DrawScore (true);
	}
	else
	{
		int rng;

		SD_Play (SD_GAMEOVERSND);
		rng=RandomNumber("Died",0);
		if (rng<64)
			RotateBuffer(0,(FINEANGLES>>1),(FINEANGLES),(FINEANGLES*64),(VBLCOUNTER*(3+slowrate)));
		else if (rng<128)
			VL_FadeToColor (VBLCOUNTER*3, 255, 255, 255);
		else if (rng<192)
			RotateBuffer(0,(FINEANGLES*2),(FINEANGLES),(FINEANGLES*64),(VBLCOUNTER*(3+slowrate)));
		else
			RotateBuffer(0,(FINEANGLES*2),(FINEANGLES),(FINEANGLES*64),(VBLCOUNTER*(3+slowrate)));

		screenfaded=false;

		VL_FadeOut (0, 255, 0,0,0,VBLCOUNTER>>1);

		MU_StartSong(song_gameover);

#if (SHAREWARE==0)
		if (gamestate.violence==vl_excessive)
			LBM = (lbm_t *) W_CacheLumpNum (W_GetNumForName ("bootblod"), PU_CACHE);
		else
			LBM = (lbm_t *) W_CacheLumpNum (W_GetNumForName ("bootnorm"), PU_CACHE);
#else
		LBM = (lbm_t *) W_CacheLumpNum (W_GetNumForName ("bootblod"), PU_CACHE);
#endif
		VL_DecompressLBM (LBM,true);

		StopWind();

		IN_UserInput (VBLCOUNTER*60);

		MainMenu[savegame].active = 0;
		MainMenu[viewscores].routine = (void *)CP_ViewScores;
		MainMenu[viewscores].texture[6] = '7';
		MainMenu[viewscores].texture[7] = '\0';
		MainMenu[viewscores].letter	  = 'V';
	}
	ClearGraphicsScreen();

	VL_FadeIn (0, 255, origpal, 15);
}


//******************************************************************************
//
// DoLoadGameAction ()
//
//******************************************************************************

static byte whichstr = 0;

void DoLoadGameAction (void)
{
	if ((SaveTime+1) < ticcount)
	{
		int temp = bufferofs;

		bufferofs = displayofs;
		SaveTime = ticcount;

		CurrentFont=tinyfont;

		px = 92;
		py = 152;
		if (whichstr)
		{
			VW_DrawPropString ("");
			whichstr = 0;
		}
		else
		{
			VW_DrawPropString ("");
			whichstr = 1;
		}
		bufferofs = temp;
	}
}

//******************************************************************************
//
// DoCheckSum ()
//
//******************************************************************************

long DoCheckSum (byte *source, int size, long csum)
{
	int i;
	long checksum;

	checksum = csum;

	for (i = 0; i < size; i++)
		checksum=updatecrc(checksum,*(source+i));

	return checksum;
}

//******************************************************************************
//
// CaculateSaveGameCheckSum ()
//
//******************************************************************************

#define SAVECHECKSUMSIZE (10000)
long CalculateSaveGameCheckSum (char * filename)
{
	int handle;
	int lengthleft;
	int length;
	byte * altbuffer;
	long checksum;

	altbuffer=SafeMalloc(SAVECHECKSUMSIZE);

	checksum = 0;

	// Open the savegame file

	handle = SafeOpenRead (filename);
	lengthleft = w_filelength (handle);

	while (lengthleft>0)
		{
		length=SAVECHECKSUMSIZE;
		if (length>lengthleft)
			length=lengthleft;

		SafeRead(handle,altbuffer,length);
		checksum = DoCheckSum (altbuffer, length, checksum);

		lengthleft-=length;
		}

	SafeFree(altbuffer);

	w_close (handle);

	return checksum;
}

//******************************************************************************
//
// StoreBuffer
//
//******************************************************************************
void StoreBuffer (int handle, byte * src, int size)
{
	SafeWrite(handle,&size,sizeof(size));
	SafeWrite(handle,src,size);
}

//******************************************************************************
//
// SaveTag
//
//******************************************************************************
void SaveTag (int handle, char * tag, int size)
{
	SafeWrite(handle,tag,size);
}


//******************************************************************************
//
// SaveTheGame ()
//
// Expects game to be premalloced
//
//******************************************************************************

boolean SaveTheGame (int num, gamestorage_t * game)
{
//	struct diskfree_t dfree;
	char	loadname[45]="ROTTGAM0.ROT";
	char	filename[ 128 ];
	byte	* altbuffer;
	int	 size;
	int	 avail;
	int	 savehandle;
	int	 crc;
	int	 i;
	char	letter;

	if (num > 15 || num < 0)
		Error("Illegal Saved game value=%ld\n",num);

	//
	// Save Alternate Game Level information for reloading game
	//
	memset (&game->info, 0, sizeof (game->info));
	if (GameLevels.avail == true)
	{
		memcpy (&game->info.path[0], &GameLevels.path[0], sizeof (GameLevels.path));
		memcpy (&game->info.file[0], &GameLevels.file[0], sizeof (GameLevels.file));
		game->info.avail = true;
	}

	game->mapcrc=GetMapCRC (gamestate.mapon);

	// Create the proper file name

	itoa(num,&loadname[7],16);
	loadname[8]='.';


	GetPathFromEnvironment( filename, ApogeePath, loadname );

	// Determine available disk space

#if 0
	letter = toupper(filename[0]);
	if (
		 (letter >= 'A') &&
		 (letter <= 'Q')
		)
		{
		if (_dos_getdiskfree ((letter-'A'+1), &dfree))
			Error ("Error in _dos_getdiskfree call\n");
		}
	else
		{
		if (_dos_getdiskfree (0, &dfree))
			Error ("Error in _dos_getdiskfree call\n");
		}

	avail = (int) dfree.avail_clusters *
					  dfree.bytes_per_sector *
					  dfree.sectors_per_cluster;
	avail -= 8192;
#endif

	avail = 99999999;

	// Check to see if we have enough

	if (avail < MAXSAVEDGAMESIZE)
		{
		CP_DisplayMsg ("There is not enough\nspace on your disk\nto Save Game!\nPress any key to continue", 13);
		return (false);
		}

	// Open the savegame file

	savehandle = SafeOpenWrite (filename);

	// Save out file tag

	size=4;
	SaveTag(savehandle,"ROTT",size);

	// Save out header

	size=sizeof(*game);

	SafeWrite(savehandle,game,size);

/////////////////////////////////////////////////////////////////////////////
// Save out rest of save game file beyond this point
/////////////////////////////////////////////////////////////////////////////

	// Door Tag

	size=4;
	SaveTag(savehandle,"DOOR",size);

	// Doors

	SaveDoors(&altbuffer,&size);
	StoreBuffer(savehandle,altbuffer,size);
	SafeFree(altbuffer);

	// Elevator Tag

	size = 9;
	SaveTag(savehandle,"ELEVATORS",size);

	// Elevators

	SaveElevators(&altbuffer,&size);
	StoreBuffer(savehandle,altbuffer,size);
	SafeFree(altbuffer);

	// Pushwall Tag

	size=5;
	SaveTag(savehandle,"PWALL",size);

	// PushWalls

	SavePushWalls(&altbuffer,&size);
	StoreBuffer(savehandle,altbuffer,size);
	SafeFree(altbuffer);

	// MaskedWalls Tag

	size=5;
	SaveTag(savehandle,"MWALL",size);

	// Masked Walls

	SaveMaskedWalls(&altbuffer,&size);
	StoreBuffer(savehandle,altbuffer,size);
	SafeFree(altbuffer);

	// Switches Tag

	size=6;
	SaveTag(savehandle,"SWITCH",size);

	// Switches

	SaveSwitches(&altbuffer,&size);
	StoreBuffer(savehandle,altbuffer,size);
	SafeFree(altbuffer);

	// Statics Tag

	size=6;
	SaveTag(savehandle,"STATIC",size);

	// Statics

	SaveStatics(&altbuffer,&size);
	StoreBuffer(savehandle,altbuffer,size);
	SafeFree(altbuffer);

	// Actors Tag

	size=5;
	SaveTag(savehandle,"ACTOR",size);

	// Actors

	SaveActors(&altbuffer,&size);
	StoreBuffer(savehandle,altbuffer,size);
	SafeFree(altbuffer);

	// TouchPlates Tag

	size=5;
	SaveTag(savehandle,"TOUCH",size);

	// TouchPlates

	SaveTouchPlates(&altbuffer,&size);
	StoreBuffer(savehandle,altbuffer,size);
	SafeFree(altbuffer);

	// GameState Tag

	size=9;
	SaveTag(savehandle,"GAMESTATE",size);

	// GameState

	size=sizeof(gamestate);
	SafeWrite(savehandle,&gamestate,size);

	// PlayerState Tag

	size=12;
	SaveTag(savehandle,"PLAYERSTATES",size);

	// PlayerStates
	size=sizeof(playertype);
	for(i=0;i<numplayers;i++)
	  {
		SafeWrite(savehandle,&PLAYERSTATE[i],size);
	  }

	// Mapseen Tag

	size=7;
	SaveTag(savehandle,"MAPSEEN",size);

	// MapSeen

	size=sizeof(mapseen);
	SafeWrite(savehandle,&mapseen,size);

	// Song Tag

	size=4;
	SaveTag(savehandle,"SONG",size);

	// Song info

	MU_SaveMusic(&altbuffer,&size);
	StoreBuffer(savehandle,altbuffer,size);
	SafeFree(altbuffer);

	// Misc Tag

	size=4;
	SaveTag(savehandle,"MISC",size);

	// Misc

	// ticcount
	size=sizeof(ticcount);
	SafeWrite(savehandle,(int *)(&ticcount),size);

	// shaketics
	size=sizeof(SHAKETICS);
	SafeWrite(savehandle,&SHAKETICS,size);

	// damagecount
	size=sizeof(damagecount);
	SafeWrite(savehandle,&damagecount,size);

	// viewsize
	size=sizeof(viewsize);
	SafeWrite(savehandle,&viewsize,size);

	// poweruptimes
	size = sizeof (poweruptime);
	SafeWrite(savehandle,&poweruptime,size);

	size = sizeof (protectiontime);
	SafeWrite(savehandle,&protectiontime,size);

	size = sizeof (powerupheight);
	SafeWrite(savehandle,&powerupheight,size);

	size = sizeof (protectionheight);
	SafeWrite(savehandle,&protectionheight,size);

	size = sizeof (poweradjust);
	SafeWrite(savehandle,&poweradjust,size);

	w_close (savehandle);

	// Calculate CRC

	crc = CalculateSaveGameCheckSum (filename);

	// Append the crc

	savehandle = SafeOpenAppend (filename);

	size=sizeof(crc);
	SafeWrite(savehandle,&crc,size);

	w_close (savehandle);

	pickquick = true;
	return (true);
}


//******************************************************************************
//
// LoadTag
//
//******************************************************************************

void LoadTag (byte ** src, char * tag, int size)
{
	if (StringsNotEqual((char *)*src,(char *)tag,size)==true)
		Error("Could not locate %s header in saved game file\n",tag);
	*src+=size;
}

//******************************************************************************
//
// LoadBuffer
//
//******************************************************************************
int LoadBuffer (byte ** dest, byte ** src)
{
	int size;

	memcpy(&size,*src,sizeof(size));
	*src+=sizeof(size);
	*dest=SafeMalloc(size);
	memcpy(*dest,*src,size);
	*src+=size;
	return size;
}


//******************************************************************************
//
// LoadTheGame ()
//
// Expects game to be premalloced
//
//******************************************************************************

boolean LoadTheGame (int num, gamestorage_t * game)
{
	char	loadname[45]="ROTTGAM0.ROT";
	char	filename[128];
	byte	* loadbuffer;
	byte	* bufptr;
	byte	* altbuffer;
	int	 size;
	int	 totalsize;
	int	 checksum;
	int	 savedchecksum;
	int	 i;
	word	mapcrc;


	if (num>15 || num<0)
		Error("Illegal Load game value=%ld\n",num);

	// Create the proper file name

	itoa(num,&loadname[7],16);
	loadname[8]='.';

	GetPathFromEnvironment( filename, ApogeePath, loadname );

	// Load the file

	totalsize=LoadFile(filename,&loadbuffer);
	bufptr=loadbuffer;

	// Calculate checksum

	checksum = DoCheckSum (loadbuffer, totalsize-sizeof(checksum), 0);

	// Retrieve saved checksum

	memcpy (&savedchecksum,loadbuffer+(totalsize-sizeof(savedchecksum)),sizeof(savedchecksum));

	// Compare the two checksums;

	if (checksum!=savedchecksum)
		{
		if (CP_DisplayMsg ("Your Saved Game file is\n"
								 "shall we say, \"corrupted\".\n"
								 "Would you like to\n"
								 "continue anyway (Y/N)?\n", 12)==false)
			{
			return false;
			}
		}

	// Load in file tag

	size=4;
	LoadTag(&bufptr,"ROTT",size);

	// Load in header

	size=sizeof(*game);
	memcpy(game,bufptr,size);
	bufptr+=size;

	if (game->version!=ROTTVERSION)
		return false;

	memcpy (&GameLevels, &game->info, sizeof (GameLevels));

	gamestate.episode=game->episode;
	gamestate.mapon=game->area;

	mapcrc=GetMapCRC (gamestate.mapon);

	if (mapcrc!=game->mapcrc)
		return false;

/////////////////////////////////////////////////////////////////////////////
// Load in rest of saved game file beyond this point
/////////////////////////////////////////////////////////////////////////////

	// Free up the current level
	Z_FreeTags (PU_LEVELSTRUCT, PU_LEVELEND);		 // Free current level

	gamestate.battlemode = battle_StandAloneGame;
	BATTLE_SetOptions( &BATTLE_Options[ battle_StandAloneGame ] );
	BATTLE_Init( gamestate.battlemode, 1 );

	DoLoadGameAction ();
	SetupGameLevel();

	// Door Tag

	size=4;
	LoadTag(&bufptr,"DOOR",size);

	// Doors

	DoLoadGameAction ();
	size=LoadBuffer(&altbuffer,&bufptr);
	LoadDoors(altbuffer,size);
	SafeFree(altbuffer);

	// Elevator Tag

	size = 9;
	LoadTag(&bufptr,"ELEVATORS",size);


	// Elevators

	DoLoadGameAction ();
	size=LoadBuffer(&altbuffer,&bufptr);
	LoadElevators(altbuffer,size);
	SafeFree(altbuffer);

	// Pushwall Tag

	size=5;
	LoadTag(&bufptr,"PWALL",size);

	// PushWalls

	DoLoadGameAction ();
	size=LoadBuffer(&altbuffer,&bufptr);
	LoadPushWalls(altbuffer,size);
	SafeFree(altbuffer);
#if 0
	// Animated Walls Tag

	size=5;
	LoadTag(&bufptr,"AWALL",size);

	// Animated Walls
	size=LoadBuffer(&altbuffer,&bufptr);
	LoadAnimWalls(altbuffer,size);
	SafeFree(altbuffer);
#endif

	// MaskedWalls Tag

	size=5;
	LoadTag(&bufptr,"MWALL",size);

	// Masked Walls

	DoLoadGameAction ();
	size=LoadBuffer(&altbuffer,&bufptr);
	LoadMaskedWalls(altbuffer,size);
	SafeFree(altbuffer);

	// Switches Tag

	size=6;
	LoadTag(&bufptr,"SWITCH",size);

	// Switches

	DoLoadGameAction ();
	size=LoadBuffer(&altbuffer,&bufptr);
	LoadSwitches(altbuffer,size);
	SafeFree(altbuffer);


	// Statics Tag

	size=6;
	LoadTag(&bufptr,"STATIC",size);

	// Statics

	DoLoadGameAction ();
	size=LoadBuffer(&altbuffer,&bufptr);
	LoadStatics(altbuffer,size);
	SafeFree(altbuffer);

	// Actors Tag

	size=5;
	LoadTag(&bufptr,"ACTOR",size);

	// Actors

	DoLoadGameAction ();
	size=LoadBuffer(&altbuffer,&bufptr);
	LoadActors(altbuffer,size);
	SafeFree(altbuffer);

	// TouchPlates Tag

	size=5;
	LoadTag(&bufptr,"TOUCH",size);

	// TouchPlates

	DoLoadGameAction ();
	size=LoadBuffer(&altbuffer,&bufptr);
	LoadTouchPlates(altbuffer,size);
	SafeFree(altbuffer);

	// SetupWindows

	SetupWindows();

	// GameState Tag

	size=9;
	LoadTag(&bufptr,"GAMESTATE",size);

	// GameState

	DoLoadGameAction ();
	size=sizeof(gamestate);
	memcpy(&gamestate,bufptr,size);
	bufptr+=size;

	// PlayerState Tag

	size=12;
	LoadTag(&bufptr,"PLAYERSTATES",size);

	// PlayerState

	DoLoadGameAction ();
	size=sizeof(playertype);
	for(i=0;i<numplayers;i++)
	 {memcpy(&PLAYERSTATE[i],bufptr,size);
	  bufptr+=size;
	 }

	// Zero out player targets

	locplayerstate->guntarget=0;
	locplayerstate->targettime=0;

	// Mapseen Tag

	size=7;
	LoadTag(&bufptr,"MAPSEEN",size);

	// MapSeen

	DoLoadGameAction ();
	size=sizeof(mapseen);
	memcpy(&mapseen,bufptr,size);
	bufptr+=size;

	// Song Tag

	size=4;
	LoadTag(&bufptr,"SONG",size);

	// Song info

	DoLoadGameAction ();
	size=LoadBuffer(&altbuffer,&bufptr);
	MU_LoadMusic(altbuffer,size);
	SafeFree(altbuffer);

	// Misc Tag

	size=4;
	LoadTag(&bufptr,"MISC",size);

	// Misc

	// ticcount
	DoLoadGameAction ();
	size=sizeof(ticcount);
//	memcpy(&ticcount,bufptr,size);
	memcpy((void *)(&ticcount),bufptr,size);
	bufptr+=size;
	SaveTime = ticcount;

	// shaketics
	DoLoadGameAction ();
	size=sizeof(SHAKETICS);
	memcpy(&SHAKETICS,bufptr,size);
	bufptr+=size;

	// damagecount
	DoLoadGameAction ();
	size=sizeof(damagecount);
	memcpy(&damagecount,bufptr,size);
	bufptr+=size;

	// viewsize
	DoLoadGameAction ();
	size=sizeof(viewsize);
	memcpy(&viewsize,bufptr,size);
	bufptr+=size;

	// powerup times
	DoLoadGameAction ();
	size = sizeof (poweruptime);
	memcpy (&poweruptime, bufptr, size);
	bufptr += size;
	size = sizeof (protectiontime);
	memcpy (&protectiontime, bufptr, size);
	bufptr += size;
	size = sizeof (powerupheight);
	memcpy (&powerupheight, bufptr, size);
	bufptr += size;
	size = sizeof (protectionheight);
	memcpy (&protectionheight, bufptr, size);
	bufptr += size;
	size = sizeof (poweradjust);
	memcpy (&poweradjust, bufptr, size);
	bufptr += size;

  // Set the viewsize

	SetViewSize(viewsize);
	DoLoadGameAction ();

	// Connect areas

	ConnectAreas ();
	DoLoadGameAction ();

	// Free up the loadbuffer

	SafeFree (loadbuffer);
	DoLoadGameAction ();

	Illuminate();

	IN_UpdateKeyboard ();
	LoadPlayer ();
	DoLoadGameAction ();
	SetupPlayScreen();
	UpdateScore (gamestate.score);
	UpdateLives (locplayerstate->lives);
	UpdateTriads (player, 0);
	PreCache ();
	InitializeMessages();

	for (i=0;i<100;i++)
		UpdateLightLevel(player->areanumber);

	CalcTics();
	CalcTics();

	pickquick = true;

	return (true);
}


//******************************************************************************
//
// GetSavedMessage ()
//
// Expects message to be premalloced
//
//******************************************************************************

void GetSavedMessage (int num, char * message)
{
	gamestorage_t game;
	char	loadname[45]="ROTTGAM0.ROT";
	char	filename[128];
	byte	* loadbuffer;
	byte	* bufptr;
	int	 size;

	if (num>15 || num<0)
		Error("Illegal Load game value=%ld\n",num);

	// Create the proper file name

	itoa(num,&loadname[7],16);
	loadname[8]='.';

	GetPathFromEnvironment( filename, ApogeePath, loadname );

	// Load the file

	size=LoadFile(filename,&loadbuffer);
	bufptr=loadbuffer;

	size=4;
	LoadTag(&bufptr,"ROTT",size);

	// Load in header

	size=sizeof(game);
	memcpy(&game,bufptr,size);
	strcpy(message,game.message);
	SafeFree(loadbuffer);
}

//******************************************************************************
//
// GetSavedHeader ()
//
// Expects game to be premalloced
//
//******************************************************************************

void GetSavedHeader (int num, gamestorage_t * game)
{
	char	loadname[45]="ROTTGAM0.ROT";
	char	filename[128];
	byte	* loadbuffer;
	byte	* bufptr;
	int	 size;

	if (num>15 || num<0)
		Error("Illegal Load game value=%ld\n",num);

	// Create the proper file name

	itoa(num,&loadname[7],16);
	loadname[8]='.';

	GetPathFromEnvironment( filename, ApogeePath, loadname );

	// Load the file

	size=LoadFile(filename,&loadbuffer);
	bufptr=loadbuffer;

	size=4;
	LoadTag(&bufptr,"ROTT",size);

	// Load in header

	size=sizeof(*game);
	memcpy(game,bufptr,size);
	SafeFree(loadbuffer);
}



//******************************************************************************
//
// GetLevel ()
//
//******************************************************************************

int GetLevel (int episode, int mapon)
{
	int level;

	level = (mapon+1) - ((episode-1) << 3);

	return (level);
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include <stdio.h>
// #include <conio.h>
// #include <dos.h>
// #include <i86.h>
#include <string.h>

#include "rt_main.h"
// #include "rt_spball.h"
#include "rt_def.h"
#include "rt_in.h"
#include "_rt_in.h"
#include "isr.h"
#include "rt_util.h"
// #include "rt_swift.h"
#include "rt_vh_a.h"
#include "rt_cfg.h"
#include "rt_msg.h"
#include "rt_playr.h"
#include "rt_net.h"
#include "rt_com.h"
#include "rt_cfg.h"
//MED
#include "memcheck.h"

#define MAXMESSAGELENGTH      (COM_MAXTEXTSTRINGLENGTH-1)

//****************************************************************************
//
// GLOBALS
//
//****************************************************************************]

//
// Used by menu routines that need to wait for a button release.
// Sometimes the mouse driver misses an interrupt, so you can't wait for
// a button to be released.  Instead, you must ignore any buttons that
// are pressed.
//
int IgnoreMouse = 0;

// configuration variables
//
boolean  SpaceBallPresent;
boolean  CybermanPresent;
boolean  AssassinPresent;
boolean  MousePresent;
boolean  JoysPresent[MaxJoys];
boolean  JoyPadPresent     = 0;

//    Global variables
//
boolean  Paused;
char LastASCII;
volatile int LastScan;

byte Joy_xb,
     Joy_yb,
     Joy_xs,
     Joy_ys;
word Joy_x,
     Joy_y;


int LastLetter = 0;
char LetterQueue[MAXLETTERS];
ModemMessage MSG;

//   'q','w','e','r','t','y','u','i','o','p','[',']','\\', 0 ,'a','s',

char ScanChars[128] =    // Scan code names with single chars
{
    0 , 0 ,'1','2','3','4','5','6','7','8','9','0','-','=', 0 , 0 ,
   'q','w','e','r','t','y','u','i','o','p','[',']', 0 , 0 ,'a','s',
   'd','f','g','h','j','k','l',';','\'','`', 0 ,'\\','z','x','c','v',
   'b','n','m',',','.','/', 0 , 0 , 0 ,' ', 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,'-', 0 ,'5', 0 ,'+', 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
};

char ShiftedScanChars[128] =    // Shifted Scan code names with single chars
{
    0 , 0 ,'!','@','#','$','%','^','&','*','(',')','_','+', 0 , 0 ,
   'Q','W','E','R','T','Y','U','I','O','P','{','}', 0 , 0 ,'A','S',
   'D','F','G','H','J','K','L',':','"','~', 0 ,'|','Z','X','C','V',
   'B','N','M','<','>','?', 0 , 0 , 0 ,' ', 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,'-', 0 ,'5', 0 ,'+', 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
};

#if 0
char ScanChars[128] =    // Scan code names with single chars
{
   '?','?','1','2','3','4','5','6','7','8','9','0','-','+','?','?',
   'Q','W','E','R','T','Y','U','I','O','P','[',']','|','?','A','S',
   'D','F','G','H','J','K','L',';','\'','?','?','?','Z','X','C','V',
   'B','N','M',',','.','/','?','?','?',' ','?','?','?','?','?','?',
   '?','?','?','?','?','?','?','?','?','?','-','?','5','?','+','?',
   '?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?',
   '?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?',
   '?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?'
};
#endif




//****************************************************************************
//
// LOCALS
//
//****************************************************************************]

static KeyboardDef KbdDefs = {0x1d,0x38,0x47,0x48,0x49,0x4b,0x4d,0x4f,0x50,0x51};
static JoystickDef JoyDefs[MaxJoys];
static ControlType Controls[MAXPLAYERS];


static boolean  IN_Started;

static   Direction   DirTable[] =      // Quick lookup for total direction
{
   dir_NorthWest, dir_North,  dir_NorthEast,
   dir_West,      dir_None,   dir_East,
   dir_SouthWest, dir_South,  dir_SouthEast
};

int (*function_ptr)();

static char *ParmStrings[] = {"nojoys","nomouse","spaceball","cyberman","assassin",NULL};


//******************************************************************************
//
// INL_GetMouseDelta () - Gets the amount that the mouse has moved from the
//                        mouse driver
//
//******************************************************************************

void INL_GetMouseDelta(int *x,int *y)
{
#if 0
   union REGS inregs;
   union REGS outregs;

   if (!MousePresent)
      return;

   inregs.w.ax = MDelta;
   int386 (MouseInt, &inregs, &outregs);

   *x = outregs.w.cx;
   *y = outregs.w.dx;
#endif
}



//******************************************************************************
//
// IN_GetMouseButtons () - Gets the status of the mouse buttons from the
//                         mouse driver
//
//******************************************************************************

word IN_GetMouseButtons
   (
   void
   )

   {
#if 0
   word  buttons;
   union REGS inregs;
   union REGS outregs;

   if (!MousePresent || !mouseenabled)
      return (0);

   inregs.w.ax = MButtons;
   int386 (MouseInt, &inregs, &outregs);

   buttons = outregs.w.bx;

// Used by menu routines that need to wait for a button release.
// Sometimes the mouse driver misses an interrupt, so you can't wait for
// a button to be released.  Instead, you must ignore any buttons that
// are pressed.

   IgnoreMouse &= buttons;
   buttons &= ~IgnoreMouse;

   return (buttons);
#endif
}


//******************************************************************************
//
// IN_IgnoreMouseButtons () -
//    Tells the mouse to ignore the currently pressed buttons.
//
//******************************************************************************

void IN_IgnoreMouseButtons
   (
   void
   )

   {
   word  buttons;

   IgnoreMouse |= IN_GetMouseButtons();
   }


//******************************************************************************
//
// IN_GetJoyAbs () - Reads the absolute position of the specified joystick
//
//******************************************************************************

void IN_GetJoyAbs (word joy, word *xp, word *yp)
{
   Joy_x  = Joy_y = 0;
   Joy_xs = joy? 2 : 0;       // Find shift value for x axis
   Joy_xb = 1 << Joy_xs;      // Use shift value to get x bit mask
   Joy_ys = joy? 3 : 1;       // Do the same for y axis
   Joy_yb = 1 << Joy_ys;

   JoyStick_Vals ();

   *xp = Joy_x;
   *yp = Joy_y;
}



//******************************************************************************
//
// INL_GetJoyDelta () - Returns the relative movement of the specified
//                     joystick (from +/-127)
//
//******************************************************************************

void INL_GetJoyDelta (word joy, int *dx, int *dy)
{
   word        x, y;
   JoystickDef *def;
   static longword lasttime;

   IN_GetJoyAbs (joy, &x, &y);
   def = JoyDefs + joy;

   if (x < def->threshMinX)
   {
      if (x < def->joyMinX)
         x = def->joyMinX;

      x = -(x - def->threshMinX);
      x *= def->joyMultXL;
      x >>= JoyScaleShift;
      *dx = (x > 127)? -127 : -x;
   }
   else if (x > def->threshMaxX)
   {
      if (x > def->joyMaxX)
         x = def->joyMaxX;

      x = x - def->threshMaxX;
      x *= def->joyMultXH;
      x >>= JoyScaleShift;
      *dx = (x > 127)? 127 : x;
   }
   else
      *dx = 0;

   if (y < def->threshMinY)
   {
      if (y < def->joyMinY)
         y = def->joyMinY;

      y = -(y - def->threshMinY);
      y *= def->joyMultYL;
      y >>= JoyScaleShift;
      *dy = (y > 127)? -127 : -y;
   }
   else if (y > def->threshMaxY)
   {
      if (y > def->joyMaxY)
         y = def->joyMaxY;

      y = y - def->threshMaxY;
      y *= def->joyMultYH;
      y >>= JoyScaleShift;
      *dy = (y > 127)? 127 : y;
   }
   else
      *dy = 0;

   lasttime = ticcount;
}



//******************************************************************************
//
// INL_GetJoyButtons () - Returns the button status of the specified
//                        joystick
//
//******************************************************************************

word INL_GetJoyButtons (word joy)
{
   word  result;

   result = inp (0x201);   // Get all the joystick buttons
   result >>= joy? 6 : 4;  // Shift into bits 0-1
   result &= 3;            // Mask off the useless bits
   result ^= 3;
   return (result);
}

#if 0
//******************************************************************************
//
// IN_GetJoyButtonsDB () - Returns the de-bounced button status of the
//                         specified joystick
//
//******************************************************************************

word IN_GetJoyButtonsDB (word joy)
{
   longword lasttime;
   word result1,result2;

   do
   {
      result1 = INL_GetJoyButtons (joy);
      lasttime = ticcount;
      while (ticcount == lasttime)
         ;
      result2 = INL_GetJoyButtons (joy);
   } while (result1 != result2);

   return(result1);
}
#endif

//******************************************************************************
//
// INL_StartMouse () - Detects and sets up the mouse
//
//******************************************************************************

boolean INL_StartMouse (void)
{
#if 0
   union REGS inregs;
   union REGS outregs;

   inregs.w.ax = 0;
   int386 (MouseInt, &inregs, &outregs);

   if (outregs.w.ax == 0xffff)
      return (true);
   else
      return (false);
#endif
}



//******************************************************************************
//
// INL_SetJoyScale () - Sets up scaling values for the specified joystick
//
//******************************************************************************

void INL_SetJoyScale (word joy)
{
   JoystickDef *def;

   def = &JoyDefs[joy];
   def->joyMultXL = JoyScaleMax / (def->threshMinX - def->joyMinX);
   def->joyMultXH = JoyScaleMax / (def->joyMaxX - def->threshMaxX);
   def->joyMultYL = JoyScaleMax / (def->threshMinY - def->joyMinY);
   def->joyMultYH = JoyScaleMax / (def->joyMaxY - def->threshMaxY);
}



//******************************************************************************
//
// IN_SetupJoy () - Sets up thresholding values and calls INL_SetJoyScale()
//                  to set up scaling values
//
//******************************************************************************

void IN_SetupJoy (word joy, word minx, word maxx, word miny, word maxy)
{
   word     d,r;
   JoystickDef *def;

   def = &JoyDefs[joy];

   def->joyMinX = minx;
   def->joyMaxX = maxx;
   r = maxx - minx;
   d = r / 3;
   def->threshMinX = ((r / 2) - d) + minx;
   def->threshMaxX = ((r / 2) + d) + minx;

   def->joyMinY = miny;
   def->joyMaxY = maxy;
   r = maxy - miny;
   d = r / 3;
   def->threshMinY = ((r / 2) - d) + miny;
   def->threshMaxY = ((r / 2) + d) + miny;

   INL_SetJoyScale (joy);
}


//******************************************************************************
//
// INL_StartJoy () - Detects & auto-configures the specified joystick
//                   The auto-config assumes the joystick is centered
//
//******************************************************************************

boolean INL_StartJoy (word joy)
{
   word x,y;

   IN_GetJoyAbs (joy, &x, &y);

   if
   (
      ((x == 0) || (x > MaxJoyValue - 10))
   || ((y == 0) || (y > MaxJoyValue - 10))
   )
      return(false);
   else
   {
      IN_SetupJoy (joy, 0, x * 2, 0, y * 2);
      return (true);
   }
}



//******************************************************************************
//
// INL_ShutJoy() - Cleans up the joystick stuff
//
//******************************************************************************

void INL_ShutJoy (word joy)
{
   JoysPresent[joy] = false;
}



//******************************************************************************
//
// IN_Startup() - Starts up the Input Mgr
//
//******************************************************************************


void IN_Startup (void)
{
   boolean checkjoys,
           checkmouse,
           checkcyberman,
           checkspaceball,
           swiftstatus,
           checkassassin;

   word    i;

   if (IN_Started==true)
      return;

   checkjoys        = true;
   checkmouse       = true;
   checkcyberman    = false;
   checkassassin    = false;
   checkspaceball   = false;
   SpaceBallPresent = false;
   CybermanPresent  = false;
   AssassinPresent  = false;

   for (i = 1; i < _argc; i++)
   {
      switch (US_CheckParm (_argv[i], ParmStrings))
      {
      case 0:
         checkjoys = false;
      break;

      case 1:
         checkmouse = false;
      break;

      case 2:
         checkspaceball = true;
      break;

      case 3:
         checkcyberman = true;
         checkmouse = false;
      break;

      case 4:
         checkassassin = true;
         checkmouse = false;
      break;
      }
   }

   MousePresent = checkmouse ? INL_StartMouse() : false;

   if (!MousePresent)
      mouseenabled = false;
   else
      {
      if (!quiet)
         printf("IN_Startup: Mouse Present\n");
      }

   for (i = 0;i < MaxJoys;i++)
      {
      JoysPresent[i] = checkjoys ? INL_StartJoy(i) : false;
      if (INL_StartJoy(i))
         {
         if (!quiet)
            printf("IN_Startup: Joystick Present\n");
         }
      }

//   if (checkspaceball)
//      {
//      OpenSpaceBall ();
//      spaceballenabled=true;
//      }

#if 0
   if ((checkcyberman || checkassassin) && (swiftstatus = SWIFT_Initialize ()))
   {
      int dynamic;

      if (checkcyberman)
         {
         CybermanPresent = swiftstatus;
         cybermanenabled = true;
         }
      else if (checkassassin)
         {
         AssassinPresent = checkassassin & swiftstatus;
         assassinenabled = true;
         }

      dynamic = SWIFT_GetDynamicDeviceData ();

      SWIFT_TactileFeedback (40, 20, 20);

      if (SWIFT_GetDynamicDeviceData () == 2)
         Error ("SWIFT ERROR : External Power too high!\n");

      SWIFT_TactileFeedback (100, 10, 10);
      if (!quiet)
         printf("IN_Startup: Swift Device Present\n");
   }
#endif

   IN_Started = true;
}


#if 0
//******************************************************************************
//
// IN_Default() - Sets up default conditions for the Input Mgr
//
//******************************************************************************

void IN_Default (boolean gotit, ControlType in)
{
   if
   (
      (!gotit)
   ||    ((in == ctrl_Joystick1) && !JoysPresent[0])
   ||    ((in == ctrl_Joystick2) && !JoysPresent[1])
   ||    ((in == ctrl_Mouse) && !MousePresent)
   )
      in = ctrl_Keyboard1;
   IN_SetControlType (0, in);
}
#endif

//******************************************************************************
//
// IN_Shutdown() - Shuts down the Input Mgr
//
//******************************************************************************

void IN_Shutdown (void)
{
   word  i;

   if (IN_Started==false)
      return;

//   INL_ShutMouse();

//   for (i = 0;i < MaxJoys;i++)
//      INL_ShutJoy(i);

//   if (CybermanPresent || AssassinPresent)
//      SWIFT_Terminate ();

//   CloseSpaceBall ();

   IN_Started = false;
}


//******************************************************************************
//
// IN_ClearKeysDown() - Clears the keyboard array
//
//******************************************************************************

void IN_ClearKeysDown (void)
{
   LastScan = sc_None;
   memset (Keyboard, 0, sizeof (Keyboard));
}


//******************************************************************************
//
// IN_ReadControl() - Reads the device associated with the specified
//    player and fills in the control info struct
//
//******************************************************************************

void IN_ReadControl (int player, ControlInfo *info)
{
   boolean     realdelta;
   word        buttons;
   int         dx,dy;
   Motion      mx,my;
   ControlType type;

   KeyboardDef *def;

   dx = dy = 0;
   mx = my = motion_None;
   buttons = 0;


   switch (type = Controls[player])
   {
      case ctrl_Keyboard:
         def = &KbdDefs;

#if 0
         if (Keyboard[def->upleft])
            mx = motion_Left,my = motion_Up;
         else if (Keyboard[def->upright])
            mx = motion_Right,my = motion_Up;
         else if (Keyboard[def->downleft])
            mx = motion_Left,my = motion_Down;
         else if (Keyboard[def->downright])
            mx = motion_Right,my = motion_Down;
#endif
         if (Keyboard[sc_UpArrow])
            my = motion_Up;
         else if (Keyboard[sc_DownArrow])
            my = motion_Down;

         if (Keyboard[sc_LeftArrow])
            mx = motion_Left;
         else if (Keyboard[sc_RightArrow])
            mx = motion_Right;

         if (Keyboard[def->button0])
            buttons += 1 << 0;
         if (Keyboard[def->button1])
            buttons += 1 << 1;
         realdelta = false;
      break;

#if 0
      case ctrl_Joystick1:
      case ctrl_Joystick2:
         INL_GetJoyDelta (type - ctrl_Joystick, &dx, &dy);
         buttons = INL_GetJoyButtons (type - ctrl_Joystick);
         realdelta = true;
      break;

      case ctrl_Mouse:
         INL_GetMouseDelta (&dx,&dy);
         buttons = IN_GetMouseButtons ();
         realdelta = true;
      break;
#endif
   }

   if (realdelta)
   {
      mx = (dx < 0)? motion_Left : ((dx > 0)? motion_Right : motion_None);
      my = (dy < 0)? motion_Up : ((dy > 0)? motion_Down : motion_None);
   }
   else
   {
      dx = mx * 127;
      dy = my * 127;
   }

   info->x = dx;
   info->xaxis = mx;
   info->y = dy;
   info->yaxis = my;
   info->button0 = buttons & (1 << 0);
   info->button1 = buttons & (1 << 1);
   info->button2 = buttons & (1 << 2);
   info->button3 = buttons & (1 << 3);
   info->dir = DirTable[((my + 1) * 3) + (mx + 1)];
}


//******************************************************************************
//
// IN_WaitForKey() - Waits for a scan code, then clears LastScan and
//    returns the scan code
//
//******************************************************************************

ScanCode IN_WaitForKey (void)
{
   ScanCode result;

   while (!(result = LastScan))
      ;
   LastScan = 0;
   return (result);
}


//******************************************************************************
//
// IN_Ack() - waits for a button or key press.  If a button is down, upon
// calling, it must be released for it to be recognized
//
//******************************************************************************

boolean  btnstate[8];

void IN_StartAck (void)
{
   unsigned i,
            buttons = 0;

//
// get initial state of everything
//
   LastScan = 0;

   IN_ClearKeysDown ();
   memset (btnstate, 0, sizeof(btnstate));

	buttons = 0;
//   buttons = IN_JoyButtons () << 4;

   buttons |= IN_GetMouseButtons();

//	if (SpaceBallPresent && spaceballenabled)
//		{
//      buttons |= GetSpaceBallButtons ();
//      }

   for (i=0;i<8;i++,buttons>>=1)
      if (buttons&1)
         btnstate[i] = true;
}



//******************************************************************************
//
// IN_CheckAck ()
//
//******************************************************************************

boolean IN_CheckAck (void)
{
   unsigned i,
            buttons = 0;

//
// see if something has been pressed
//
   if (LastScan)
      return true;

   buttons = IN_JoyButtons () << 4;

   buttons |= IN_GetMouseButtons();

   for (i=0;i<8;i++,buttons>>=1)
      if ( buttons&1 )
      {
         if (!btnstate[i])
            return true;
      }
      else
         btnstate[i]=false;

   return false;
}



//******************************************************************************
//
// IN_Ack ()
//
//******************************************************************************

void IN_Ack (void)
{
   IN_StartAck ();

   while (!IN_CheckAck ())
   ;
}



//******************************************************************************
//
// IN_UserInput() - Waits for the specified delay time (in ticks) or the
//    user pressing a key or a mouse button. If the clear flag is set, it
//    then either clears the key or waits for the user to let the mouse
//    button up.
//
//******************************************************************************

boolean IN_UserInput (long delay)
{
   long lasttime;

   lasttime = ticcount;

   IN_StartAck ();
   do
   {
      if (IN_CheckAck())
         return true;
   } while ((ticcount - lasttime) < delay);

   return (false);
}

//===========================================================================


/*
===================
=
= IN_JoyButtons
=
===================
*/

byte IN_JoyButtons (void)
{
   unsigned joybits;

   joybits = inp (0x201);  // Get all the joystick buttons
   joybits >>= 4;          // only the high bits are useful
   joybits ^= 15;          // return with 1=pressed

   return joybits;
}


//******************************************************************************
//
// IN_UpdateKeyboard ()
//
//******************************************************************************

void IN_UpdateKeyboard (void)
{
   int tail;
   int key;

   if (Keytail != Keyhead)
   {
      tail = Keytail;

      while (Keyhead != tail)
      {
         if (KeyboardQueue[Keyhead] & 0x80)        // Up event
         {
            key = KeyboardQueue[Keyhead] & 0x7F;   // AND off high bit

//            if (keysdown[key])
//            {
//               KeyboardQueue[Keytail] = KeyboardQueue[Keyhead];
//               Keytail = (Keytail+1)&(KEYQMAX-1);
//            }
//            else
    				Keyboard[key] = 0;
         }
         else                                      // Down event
         {
            Keyboard[KeyboardQueue[Keyhead]] = 1;
//            keysdown[KeyboardQueue[Keyhead]] = 1;
         }

         Keyhead = (Keyhead+1)&(KEYQMAX-1);

      }        // while
    }           // if

   // Carry over movement keys from the last refresh
//   keysdown[sc_RightArrow] = Keyboard[sc_RightArrow];
//   keysdown[sc_LeftArrow]  = Keyboard[sc_LeftArrow];
//   keysdown[sc_UpArrow]    = Keyboard[sc_UpArrow];
//   keysdown[sc_DownArrow]  = Keyboard[sc_DownArrow];
   }



//******************************************************************************
//
// IN_InputUpdateKeyboard ()
//
//******************************************************************************

int IN_InputUpdateKeyboard (void)
{
   int key;
   int returnval = 0;
   boolean done = false;

//   _disable ();

   if (Keytail != Keyhead)
   {
      int tail = Keytail;

      while (!done && (Keyhead != tail))
      {
         if (KeyboardQueue[Keyhead] & 0x80)        // Up event
         {
            key = KeyboardQueue[Keyhead] & 0x7F;   // AND off high bit

            Keyboard[key] = 0;
         }
         else                                      // Down event
         {
            Keyboard[KeyboardQueue[Keyhead]] = 1;
            returnval = KeyboardQueue[Keyhead];
            done = true;
         }

         Keyhead = (Keyhead+1)&(KEYQMAX-1);
      }
    }           // if

//   _enable ();

   return (returnval);
}


//******************************************************************************
//
// IN_ClearKeyboardQueue ()
//
//******************************************************************************

void IN_ClearKeyboardQueue (void)
{
   return;

//   IN_ClearKeysDown ();

//   Keytail = Keyhead = 0;
//   memset (KeyboardQueue, 0, sizeof (KeyboardQueue));
//   I_SendKeyboardData(0xf6);
//   I_SendKeyboardData(0xf4);
}


#if 0
//******************************************************************************
//
// IN_DumpKeyboardQueue ()
//
//******************************************************************************

void IN_DumpKeyboardQueue (void)
{
   int head = Keyhead;
   int tail = Keytail;
   int key;

   if (tail != head)
   {
      SoftError( "START DUMP\n");

      while (head != tail)
      {
         if (KeyboardQueue[head] & 0x80)        // Up event
         {
            key = KeyboardQueue[head] & 0x7F;   // AND off high bit

//            if (keysdown[key])
//            {
//               SoftError( "%s - was put in next refresh\n",
//                                 IN_GetScanName (key));
//            }
//            else
//            {
               if (Keyboard[key] == 0)
                  SoftError( "%s %ld - was lost\n", IN_GetScanName (key), key);
               else
                  SoftError( "%s %ld - up\n", IN_GetScanName (key), key);
//            }
         }
         else                                      // Down event
            SoftError( "%s %ld - down\n", IN_GetScanName (KeyboardQueue[head]), KeyboardQueue[head]);

         head = (head+1)&(KEYQMAX-1);
      }        // while

      SoftError( "END DUMP\n");

    }           // if
}
#endif


//******************************************************************************
//
// QueueLetterInput ()
//
//******************************************************************************

void QueueLetterInput (void)
{
   int head = Keyhead;
   int tail = Keytail;
   char c;
   int scancode;
   boolean send = false;

   while (head != tail)
      {
      if (!(KeyboardQueue[head] & 0x80))        // Down event
         {
         scancode = KeyboardQueue[head];

         if (Keyboard[sc_RShift] || Keyboard[sc_LShift])
            {
            c = ShiftedScanChars[scancode];
            }
         else
            {
            c = ScanChars[scancode];
            }

         // If "is printable char", queue the character
         if (c)
            {
            LetterQueue[LastLetter] = c;
            LastLetter = (LastLetter+1)&(MAXLETTERS-1);

            // If typing a message, update the text with 'c'

            if ( MSG.messageon )
               {
               Keystate[scancode]=0;
               KeyboardQueue[head] = 0;
               if ( MSG.inmenu )
                  {
                  if ( ( c == 'A' ) || ( c == 'a' ) )
                     {
                     MSG.towho = MSG_DIRECTED_TO_ALL;
                     send      = true;
                     }

                  if ( ( gamestate.teamplay ) &&
                     ( ( c == 'T' ) || ( c == 't' ) ) )
                     {
                     MSG.towho = MSG_DIRECTED_TO_TEAM;
                     send      = true;
                     }

                  if ( ( c >= '0' ) && ( c <= '9' ) )
                     {
                     int who;

                     if ( c == '0' )
                        {
                        who = 10;
                        }
                     else
                        {
                        who = c - '1';
                        }

                     // Skip over local player
                     if ( who >= consoleplayer )
                        {
                        who++;
                        }

                     if ( who < numplayers )
                        {
                        MSG.towho = who;
                        send      = true;
                        }
                     }

                  if ( send )
                     {
                     MSG.messageon = false;
                     KeyboardQueue[ head ] = 0;
                     Keyboard[ scancode ]  = 0;
                     LastScan              = 0;
                     FinishModemMessage( MSG.textnum, true );
                     }
                  }
               else if ( ( scancode >= sc_1 ) && ( scancode <= sc_0 ) &&
                  ( Keyboard[ sc_Alt ] ) )
                  {
                  int msg;

                  msg = scancode - sc_1;

                  if ( CommbatMacros[ msg ].avail )
                     {
                     MSG.length = strlen( CommbatMacros[ msg ].macro ) + 1;
                     strcpy( Messages[ MSG.textnum ].text,
                        CommbatMacros[ msg ].macro );

                     MSG.messageon = false;
                     FinishModemMessage( MSG.textnum, true );
                     KeyboardQueue[ head ] = 0;
                     Keyboard[ sc_Enter ]  = 0;
                     Keyboard[ sc_Escape ] = 0;
                     LastScan              = 0;
                     }
                  else
                     {
                     MSG.messageon = false;
                     MSG.directed  = false;

                     FinishModemMessage( MSG.textnum, false );
                     AddMessage( "No macro.", MSG_MACRO );
                     KeyboardQueue[ head ] = 0;
                     Keyboard[ sc_Enter ]  = 0;
                     Keyboard[ sc_Escape ] = 0;
                     LastScan              = 0;
                     }
                  }
               else if ( MSG.length < MAXMESSAGELENGTH )
                  {
                  UpdateModemMessage (MSG.textnum, c);
                  }
               }
            }
         else
            {
            // If typing a message, check for special characters

            if ( MSG.messageon && MSG.inmenu )
               {
               if ( scancode == sc_Escape )
                  {
                  MSG.messageon = false;
                  MSG.directed  = false;
                  FinishModemMessage( MSG.textnum, false );
                  KeyboardQueue[head] = 0;
                  Keyboard[sc_Enter]  = 0;
                  Keyboard[sc_Escape] = 0;
                  LastScan            = 0;
                  }
               }
            else if ( MSG.messageon && !MSG.inmenu )
               {
               if ( ( scancode >= sc_F1 ) &&
                  ( scancode <= sc_F10 ) )
                  {
                  MSG.remoteridicule = scancode - sc_F1;
                  MSG.messageon = false;
                  FinishModemMessage(MSG.textnum, true);
                  KeyboardQueue[head] = 0;
                  Keyboard[sc_Enter]  = 0;
                  Keyboard[sc_Escape] = 0;
                  LastScan            = 0;
                  }

               switch (scancode)
                  {
                  case sc_BackSpace:
                     KeyboardQueue[head] = 0;
                     if (MSG.length > 1)
                        {
                        ModemMessageDeleteChar (MSG.textnum);
                        }
                     Keystate[scancode]=0;
                     break;

                  case sc_Enter:
                     MSG.messageon = false;
                     FinishModemMessage(MSG.textnum, true);
                     KeyboardQueue[head] = 0;
                     Keyboard[sc_Enter]  = 0;
                     Keyboard[sc_Escape] = 0;
                     LastScan            = 0;
                     Keystate[scancode]=0;
                     break;

                  case sc_Escape:
                     MSG.messageon = false;
                     MSG.directed  = false;
                     FinishModemMessage(MSG.textnum, false);
                     KeyboardQueue[head] = 0;
                     Keyboard[sc_Enter]  = 0;
                     Keyboard[sc_Escape] = 0;
                     LastScan            = 0;
                     break;
                  }
               }
            }
         }

      head = (head+1)&(KEYQMAX-1);
      }        // while
   }
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include <stdio.h>
#include <string.h>

#include "rt_main.h"
#include "rt_def.h"
#include "rt_in.h"
// #include "_rt_in.h"
#include "isr.h"
#include "keyb.h"
#include "rt_util.h"
#include "rt_vh_a.h"
#include "rt_cfg.h"
#include "rt_msg.h"
#include "rt_playr.h"
#include "rt_net.h"
#include "rt_com.h"
#include "rt_cfg.h"

#include "gfxdrv_keys.h"


#define MAXMESSAGELENGTH		(COM_MAXTEXTSTRINGLENGTH-1)

//****************************************************************************
//
// GLOBALS
//
//****************************************************************************]

//
// Used by menu routines that need to wait for a button release.
// Sometimes the mouse driver misses an interrupt, so you can't wait for
// a button to be released.  Instead, you must ignore any buttons that
// are pressed.
//
int IgnoreMouse = 0;

// configuration variables
//
// boolean  SpaceBallPresent;
// boolean  CybermanPresent;
// boolean  AssassinPresent;
boolean  MousePresent;
boolean  JoysPresent[MaxJoys];
boolean  JoyPadPresent	= 0;

volatile boolean PausePressed = 0;
volatile boolean PanicPressed = 0;

//	Global variables
//
boolean  Paused;
char LastASCII;
volatile int LastScan;

static volatile boolean ExtendedKeyFlag;
static volatile boolean KeyUpFlag;
static volatile int pausecount=0;
static int LEDs;
static volatile int KBFlags;

byte Joy_xb,
	Joy_yb,
	Joy_xs,
	Joy_ys;
word Joy_x,
	Joy_y;


int LastLetter = 0;
char LetterQueue[MAXLETTERS];
ModemMessage MSG;

//	'q','w','e','r','t','y','u','i','o','p','[',']','\\', 0 ,'a','s',

char ScanChars[128] =	// Scan code names with single chars
{
	0 , 0 ,'1','2','3','4','5','6','7','8','9','0','-','=', 0 , 0 ,
	'q','w','e','r','t','y','u','i','o','p','[',']', 0 , 0 ,'a','s',
	'd','f','g','h','j','k','l',';','\'','`', 0 ,'\\','z','x','c','v',
	'b','n','m',',','.','/', 0 , 0 , 0 ,' ', 0 , 0 , 0 , 0 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,'-', 0 ,'5', 0 ,'+', 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
};

char ShiftedScanChars[128] =	// Shifted Scan code names with single chars
{
	0 , 0 ,'!','@','#','$','%','^','&','*','(',')','_','+', 0 , 0 ,
	'Q','W','E','R','T','Y','U','I','O','P','{','}', 0 , 0 ,'A','S',
	'D','F','G','H','J','K','L',':','"','~', 0 ,'|','Z','X','C','V',
	'B','N','M','<','>','?', 0 , 0 , 0 ,' ', 0 , 0 , 0 , 0 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,'-', 0 ,'5', 0 ,'+', 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
};


volatile int Keyboard[MAXKEYBOARDSCAN];
volatile int KeyboardQueue[KEYQMAX];
volatile int Keystate[MAXKEYBOARDSCAN];
volatile int Keyhead;
volatile int Keytail;

int KeyboardStarted=false;


void I_StartupKeyboard (void)
{
	if (KeyboardStarted==true)
		return;
	KeyboardStarted=true;

	Keyhead = Keytail = 0;
	memset(Keystate,0,sizeof(Keystate));
	if (!quiet)
		printf("I_StartupKeyboard: Keyboard Started\n");
}

#if 1
void I_AddScanByteKeyboard (int scan)
{
	int k;
	int temp;
	int keyon;
	int strippedkey;

	k = scan;

#if 0
	if ( KBFlags & kb_pr_led )
	{
		if ( k == kb_resend )
		{
			// Handle resend
			KBFlags |= kb_fe;
		}
		else if (k == kb_ack)
		{
			// Handle ack
			KBFlags |= kb_fa;
		}
	}
	else
#endif
	if ( pausecount )
	{
		pausecount--;
	}
	else if ( k == 0xe1 )			// Handle Pause key
	{
		PausePressed = true;
		pausecount = 5;
	}
	else if ( k == 0x46 )			// Handle Panic key (Scroll Lock)
	{
		PanicPressed = true;
	}
	else
	{
		if ( k == 0xF0 )
		{
			KeyUpFlag = true;
		}
		else
			if ( k == 0xE0 )
		{
			ExtendedKeyFlag = true;
		}
		else
		{
			keyon = k & 0x80;
			strippedkey = k & 0x7f;

			if ( ExtendedKeyFlag )
			{
				if ( ( strippedkey == sc_LShift ) ||
					( strippedkey == sc_RShift ) )
				{
					k = sc_None;
				}
/*
				else
				{
					if ( strippedkey == sc_Alt )
					{
						k = sc_RightAlt | keyon;
					}
					if ( strippedkey == sc_Control )
					{
						k = sc_RightCtrl | keyon;
					}
				}
*/
			}

			if ( k != sc_None )
			{
				if ( strippedkey == sc_LShift )
				{
					k = sc_RShift | keyon;
				}

				if ( !keyon )
//				if (!KeyUpFlag)		// Up event
				{
					LastScan = k;
				}

				if (k & 0x80)		// Up event
//				if (KeyUpFlag)		// Up event
				{
					Keystate[k&0x7f]=0;
				}
				else					// Down event
				{
					Keystate[k]=1;
				}

//				if(KeyUpFlag)
//					k|=0x80;

				KeyboardQueue[ Keytail ] = k;
				Keytail = ( Keytail + 1 )&( KEYQMAX - 1 );
			}

			ExtendedKeyFlag = false;
			KeyUpFlag = false;
		}
	}

}
#endif

#if 0
void I_AddScanByteKeyboard (int scan)
{
	KeyboardQueue[ Keytail ] = scan;
	Keytail = ( Keytail + 1 )&( KEYQMAX - 1 );
}
#endif

#if 0
static const short ps2_key2scan[256]={
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//00..07
	0x066, 0x00D, 0x000, 0x000, 0x000, 0x05A, 0x000, 0x000,		//08..0F
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//10..17
	0x000, 0x000, 0x000, 0x076, 0x000, 0x000, 0x000, 0x000,		//18..1F
	0x029, 0x016, 0x052, 0x026, 0x025, 0x02E, 0x03D, 0x052,		//20..27
	0x046, 0x045, 0x03E, 0x055, 0x041, 0x04E, 0x049, 0x04A,		//28..2F
	0x045, 0x016, 0x01E, 0x026, 0x025, 0x02E, 0x036, 0x03D,		//30..37
	0x03E, 0x046, 0x04C, 0x04C, 0x041, 0x055, 0x049, 0x04A,		//38..3F
	0x01E, 0x01C, 0x032, 0x021, 0x023, 0x024, 0x02B, 0x034,		//40..47
	0x033, 0x043, 0x03B, 0x042, 0x04B, 0x03A, 0x031, 0x044,		//48..4F
	0x04D, 0x015, 0x02D, 0x01B, 0x02C, 0x03C, 0x02A, 0x01D,		//50..57
	0x022, 0x035, 0x01A, 0x054, 0x05D, 0x05B, 0x036, 0x04E,		//58..5F
	0x00E, 0x01C, 0x032, 0x021, 0x023, 0x024, 0x02B, 0x034,		//60..67
	0x033, 0x043, 0x03B, 0x042, 0x04B, 0x03A, 0x031, 0x044,		//68..6F
	0x04D, 0x015, 0x02D, 0x01B, 0x02C, 0x03C, 0x02A, 0x01D,		//70..77
	0x022, 0x035, 0x01A, 0x054, 0x05D, 0x05B, 0x00E, 0x171,		//78..7F
	0x175, 0x172, 0x16B, 0x174, 0x011, 0x014, 0x012, 0x005,		//80..87
	0x006, 0x004, 0x00C, 0x003, 0x00B, 0x083, 0x00A, 0x001,		//88..8F
	0x009, 0x078, 0x007, 0x170, 0x000, 0x17A, 0x17D, 0x16C,		//90..97
	0x169, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//98..9F
	0x058, 0x07E, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//A0..A7
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//A8..AF
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//B0..B7
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//B8..BF
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//C0..C7
	0x000, 0x000, 0x000, 0x000, 0x079, 0x07B, 0x07C, 0x14A,		//C8..CF
	0x070, 0x069, 0x072, 0x07A, 0x06B, 0x073, 0x074, 0x06C,		//D0..D7
	0x075, 0x07D, 0x15A, 0x071, 0x000, 0x000, 0x000, 0x000,		//D8..DF
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//E0..E7
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//E8..EF
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//F0..F7
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,		//F8..FF
};
#endif

static short ps2_key2scan[256];
boolean ps2_key2scan_init = 0;

int Key_Event(int key, int down)
{
	int sc;
	int i, j, k;
	
	if(!ps2_key2scan_init)
	{
		for(i=0; i<128; i++)
		{
			j=ASCIINames[i];
			if(j)	ps2_key2scan[j]=i;
			j=ShiftNames[i];
			if(j)	ps2_key2scan[j]=i;
		}
	
		ps2_key2scan['0']=sc_0;
		ps2_key2scan['1']=sc_1;
		ps2_key2scan['2']=sc_2;
		ps2_key2scan['3']=sc_3;
		ps2_key2scan['4']=sc_4;
		ps2_key2scan['5']=sc_5;
		ps2_key2scan['6']=sc_6;
		ps2_key2scan['7']=sc_7;
		ps2_key2scan['8']=sc_8;
		ps2_key2scan['9']=sc_9;
		ps2_key2scan['-']=sc_Minus;
		ps2_key2scan['_']=sc_Minus;
		ps2_key2scan['=']=sc_Equals;
		ps2_key2scan['+']=sc_Plus;

		ps2_key2scan['A']=sc_A;		ps2_key2scan['B']=sc_B;
		ps2_key2scan['C']=sc_C;		ps2_key2scan['D']=sc_D;
		ps2_key2scan['E']=sc_E;		ps2_key2scan['F']=sc_F;
		ps2_key2scan['G']=sc_G;		ps2_key2scan['H']=sc_H;
		ps2_key2scan['I']=sc_I;		ps2_key2scan['J']=sc_J;
		ps2_key2scan['K']=sc_K;		ps2_key2scan['L']=sc_L;
		ps2_key2scan['M']=sc_M;		ps2_key2scan['N']=sc_N;
		ps2_key2scan['O']=sc_O;		ps2_key2scan['P']=sc_P;
		ps2_key2scan['Q']=sc_Q;		ps2_key2scan['R']=sc_R;
		ps2_key2scan['S']=sc_S;		ps2_key2scan['T']=sc_T;
		ps2_key2scan['U']=sc_U;		ps2_key2scan['V']=sc_V;
		ps2_key2scan['W']=sc_W;		ps2_key2scan['X']=sc_X;
		ps2_key2scan['Y']=sc_Y;		ps2_key2scan['Z']=sc_Z;

		ps2_key2scan['a']=sc_A;		ps2_key2scan['b']=sc_B;
		ps2_key2scan['c']=sc_C;		ps2_key2scan['d']=sc_D;
		ps2_key2scan['e']=sc_E;		ps2_key2scan['f']=sc_F;
		ps2_key2scan['g']=sc_G;		ps2_key2scan['h']=sc_H;
		ps2_key2scan['i']=sc_I;		ps2_key2scan['j']=sc_J;
		ps2_key2scan['k']=sc_K;		ps2_key2scan['l']=sc_L;
		ps2_key2scan['m']=sc_M;		ps2_key2scan['n']=sc_N;
		ps2_key2scan['o']=sc_O;		ps2_key2scan['p']=sc_P;
		ps2_key2scan['q']=sc_Q;		ps2_key2scan['r']=sc_R;
		ps2_key2scan['s']=sc_S;		ps2_key2scan['t']=sc_T;
		ps2_key2scan['u']=sc_U;		ps2_key2scan['v']=sc_V;
		ps2_key2scan['w']=sc_W;		ps2_key2scan['x']=sc_X;
		ps2_key2scan['y']=sc_Y;		ps2_key2scan['z']=sc_Z;

		ps2_key2scan[K_DEL			]=0x153;

		ps2_key2scan[K_UPARROW		]=0x148;
		ps2_key2scan[K_DOWNARROW	]=0x150;
		ps2_key2scan[K_LEFTARROW	]=0x14B;
		ps2_key2scan[K_RIGHTARROW	]=0x14D;
		ps2_key2scan[K_CTRL			]=0x01D;
		ps2_key2scan[K_ALT			]=0x038;
		ps2_key2scan[K_SHIFT		]=0x02A;
		ps2_key2scan[K_INS			]=0x152;
		ps2_key2scan[K_PGDN			]=0x151;
		ps2_key2scan[K_PGUP			]=0x149;
		ps2_key2scan[K_HOME			]=0x147;
		ps2_key2scan[K_END			]=0x14F;
//		ps2_key2scan[K_PAUSE		]=0x14F;

		ps2_key2scan[K_F1			]=0x03B;
		ps2_key2scan[K_F2			]=0x03C;
		ps2_key2scan[K_F3			]=0x03D;
		ps2_key2scan[K_F4			]=0x03E;
		ps2_key2scan[K_F5			]=0x03F;
		ps2_key2scan[K_F6			]=0x040;
		ps2_key2scan[K_F7			]=0x041;
		ps2_key2scan[K_F8			]=0x042;
		ps2_key2scan[K_F9			]=0x043;
		ps2_key2scan[K_F10			]=0x044;
		ps2_key2scan[K_F11			]=0x057;
		ps2_key2scan[K_F12			]=0x058;
	
		ps2_key2scan_init=1;
	}
	
	sc=ps2_key2scan[key&0xFF];
	if(!sc)
		return(0);

//	if(key&0x8000)
	if(!down)
	{
		if(sc&0x100)
			I_AddScanByteKeyboard(0xE0);
		I_AddScanByteKeyboard(0xF0);
//		I_AddScanByteKeyboard(sc&0xFF);
		I_AddScanByteKeyboard((sc&0xFF)|0x80);
		return(0);
	}

	if(sc&0x100)
		I_AddScanByteKeyboard(0xE0);
	I_AddScanByteKeyboard(sc&0xFF);
	return(0);
}


//****************************************************************************
//
// LOCALS
//
//****************************************************************************]

static KeyboardDef KbdDefs = {0x1d,0x38,0x47,0x48,0x49,0x4b,0x4d,0x4f,0x50,0x51};
static JoystickDef JoyDefs[MaxJoys];
static ControlType Controls[MAXPLAYERS];


static boolean  IN_Started;

static	Direction	DirTable[] =		// Quick lookup for total direction
{
	dir_NorthWest, dir_North,  dir_NorthEast,
	dir_West,		dir_None,	dir_East,
	dir_SouthWest, dir_South,  dir_SouthEast
};

int (*function_ptr)();

static char *ParmStrings[] = {"nojoys","nomouse","spaceball","cyberman","assassin",NULL};


//******************************************************************************
//
// INL_GetMouseDelta () - Gets the amount that the mouse has moved from the
//								mouse driver
//
//******************************************************************************

void INL_GetMouseDelta(int *x, int *y)
{
	*x=0;
	*y=0;
}



//******************************************************************************
//
// IN_GetMouseButtons () - Gets the status of the mouse buttons from the
//								mouse driver
//
//******************************************************************************

word IN_GetMouseButtons( void )

{
	return(0);
}


//******************************************************************************
//
// IN_IgnoreMouseButtons () -
//	Tells the mouse to ignore the currently pressed buttons.
//
//******************************************************************************

void IN_IgnoreMouseButtons ( void )
{
	word  buttons;

	IgnoreMouse |= IN_GetMouseButtons();
}

//******************************************************************************
//
// IN_GetJoyAbs () - Reads the absolute position of the specified joystick
//
//******************************************************************************

void IN_GetJoyAbs (word joy, word *xp, word *yp)
{
#if 0
	Joy_x  = Joy_y = 0;
	Joy_xs = joy? 2 : 0;		// Find shift value for x axis
	Joy_xb = 1 << Joy_xs;		// Use shift value to get x bit mask
	Joy_ys = joy? 3 : 1;		// Do the same for y axis
	Joy_yb = 1 << Joy_ys;

	JoyStick_Vals ();

	*xp = Joy_x;
	*yp = Joy_y;
#endif

	*xp=0;
	*yp=0;
}



//******************************************************************************
//
// INL_GetJoyDelta () - Returns the relative movement of the specified
//							joystick (from +/-127)
//
//******************************************************************************

#if 0
void INL_GetJoyDelta (word joy, int *dx, int *dy)
{
	word		x, y;
	JoystickDef *def;
	static longword lasttime;

	IN_GetJoyAbs (joy, &x, &y);
	def = JoyDefs + joy;

	if (x < def->threshMinX)
	{
		if (x < def->joyMinX)
			x = def->joyMinX;

		x = -(x - def->threshMinX);
		x *= def->joyMultXL;
		x >>= JoyScaleShift;
		*dx = (x > 127)? -127 : -x;
	}
	else if (x > def->threshMaxX)
	{
		if (x > def->joyMaxX)
			x = def->joyMaxX;

		x = x - def->threshMaxX;
		x *= def->joyMultXH;
		x >>= JoyScaleShift;
		*dx = (x > 127)? 127 : x;
	}
	else
		*dx = 0;

	if (y < def->threshMinY)
	{
		if (y < def->joyMinY)
			y = def->joyMinY;

		y = -(y - def->threshMinY);
		y *= def->joyMultYL;
		y >>= JoyScaleShift;
		*dy = (y > 127)? -127 : -y;
	}
	else if (y > def->threshMaxY)
	{
		if (y > def->joyMaxY)
			y = def->joyMaxY;

		y = y - def->threshMaxY;
		y *= def->joyMultYH;
		y >>= JoyScaleShift;
		*dy = (y > 127)? 127 : y;
	}
	else
		*dy = 0;

	lasttime = ticcount;
}
#endif

void INL_GetJoyDelta (word joy, int *dx, int *dy)
{
	static word		lx, ly;
	word				x, y;

	IN_GetJoyAbs (joy, &x, &y);
	*dx=x-lx;
	*dy=y-ly;
	lx=x;
	ly=y;
}


//******************************************************************************
//
// INL_GetJoyButtons () - Returns the button status of the specified
//								joystick
//
//******************************************************************************

word INL_GetJoyButtons (word joy)
{
#if 0
	word  result;

//	result = inp (0x201);	// Get all the joystick buttons
	result >>= joy? 6 : 4;  // Shift into bits 0-1
	result &= 3;				// Mask off the useless bits
	result ^= 3;
	return (result);
#endif

	return(0);
}

#if 0
//******************************************************************************
//
// IN_GetJoyButtonsDB () - Returns the de-bounced button status of the
//								specified joystick
//
//******************************************************************************

word IN_GetJoyButtonsDB (word joy)
{
	longword lasttime;
	word result1,result2;

	do
	{
		result1 = INL_GetJoyButtons (joy);
		lasttime = ticcount;
		while (ticcount == lasttime)
			;
		result2 = INL_GetJoyButtons (joy);
	} while (result1 != result2);

	return(result1);
}
#endif

//******************************************************************************
//
// INL_StartMouse () - Detects and sets up the mouse
//
//******************************************************************************

boolean INL_StartMouse (void)
{
	return(true);
}



//******************************************************************************
//
// INL_SetJoyScale () - Sets up scaling values for the specified joystick
//
//******************************************************************************

void INL_SetJoyScale (word joy)
{
#if 0
	JoystickDef *def;

	def = &JoyDefs[joy];
	def->joyMultXL = JoyScaleMax / (def->threshMinX - def->joyMinX);
	def->joyMultXH = JoyScaleMax / (def->joyMaxX - def->threshMaxX);
	def->joyMultYL = JoyScaleMax / (def->threshMinY - def->joyMinY);
	def->joyMultYH = JoyScaleMax / (def->joyMaxY - def->threshMaxY);
#endif
}



//******************************************************************************
//
// IN_SetupJoy () - Sets up thresholding values and calls INL_SetJoyScale()
//						to set up scaling values
//
//******************************************************************************

void IN_SetupJoy (word joy, word minx, word maxx, word miny, word maxy)
{
	word	d,r;
	JoystickDef *def;

	def = &JoyDefs[joy];

	def->joyMinX = minx;
	def->joyMaxX = maxx;
	r = maxx - minx;
	d = r / 3;
	def->threshMinX = ((r / 2) - d) + minx;
	def->threshMaxX = ((r / 2) + d) + minx;

	def->joyMinY = miny;
	def->joyMaxY = maxy;
	r = maxy - miny;
	d = r / 3;
	def->threshMinY = ((r / 2) - d) + miny;
	def->threshMaxY = ((r / 2) + d) + miny;

	INL_SetJoyScale (joy);
}


//******************************************************************************
//
// INL_StartJoy () - Detects & auto-configures the specified joystick
//						The auto-config assumes the joystick is centered
//
//******************************************************************************

boolean INL_StartJoy (word joy)
{
#if 0
	word x,y;

	IN_GetJoyAbs (joy, &x, &y);

	if
	(
		((x == 0) || (x > MaxJoyValue - 10))
	|| ((y == 0) || (y > MaxJoyValue - 10))
	)
		return(false);
	else
	{
		IN_SetupJoy (joy, 0, x * 2, 0, y * 2);
		return (true);
	}
#endif

	return(false);
}



//******************************************************************************
//
// INL_ShutJoy() - Cleans up the joystick stuff
//
//******************************************************************************

void INL_ShutJoy (word joy)
{
	JoysPresent[joy] = false;
}



//******************************************************************************
//
// IN_Startup() - Starts up the Input Mgr
//
//******************************************************************************


void IN_Startup (void)
{
	boolean checkjoys,
			checkmouse,
			checkcyberman,
			checkspaceball,
			swiftstatus,
			checkassassin;

	word	i;

	if (IN_Started==true)
		return;

	checkjoys		= true;
	checkmouse		= true;
//	checkcyberman	= false;
//	checkassassin	= false;
//	checkspaceball	= false;
//	SpaceBallPresent = false;
//	CybermanPresent  = false;
//	AssassinPresent  = false;

	for (i = 1; i < _argc; i++)
	{
		switch (US_CheckParm (_argv[i], ParmStrings))
		{
		case 0:
			checkjoys = false;
		break;

		case 1:
			checkmouse = false;
		break;

		case 2:
 //		checkspaceball = true;
		break;

		case 3:
//			checkcyberman = true;
//			checkmouse = false;
		break;

		case 4:
//			checkassassin = true;
//			checkmouse = false;
		break;
		}
	}

	MousePresent = checkmouse ? INL_StartMouse() : false;

	if (!MousePresent)
		mouseenabled = false;
	else
		{
		if (!quiet)
			printf("IN_Startup: Mouse Present\n");
		}

	for (i = 0;i < MaxJoys;i++)
		{
		JoysPresent[i] = checkjoys ? INL_StartJoy(i) : false;
		if (INL_StartJoy(i))
			{
			if (!quiet)
				printf("IN_Startup: Joystick Present\n");
			}
		}

//	if (checkspaceball)
//		{
//		OpenSpaceBall ();
//		spaceballenabled=true;
//		}

#if 0
	if ((checkcyberman || checkassassin) && (swiftstatus = SWIFT_Initialize ()))
	{
		int dynamic;

		if (checkcyberman)
			{
//			CybermanPresent = swiftstatus;
//			cybermanenabled = true;
			}
		else if (checkassassin)
			{
			AssassinPresent = checkassassin & swiftstatus;
			assassinenabled = true;
			}

		dynamic = SWIFT_GetDynamicDeviceData ();

		SWIFT_TactileFeedback (40, 20, 20);

		if (SWIFT_GetDynamicDeviceData () == 2)
			Error ("SWIFT ERROR : External Power too high!\n");

		SWIFT_TactileFeedback (100, 10, 10);
		if (!quiet)
			printf("IN_Startup: Swift Device Present\n");
	}
#endif

	IN_Started = true;
}


#if 0
//******************************************************************************
//
// IN_Default() - Sets up default conditions for the Input Mgr
//
//******************************************************************************

void IN_Default (boolean gotit, ControlType in)
{
	if
	(
		(!gotit)
	||	((in == ctrl_Joystick1) && !JoysPresent[0])
	||	((in == ctrl_Joystick2) && !JoysPresent[1])
	||	((in == ctrl_Mouse) && !MousePresent)
	)
		in = ctrl_Keyboard1;
	IN_SetControlType (0, in);
}
#endif

//******************************************************************************
//
// IN_Shutdown() - Shuts down the Input Mgr
//
//******************************************************************************

void IN_Shutdown (void)
{
	word  i;

	if (IN_Started==false)
		return;

//	INL_ShutMouse();

//	for (i = 0;i < MaxJoys;i++)
//		INL_ShutJoy(i);

//	if (CybermanPresent || AssassinPresent)
//		SWIFT_Terminate ();

//	CloseSpaceBall ();

	IN_Started = false;
}


//******************************************************************************
//
// IN_ClearKeysDown() - Clears the keyboard array
//
//******************************************************************************

void IN_ClearKeysDown (void)
{
	LastScan = sc_None;
	memset (Keyboard, 0, sizeof (Keyboard));
}


//******************************************************************************
//
// IN_ReadControl() - Reads the device associated with the specified
//	player and fills in the control info struct
//
//******************************************************************************

void IN_ReadControl (int player, ControlInfo *info)
{
	boolean	realdelta;
	word		buttons;
	int			dx,dy;
	Motion		mx,my;
	ControlType type;

	KeyboardDef *def;

	dx = dy = 0;
	mx = my = motion_None;
	buttons = 0;


	switch (type = Controls[player])
	{
		case ctrl_Keyboard:
			def = &KbdDefs;

#if 0
			if (Keyboard[def->upleft])
				mx = motion_Left,my = motion_Up;
			else if (Keyboard[def->upright])
				mx = motion_Right,my = motion_Up;
			else if (Keyboard[def->downleft])
				mx = motion_Left,my = motion_Down;
			else if (Keyboard[def->downright])
				mx = motion_Right,my = motion_Down;
#endif
			if (Keyboard[sc_UpArrow])
				my = motion_Up;
			else if (Keyboard[sc_DownArrow])
				my = motion_Down;

			if (Keyboard[sc_LeftArrow])
				mx = motion_Left;
			else if (Keyboard[sc_RightArrow])
				mx = motion_Right;

			if (Keyboard[def->button0])
				buttons += 1 << 0;
			if (Keyboard[def->button1])
				buttons += 1 << 1;
			realdelta = false;
		break;

#if 0
		case ctrl_Joystick1:
		case ctrl_Joystick2:
			INL_GetJoyDelta (type - ctrl_Joystick, &dx, &dy);
			buttons = INL_GetJoyButtons (type - ctrl_Joystick);
			realdelta = true;
		break;

		case ctrl_Mouse:
			INL_GetMouseDelta (&dx,&dy);
			buttons = IN_GetMouseButtons ();
			realdelta = true;
		break;
#endif
	}

	if (realdelta)
	{
		mx = (dx < 0)? motion_Left : ((dx > 0)? motion_Right : motion_None);
		my = (dy < 0)? motion_Up : ((dy > 0)? motion_Down : motion_None);
	}
	else
	{
		dx = mx * 127;
		dy = my * 127;
	}

	info->x = dx;
	info->xaxis = mx;
	info->y = dy;
	info->yaxis = my;
	info->button0 = buttons & (1 << 0);
	info->button1 = buttons & (1 << 1);
	info->button2 = buttons & (1 << 2);
	info->button3 = buttons & (1 << 3);
	info->dir = DirTable[((my + 1) * 3) + (mx + 1)];
}


//******************************************************************************
//
// IN_WaitForKey() - Waits for a scan code, then clears LastScan and
//	returns the scan code
//
//******************************************************************************

ScanCode IN_WaitForKey (void)
{
	ScanCode result;

	while (!(result = LastScan))
		;
	LastScan = 0;
	return (result);
}


//******************************************************************************
//
// IN_Ack() - waits for a button or key press.  If a button is down, upon
// calling, it must be released for it to be recognized
//
//******************************************************************************

boolean  btnstate[8];

void IN_StartAck (void)
{
	unsigned i,
				buttons = 0;

//
// get initial state of everything
//
	LastScan = 0;

	IN_ClearKeysDown ();
	memset (btnstate, 0, sizeof(btnstate));

	buttons = 0;
//	buttons = IN_JoyButtons () << 4;

	buttons |= IN_GetMouseButtons();

//	if (SpaceBallPresent && spaceballenabled)
//		{
//		buttons |= GetSpaceBallButtons ();
//		}

	for (i=0;i<8;i++,buttons>>=1)
		if (buttons&1)
			btnstate[i] = true;
}



//******************************************************************************
//
// IN_CheckAck ()
//
//******************************************************************************

boolean IN_CheckAck (void)
{
	unsigned i,
				buttons = 0;

//
// see if something has been pressed
//
	if (LastScan)
		return true;

	buttons = IN_JoyButtons () << 4;

	buttons |= IN_GetMouseButtons();

	for (i=0;i<8;i++,buttons>>=1)
		if ( buttons&1 )
		{
			if (!btnstate[i])
				return true;
		}
		else
			btnstate[i]=false;

	return false;
}



//******************************************************************************
//
// IN_Ack ()
//
//******************************************************************************

void IN_Ack (void)
{
	IN_StartAck ();

	while (!IN_CheckAck ())
	;
}



//******************************************************************************
//
// IN_UserInput() - Waits for the specified delay time (in ticks) or the
//	user pressing a key or a mouse button. If the clear flag is set, it
//	then either clears the key or waits for the user to let the mouse
//	button up.
//
//******************************************************************************

boolean IN_UserInput (long delay)
{
	long lasttime;

	lasttime = ticcount;

	IN_StartAck ();
	do
	{
		if (IN_CheckAck())
			return true;
	} while ((ticcount - lasttime) < delay);

	return (false);
}

//===========================================================================


/*
===================
=
= IN_JoyButtons
=
===================
*/

byte IN_JoyButtons (void)
{
	unsigned joybits;

//	joybits = inp (0x201);  // Get all the joystick buttons
	joybits = 0;
//	joybits >>= 4;			// only the high bits are useful
//	joybits ^= 15;			// return with 1=pressed

	return joybits;
}


//******************************************************************************
//
// IN_UpdateKeyboard ()
//
//******************************************************************************

void IN_UpdateKeyboard (void)
{
	int tail;
	int key;

	I_HandleInput ();

	if (Keytail != Keyhead)
	{
		tail = Keytail;

		while (Keyhead != tail)
		{
			if (KeyboardQueue[Keyhead] & 0x80)		// Up event
			{
				key = KeyboardQueue[Keyhead] & 0x7F;	// AND off high bit

//				if (keysdown[key])
//				{
//					KeyboardQueue[Keytail] = KeyboardQueue[Keyhead];
//					Keytail = (Keytail+1)&(KEYQMAX-1);
//				}
//				else
					Keyboard[key] = 0;
			}
			else												// Down event
			{
				Keyboard[KeyboardQueue[Keyhead]] = 1;
//				keysdown[KeyboardQueue[Keyhead]] = 1;
			}

			Keyhead = (Keyhead+1)&(KEYQMAX-1);

		}		// while
	}			// if

	// Carry over movement keys from the last refresh
//	keysdown[sc_RightArrow] = Keyboard[sc_RightArrow];
//	keysdown[sc_LeftArrow]  = Keyboard[sc_LeftArrow];
//	keysdown[sc_UpArrow]	= Keyboard[sc_UpArrow];
//	keysdown[sc_DownArrow]  = Keyboard[sc_DownArrow];
	}



//******************************************************************************
//
// IN_InputUpdateKeyboard ()
//
//******************************************************************************

int IN_InputUpdateKeyboard (void)
{
	int key;
	int returnval = 0;
	boolean done = false;

//	_disable ();

	I_HandleInput ();

	if (Keytail != Keyhead)
	{
		int tail = Keytail;

		while (!done && (Keyhead != tail))
		{
			if (KeyboardQueue[Keyhead] & 0x80)		// Up event
			{
				key = KeyboardQueue[Keyhead] & 0x7F;	// AND off high bit

				Keyboard[key] = 0;
			}
			else												// Down event
			{
				Keyboard[KeyboardQueue[Keyhead]] = 1;
				returnval = KeyboardQueue[Keyhead];
				done = true;
			}

			Keyhead = (Keyhead+1)&(KEYQMAX-1);
		}
	}			// if

//	_enable ();

	return (returnval);
}


//******************************************************************************
//
// IN_ClearKeyboardQueue ()
//
//******************************************************************************

void IN_ClearKeyboardQueue (void)
{
	return;

//	IN_ClearKeysDown ();

//	Keytail = Keyhead = 0;
//	memset (KeyboardQueue, 0, sizeof (KeyboardQueue));
//	I_SendKeyboardData(0xf6);
//	I_SendKeyboardData(0xf4);
}


#if 0
//******************************************************************************
//
// IN_DumpKeyboardQueue ()
//
//******************************************************************************

void IN_DumpKeyboardQueue (void)
{
	int head = Keyhead;
	int tail = Keytail;
	int key;

	if (tail != head)
	{
		SoftError( "START DUMP\n");

		while (head != tail)
		{
			if (KeyboardQueue[head] & 0x80)		// Up event
			{
				key = KeyboardQueue[head] & 0x7F;	// AND off high bit

//				if (keysdown[key])
//				{
//					SoftError( "%s - was put in next refresh\n",
//											IN_GetScanName (key));
//				}
//				else
//				{
					if (Keyboard[key] == 0)
						SoftError( "%s %ld - was lost\n", IN_GetScanName (key), key);
					else
						SoftError( "%s %ld - up\n", IN_GetScanName (key), key);
//				}
			}
			else												// Down event
				SoftError( "%s %ld - down\n", IN_GetScanName (KeyboardQueue[head]), KeyboardQueue[head]);

			head = (head+1)&(KEYQMAX-1);
		}		// while

		SoftError( "END DUMP\n");

	}			// if
}
#endif


//******************************************************************************
//
// QueueLetterInput ()
//
//******************************************************************************

void QueueLetterInput (void)
{
	int head = Keyhead;
	int tail = Keytail;
	char c;
	int scancode;
	boolean send = false;

	while (head != tail)
		{
		if (!(KeyboardQueue[head] & 0x80))		// Down event
			{
			scancode = KeyboardQueue[head];

			if (Keyboard[sc_RShift] || Keyboard[sc_LShift])
				{
				c = ShiftedScanChars[scancode];
				}
			else
				{
				c = ScanChars[scancode];
				}

			// If "is printable char", queue the character
			if (c)
				{
				LetterQueue[LastLetter] = c;
				LastLetter = (LastLetter+1)&(MAXLETTERS-1);

				// If typing a message, update the text with 'c'

				if ( MSG.messageon )
					{
					Keystate[scancode]=0;
					KeyboardQueue[head] = 0;
					if ( MSG.inmenu )
						{
						if ( ( c == 'A' ) || ( c == 'a' ) )
							{
							MSG.towho = MSG_DIRECTED_TO_ALL;
							send		= true;
							}

						if ( ( gamestate.teamplay ) &&
							( ( c == 'T' ) || ( c == 't' ) ) )
							{
							MSG.towho = MSG_DIRECTED_TO_TEAM;
							send		= true;
							}

						if ( ( c >= '0' ) && ( c <= '9' ) )
							{
							int who;

							if ( c == '0' )
								{
								who = 10;
								}
							else
								{
								who = c - '1';
								}

							// Skip over local player
							if ( who >= consoleplayer )
								{
								who++;
								}

							if ( who < numplayers )
								{
								MSG.towho = who;
								send		= true;
								}
							}

						if ( send )
							{
							MSG.messageon = false;
							KeyboardQueue[ head ] = 0;
							Keyboard[ scancode ]  = 0;
							LastScan				= 0;
							FinishModemMessage( MSG.textnum, true );
							}
						}
					else if ( ( scancode >= sc_1 ) && ( scancode <= sc_0 ) &&
						( Keyboard[ sc_Alt ] ) )
						{
						int msg;

						msg = scancode - sc_1;

						if ( CommbatMacros[ msg ].avail )
							{
							MSG.length = strlen( CommbatMacros[ msg ].macro ) + 1;
							strcpy( Messages[ MSG.textnum ].text,
								CommbatMacros[ msg ].macro );

							MSG.messageon = false;
							FinishModemMessage( MSG.textnum, true );
							KeyboardQueue[ head ] = 0;
							Keyboard[ sc_Enter ]  = 0;
							Keyboard[ sc_Escape ] = 0;
							LastScan				= 0;
							}
						else
							{
							MSG.messageon = false;
							MSG.directed  = false;

							FinishModemMessage( MSG.textnum, false );
							AddMessage( "No macro.", MSG_MACRO );
							KeyboardQueue[ head ] = 0;
							Keyboard[ sc_Enter ]  = 0;
							Keyboard[ sc_Escape ] = 0;
							LastScan				= 0;
							}
						}
					else if ( MSG.length < MAXMESSAGELENGTH )
						{
						UpdateModemMessage (MSG.textnum, c);
						}
					}
				}
			else
				{
				// If typing a message, check for special characters

				if ( MSG.messageon && MSG.inmenu )
					{
					if ( scancode == sc_Escape )
						{
						MSG.messageon = false;
						MSG.directed  = false;
						FinishModemMessage( MSG.textnum, false );
						KeyboardQueue[head] = 0;
						Keyboard[sc_Enter]  = 0;
						Keyboard[sc_Escape] = 0;
						LastScan				= 0;
						}
					}
				else if ( MSG.messageon && !MSG.inmenu )
					{
					if ( ( scancode >= sc_F1 ) &&
						( scancode <= sc_F10 ) )
						{
						MSG.remoteridicule = scancode - sc_F1;
						MSG.messageon = false;
						FinishModemMessage(MSG.textnum, true);
						KeyboardQueue[head] = 0;
						Keyboard[sc_Enter]  = 0;
						Keyboard[sc_Escape] = 0;
						LastScan				= 0;
						}

					switch (scancode)
						{
						case sc_BackSpace:
							KeyboardQueue[head] = 0;
							if (MSG.length > 1)
								{
								ModemMessageDeleteChar (MSG.textnum);
								}
							Keystate[scancode]=0;
							break;

						case sc_Enter:
							MSG.messageon = false;
							FinishModemMessage(MSG.textnum, true);
							KeyboardQueue[head] = 0;
							Keyboard[sc_Enter]  = 0;
							Keyboard[sc_Escape] = 0;
							LastScan				= 0;
							Keystate[scancode]=0;
							break;

						case sc_Escape:
							MSG.messageon = false;
							MSG.directed  = false;
							FinishModemMessage(MSG.textnum, false);
							KeyboardQueue[head] = 0;
							Keyboard[sc_Enter]  = 0;
							Keyboard[sc_Escape] = 0;
							LastScan				= 0;
							break;
						}
					}
				}
			}

		head = (head+1)&(KEYQMAX-1);
		}		// while
	}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "lumpy.h"
//#include <malloc.h>
//#include <dos.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
//#include <fcntl.h>
//#include <io.h>
//#include <conio.h>
//#include <graph.h>
#include <string.h>
//#include <process.h>
#include "rt_actor.h"
#include "rt_stat.h"
#include "rt_vid.h"
#include "rt_menu.h"
#include "rt_sound.h"
#include "watcom.h"
#include "scriplib.h"
#include "rt_main.h"
#include "_rt_main.h"
#include "rt_com.h"
#include "rt_util.h"
#include "z_zone.h"
#include "w_wad.h"
#include "rt_game.h"
#include "rt_floor.h"
#include "rt_playr.h"
#include "rt_draw.h"
#include "rt_str.h"
#include "rt_view.h"
#include "rt_door.h"
#include "rt_ted.h"
#include "rt_in.h"
#include "rt_map.h"
#include "rt_rand.h"
#include "rt_debug.h"
#include "isr.h"
#include "rt_cfg.h"
#include "develop.h"
#include "version.h"
#include "rt_menu.h"
#include "rt_dr_a.h"
#include "rt_msg.h"
#include "rt_build.h"
#include "rt_error.h"
#include "modexlib.h"
#include "rt_net.h"
#include "cin_main.h"
#include "rottnet.h"
#include "rt_scale.h"

//#include <direct.h>
//#include <bios.h>


#include "music.h"
#include "fx_man.h"
//MED
// #include "memcheck.h"

volatile int	oldtime;
volatile int	gametime;

boolean			tedlevel;
int				tedlevelnum;
int				tedx=0;
int				tedy=0;
boolean			warp;
int				warpx=0;
int				warpy=0;
int				warpa=0;
int				NoSound;
int				polltime;
int				oldpolltime;
boolean			fizzlein = false;
int				pheight;

boolean SCREENSHOTS				= false;
boolean MONOPRESENT				= false;
boolean MAPSTATS					= false;
boolean TILESTATS					= false;
boolean HUD							= false;
boolean IS8250						= false;

boolean dopefish;

boolean newlevel = false;
boolean infopause;
boolean SOUNDSETUP=false;
boolean quiet = false;

#if (DEVELOPMENT == 1)
boolean DebugOk = true;
#else
boolean DebugOk = false;
#endif

#if (WHEREAMI==1)
int programlocation=-1;
#endif

#if SAVE_SCREEN
static char savename[13] = "ROTT0000.LBM";
static int totalbytes;
static byte *bptr;
#endif
static boolean turbo;

static int NoWait;
static int startlevel=0;
static int demonumber=-1;

char CWD[40];								// curent working directory
static boolean quitactive = false;

int timelimit;
int maxtimelimit;
boolean timelimitenabled;
boolean demoexit;
boolean noecho;

int _argc;
char **_argv;

void main ( int argc, char *argv[] )
{
	_argc = argc;
	_argv = argv;

	// Set which release version we're on
	gamestate.Version = ROTTVERSION;

#if ( SHAREWARE == 1 )
	gamestate.Product = ROTT_SHAREWARE;
#elif ( SUPERROTT == 1 )
	gamestate.Product = ROTT_SUPERCD;
#elif ( SITELICENSE == 1 )
	gamestate.Product = ROTT_SITELICENSE;
#else
	gamestate.Product = ROTT_REGISTERED;
#endif

	DrawRottTitle ();
	gamestate.randomseed=-1;

	gamestate.autorun = 0;
	StartupSoftError();
//	UL_ErrorStartup ();

	CheckCommandLineParameters();

	// Start up Memory manager with a certain amount of reserved memory

	Z_Init(50000,1000000);

	IN_Startup ();

	InitializeGameCommands();
	if (standalone==false)
		{
		ReadConfig ();
		ReadSETUPFiles ();
		doublestep=0;
		SetupWads();
		BuildTables ();
		GetMenuInfo ();
		}

//	if (modemgame==true)
//		{
//		SCREENSHOTS=true;
//		if (standalone==false)
//			{
//			MenuFixup ();
//			}
//		MAPSTATS=true;
//		}
	if (standalone==false)
		{
		int status1 = 0;
		int status2 = 0;
		int status3 = 0;

		if ( !NoSound && !IS8250 )
			{
			if (!quiet)
				printf( "MU_Startup: " );
			status1 = MU_Startup(false);
			if (!quiet)
				printf( "%s\n", MUSIC_ErrorString( MUSIC_Error ) );
			}
		else if ( IS8250 )
			{
			printf( "==============================================================================\n");
			printf( "WARNING: 8250 detected.\n" );
			printf( "Music has been disabled.  This is necessary to maintain high interrupt\n" );
			printf( "rates with the 8250 UART which will improve overall game performance.\n");
			printf( "							< Press any key to continue >\n");
			printf( "==============================================================================\n");
			getchar();
			}

		if (!NoSound)
			{
			int nv, nb, nc;

			if (!quiet)
				printf( "SD_SetupFXCard: " );
			status2 = SD_SetupFXCard (&nv, &nb, &nc);
			if (!quiet)
				printf( "%s\n", FX_ErrorString( FX_Error ) );

			if ( !status2 )
				{
				if (!quiet)
					printf( "SD_Startup: " );
				status3 = SD_Startup(false);
				if (!quiet)
					printf( "%s\n", FX_ErrorString( FX_Error ) );
				}
			}
		else
			{
			if (!quiet)
				printf( "Sound FX disabled.\n" );
			}

		if ( status1 || status2 || status3 )
			{
			printf( "\n\nROTT was unable to initialize your " );
			if ( status1 )
				{
				printf( "music " );
				MusicMode = 0;
				}
			if ( status2 || status3 )
				{
				if ( status1 )
					{
					printf( "or " );
					}
				printf( "sound fx " );

				FXMode = 0;
				}

			printf( "hardware.\n"
				"Please reconfigure your sound setup or run ROTTHELP for\n"
				"information on setting up sound on your computer.\n\n"
				"< Press any key to run SNDSETUP >\n" );

			SOUNDSETUP = true;
			getchar();
			}

		Init_Tables ();
		InitializeRNG ();
		InitializeMessages();
		LoadColorMap();
		}
	if (infopause==true)
		{
		printf("\n< Press any key to continue >\n");
		getchar();
		}
	I_StartupTimer();
	I_StartupKeyboard();
#if 0
#if (SHAREWARE == 1)
	if ((!SOUNDSETUP) && (standalone==false))
		{
		byte * txtscn;
		int i;

		for (i=0;i<20;i++)
			printf("\n");
		txtscn = (byte *) W_CacheLumpNum (W_GetNumForName ("rotts10"), PU_CACHE);
		memcpy ((byte *)0xB8000, txtscn, 4000);
		I_Delay (600);
		}
#endif
#endif
	locplayerstate = &PLAYERSTATE[consoleplayer];

	if (standalone==true)
		ServerLoop();

	VL_SetVGAPlaneMode();
	VL_SetPalette(origpal);

//	TextMode();
//	GraphicsMode();
//	TextMode();
//	VL_SetVGAPlaneMode();
//	VL_SetPalette(origpal);
//	SetBorderColor(155);
	SetViewSize(8);

	if ( SOUNDSETUP )
		{
		SwitchPalette( origpal, 35 );
		CP_SoundSetup();
		}

	playstate = ex_titles;

//	I_SetKeyboardLEDs( caps_lock, 0 );

	gamestate.battlemode = battle_StandAloneGame;

	BATTLE_SetOptions( &BATTLE_Options[ battle_StandAloneGame ] );

	if (turbo || tedlevel)
		{
		if (modemgame == true)
			{
			turbo = false;
			NoWait = true;
			}
		else
			{
			PlayTurboGame();
			}
		}
	else
		{
#if (SHAREWARE == 0)
		if ( dopefish == true )
			{
			DopefishTitle();
			}
		else if ( NoWait == false )
			{
			ApogeeTitle();
			}
#else
		if ( NoWait == false )
			{
			if (W_CheckNumForName("svendor") != -1)
				{
				lbm_t * LBM;

				LBM = (lbm_t *) W_CacheLumpName( "svendor", PU_CACHE);
				VL_DecompressLBM (LBM,true);
				I_Delay(40);
				MenuFadeOut();
				}
//			ParticleIntro ();
			ApogeeTitle();
			}
#endif
		}

	GameLoop();


	QuitGame();
}

void DrawRottTitle ( void )
{
	char title[80];
	char buf[5];

	TextMode();
	TurnOffTextCursor ();

	if (CheckParm("QUIET") == 0)
		{
		TextMode();
		TurnOffTextCursor ();
		if (CheckParm ("SOUNDSETUP") == 0)
			{
			printf("\n\n\n");
			strcpy (title,"Rise of the Triad Startup  Version ");
			strcat (title,itoa(ROTTMAJORVERSION,&buf[0],10));
			strcat (title,".");
//MED
//			strcat (title,itoa(ROTTMINORVERSION,&buf[0],10));
			strcat (title,"DFISH");

			px=(80-strlen(title))>>1;
			py=0;

			UL_printf(title);

			memset (title,0,sizeof(title));

			if (gamestate.Product == ROTT_SHAREWARE)
				{
#if (DELUXE==1)
				strcpy(title,"Lasersoft Deluxe Version");
#elif (LOWCOST==1)
				strcpy(title,"Episode One");
#else
				strcpy(title,"Shareware Version");
#endif
				}
			else if (gamestate.Product == ROTT_SUPERCD)
				strcpy(title,"CD Version");
			else if (gamestate.Product == ROTT_SITELICENSE)
				strcpy(title,"Site License CD Version");
			else
				strcpy(title,"Commercial Version");

			px=(80-strlen(title))>>1;
			py=1;

			UL_printf(title);

			UL_ColorBox (0, 0, 80, 2, 0x1e);
			}
		else
			{
			printf("\n\n");
			strcpy (title,"Rise of the Triad Sound Setup  Version ");
			strcat (title,itoa(ROTTMAJORVERSION,&buf[0],10));
			strcat (title,".");
			strcat (title,itoa(ROTTMINORVERSION,&buf[0],10));

			px=(80-strlen(title))>>1;
			py=0;

			UL_printf(title);

			UL_ColorBox (0, 0, 80, 1, 0x1e);
			}
		}
	else
		{
		TurnOffTextCursor ();
		}

}

void CheckCommandLineParameters( void )
{
	char *PStrings[] = {"TEDLEVEL","NOWAIT","NOSOUND","NOW",
							"TRANSPORT","DOPEFISH","SCREENSHOTS",
							"MONO","MAPSTATS","TILESTATS","VER","net",
							"PAUSE","SOUNDSETUP","WARP","IS8250","ENABLEVR",
							"TIMELIMIT","MAXTIMELIMIT","NOECHO","DEMOEXIT","QUIET",NULL};
	int i,n;

	infopause=false;
	SOUNDSETUP = false;
	tedlevel=false;
	NoWait=false;
	NoSound=false;
	turbo=false;
	warp=false;
	dopefish=false;
	modemgame=false;
	SCREENSHOTS=false;
	MONOPRESENT=false;
	MAPSTATS=false;
	TILESTATS=false;
	IS8250 = false;
//	vrenabled = false;
	demoexit = false;

	modemgame=false;
	networkgame=false;
	consoleplayer=0;
	numplayers = 1;
	timelimit=-1;
	timelimitenabled=false;
	noecho = false;
	quiet = false;

	if (
		(CheckParm("?\0")) ||
		(CheckParm("HELP")) ||
		(
			(_argc>1) &&
			(_argv[1][0]=='?')
		)
		)
		{
		TextMode ();
		printf ("Rise of the Triad  (c) 1995 Apogee Software\n\n");
		printf ("COMMAND LINE PARAMETERS\n");
		printf ("	SPACEBALL  - Enable check for Spaceball.\n");
		printf ("	NOJOYS	- Disable check for joystick.\n");
		printf ("	NOMOUSE	- Disable check for mouse.\n");
		printf ("	CYBERMAN	- Enable check for Cyberman.\n");
		printf ("	ASSASSIN	- Enable check for Wingman Assassin.\n");
		printf ("	VER		- Version number.\n");
		printf ("	MAPSTATS	- Dump Map statistics to ERROR.\n");
		printf ("	TILESTATS  - Dump Tile statistics to ERROR.\n");
		printf ("	MONO		- Enable mono-monitor support.\n");
		printf ("	SCREENSHOTS- Clean screen capture for shots.\n");
		printf ("	PAUSE		- Pauses startup screen information.\n");
		printf ("	SOUNDSETUP - Setup sound for ROTT\n");
		printf ("	ENABLEVR	- Enable VR helmet input devices\n");
		printf ("	NOECHO	- Turn off sound reverb\n");
		printf ("	DEMOEXIT	- Exit program when demo is terminated\n");
		printf ("	WARP		- Warp to specific ROTT level\n");
		printf ("					next paramater is level to start on\n");
		printf ("	TIMELIMIT  - Play ROTT in time limit mode\n");
		printf ("					next paramater is time in seconds\n");
		printf ("	MAXTIMELIMIT - Maximimum time to count down from\n");
		printf ("					next paramater is time in seconds\n");
		printf ("	DOPEFISH	- ?\n");
		exit (0);
		}

	// Check For command line parameters

	for (i = 1;i < _argc;i++)
	{
		n = US_CheckParm(_argv[i],PStrings);
		switch(n)
		{
#if (TEDLAUNCH==1)
		case 0:
			tedlevelnum = ParseNum(_argv[i + 1]);
			tedlevel=true;
			if (i+3>=_argc)
				{
				tedx=0;
				tedy=0;
				}
			else
				{
				tedx=ParseNum(_argv[i + 2]);
				tedy=ParseNum(_argv[i + 3]);
				}
			MenuFixup ();
			break;
#endif
		case 1:
			NoWait = true;
			break;
		case 2:
			NoSound = true;
			break;
		case 3:
			turbo = true;
			break;
		case 4:
			warp = true;
			warpx=ParseNum(_argv[i + 1]);
			warpy=ParseNum(_argv[i + 2]);
			warpa=ParseNum(_argv[i + 3]);
			break;
		case 5:
			dopefish=true;
			break;
		case 6:
			SCREENSHOTS = true;
			break;
		case 7:
			MONOPRESENT = true;
			break;
		case 8:
			MAPSTATS = true;
			break;
		case 9:
			TILESTATS = true;
			break;
		case 10:
			TextMode ();
			printf ("Rise of the Triad  (c) 1995 Apogee Software\n");
//MED
			if (gamestate.Product == ROTT_SHAREWARE)
				{
#if (DELUXE==1)
				printf("Lasersoft Deluxe ");
#elif (LOWCOST==1)
				printf("Episode One ");
#else
				printf("Shareware ");
#endif
				}
			else if (gamestate.Product == ROTT_SUPERCD)
				printf("CD ");
			else if (gamestate.Product == ROTT_SITELICENSE)
				printf("Site License ");
			else
				printf("Commercial ");
			printf ("Version %d.%d\n", ROTTMAJORVERSION,ROTTMINORVERSION);
			exit (0);
			break;
		case 11:
			InitROTTNET();
			numplayers = rottcom->numplayers;
			if (numplayers>MAXPLAYERS)
				Error("Too many players.\n");
			if (!quiet)
				printf("Playing %ld player ROTT\n",numplayers);
			modemgame=true;
			if (rottcom->gametype==NETWORK_GAME)
				{
				if (!quiet)
					printf("NETWORK GAME\n");
				networkgame=true;
				}
			else
				{
				if (!quiet)
					printf("MODEM GAME\n");
				}
			break;
		case 12:
			infopause=true;
			break;
		case 13:
			SOUNDSETUP = true;
			break;
		case 14:
			startlevel = (ParseNum(_argv[i + 1])-1);
			break;
		case 15:
			IS8250 = true;
			break;
		case 16:
//			vrenabled = true;
//			if (!quiet)
//				printf("Virtual Reality Mode enabled\n");
			break;
		case 17:
			timelimitenabled = true;
			timelimit = ParseNum(_argv[i + 1]);
			if (!quiet)
				printf("Time Limit = %ld Seconds\n",timelimit);
			timelimit *= VBLCOUNTER;
			break;

		case 18:
			maxtimelimit = ParseNum(_argv[i + 1]);
			maxtimelimit *= VBLCOUNTER;
			break;
		case 19:
			noecho = true;
			break;
		case 20:
			demoexit = true;
			break;
		case 21:
			quiet = true;
			break;
		}
	}
}

void SetupWads( void )
{
	char  *newargs[99];
	int argnum = 0;
#if (SHAREWARE==0)
	int arg;
#endif
	char tempstr[129];

#if (SHAREWARE==0)

	// Check for User wads

	arg = CheckParm ("file");
	if (arg!=0)
		{
		newargs [argnum++] = _argv[arg+1];
		}

	arg = CheckParm ("file1");
	if (arg!=0)
		{
		newargs [argnum++] = _argv[arg+1];
		}

	arg = CheckParm ("file2");
	if (arg!=0)
		{
		newargs [argnum++] = _argv[arg+1];
		}

#else
	if (
		(CheckParm ("file") > 0) ||
		(CheckParm ("file1") > 0) ||
		(CheckParm ("file2") > 0)
		)
		printf("External wads ignored.\n");

#endif

	// Normal ROTT wads

#if (SHAREWARE)
	newargs [argnum++] = "huntbgin.wad";
#else
	newargs [argnum++] = "darkwar.wad";
#endif

//	newargs [argnum++] = "credits.wad";

	// Check for Remote Ridicule WAD

	if (RemoteSounds.avail == true)
		{
		char  *src;

		strcpy (tempstr,RemoteSounds.path);
		src = RemoteSounds.path + strlen(RemoteSounds.path) - 1;
		if (*src != '\\')
			strcat (tempstr,"\\\0");
		strcat (tempstr,RemoteSounds.file);
		newargs [argnum++] = tempstr;
		}
	else
		{
		newargs [argnum++] = "remote1.rts";
		}

	newargs [argnum++] = NULL;

	W_InitMultipleFiles(newargs);
}

void PlayTurboGame
	(
	void
	)

	{
	NewGame = true;
	locplayerstate->player = DefaultPlayerCharacter;
	playstate = ex_resetgame;
	GameLoop();
	}


//***************************************************************************
//
// Init_Tables () - Init tables needed for double buffering
//
//***************************************************************************

void StoreFile(char *name, void *buf, int sz)
{
	FILE *fd;
	
	fd=fopen(name, "wb");
	if(!fd)return;
	fwrite(buf, 1, sz, fd);
	fclose(fd);
}

void Init_Tables (void)
{
	int i;
	int x,
		y;
	unsigned *blockstart;
	byte * shape;

	memset (&CWD[0], 0, 40);
	getcwd (CWD, 40);							// get the current directory

	origpal=SafeMalloc(768);
	memcpy (origpal, W_CacheLumpName("pal",PU_CACHE), 768);

#ifdef _WIN32
	StoreFile("palette.lmp", origpal, 768);
#endif

	FindEGAColors();

	for (i=0;i<PORTTILESHIGH;i++)
		uwidthtable[i] = UPDATEWIDE*i;

	updateptr = &update[0];

	blockstart = &blockstarts[0];
	for (y=0;y<UPDATEHIGH;y++)
		for (x=0;x<UPDATEWIDE;x++)
			*blockstart++ = SCREENWIDTH*16*y+x*TILEWIDTH;

	for (i = 0; i < 0x300; i++)
		*(origpal+(unsigned int)i) = (*(origpal+(unsigned int)i))>>2;

	// Cache in fonts
	shape = W_CacheLumpNum (W_GetNumForName ("smallfont"), PU_STATIC);
	smallfont = (font_t *)shape;
	CurrentFont = smallfont;

	// Cache in tiny font
	shape = W_CacheLumpNum (W_GetNumForName ("tinyfont"), PU_STATIC);
	tinyfont = (font_t *)shape;

	intensitytable=W_CacheLumpNum(W_GetNumForName("menucmap"),PU_STATIC);
	fontcolor = egacolor[4];

	if (!quiet)
		printf("RT_MAIN: Fonts Initialized\n");
}




int NumberOfTeams
	(
	void
	)

	{
	int index;
	int team[ MAXPLAYERCOLORS ];
	int count;
	int color;

	memset( team, 0, sizeof( team ) );

	count = 0;
	for( index = 0; index < numplayers; index++ )
		{
		color = PLAYERSTATE[ index ].uniformcolor;
		if ( !team[ color ] )
			{
			team[ color ] = true;
			count++;
			}
		}

	return( count );
	}

void GameLoop (void)
{
	boolean done	= false;
	boolean loadit = false;
	int NextLevel;

	wami(1);

	while (1)
		{
		if ( playstate == ex_battledone )
			{
			while( damagecount > 0 )
				{
				DoBorderShifts();
				}
			damagecount = 0;
			SetBorderColor (0);

			StopWind();

			ShutdownClientControls();

			SD_Play (SD_LEVELDONESND);

			if ( ( player->flags & FL_DOGMODE ) ||
				( gamestate.battlemode == battle_Eluder ) )
				MU_StartSong(song_dogend);
			else
				MU_StartSong(song_endlevel);


			VL_FillPalette(255,255,255);
			VL_FadeIn(0,255,origpal,10);

			BattleLevelCompleted( consoleplayer );

			BATTLE_Shutdown();

			Z_FreeTags (PU_LEVELSTRUCT, PU_LEVELEND);		// Free current level

			ingame = false;

			if ( networkgame == true )
				{
				AddGameEndCommand ();
				}

			AdjustMenuStruct ();

			CalcTics();
			CalcTics();

			playstate = ex_titles;
			}

		switch (playstate)
			{
			case ex_titles:
				BATTLE_Shutdown();
				MU_StartSong(song_title);
				if ((NoWait==false)&&(!modemgame))
					{
					byte dimpal[768];
					int i;

					for (i = 0; i < 0x300; i++)
						dimpal[i] = origpal[i]>>2;
					CalcTics();
					CalcTics();
					IN_ClearKeysDown ();
					while (IN_GetMouseButtons()) {}
					while ((!LastScan) && (!IN_GetMouseButtons()))
						{
						int i;
						unsigned tempbuf;
						MenuFadeOut();
						ClearGraphicsScreen();
						SetPalette(&dimpal[0]);
						PlayMovie ("shartitl", true);
						if ( ( LastScan ) || ( IN_GetMouseButtons() ) )
							{
							break;
							}

						PlayMovie ("shartit2", true);

						if ( ( LastScan ) || ( IN_GetMouseButtons() ) )
							{
							break;
							}
						SD_Play (SD_LIGHTNINGSND);
						MenuFadeIn();
						I_Delay(30);
						SD_Play (SD_ACTORSQUISHSND);
						tempbuf=bufferofs;
						bufferofs=displayofs;
						DrawNormalSprite(320-94,200-41,W_GetNumForName("rsac"));
						bufferofs=tempbuf;
						I_Delay(30);

						if ( ( LastScan ) || ( IN_GetMouseButtons() ) )
							{
							break;
							}

						DoCreditScreen ();
						if ((!LastScan) && (!IN_GetMouseButtons()))
							CheckHighScore (0, 0, false);
#if (SHAREWARE==0)
						if ((!LastScan) && (!IN_GetMouseButtons()))
							{
							DoMicroStoryScreen ();
							}
#endif
						if (
							(!LastScan) &&
							(!IN_GetMouseButtons()) &&
							(lowmemory==0) &&
							(GameLevels.avail==false)
							)
							{
							if (demonumber==-1)
								demonumber=RandomNumber("GameLoop",0);
							for (i=0;i<4;i++)
								{
								demonumber=(demonumber+1)%4;
								if (DemoExists (demonumber+1) == true)
									break;
								}
							if (DemoExists (demonumber+1) == true)
								{
								ingame=true;
								LoadDemo (demonumber+1);
								break;
								}
							}
						}
					}

				if (playstate != ex_demoplayback)
					{
					if (demoexit == true)
						{
						QuitGame();
						}
					NoWait = false;
					SwitchPalette(origpal,35);
					CP_MainMenu();
					}
			break;

			case ex_resetgame:
				InitCharacter();

				InitializeMessages();

				fizzlein = true;
				BATTLE_GetSpecials();
				BATTLE_SetOptions( &BATTLE_Options[ gamestate.battlemode ] );

				if ( modemgame == true )
					{
					fizzlein = false;

					if ( consoleplayer == 0 )
						{
						// Setup Master
						SetupGameMaster();
						}
					else
						{
						// Setup slave
						SetupGamePlayer();
						}

					if ( gamestate.Version < ROTTVERSION )
						{
						Error( "This version of Rise of the Triad (%d.%d) is incompatible with\n"
							"version %d.%d.", ROTTMAJORVERSION, ROTTMINORVERSION,
							gamestate.Version / 10, gamestate.Version % 10 );
						}
					if ( gamestate.teamplay )
						{
						int teams;

						teams = NumberOfTeams();
						if ( gamestate.battlemode == battle_CaptureTheTriad )
							{
							if ( teams != 2 )
								{
								CP_CaptureTheTriadError();
								playstate = ex_titles;
								continue;
								}
							}
						else if ( teams < 2 )
							{
							CP_TeamPlayErrorMessage();
							playstate = ex_titles;
							continue;
							}
						}
					}

				InitCharacter();

				BATTLE_Init( gamestate.battlemode, numplayers );

				NewGame = true;

				if ( ( BATTLEMODE ) && ( BATTLE_ShowKillCount ) )
					{
					StatusBar |= STATUS_KILLS;
					}
				else
					{
					StatusBar &= ~STATUS_KILLS;
					}

				if (loadedgame == false)
					{
					if ( !BATTLEMODE )
						{
						PlayCinematic();
						}

					SetupGameLevel();
					}

				IN_ClearKeyboardQueue();

				SetupScreen (true);

				MenuFixup ();
				playstate=ex_stillplaying;
			break;

			case ex_stillplaying:
				InitializeMessages();

				SHAKETICS = 0xFFFF;
				if (modemgame==true)
					{
					SetTime();
					turbo = false;
					}
				else if (turbo==true)
					turbo=false;
				else
					newlevel=true;
				PlayLoop ();
			break;

			case ex_died:
				loadit = done = false;

				Died ();
				StopWind();

				while (damagecount>0)
					DoBorderShifts();

				damagecount = 0;
				SetBorderColor (0);
				if (demorecord)
					{
					FreeDemo ();
					}
				if (demoplayback)
					{
					FreeDemo ();
					playstate=ex_demodone;
					}
				else
					{
					ShutdownClientControls();

					Z_FreeTags (PU_LEVELSTRUCT, PU_LEVELEND);		// Free current level

					if (CheckForQuickLoad()==false)
						{
						if (locplayerstate->lives < 0)
							{
							if (timelimitenabled == false)
								{
								CheckHighScore (gamestate.score, gamestate.mapon+1, false);
								playstate = ex_titles;
								AdjustMenuStruct ();
								ingame = false;
								locplayerstate->health	= MaxHitpointsForCharacter(locplayerstate);
								gamestate.score				= 0;
								locplayerstate->lives		= 3;
								locplayerstate->weapon	= wp_pistol;
								locplayerstate->triads	= 0;
								UpdateLives (locplayerstate->lives);
								UpdateScore (gamestate.score);
								}
							else
								{
								QuitGame();
								}
							}
						else
							{
							fizzlein = true;
							SetupGameLevel ();
							UpdateTriads(player,0);
							playstate = ex_stillplaying;
							}
						}
					}
				break;

			case ex_warped:
				StopWind();
				TurnShakeOff();
				SHAKETICS = 0xffff;
				gamestate.TimeCount = 0;
				gamestate.frame=0;

				Z_FreeTags (PU_LEVELSTRUCT, PU_LEVELEND);		// Free current level

				fizzlein = true;
				SetupGameLevel ();

				playstate = ex_stillplaying;
			break;

			case ex_skiplevel:
			case ex_secretdone:
			case ex_secretlevel:
			case ex_completed:
			case ex_bossdied:

				ShutdownClientControls();
				TurnShakeOff();
				SHAKETICS = 0xffff;
				if (timelimitenabled == false)
					{
					gamestate.TimeCount = 0;
					gamestate.frame=0;
					}
				StopWind();
#if (SHAREWARE==0)
				if ((playstate==ex_bossdied) && (gamestate.mapon!=30))
				{
					int shape;
					lbm_t * LBM;
					byte *s;
					patch_t *p;
					char str[50];
					int width, height;

					LBM = (lbm_t *) W_CacheLumpName( "deadboss", PU_CACHE);
					VL_DecompressLBM (LBM,false);
					MenuFadeOut();
					switch (gamestate.mapon)
						{
						case 6:
							shape = W_GetNumForName("deadstev");
							break;
						case 14:
							shape = W_GetNumForName("deadjoe");
							break;
						case 22:
							shape = W_GetNumForName("deadrobo");
							break;
						case 33:
							shape = W_GetNumForName("deadtom");
							break;
//						default:
//							Error("Boss died on an illegal level\n");
//							break;
						}
					s = W_CacheLumpNum (shape, PU_CACHE);
					p = (patch_t *)s;
					DrawNormalSprite ((320-p->origsize)>>1, (230-(p->height-p->topoffset))>>1, shape);
					switch (gamestate.mapon)
						{
						case 6:
							strcpy(&str[0],"\"General\" John Darian");
							break;
						case 14:
							strcpy(&str[0],"Sebastian \"Doyle\" Krist");
							break;
						case 22:
							strcpy(&str[0],"the NME");
							break;
						case 33:
							strcpy(&str[0],"El Oscuro");
							break;
//						default:
//							Error("Boss died on an illegal level\n");
//							break;
						}
					CurrentFont=smallfont;
					US_MeasureStr (&width, &height, str);
					US_ClippedPrint ((320-width)>>1, 180, str);
					VW_UpdateScreen();
					MenuFadeIn();

					WaitKeyUp();
					LastScan = 0;
					while (!LastScan)
					{
						IN_UpdateKeyboard();
					}
					LastScan=0;
				}
#endif
				LevelCompleted ( playstate );

				NextLevel = GetNextMap(player->tilex,player->tiley);

				demoplayback = false;

				Z_FreeTags (PU_LEVELSTRUCT, PU_LEVELEND);		// Free current level
				if (NextLevel != -1 )
					{
					gamestate.mapon = NextLevel;
					PlayCinematic();
					fizzlein = true;
					SetupGameLevel ();
					playstate = ex_stillplaying;
					}
				else
					{
					playstate = ex_gameover;
					}
			break;

			case ex_demodone:
				ingame=false;
				ShutdownClientControls();
				TurnShakeOff();
				SHAKETICS = 0xffff;
				gamestate.TimeCount = 0;
				gamestate.frame=0;

				demoplayback = false;

				Z_FreeTags (PU_LEVELSTRUCT, PU_LEVELEND);		// Free current level
				playstate=ex_titles;
			break;

			case ex_gameover:
				StopWind();
				DoEndCinematic();
				if (playstate==ex_gameover)
					{
					CheckHighScore (gamestate.score, gamestate.mapon+1, false);

					ingame = false;
					AdjustMenuStruct ();
					playstate = ex_titles;
					}
			break;

			case ex_demorecord:
				ShutdownClientControls();
				Z_FreeTags (PU_LEVELSTRUCT, PU_LEVELEND);		// Free current level

				RecordDemo();
				SetupGameLevel ();

				fizzlein = true;
				playstate = ex_stillplaying;
			break;

			case ex_demoplayback:
				ShutdownClientControls();
				Z_FreeTags (PU_LEVELSTRUCT, PU_LEVELEND);		// Free current level

				SetupDemo();
				SetupGameLevel ();

				fizzlein = true;
				playstate = ex_stillplaying;
			break;
			}
		}
	waminot();
	}

boolean CheckForQuickLoad
	(
	void
	)

	{
	if ( pickquick )
		{
		SetupMenuBuf();

		pickquick = CP_DisplayMsg( "\nQuick load saved game?\n", 12 );
		if ( pickquick )
			{
			AllocateSavedScreenPtr();
			CP_LoadGame( 1, 1 );
			FreeSavedScreenPtr();
			}
		else
			{
			// Erase the quick load message
			VL_FadeOut( 0, 255, 0, 0, 0, 20 );
			}

		ShutdownMenuBuf();
		}

	return( pickquick );
	}

//===========================================================================

void ShutDown ( void )
{
	if ( ( standalone == false ) || ( SOUNDSETUP ) )
		{
		WriteConfig ();
		}

//	if (
//		(networkgame==false) &&
//		(modemgame==true)
//		)
//		{
//		ShutdownModemGame ();
//		}

	ShutdownClientControls();
	I_ShutdownKeyboard();
	UL_ErrorShutdown ();
	ShutdownGameCommands();
	MU_Shutdown();
	I_ShutdownTimer();
	SD_Shutdown();
	IN_Shutdown ();
	ShutdownSoftError ();
	Z_ShutDown();
//	_settextcursor (0x0607);
}

//===========================================================================

#if (DEVELOPMENT == 1)
	extern int totallevelsize;
#endif

void QuitGame ( void )
{
#if (DEBUG == 1)
	char buf[5];
#endif

#if (DEVELOPMENT == 1)
	int temp;
#else
	byte *txtscn;
#endif
	int k;

	MU_FadeOut(200);
	while (MU_FadeActive())
		{
		int time=ticcount;
		while (ticcount==time) {}
		}

	PrintMapStats();
	PrintTileStats();
	TextMode();

#if 0

#if (DEVELOPMENT == 1)
	printf("Clean Exit\n");
	if (gamestate.TimeCount)
		{
		temp=(gamestate.frame*VBLCOUNTER*100)/gamestate.TimeCount;
		printf("fps  = %2ld.%2ld\n",temp/100,temp%100);
		}
	printf("argc=%ld\n",_argc);
	for (k=0;k<_argc;k++) printf("%s\n",_argv[k]);
	switch( _heapchk() )
	{
	case _HEAPOK:
	printf( "OK - heap is good\n" );
	break;
	case _HEAPEMPTY:
	printf( "OK - heap is empty\n" );
	break;
	case _HEAPBADBEGIN:
	printf( "ERROR - heap is damaged\n" );
	break;
	case _HEAPBADNODE:
	printf( "ERROR - bad node in heap\n" );
	break;
	}
	printf("\nLight Characteristics\n");
	printf("---------------------\n");
	if (fog)
		printf("FOG is ON\n");
	else
		printf("FOG is OFF\n");
	printf("LIGHTLEVEL=%ld\n",GetLightLevelTile());
	printf("LIGHTRATE =%ld\n",GetLightRateTile());
	printf("\nCENTERY=%ld\n",centery);
#else
	if ( !SOUNDSETUP )
	{
#if (SHAREWARE==0)
		txtscn = (byte *) W_CacheLumpNum (W_GetNumForName ("regend"), PU_CACHE);
#else
		txtscn = (byte *) W_CacheLumpNum (W_GetNumForName ("shareend"), PU_CACHE);
#endif
		for (k = 0; k < 23; k++)
			printf ("\n");
//		memcpy ((byte *)0xB8000, txtscn, 4000);
#if (DEBUG == 1)
		px = ERRORVERSIONCOL;
		py = ERRORVERSIONROW;
#if (BETA == 1)
		UL_printf ("");
#else
		UL_printf (itoa(ROTTMAJORVERSION,&buf[0],10));
#endif
		// Skip the dot
		px++;

		UL_printf (itoa(ROTTMINORVERSION,&buf[0],10));
#endif
	}
#endif

#endif

	if ( SOUNDSETUP )
	{
		printf( "\nSound setup complete.\n"
				"Type ROTT to run the game.\n" );
	}
	ShutDown();

	exit(0);
}

void InitCharacter( void )
{
	locplayerstate->health = MaxHitpointsForCharacter( locplayerstate );
	if (timelimitenabled == true)
	{
		locplayerstate->lives  = 1;
	}
	else
	{
		locplayerstate->lives  = 3;
	}

	ClearTriads (locplayerstate);
	locplayerstate->playerheight = characters[ locplayerstate->player ].height;
//	locplayerstate->stepwhich = 0;
//	locplayerstate->steptime = 0;

	gamestate.score = 0;

	if ( gamestate.battlemode == battle_StandAloneGame )
	{
		gamestate.mapon = startlevel;
		gamestate.difficulty = DefaultDifficulty;
	}
	else
	{
		gamestate.difficulty = gd_hard;
	}

	gamestate.dipballs = 0;
	gamestate.TimeCount = 0;

	godmode = 0;
	damagecount = 0;

	UpdateScore( gamestate.score );
}




void UpdateGameObjects ( void )
{
	int j;
	volatile int atime;
	objtype * ob,*temp;
	battle_status BattleStatus;

	wami(2);

	if (controlupdatestarted==0)
	{
		return;
		waminot();
	}


	if((oldpolltime+60)<oldtime)
	{
		while (oldpolltime<oldtime)
		{
//			CheckUnPause();
#if (SYNCCHECK == 1)
			CheckForSyncCheck();
#endif
			oldpolltime++;
		}
	}

	atime=fasttics;

	UpdateClientControls ();

	if (demoplayback == false)
		PollControls ();

	CalcTics ();

	UpdateClientControls ();


	while (oldpolltime<oldtime)
		{
		UpdateClientControls ();
		MoveDoors();
		ProcessElevators();
		MovePWalls();
		UpdateLightning ();
		TriggerStuff();
		CheckCriticalStatics();
		for(j=0;j<numclocks;j++)
			if (Clocks[j].time1 &&
				((gamestate.TimeCount == Clocks[j].time1) ||
				(gamestate.TimeCount == Clocks[j].time2)))
				TRIGGER[Clocks[j].linkindex]=1;
		for (ob = firstactive; ob;)
			{
			temp = ob->nextactive;
			DoActor (ob);
#if (DEVELOPMENT == 1)
			if ((ob->x<=0) || (ob->y<=0))
				Error("object xy below zero obj->x=%ld obj->y=%ld obj->obclass=%ld\n",ob->x,ob->y,ob->obclass);
			if ((ob->angle<0) || (ob->angle>=FINEANGLES))
				Error("object angle below zero obj->angle=%ld obj->obclass=%ld\n",ob->angle,ob->obclass);
#endif
			ob = temp;
			}

		BattleStatus = BATTLE_CheckGameStatus( battle_refresh, 0 );
		if ( BattleStatus != battle_no_event )
			{
			switch( BattleStatus )
				{
				case battle_end_game :
				case battle_out_of_time :
					playstate = ex_battledone;
					break;

				case battle_end_round :
					SetWhoHaveWeapons();
					break;
				}
			if ( playstate == ex_battledone )
				{
				break;
				}
			}
#if (SYNCCHECK == 1)
		CheckForSyncCheck();
#endif
		if (timelimitenabled == true)
			{
			if (timelimit-gamestate.TimeCount>maxtimelimit)
				timelimit = maxtimelimit+gamestate.TimeCount;
			if (gamestate.TimeCount == timelimit)
				{
				locplayerstate->lives=-1;
				playstate=ex_died;
				}
			}

		gamestate.TimeCount ++;

		ResetCurrentCommand();

		oldpolltime++;
		if (GamePaused==true)
			break;
		}
	actortime=fasttics-atime;

	UpdateClientControls ();

	if (noecho == false)
		{
		if ( player->flags & FL_SHROOMS )
			{
			FX_SetReverb( 230 );
			}
		else if (sky == 0)
			{
			FX_SetReverb( min( numareatiles[ player->areanumber ] >> 1, 90 ) );
			}
		}

	waminot();

}


void PauseLoop ( void )
{
	StopWind();

	UpdateClientControls ();

	while (oldpolltime<oldtime)
		{
		CheckUnPause();
#if (SYNCCHECK == 1)
		CheckForSyncCheck();
#endif
		oldpolltime++;
		if (GamePaused==false)
			{
			break;
			}
		}

	CalcTics ();
	if (demoplayback==false)
		PollControls ();

	if ((RefreshPause == true) &&
		(GamePaused == true) &&
		((ticcount - pausedstartedticcount) >= blanktime))
		{
		RefreshPause = false;
		StartupScreenSaver();
		}
}



void PlayLoop
	(
	void
	)

	{
	volatile int atime;

	boolean canquit = true;
	int	quittime = 0;

	wami(3);


	if ( (loadedgame == false) && (timelimitenabled == false) )
		{
		gamestate.TimeCount = 0;
		gamestate.frame = 0;
		}

fromloadedgame:

	GamePaused = false;

	if ( loadedgame == false )
		{
		DrawPlayScreen( true );
		missobj = NULL;
		}
	else
		{
		loadedgame = false;
		DoLoadGameSequence();
		}

	drawtime  = 0;
	actortime = 0;
	tics		= 0;
	fasttics  = 0;

	if ( fizzlein == false )
		{
		StartupClientControls();
		}
	else
		{
		ShutdownClientControls();
		}

	// set detail level
	doublestep = 2 - DetailLevel;

	ResetMessageTime();
	DeletePriorityMessage( MSG_SYSTEM );

	if ( ( gamestate.battlemode == battle_Normal ) &&
		( numplayers == 1 ) )
		{
		AddMessage( "Comm-bat is for Modem and Network games.", MSG_GAME );
		AddMessage( "You will not be facing any", MSG_GAME );
		AddMessage( "opponents.  Have fun and explore.", MSG_GAME );
		}


	while( playstate == ex_stillplaying )
		{
		UpdateClientControls();

		if ( GamePaused )
			{
			PauseLoop();

			atime = fasttics;

			if ( RefreshPause )
				{
				ThreeDRefresh();
				}
			else
				{
				UpdateScreenSaver();
				}
			}
		else
			{
			if (controlupdatestarted == 1)
				UpdateGameObjects();

			atime = fasttics;

			ThreeDRefresh();
			}

		SyncToServer();

		drawtime = fasttics - atime;

		// Don't allow player to quit if entering message
		canquit = !MSG.messageon;

		PollKeyboard();

		MISCVARS->madenoise = false;

		AnimateWalls();

		UpdateClientControls();

		#if (DEVELOPMENT == 1)
			Z_CheckHeap();
		#endif

		if ( AutoDetailOn == true )
			{
			AdaptDetail();
			}

		UpdateClientControls();

		DoSprites();
		DoAnimatedMaskedWalls();

		UpdatePlayers();

		DrawTime( false );

		UpdateClientControls();

		if ( ( !BATTLEMODE ) && ( CP_CheckQuick( LastScan ) ) )
			{
			boolean escaped=false;

			if (LastScan == sc_Escape)
				{
				MU_StoreSongPosition();
				MU_StartSong(song_menu);
				escaped = true;
				}
			TurnShakeOff();
			StopWind();
			SetBorderColor( 0 );
			ShutdownClientControls();
			if (demoplayback==true)
				{
				FreeDemo();
				playstate = ex_demodone;
				if (demoexit==true)
					{
					QuitGame();
					}
				return;
				}

			ControlPanel( LastScan );

			// set detail level
			doublestep = 2 - DetailLevel;

			inmenu = false;

			if ( playstate == ex_titles )
				{
				return;
				}

			if ( playstate == ex_stillplaying )
				{
				SetupScreen( false );
				}

			if ( loadedgame == true )
				{
				goto fromloadedgame;
				}

			if (
				( playstate == ex_stillplaying ) &&
				( ( fizzlein == false ) ||
					( GamePaused )
				)
				)
				{
				StartupClientControls();
				}

			if (
				(playstate == ex_stillplaying) &&
				(GamePaused == false) &&
				(escaped == true)
				)
				{
				MU_StartSong(song_level);
				MU_RestoreSongPosition();
				}
			}

		if ( BATTLEMODE )
			{
			if ( MSG.messageon == false )
				{
				CheckRemoteRidicule( LastScan );
				}
			if ( quitactive == false )
				{
				if ( ( LastScan == sc_Escape ) && ( canquit ) )
					{
					quitactive = true;
					quittime	= ticcount + QUITTIMEINTERVAL;

					if ( (consoleplayer == 0) || (networkgame == false) )
						{
						AddMessage( "Do you want to end this game? "
							"(\\FY\\O/\\FN\\O)", MSG_QUIT );
						}
					else
						{
						AddMessage( "Do you want to exit to DOS? "
							"(\\FY\\O/\\EN\\O)", MSG_QUIT );
						}
					}
				}
			else
				{
				if ( ticcount > quittime )
					{
					quitactive = false;
					}
				else if ( LastScan == sc_N )
					{
					DeletePriorityMessage( MSG_QUIT );
					quitactive = false;
					}
				else if ( LastScan == sc_Y )
					{
					DeletePriorityMessage( MSG_QUIT );
					if ( (consoleplayer == 0) || (networkgame==false) )
						{
						AddEndGameCommand();
						}
					else
						{
						AddQuitCommand();
						}
					}
				}
			}
		}
	waminot();
	}

//******************************************************************************
//
// CheckRemoteRidicule ()
//
//******************************************************************************

void CheckRemoteRidicule ( int scancode )
{
	int num=-1;

	wami(4);
	switch (scancode)
	{
		case sc_F1:
			num=0;
			break;
		case sc_F2:
			num=1;
			break;
		case sc_F3:
			num=2;
			break;
		case sc_F4:
			num=3;
			break;
		case sc_F5:
			if ( !Keyboard[ sc_RShift ] )
				{
				num=4;
				}
			break;
		case sc_F6:
			num=5;
			break;
		case sc_F7:
			if ( !Keyboard[ sc_RShift ] )
				{
				num=6;
				}
			break;
		case sc_F8:
			num=7;
			break;
		case sc_F9:
			num=8;
			break;
		case sc_F10:
			num=9;
			break;
	}
	if (num>=0)
		{
		AddRemoteRidiculeCommand ( consoleplayer, MSG_DIRECTED_TO_ALL, num );
		LastScan=0;
		}
	waminot();
}

//******************************************************************************
//
// DoBossKey ()
//
//******************************************************************************

void DoBossKey ( void )
{
	__debugbreak();
}

#if 0
void DoBossKey ( void )
{
	union REGS regs;
	ShutdownClientControls();

	TextMode();

	// move cursor to the row 0 column 4
	regs.w.ax = 0x0200;
	regs.w.bx = 0;
	regs.w.dx = 0x0004;
	int386(0x10,&regs,&regs);
	px=0;
	py=0;
	UL_printf("C:\\>\n");

	LastScan = 0;
	IN_WaitForKey ();
	VL_SetVGAPlaneMode();
	VL_SetPalette(origpal);
	SetBorderColor(0);
	TurnShakeOff();
	SetupScreen(true);
	ThreeDRefresh();

	StartupClientControls();
}
#endif


//******************************************************************************
//
// PollKeyboard ()
//
//******************************************************************************

void PollKeyboard
	(
	void
	)

	{
	static char autopressed = false;

	wami(5);

	if (demoplayback==true)
		{
		IN_UpdateKeyboard();
		}

	if ( !BATTLEMODE )
		{
		CheckDebug ();
		if (
			( Keyboard[ sc_CapsLock ] ) &&
			( DebugOk )
			)
			{
			DebugKeys ();
			}
		}

	if ( locplayerstate->buttonstate[ bt_autorun ] )
		{
		if ( !autopressed )
			{
			autopressed = true;
			gamestate.autorun ^= 1;
			if ( gamestate.autorun == 0 )
				{
				AddMessage( "AutoRun is \\cOFF", MSG_SYSTEM );
				}
			else
				{
				AddMessage( "AutoRun is \\cON", MSG_SYSTEM );
				}
			}
		}
	else
		{
		autopressed = false;
		}

#if 0
	if ( modemgame == false )
		{
		CheckDevelopmentKeys();
		}
#endif

	if ( ( MSG.messageon == false ) && ( !quitactive ) )
		{
		if ( ( Keyboard[ buttonscan[ bt_message ] ] ) && ( BATTLEMODE ) )
			{
			// Send message to all
			MSG.messageon = true;
			MSG.directed  = false;
			MSG.inmenu	= false;
			MSG.remoteridicule = -1;
			MSG.towho	= MSG_DIRECTED_TO_ALL;
			MSG.textnum	= AddMessage( "_", MSG_MODEM );
			MSG.length	= 1;
			DeletePriorityMessage( MSG_MACRO );
			}
		else if ( ( Keyboard[ buttonscan[ bt_directmsg ] ] ) && ( BATTLEMODE ) )
			{
			// Send directed message
			MSG.messageon = true;
			MSG.directed  = true;
			MSG.inmenu	= false;
			MSG.remoteridicule = -1;
			MSG.towho	= 0;
			MSG.textnum	= AddMessage( "_", MSG_MODEM );
			MSG.length	= 1;
			DeletePriorityMessage( MSG_MACRO );
			}
		if ( buttonpoll[ bt_map ] )
			{
			if ( !BATTLEMODE )
			{
				// Automap
				StopWind();
				DoMap( player->tilex, player->tiley );
				buttonpoll[ bt_map ] = 0;
			}
			else
				{
				// Show kill counts
				if ( SHOW_KILLS() )
					{
					BATTLE_ShowKillCount = false;
					StatusBar &= ~STATUS_KILLS;
					}
				else
					{
					StatusBar |= STATUS_KILLS;
					BATTLE_ShowKillCount = true;
					}

				SetupScreen( true );
				}
			}

		// Shrink screen
		if ( Keyboard[ sc_Minus ] )
			{
			if ( viewsize > 0 )
				{
				viewsize--;
				SetupScreen( true );
				}
			}

		// Expand screen
		if ( Keyboard[ sc_Plus ] )
			{
			if ( viewsize < MAXVIEWSIZES - 1 )
				{
				viewsize++;
				SetupScreen( true );
				}
			}

		// Set detail
		if ( ( Keyboard[ sc_F5 ] ) && ( ( !BATTLEMODE ) ||
			( Keyboard[ sc_RShift ] ) ) )
			{
			Keyboard[ sc_F5 ] = false;
			LastScan = 0;
			DetailLevel++;
			if ( DetailLevel > 2 )
				{
				DetailLevel = 0;
				}

			switch( DetailLevel )
				{
				case 0 :
					AddMessage( "Low detail", MSG_SYSTEM );
					break;

				case 1 :
					AddMessage( "Medium detail", MSG_SYSTEM );
					break;

				case 2 :
					AddMessage( "High detail", MSG_SYSTEM );
					break;
				}
			doublestep = 2 - DetailLevel;
			}

		// Turn messages on/off

		if ( ( Keyboard[ sc_F7 ] ) && ( ( !BATTLEMODE ) ||
			( Keyboard[ sc_RShift ] ) ) )
			{
			Keyboard[ sc_F7 ] = false;
			LastScan = 0;
			MessagesEnabled = !MessagesEnabled;
			if ( !MessagesEnabled )
				{
				AddMessage( "Messages disabled.", MSG_MSGSYSTEM );
				}
			else
				{
				AddMessage( "Messages enabled.", MSG_MSGSYSTEM );
				}
			}

		if ( ( Keyboard[ sc_F6 ] ) && ( !BATTLEMODE ) )
			{
			Keyboard[ sc_F6 ] = false;
			if (Keyboard[sc_RShift])
				{
				ShutdownClientControls();
				UndoQuickSaveGame();
				StartupClientControls();
				}
			else if (quicksaveslot==-1)
				{
				ShutdownClientControls();
				LastScan=sc_F2;
				inmenu = true;
				ControlPanel( LastScan );
				StartupClientControls();
				}
			else
				{
				LastScan = 0;
				ShutdownClientControls();
				ThreeDRefresh();
				QuickSaveGame();
				StartupClientControls();
				}
			}

//#if 0
		if ( ( Keyboard[ sc_F12 ] ) && ( !BATTLEMODE ) )
			{
			Keyboard[ sc_F12 ] = false;
			LastScan = 0;
			DoBossKey();
			}
//#endif

		// Gamma correction
		if ( Keyboard[ sc_F11 ] )
			{
			char str[ 50 ] = "Gamma Correction Level ";
			char str2[ 10 ];

			gammaindex++;
			if ( gammaindex == NUMGAMMALEVELS )
				{
				gammaindex = 0;
				}
			VL_SetPalette( origpal );
			itoa( gammaindex, str2, 10 );
			strcat( str, str2 );
			AddMessage( str, MSG_SYSTEM );

			while( Keyboard[ sc_F11 ] )
				{
				IN_UpdateKeyboard();
				}
			}
	#if 0
		if ( Keyboard[ sc_M ] )
			{
			char str[ 50 ] = "Mouse Y-Rotation Input Scale ";
			char str2[ 10 ];

			if ( Keyboard[ sc_RShift ] )
				mouse_ry_input_scale += 50;
			else
				mouse_ry_input_scale -= 50;

			itoa(mouse_ry_input_scale,str2,10);
			strcat( str, str2 );
			AddMessage( str, MSG_SYSTEM );

			}
	#endif
		// Increase volume
		if ( Keyboard[ sc_CloseBracket ] )
			{
			if ( Keyboard[ sc_RShift ] )
				{
				char str[ 50 ] = "Music Volume Level ";
				char str2[ 10 ];

				if ( MUvolume < 255 )
					{
					MUvolume++;
					}
				MU_SetVolume( MUvolume );

				itoa( MUvolume, str2, 10 );
				strcat( str, str2 );
				AddMessage( str, MSG_SYSTEM );
				}
			else
				{
				char str[ 50 ] = "Sound FX Volume Level ";
				char str2[ 10 ];

				if ( FXvolume < 255 )
					{
					FXvolume++;
					}
				FX_SetVolume( FXvolume );

				itoa( FXvolume, str2, 10 );
				strcat( str, str2 );
				AddMessage( str, MSG_SYSTEM );
				}
			}

		// Decrease volume
		if ( Keyboard[ sc_OpenBracket ] )
			{
			if ( Keyboard[ sc_RShift ] )
				{
				char str[ 50 ] = "Music Volume Level ";
				char str2[ 10 ];

				if ( MUvolume > 0 )
					{
					MUvolume--;
					}
				MU_SetVolume( MUvolume );

				itoa( MUvolume, str2, 10 );
				strcat( str, str2 );
				AddMessage( str, MSG_SYSTEM );
				}
			else
				{
				char str[ 50 ] = "Sound FX Volume Level ";
				char str2[ 10 ];

				if ( FXvolume > 0 )
					{
					FXvolume--;
					}
				FX_SetVolume( FXvolume );

				itoa( FXvolume, str2, 10 );
				strcat( str, str2 );
				AddMessage( str, MSG_SYSTEM );
				}
			}

		#if SAVE_SCREEN
#if (DEVELOPMENT == 1)
			if ( Keyboard[ sc_CapsLock ] && Keyboard[ sc_C ] )
				{
				SaveScreen( true );
				}
			else if ( Keyboard[ sc_CapsLock ] && Keyboard[ sc_X ] )
				{
				SaveScreen( false );
				}
#endif
			else if ( Keyboard[ sc_Alt] && Keyboard[ sc_C ] )
				{
				SaveScreen( false );
				}
			else if ( Keyboard[ sc_Alt] && Keyboard[ sc_V ] )
				{
				SaveScreen( true );
				}
		#endif
		}
	waminot();
	}


//******************************************************************************
//
// CheckDevelopmentKeys ()
//
//******************************************************************************
#if 0
void CheckDevelopmentKeys
	(
	void
	)

	{
	#if (DEBUG == 1)
	if ( Keyboard[ sc_CapsLock ] && Keyboard[ sc_T ] )
		{
		if ( warp == true )
			{
			player->x	= warpx;
			player->y	= warpy;
			player->angle = warpa;
			locplayerstate->anglefrac = warpa << ANGLEBITS;
			player->momentumx = 0;
			player->momentumy = 0;
			player->momentumz = 0;
			}
		return;
		}
	#endif

	// Lower wall height
	if ( Keyboard[ sc_5 ] )
		{
		if ( levelheight > 1 )
			{
			levelheight--;
			}

		while( Keyboard[ sc_5 ] )
			{
			IN_UpdateKeyboard ();
			}

		maxheight = ( levelheight << 6 ) - 32;
		nominalheight = maxheight - 32;
		}

	// Raise wall height
	if ( Keyboard[ sc_6 ] )
		{
		levelheight++;

		while( Keyboard[ sc_6 ] )
			{
			IN_UpdateKeyboard();
			}

		maxheight = ( levelheight << 6 ) - 32;
		nominalheight = maxheight - 32;
		}

	if ( Keyboard[ sc_8 ] )
		{
		char str[ 50 ] = "You are now player ";
		char str2[ 10 ];

		locplayerstate->player++;
		if ( locplayerstate->player == 5 )
			{
			locplayerstate->player = 0;
			}

		while( Keyboard[ sc_8 ] )
			{
			IN_UpdateKeyboard ();
			}

		itoa( locplayerstate->player, str2, 10 );
		strcat( str, str2 );
		AddMessage( str, MSG_SYSTEM );
		}

#if 0
	// Cycle forward through wall textures
		if (Keyboard[sc_W] && (modemgame==false))
			{int i,j;

			for(i=0;i<128;i++)
				for(j=0;j<128;j++)
				{if (IsWall(i,j))
					{
//						if (tilemap[i][j] ==
//							(W_GetNumForName("WALLSTOP")-
//							W_GetNumForName("WALLSTRT")-1))
//						tilemap[i][j] = 1;
//						else
//						tilemap[i][j] ++;
					}
				}
			while(Keyboard[sc_W])
				IN_UpdateKeyboard ();

			}



		if (Keyboard[sc_Q] && (modemgame==false))
			{int i,j;

			for(i=0;i<128;i++)
				for(j=0;j<128;j++)
				{if (IsWall(i,j))
					{if (tilemap[i][j] == 1)
						tilemap[i][j] = 74;
						else
						tilemap[i][j] --;
					}
				}
			while(Keyboard[sc_Q])
				IN_UpdateKeyboard ();

			}

#endif
	// Step through cieling/skies
	if ( Keyboard[ sc_K ] )
		{
		if ( sky > 0 )
			{
			MAPSPOT( 1, 0, 0 )++;
			if ( MAPSPOT( 1, 0, 0 ) > 239 )
				{
				MAPSPOT( 1, 0, 0 ) = 234;
				}
			}
		else
			{
			MAPSPOT( 1, 0, 0 )++;
			if ( MAPSPOT( 1, 0, 0 ) > 198 + 15 )
				{
				MAPSPOT( 1, 0, 0 ) = 198;
				}
			}

		SetPlaneViewSize();

		while( Keyboard[ sc_K ] )
			{
			IN_UpdateKeyboard();
			}
		}

	// Step through floors
	if ( Keyboard[ sc_L ] )
		{
		MAPSPOT( 0, 0, 0 )++;
		if ( MAPSPOT( 0, 0, 0 ) > 180 + 15 )
			{
			MAPSPOT( 0, 0, 0 ) = 180;
			SetPlaneViewSize();

			while( Keyboard[ sc_L ] )
				{
				IN_UpdateKeyboard();
				}
			}
		}

	// Increase darkness level
	if ( Keyboard[ sc_M ] )
		{
		if ( darknesslevel < 7 )
			{
			darknesslevel++;
			}

		SetLightLevels( darknesslevel );

		while( Keyboard[ sc_M ] )
			{
			IN_UpdateKeyboard();
			}
		}

	// Decrease darkness level
	if ( Keyboard[ sc_N ] )
		{
		if ( darknesslevel > 0 )
			{
			darknesslevel--;
			}

		SetLightLevels( darknesslevel );

		while( Keyboard[ sc_N ] )
			{
			IN_UpdateKeyboard();
			}
		}

	// Increase light rate
	if ( Keyboard[ sc_B ] )
		{
		SetLightRate( GetLightRate() + 1 );
		myprintf( "normalshade = %ld\n", normalshade );

		while( Keyboard[ sc_B ] )
			{
			IN_UpdateKeyboard();
			}
		}

	// Decrease light rate
	if ( Keyboard[ sc_V ] )
		{
		SetLightRate( GetLightRate() - 1 );
		myprintf( "normalshade = %ld\n", normalshade );

		while( Keyboard[ sc_V ] )
			{
			IN_UpdateKeyboard();
			}
		}

	// Toggle light diminishing on/off
	if ( Keyboard[ sc_T ] )
		{
		fulllight ^= 1;

		while( Keyboard[ sc_T ] )
			{
			IN_UpdateKeyboard();
			}
		}
	}
#endif


#if SAVE_SCREEN


short	BigShort (short l)
{
	byte	b1,b2;

	b1 = l&255;
	b2 = (l>>8)&255;

	return (b1<<8) + b2;
}

long	BigLong (long l)
{
	byte	b1,b2,b3,b4;

	b1 = l&255;
	b2 = (l>>8)&255;
	b3 = (l>>16)&255;
	b4 = (l>>24)&255;

	return ((long)b1<<24) + ((long)b2<<16) + ((long)b3<<8) + b4;
}

/*
==============
=
= WriteLBMfile
=
==============
*/

void WriteLBMfile (char *filename, byte *data, int width, int height)
{
	byte	*lbm, *lbmptr;
	long	*formlength, *bmhdlength, *cmaplength, *bodylength;
	long	length;
	bmhd_t  basebmhd;
	int	handle;
	int	i;

	lbm = lbmptr = (byte *) SafeMalloc (65000);

//
// start FORM
//
	*lbmptr++ = 'F';
	*lbmptr++ = 'O';
	*lbmptr++ = 'R';
	*lbmptr++ = 'M';

	formlength = (long*)lbmptr;
	lbmptr+=4;							// leave space for length

	*lbmptr++ = 'P';
	*lbmptr++ = 'B';
	*lbmptr++ = 'M';
	*lbmptr++ = ' ';

//
// write BMHD
//
	*lbmptr++ = 'B';
	*lbmptr++ = 'M';
	*lbmptr++ = 'H';
	*lbmptr++ = 'D';

	bmhdlength = (long *)lbmptr;
	lbmptr+=4;							// leave space for length

	memset (&basebmhd,0,sizeof(basebmhd));
	basebmhd.w = BigShort(width);
	basebmhd.h = BigShort(height);
	basebmhd.nPlanes = BigShort(8);
	basebmhd.xAspect = BigShort(5);
	basebmhd.yAspect = BigShort(6);
	basebmhd.pageWidth = BigShort(width);
	basebmhd.pageHeight = BigShort(height);

	memcpy (lbmptr,&basebmhd,sizeof(basebmhd));
	lbmptr += sizeof(basebmhd);

	length = lbmptr-(byte *)bmhdlength-4;
	*bmhdlength = BigLong(length);
	if (length&1)
		*lbmptr++ = 0;			// pad chunk to even offset

//
// write CMAP
//
	*lbmptr++ = 'C';
	*lbmptr++ = 'M';
	*lbmptr++ = 'A';
	*lbmptr++ = 'P';

	cmaplength = (long *)lbmptr;
	lbmptr+=4;							// leave space for length

	for (i = 0; i < 0x300; i++)
		*lbmptr++ = (*(origpal+i))<<2;

// memcpy (lbmptr,&origpal[0],768);
// lbmptr += 768;

	length = lbmptr-(byte *)cmaplength-4;
	*cmaplength = BigLong(length);
	if (length&1)
		*lbmptr++ = 0;			// pad chunk to even offset

//
// write BODY
//
	*lbmptr++ = 'B';
	*lbmptr++ = 'O';
	*lbmptr++ = 'D';
	*lbmptr++ = 'Y';

	bodylength = (long *)lbmptr;
	lbmptr+=4;							// leave space for length

	memcpy (lbmptr,data,width*height);
	lbmptr += width*height;

	length = lbmptr-(byte *)bodylength-4;
	*bodylength = BigLong(length);
	if (length&1)
		*lbmptr++ = 0;			// pad chunk to even offset

//
// done
//
	length = lbmptr-(byte *)formlength-4;
	*formlength = BigLong(length);
	if (length&1)
		*lbmptr++ = 0;			// pad chunk to even offset

//
// write output file
//
	handle = SafeOpenWrite (filename);

	SafeWrite (handle, lbm, lbmptr-lbm);

	w_close (handle);
	SafeFree(lbm);
}


//****************************************************************************
//
// GetFileName ()
//
//****************************************************************************

#if 0
void GetFileName (boolean saveLBM)
{
	char num[4];
	int cnt = 0;
	struct find_t fblock;

	if (saveLBM)
		memcpy (savename, "ROTT0000.LBM\0", 13);
	else
		memcpy (savename, "ROTT0000.PCX\0", 13);

	if (_dos_findfirst (savename, 0, &fblock) != 0)
		return;

	do
	{
		cnt++;
		memset (&num[0], 0, 4);
		itoa (cnt, num, 10);

		if (cnt > 99)
		{
			savename[5] = num[0];
			savename[6] = num[1];
			savename[7] = num[2];
		}
		else
		if (cnt > 9)
		{
			savename[6] = num[0];
			savename[7] = num[1];
		}
		else
			savename[7] = num[0];
	}
	while (_dos_findfirst (savename, 0, &fblock) == 0);
}
#endif

void GetFileName (boolean saveLBM)
{
	char num[4];
	int cnt = 0;

	if (saveLBM)
		memcpy (savename, "ROTT0000.LBM\0", 13);
	else
		memcpy (savename, "ROTT0000.PCX\0", 13);

	if (w_chkaccess (savename) < 0)
		return;

	do
	{
		cnt++;
		memset (&num[0], 0, 4);
		itoa (cnt, num, 10);

		if (cnt > 99)
		{
			savename[5] = num[0];
			savename[6] = num[1];
			savename[7] = num[2];
		}
		else
		if (cnt > 9)
		{
			savename[6] = num[0];
			savename[7] = num[1];
		}
		else
			savename[7] = num[0];
	}while (w_chkaccess (savename) >= 0);
}

//****************************************************************************
//
// SaveScreen ()
//
//****************************************************************************

boolean inhmenu;

#if (BETA == 1)
#define SSX (160-(46*2))
#define SSY (17)
#endif
void SaveScreen (boolean saveLBM)
{
	byte *buffer;
//	byte * screen;
	unsigned screen;
	boolean oldHUD;
	char filename[ 128 ];

#if (BETA == 1)
	unsigned tmp;
	char buf[30];
	int i;
#endif


	oldHUD=HUD;
	HUD=false;
	doublestep=0;
	if (inhmenu==false)
//		screen = (byte *) bufferofs;
		screen = bufferofs;
	else
//		screen = (byte *) displayofs;
		screen = displayofs;

	if (inhmenu==false)
		ThreeDRefresh ();
	doublestep = 2 - DetailLevel;

	buffer = (byte *) SafeMalloc (65000);

#if (BETA == 1)
	if (SCREENSHOTS == false)
	{
//		if (screen!=(byte *)bufferofs)
		if (screen!=bufferofs)
			{
			tmp=bufferofs;
			bufferofs=displayofs;
			}
		CurrentFont=tinyfont;

		VGAMAPMASK(15);
		for (i=-1;i<6;i++)
//			memset((byte *)bufferofs+(ylookup[i+SSY])+(SSX>>2),0,46);
			VGAMEMSET(bufferofs+(ylookup[i+SSY])+(SSX>>2),0,46);
		px=SSX;
		py=SSY;
		VW_DrawPropString(" Rise of the Triad (c) 1995 Apogee  Version ");
		VW_DrawPropString(itoa(ROTTMAJORVERSION,&buf[0],10));
		VW_DrawPropString(".");
		VW_DrawPropString(itoa(ROTTMINORVERSION,&buf[0],10));
		px=SSX+13;
		py=SSY+8;
		VW_DrawPropString(" Episode ");
		VW_DrawPropString(itoa(gamestate.episode,&buf[0],10));
		VW_DrawPropString(" Area ");
		VW_DrawPropString(itoa(GetLevel(gamestate.episode, gamestate.mapon),&buf[0],10));

		if (screen!=(byte *)bufferofs)
			bufferofs=tmp;
	}
#endif

	VL_CopyPlanarPageToMemory(screen,buffer);

	GetFileName (saveLBM);
	GetPathFromEnvironment( filename, ApogeePath, savename );

	if (saveLBM)
	{
		WriteLBMfile (filename, buffer, 320, 200);
		while (Keyboard[sc_CapsLock] && Keyboard[sc_C])
			IN_UpdateKeyboard ();
	}
	else
	{
		WritePCX (filename, buffer);
		while (Keyboard[sc_CapsLock] && Keyboard[sc_X])
			IN_UpdateKeyboard ();
	}

	SafeFree(buffer);
	HUD=oldHUD;
}

//****************************************************************************
//
// WritePCX ()
//
//****************************************************************************

void WritePCX (char * file, byte * source)
{
	PCX_HEADER pcxHDR;
	byte *tempbuffer;
	byte pal[0x300];
	int pcxhandle;
	int i, j, y;
	unsigned char c;
	unsigned char buffer1[GAP_SIZE];

	pcxhandle = SafeOpenWrite (file);

		/* --- init the header that we'll write.
		*	Note: since DPaint never reads & writes at the same time,
		*	it is okay to share the same read & write structure,
		*	unlike in CONVERT.EXE.
		*/

	memset (&pcxHDR, sizeof(PCX_HEADER), 0);

	pcxHDR.manufacturer  = 10;
	pcxHDR.version		= 5;
	pcxHDR.encoding		= 1;

	pcxHDR.bitsperpixel  = 8;			//bpp;
	pcxHDR.xmin			= pcxHDR.ymin = 0;
	pcxHDR.xmax			= 319;			//bitmap->box.w - 1;
	pcxHDR.ymax			= 199;			//bitmap->box.h - 1;
	pcxHDR.hres			= 320;			//N_COLUMNS;
	pcxHDR.vres			= 200;			//N_LINES;

  // bytesperline doesn't take into account multiple planes.
  // Output in same format as bitmap (planar vs packed).
  //
	pcxHDR.bytesperline  = 320;			//bitmap->width;

	pcxHDR.nplanes		= 1;			//bitmap->planes;
	pcxHDR.reserved		= 0;

  // First 16 colors of our palette info.
	for (i = 0, j = 0; i < 16; ++i, j += 3) {
		pcxHDR.colormap[i][0] = (unsigned char)(origpal[j]);
		pcxHDR.colormap[i][1] = (unsigned char)(origpal[j]+2);
		pcxHDR.colormap[i][2] = (unsigned char)(origpal[j]+3);
	}

  //
  // Write the 128-byte header
  //
	SafeWrite(pcxhandle,&pcxHDR, sizeof (PCX_HEADER));

	memset (buffer1, GAP_SIZE, 0);

	SafeWrite (pcxhandle, &buffer1, GAP_SIZE);

	tempbuffer = (byte *) SafeMalloc (65000);
	bptr = tempbuffer;
	totalbytes = 0;

  //
  // Write to a bit-packed file.
  //
	for (y = 0;  y < 200;  ++y) 		// for each line in band
		if (PutBytes (((unsigned char *) (source+(y*320))),
						pcxHDR.bytesperline))
			Error ("Error writing PCX bit-packed line!\n");

	SafeWrite (pcxhandle, tempbuffer, totalbytes);

  //
  // Write out PCX palette
  //
	c = 0x0C;

	for (i = 0; i < 0x300; i++)
		pal[i] = (*(origpal+i))<<2;

	SafeWrite (pcxhandle, &c, 1);
	SafeWrite (pcxhandle, &pal[0], 768);

	w_close (pcxhandle);
	SafeFree (tempbuffer);
}


//****************************************************************************
//
// PutBytes ()
//
// Write bytes to a file, handling packing as it goes.
// Returns :  0 == SUCCESS
//				1 == FAIL.
//
//****************************************************************************

int PutBytes (unsigned char *ptr, unsigned int bytes)
{
	unsigned int startbyte, count;
	char b;

	while (bytes > 0) {
	// check for a repeating byte value
		startbyte = *ptr;
		*ptr++ = 0;
		--bytes;
		count = 1;
		while (*ptr == startbyte && bytes > 0 && count < 63)
		{
			*ptr = 0;
			++ptr;
			--bytes;
			++count;
		}
	// If we can pack the sequence, or if we have to add a
	//	byte before it because the top 2 bits of the value
	//	are 1's, write a packed sequence of 2 bytes.
	//	Otherwise, just write the byte value.
	//
		if (count > 1  ||  (startbyte & 0xc0) == 0xc0)
		{
			b = 0xc0 | count;

			*bptr++ = b;
			totalbytes++;
		}
		b = startbyte;

		*bptr++ = b;
		totalbytes++;
	}
	return (0);
}


#endif


//****************************************************************************
//
// PlayCinematic () - Play intro cinematics
//
//****************************************************************************

void PlayCinematic (void)
{

	if ((tedlevel == true) || (turbo == true))
		return;

	switch (gamestate.mapon)
	{
#if (SHAREWARE == 0)
		byte pal[768];
		case 0:		// Start of EPISODE 1

			MU_StartSong ( song_cinematic1 );
			VL_FadeOut (0, 255, 0, 0, 0, 20);
			VL_ClearBuffer (bufferofs, 0);
			DrawNormalSprite(0,30,W_GetNumForName("nicolas"));
			DrawNormalSprite(0,168,W_GetNumForName("oneyear"));
			FlipPage();
			memcpy(&pal[0],W_CacheLumpName("nicpal",PU_CACHE),768);
			VL_NormalizePalette(&pal[0]);
			VL_FadeIn(0,255,pal,20);
			I_Delay (60);
			VL_FadeOut (0, 255, 0, 0, 0, 20);
			IN_UpdateKeyboard();
			if (LastScan!=0)
				{
				LastScan=0;
				return;
				}
			SD_PlayPitchedSound(SD_LIGHTNINGSND,255,-1500);
			DoInBetweenCinematic (20, W_GetNumForName("binoculr"), 80,
										"The HUNT cases an\n"
										"ancient monastery."
										);
			IN_UpdateKeyboard();
			if (LastScan!=0)
				{
				LastScan=0;
				return;
				}
			SD_Play(SD_NMESEESND);
			DoInBetweenCinematic (20, W_GetNumForName("binosee"), 80,
										"\"There they are,\" says\n"
										"Cassatt. \"Let's get back\n"
										"to the boat and inform HQ.\""
										);
			IN_UpdateKeyboard();
			if (LastScan!=0)
				{
				LastScan=0;
				return;
				}
			SD_Play(SD_HIGHGUARD1SEESND);
			DoInBetweenCinematic (20, W_GetNumForName("boatgard"), 80,
										"\"The intruders, on that hill!\""
										);
			IN_UpdateKeyboard();
			if (LastScan!=0)
				{
				LastScan=0;
				return;
				}
			SD_Play(SD_EXPLODESND);
			DoInBetweenCinematic (20, W_GetNumForName("boatblow"), 80,
										"\"There goes our ride home,\"\n"
										"says Barrett.  \"Looks like\n"
										"the only way out is in....\""
										);
			IN_UpdateKeyboard();
			LastScan=0;
		break;

		case 8:		// Start of EPISODE 2
			MU_StartSong ( song_cinematic2 );
			DoInBetweenCinematic (0, W_GetNumForName("epi12"), 1200,
										"The HUNT makes their way\n"
										"into the main keep."
										);
			IN_UpdateKeyboard();
			LastScan=0;
		break;

		case 16:		// Start of EPISODE 3
			MU_StartSong ( song_cinematic1 );
			DoInBetweenCinematic (20, W_GetNumForName("epi23"), 1200,
										"The HUNT stands before a pair\n"
										"of ominous wooden doors.\n"
										"The sounds of machinery and\n"
										"servomotors fill the air.\n"
										);
			IN_UpdateKeyboard();
			LastScan=0;
		break;

		case 24:		// Start of EPISODE 4
			MU_StartSong ( song_cinematic2 );
			DoInBetweenCinematic (0, W_GetNumForName("epi34"), 1200,
										"Stairs lead down beneath the\n"
										"keep.  From behind the doors\n"
										"come the moans of the undead."
										);
			IN_UpdateKeyboard();
			LastScan=0;
		break;
#endif
	}
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
// #include <conio.h>
#include <string.h>
// #include <dos.h>
#include "sprites.h"
#include "rt_map.h"
#include "rt_dr_a.h"
#include "_rt_map.h"
#include "isr.h"
#include "rt_util.h"
#include "modexlib.h"
#include "rt_draw.h"
#include "rt_stat.h"
#include "z_zone.h"
#include "w_wad.h"
#include "rt_main.h"
#include "rt_playr.h"
#include "lumpy.h"
#include "rt_door.h"
#include "rt_scale.h"
#include "rt_vid.h"
#include "rt_in.h"
#include "rt_ted.h"
#include "rt_game.h"
#include "rt_rand.h"
#include "rt_view.h"
#include "rt_floor.h"
#include "engine.h"
#include "develop.h"
// #include "rt_spbal.h"
#include "rt_menu.h"
#include "rt_net.h"
#include "rt_str.h"
#include "watcom.h"
//MED
// #include "memcheck.h"

//===========================================================================


static int tilesize;
static fixed xscale;
static fixed yscale;
static int mapscale=2;
static int oldw,oldh;
static byte * skytile;
static int mapcolor=8;

typedef struct PType {
  int	x;
  int	y;
} Ptype;

static Ptype arrows[8][7]=
		{
			{ {4,2}, {2,4}, {2,3}, {0,3}, {0,1}, {2,1}, {2,0} },
			{ {4,0}, {4,3}, {3,2}, {1,4}, {0,3}, {2,1}, {1,0} },
			{ {2,0}, {4,2}, {3,2}, {3,4}, {1,4}, {1,2}, {0,2} },
			{ {0,0}, {3,0}, {2,1}, {4,3}, {3,4}, {1,2}, {0,3} },
			{ {0,2}, {2,0}, {2,1}, {4,1}, {4,3}, {2,3}, {2,4} },
			{ {0,4}, {0,1}, {1,2}, {3,0}, {4,1}, {2,3}, {3,4} },
			{ {2,4}, {0,2}, {1,2}, {1,0}, {3,0}, {3,2}, {4,2} },
			{ {4,4}, {1,4}, {2,3}, {0,1}, {1,0}, {3,2}, {4,1} },
	};

void CheatMap( void )
{
	int i;
	int j;
	statobj_t * temp;
	objtype * a;

	for(temp=FIRSTSTAT;temp;temp=temp->statnext)
		temp->flags|=FL_SEEN;

	for(a=FIRSTACTOR;a;a=a->next)
		a->flags|=FL_SEEN;


	for (j=0;j<MAPSIZE;j++)
		for (i=0;i<MAPSIZE;i++)
			mapseen[i][j]=1;
}


void FixMapSeen( void )
{
	int i;
	int j;

	for (j=0;j<MAPSIZE;j++)
		for (i=0;i<MAPSIZE;i++)
			if (!mapseen[i][j])
				{
				if (i==0 && ((mapseen[i][j+1] && j<MAPSIZE-1) || (mapseen[i][j-1] && j>0)) && mapseen[i+1][j])
					mapseen[i][j]=1;
				else if (i==MAPSIZE-1 && mapseen[i-1][j] && ((mapseen[i][j+1] && j<MAPSIZE-1) || (mapseen[i][j-1] && j>0)))
					mapseen[i][j]=1;
				else if (j==0 && ((mapseen[i+1][j] && i<MAPSIZE-1) || (mapseen[i-1][j] && i>0)) && mapseen[i][j+1])
					mapseen[i][j]=1;
				else if (j==MAPSIZE-1 && mapseen[i][j-1] && ((mapseen[i+1][j] && i<MAPSIZE-1) || (mapseen[i-1][j] && i>0)))
					mapseen[i][j]=1;
				else if (
					(  ((mapseen[i-1][j]) && (mapseen[i][j+1]) && (!(tilemap[i-1][j+1])))
						||
						((mapseen[i-1][j]) && (mapseen[i][j-1]) && (!(tilemap[i-1][j-1])))
						||
						((mapseen[i+1][j]) && (mapseen[i][j+1]) && (!(tilemap[i+1][j+1])))
						||
						((mapseen[i+1][j]) && (mapseen[i][j-1]) && (!(tilemap[i+1][j-1])))
					) &&
					tilemap[i][j])
						mapseen[i][j]=1;
				}
}


/*
=======================
=
= DrawMap_Wall
=
=======================
*/

void DrawMap_Wall (int x, int y, int tile)
{
//	byte * buf;
	unsigned buf;
	int p;
//	byte * b;
	unsigned b;
	byte * source;
	byte * s;
	int i;

	x*=tilesize;
	y*=tilesize;
//	buf=(byte *)bufferofs+ylookup[y]+(x>>2);
	buf=bufferofs+ylookup[y]+(x>>2);
//	source=W_CacheLumpNum(tile,PU_CACHE);
	source=W_CacheWallLumpNum(tile,PU_CACHE);
	for (p=0;p<4;p++)
		{
		VGAWRITEMAP(p);
		s=source+((p*hp_srcstep)>>10);
		b=buf;
		for (i=p;i<tilesize;i+=4,b++)
			{
			DrawMapPost(tilesize,s,b);
			s+=(hp_srcstep>>8);
			}
		}
}

/*
=======================
=
= DrawMap_AnimatedWall
=
=======================
*/

void DrawMap_AnimatedWall (int x, int y, int tile)
{
	DrawMap_Wall(x,y,animwalls[tile].texture);
}

/*
=======================
=
= DrawMap_SkyTile
=
=======================
*/

void DrawMap_SkyTile (int x, int y)
{
//	byte * buf;
	unsigned buf;
	int p;
//	byte * b;
	unsigned b;
	byte * s;
	int i;

	x*=tilesize;
	y*=tilesize;
//	buf=(byte *)bufferofs+ylookup[y]+(x>>2);
	buf=bufferofs+ylookup[y]+(x>>2);
	for (p=0;p<4;p++)
		{
		VGAWRITEMAP(p);
		s=skytile+((p*hp_srcstep)>>10);
		b=buf;
		for (i=p;i<tilesize;i+=4,b++)
			{
			DrawMapPost(tilesize,s,b);
			s+=(hp_srcstep>>8);
			}
		}
}

/*
=======================
=
= DrawMap_MaskedWall
=
=======================
*/

void DrawMap_MaskedWall (int x, int y, int tile)
{
	if (IsPlatform(maskobjlist[tile]->tilex,maskobjlist[tile]->tiley))
		{
		if (!(maskobjlist[tile]->flags&MW_ABOVEPASSABLE))
			DrawMap_MaskedShape(x,y,maskobjlist[tile]->toptexture,0);
		else if (!(maskobjlist[tile]->flags&MW_BOTTOMPASSABLE))
			DrawMap_MaskedShape(x,y,maskobjlist[tile]->bottomtexture,1);
		else
			DrawMap_MaskedShape(x,y,maskobjlist[tile]->midtexture,0);
		}
	else
		{
		DrawMap_MaskedShape(x,y,maskobjlist[tile]->bottomtexture,1);
		}
}

/*
=======================
=
= DrawMap_Door
=
=======================
*/

void DrawMap_Door (int x, int y, int tile)
{
	if (
		(doorobjlist[tile]->lock > 0) &&
		(doorobjlist[tile]->lock <= 4)
		)
		DrawMap_Wall(x,y,W_GetNumForName("lock1")+doorobjlist[tile]->lock-1);
	else if (doorobjlist[tile]->texture==doorobjlist[tile]->basetexture)
		DrawMap_Wall(x,y,doorobjlist[tile]->texture);
	else
		DrawMap_MaskedShape(x,y,doorobjlist[tile]->texture,0);
}

/*
=======================
=
= DrawMap_PushWall
=
=======================
*/

void DrawMap_PushWall (int x, int y, pwallobj_t * pw)
{
	if (pw->texture&0x1000)
		DrawMap_AnimatedWall(x,y,pw->texture&0x3ff);
	else
		DrawMap_Wall(x,y,pw->texture&0x3ff);
}

/*
=======================
=
= DrawMap_Actor
=
=======================
*/

void DrawMap_Actor (int x, int y, objtype * a)
{
	int translucent;

	if (!(a->flags&FL_SEEN))
		return;

	translucent=0;
	if (a->flags&FL_TRANSLUCENT)
		translucent=1;
	DrawMap_MaskedShape(x,y,a->shapenum+shapestart,translucent);
}

/*
=======================
=
= DrawMap_Sprite
=
=======================
*/

void DrawMap_Sprite (int x, int y, statobj_t * s)
{
	int translucent;

	if (!(s->flags&FL_SEEN))
		return;

	translucent=0;
	if (s->flags&FL_TRANSLUCENT)
		translucent=1;
	DrawMap_MaskedShape(x,y,s->shapenum+shapestart,translucent);
}

/*
=======================
=
= DrawMap_MaskedShape
=
=======================
*/

void DrawMap_MaskedShape (int x, int y, int lump, int type)
{

	// Calculate center coordinates for sprites

	x*=tilesize;
	y*=tilesize;
	x+=tilesize>>1;
	y+=tilesize>>1;
	DrawPositionedScaledSprite(x,y,lump,tilesize,type);
}

/*
=======================
=
= DrawMap_PlayerArrow
=
=======================
*/

void DrawMap_PlayerArrow (int x, int y, int dir)
{
	int i;

	x*=tilesize;
	y*=tilesize;

	for (i=0;i<6;i++)
		{
		VL_DrawLine ((arrows[dir][i].x<<(4-mapscale))+x,
						(arrows[dir][i].y<<(4-mapscale))+y,
						(arrows[dir][i+1].x<<(4-mapscale))+x,
						(arrows[dir][i+1].y<<(4-mapscale))+y,
						244
						);
		}
	VL_DrawLine (  (arrows[dir][6].x<<(4-mapscale))+x,
						(arrows[dir][6].y<<(4-mapscale))+y,
						(arrows[dir][0].x<<(4-mapscale))+x,
						(arrows[dir][0].y<<(4-mapscale))+y,
						244
					);
}

/*
=======================
=
= DrawMap_Player
=
=======================
*/

void DrawMap_Player (int x, int y)
{
	if (player->flags&FL_SHROOMS)
		DrawMap_PlayerArrow(x,y,( RandomNumber("DrawMap_PLAYER",0)>>5) );
	else
		DrawMap_PlayerArrow(x,y,( ( (player->angle+(FINEANGLES/16)) & (FINEANGLES-1) ) >>8) );
	DrawMap_MaskedShape(x,y,player->shapenum+shapestart,0);
}

/*
=======================
=
= DrawMap
=
=======================
*/

void DrawMap( int cx, int cy )
{
	fixed x,y;
	statobj_t * s;
	objtype * a;
	int i,j;
	int mapx,mapy;
	int wall;

	// Clear buffer

	VL_ClearBuffer (bufferofs, egacolor[mapcolor]);

	x=cx>>16;
	y=cy>>16;

	// Draw Walls,Doors,maskedwalls,animatingwalls

	for (j=0;j<yscale;j++)
		{

		// Don't go off the bottom of the map

		mapy=j+y;

		if (mapy<0)
			continue;

		if (mapy>127)
			break;

		for (i=0;i<xscale;i++)
			{

			// Don't go off the right side of the map

			mapx=i+x;

			if (mapx<0)
				continue;

			if (mapx>127)
				break;

			if ((mapx==player->tilex ) && (mapy==player->tiley))
				{
				DrawMap_Player(i,j);
				continue;
				}

			wall=tilemap[mapx][mapy];

			// Check for absence of wall

			if (wall)
				{

				if (!mapseen[mapx][mapy])
					continue;

				// Check to see if it is a door or masked wall

				if (wall&0x8000)
					{
					if (wall&0x4000)
						{
						// Must be a masked wall
						DrawMap_MaskedWall(i,j,wall&0x3ff);
						}
					else
						{
						// Must be a door
						DrawMap_Door(i,j,wall&0x3ff);
						}
					}

				// Check to see if it is an animating wall

				else if (wall&0x1000)
					{
					DrawMap_AnimatedWall(i,j,wall&0x3ff);
					}
				else if (IsWindow(mapx,mapy))
					{
					if (sky!=0)
						DrawMap_SkyTile(i,j);
					else
						Error("Trying to draw a sky on a level without sky\n");
					}
				else
					{
					// Must be a normal wall or a wall with something above
					DrawMap_Wall(i,j,wall&0x3ff);
					}
				}
			else
				{
				a=actorat[mapx][mapy];

				// Check for absence of actor

				if (a)
					{
					switch(a->which)
						{
						case PWALL:
							if (!mapseen[mapx][mapy])
								continue;
							DrawMap_PushWall(i,j,(pwallobj_t *)a);
							break;
						case ACTOR:
							DrawMap_Actor(i,j,a);
							break;
						case SPRITE:
							DrawMap_Actor(i,j,a);
							break;
						default:
							SoftError("Unable to resolve actorat at x=%ld y=%ld which=%ld\n",mapx,mapy,a->which);
							break;
						}
					}
				else
					{
					s=sprites[mapx][mapy];

					// Check for absence of sprite

					if (s)
						{
						DrawMap_Sprite(i,j,s);
						}
					}
				}
			}
		}
}




/*
=======================
=
= SetupFullMap
=
=======================
*/

void SetupFullMap( void )
{
	int ty;
	pic_t *pic;

	// Fill in backgrounds

	pic = (pic_t *) W_CacheLumpNum (W_GetNumForName ("mmbk"), PU_CACHE);
	VWB_DrawPic (0, 0, pic);
	CheckHolidays();

	// Clear area for map

	VGAMAPMASK(15);
	for (ty=37;ty<37+127;ty++)
//		memset((byte *)bufferofs+ylookup[ty]+24,0,32);
		VGAMEMSET(bufferofs+ylookup[ty]+24,0,32);
}

/*
=======================
=
= DrawFullMap
=
=======================
*/

void DrawFullMap( void )
{
	statobj_t * s;
	objtype * a;
	int mapx,mapy;
	int wall;
//	byte * buf;
	unsigned buf;

	SetupFullMap();

	// Draw Walls,Doors,maskedwalls,animatingwalls

	for (mapx=0;mapx<mapwidth;mapx++)
		{
		VGAWRITEMAP(mapx&3);
//		buf=(byte *)bufferofs+ylookup[37]+((96+mapx)>>2);
		buf=bufferofs+ylookup[37]+((96+mapx)>>2);
		for (mapy=0;mapy<mapheight;mapy++,buf+=SCREENBWIDE)
			{
			if ((mapx==player->tilex ) && (mapy==player->tiley))
				{
//				*buf=egacolor[MAP_PLAYERCOLOR];
				VGAWRITE(buf, egacolor[MAP_PLAYERCOLOR]);
				continue;
				}

			wall=tilemap[mapx][mapy];

			// Check for absence of wall

			if (wall)
				{

				if (!mapseen[mapx][mapy])
					continue;

				// Check to see if it is a door or masked wall

				if (wall&0x8000)
					{
					if (wall&0x4000)
						{
						// Must be a maskedwall
//						*(buf)=egacolor[MAP_MWALLCOLOR];
						VGAWRITE(buf, egacolor[MAP_MWALLCOLOR]);
						}
					else
						{
						// Must be a door
//						*(buf)=egacolor[MAP_DOORCOLOR];
						VGAWRITE(buf, egacolor[MAP_DOORCOLOR]);
						}
					}

				// Check to see if it is an animating wall

				else if (wall&0x1000)
					{
//					*(buf)=egacolor[MAP_AWALLCOLOR];
					VGAWRITE(buf, egacolor[MAP_AWALLCOLOR]);
					}
				else if (IsWindow(mapx,mapy))
					{
					if (sky!=0)
//						*(buf)=egacolor[MAP_SKYCOLOR];
						VGAWRITE(buf, egacolor[MAP_SKYCOLOR]);
					else
						Error("Trying to draw a sky on a level without sky\n");
					}
				else
					{
					// Must be a normal wall or a wall with something above
//					*(buf)=egacolor[MAP_WALLCOLOR];
					VGAWRITE(buf, egacolor[MAP_WALLCOLOR]);
					}
				}
			else
				{
				a=actorat[mapx][mapy];

				// Check for absence of actor

				if (a)
					{
					switch(a->which)
						{
						case PWALL:
							if (!mapseen[mapx][mapy])
								continue;
//							*(buf)=egacolor[MAP_PWALLCOLOR];
							VGAWRITE(buf, egacolor[MAP_PWALLCOLOR]);
							break;
						case ACTOR:
							if (a->flags&FL_SEEN)
								{
								if (a->obclass==inertobj)
//									*(buf)=egacolor[MAP_SPRITECOLOR];
									VGAWRITE(buf, egacolor[MAP_SPRITECOLOR]);
								else
//									*(buf)=egacolor[MAP_ACTORCOLOR];
									VGAWRITE(buf, egacolor[MAP_ACTORCOLOR]);
								}
							break;
						case SPRITE:
							if (a->flags&FL_SEEN)
//								*(buf)=egacolor[MAP_SPRITECOLOR];
								VGAWRITE(buf, egacolor[MAP_SPRITECOLOR]);
							break;
						default:
							SoftError("Unable to resolve actorat at x=%ld y=%ld which=%ld\n",mapx,mapy,a->which);
							break;
						}
					}
				else
					{
					s=sprites[mapx][mapy];

					// Check for absence of sprite

					if (s && (s->flags&FL_SEEN))
						{
//						*(buf)=egacolor[MAP_SPRITECOLOR];
						VGAWRITE(buf, egacolor[MAP_SPRITECOLOR]);
						}
					}
				}
			}
		}
	FlipPage();
}

/*
=======================
=
= DrawMapInfo
=
=======================
*/

void DrawMapInfo ( void )
{
	char temp[80];
	int width,height;

	CurrentFont=tinyfont;

	PrintX = 2;
	PrintY = 2;
	strcpy (&temp[0], &(LevelName[0]));
	US_MeasureStr (&width, &height, &temp[0]);

	VWB_TBar (0, 0, 320, height+4);

	US_BufPrint (&temp[0]);

	strcpy (&temp[0], "TAB=EXIT");
	US_MeasureStr (&width, &height, &temp[0]);

	PrintX = 316-width;
	PrintY = 2;

	US_BufPrint (&temp[0]);

	strcpy (&temp[0], "< > CHANGE BACKGROUND COLOR");
	US_MeasureStr (&width, &height, &temp[0]);

	PrintX = (320-width)>>1;
	PrintY = 2;

	US_BufPrint (&temp[0]);
}

/*
=======================
=
= SetupMapScale
=
=======================
*/

void SetupMapScale( int s )
{
	mapscale=s;
	tilesize=64>>mapscale;
	xscale=320/tilesize;
	yscale=200/tilesize;
	hp_srcstep=0x10000<<mapscale;
}


/*
=======================
=
= ChangeMapScale
=
=======================
*/

void ChangeMapScale( int * newx, int * newy, int newmapscale )
{
	if (newmapscale<0)
		return;
	if (newmapscale>FULLMAP_SCALE)
		return;

	if (newmapscale==FULLMAP_SCALE)
		DrawFullMap();

	*newx=*newx+(xscale<<15);
	*newy=*newy+(yscale<<15);

	SetupMapScale(newmapscale);

	*newx=*newx-(xscale<<15);
	*newy=*newy-(yscale<<15);
}


/*
=======================
=
= SetupMapper
=
=======================
*/
void SetupMapper ( void )
{
	FixMapSeen();

	tics=0;
	oldw=viewwidth;
	oldh=viewheight;
	viewwidth=320;
	viewheight=200;

	if (sky!=0)
		{
		skytile=SafeMalloc(64*64);
		MakeSkyTile(skytile);
		}
}

/*
=======================
=
= ShutdownMapper
=
=======================
*/
void ShutdownMapper ( void )
{
	VL_ClearVideo (0);
	viewwidth=oldw;
	viewheight=oldh;
	SetupScreen (true);

	if (sky!=0)
		SafeFree(skytile);
	if (mouseenabled && MousePresent)
		PollMouseMove();
}

/*
=======================
=
= DoMap
=
=======================
*/

void DoMap (int cx, int cy)
{
	static int tt_exitmap;
	int x,y;
	int dx;
	int dy;
	boolean done;
	int quitkey, tabdone;
	ControlInfo control;

	if(ticcount < tt_exitmap)
		return;


	ShutdownClientControls();

	done=false;

	I_PollTimer();
	tabdone = ticcount + 8;
	while (Keyboard[sc_Tab])
	{
		I_PollTimer();
		I_HandleInput();
		IN_UpdateKeyboard ();
		if(ticcount>tabdone)
		{
			Keyboard[sc_Escape]=0;
			Keyboard[sc_Tab]=0;
			break;
		}
	}

//	if (SpaceBallPresent && spaceballenabled)
//		{
//		while (GetSpaceBallButtons()) ;
//		}

	x=(cx-(xscale>>1))<<16;
	y=(cy-(yscale>>1))<<16;

	SetupMapper();

	transparentlevel=25;

	ChangeMapScale(&x, &y, mapscale);

	while (done==false)
	{
	I_PollTimer();
	I_HandleInput();
	IN_UpdateKeyboard ();
	if ((Keyboard[sc_Tab]) || (Keyboard[sc_Escape]))
		{
		if (Keyboard[sc_Tab])
			quitkey=sc_Tab;
		else
			quitkey=sc_Escape;
		done=true;
		}
//	if (SpaceBallPresent && spaceballenabled)
//		{
//		if (GetSpaceBallButtons()!=0)
//			done=true;
//		}
	if ( Keyboard[ sc_Home ] )
		{
		x=(cx-(xscale>>1))<<16;
		y=(cy-(yscale>>1))<<16;
		}
	dx=0;
	dy=0;
	if (mapscale==FULLMAP_SCALE)
		CalcTics();
	else
		{
		DrawMap(x,y);
		DrawMapInfo ();
		FlipPage();
		CalcTics();
		DoSprites();
		AnimateWalls();
		}
	ReadAnyControl (&control);
	if ((Keyboard[sc_PgUp]) ||
			(Keyboard[sc_Plus])  ||
			(control.button1))
		{
		ChangeMapScale(&x, &y, mapscale+1);
		while(Keyboard[sc_PgUp])
			IN_UpdateKeyboard ();
		while(Keyboard[sc_Plus])
			IN_UpdateKeyboard ();
		while(control.button1)
			ReadAnyControl (&control);
		}
	if ((Keyboard[sc_PgDn]) ||
			(Keyboard[sc_Minus])  ||
			(control.button0))
		{
		ChangeMapScale(&x, &y, mapscale-1);
		while(Keyboard[sc_PgDn])
			IN_UpdateKeyboard ();
		while(Keyboard[sc_Minus])
			IN_UpdateKeyboard ();
		while(control.button0)
			ReadAnyControl (&control);
		}
	if (Keyboard[sc_CapsLock] && Keyboard[sc_C])
		{
		inhmenu=true;
		SaveScreen (true);
		inhmenu=false;
		}
	if (Keyboard[sc_CapsLock] && Keyboard[sc_X])
		{
		inhmenu=true;
		SaveScreen (false);
		inhmenu=false;
		}
	if (Keyboard[sc_Comma])
		{
		if (mapcolor>0)
			mapcolor--;
		while(Keyboard[sc_Comma])
			IN_UpdateKeyboard ();
		}
	if (Keyboard[sc_Period])
		{
		if (mapcolor<15)
			mapcolor++;
		while(Keyboard[sc_Period])
			IN_UpdateKeyboard ();
		}
	if (mapscale!=FULLMAP_SCALE)
		{
		if (control.dir==dir_East)
			dx=(tics<<17)/(5-mapscale);
		if (control.dir==dir_West)
			dx=-(tics<<17)/(5-mapscale);
		if (control.dir==dir_South)
			dy=(tics<<17)/(5-mapscale);
		if (control.dir==dir_North)
			dy=-(tics<<17)/(5-mapscale);
		}
#if (DEVELOPMENT == 1)
	if (Keyboard[sc_M])
		{
		CheatMap();
		ChangeMapScale( &x, &y, mapscale );
		}
#endif

	x+=dx;
	y+=dy;

	if (x>0x7effff)
		x=0x7effff;
	else if (x<-(xscale<<15))
		x=-(xscale<<15);
	if (y>0x7effff)
		y=0x7effff;
	else if (y<-(yscale<<15))
		y=-(yscale<<15);
	}

	I_PollTimer();
	tabdone = ticcount + 8;
	while (Keyboard[quitkey])
	{
		I_PollTimer();
		I_HandleInput();
		IN_UpdateKeyboard ();
		if(ticcount>tabdone)
		{
			Keyboard[sc_Escape]=0;
			Keyboard[sc_Tab]=0;
			break;
		}
	}

	LastScan=0;
	Keyboard[sc_Escape]=0;
	Keyboard[sc_Tab]=0;
	
	tt_exitmap = ticcount + 16;

	ShutdownMapper();

	StartupClientControls();
}

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
//******************************************************************************
//
// RT_MENU.C
//	 Contains the menu stuff!
//
//******************************************************************************


#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
// #include <fcntl.h>
// #include <conio.h>
#include <string.h>
#include <ctype.h>
// #include <dos.h>
// #include <io.h>
// #include <sys\types.h>
// #include <sys\stat.h>

#include "rt_def.h"
#include "_rt_menu.h"
#include "rt_menu.h"
#include "rt_sound.h"
#include "fx_man.h"
#include "rt_build.h"
#include "rt_in.h"
#include "isr.h"
#include "z_zone.h"
#include "w_wad.h"
#include "rt_util.h"
#include "rt_main.h"
#include "rt_playr.h"
#include "rt_rand.h"
#include "rt_game.h"
#include "rt_floor.h"
#include "rt_draw.h"
#include "rt_view.h"
#include "rt_str.h"
#include "rt_vid.h"
#include "rt_ted.h"
#include "rt_com.h"
#include "lumpy.h"
#include "rt_cfg.h"
#include "version.h"
#include "modexlib.h"
#include "rt_msg.h"
#include "rt_net.h"
// #include "rt_spbal.h"
#include "rt_scale.h"

#include "rt_battl.h"
#include "develop.h"
//MED
// #include "memcheck.h"


//******************************************************************************
//
// GLOBALS
//
//******************************************************************************

#define DELAYAMT  2

#define SNDCARDS  12

#define CP_NO	  0
#define CP_ESC	 -1
#define CP_YES	 1

int CP_Acknowledge;

boolean POK = false;
char	 pword[ 13 ];

boolean ingame	 = false;
boolean inmenu	 = false;
boolean pickquick = false;
boolean NewGame	= false;

//
// Global window coords
//
int PrintX;
int PrintY;
int WindowX;
int WindowY;
int WindowH = 160;
int WindowW;

int px;
int py;
int bufferheight;
int bufferwidth;

cfont_t *IFont;
font_t  *CurrentFont;
font_t  *newfont1;
font_t  *smallfont;
font_t  *bigfont;
font_t  *tinyfont;

boolean loadedgame = false;

battle_type BATTLE_Options[ battle_NumBattleModes ];

int quicksaveslot=-1;

//******************************************************************************
//
// LOCALS
//
//******************************************************************************

char order[ 21 ] = {
	di_west, di_east, di_north, di_south, bt_run, bt_use, bt_attack,
	bt_strafe, bt_strafeleft, bt_straferight, bt_lookup, bt_lookdown,
	bt_aimbutton, bt_horizonup, bt_horizondown, bt_swapweapon, bt_dropweapon,
	bt_turnaround, bt_autorun, bt_message, bt_directmsg
	};

// bt_pistol, bt_dualpistol, bt_mp40, bt_missileweapon, bt_recordsound,

#define RETURNVAL	 100

static boolean loadsavesound = false;
static int numdone;

static char *endStrings[ 7 ] =
	{
	"Press Y to signal \nfiring squad.\0\0",
	"Press Y to activate \nguillotine.\0\0",
	"Press Y to release \nthe cyanide gas.\0\0",
	"Press Y to open \ntrap door.\0\0",
	"Press Y to drive your \ncar off the cliff.\0\0",
	"Press Y to pull \nyour plug.\0\0",
	"Press Y to activate \nelectric chair.\0\0"
	};

static char *BattleModeDescriptions[ battle_NumBattleModes - 1 ] =
	{
	"Kill your enemies!  Don't get killed!  Kill some more!",
	"Score more points for more difficult kills.",
	"Collect the most triads to win the game.  Whoopee!",
	"Collect triads to win the game--this time with weapons!",
	"Armed hunters vs. unarmed prey--then the tables are turned!",
	"Tag your enemies.  Run away.  Lowest points wins.",
	"Chase roving 'Eluders'--tag them for points.",
	"Use weapons to destroy roving Eluder triads for points.",
	"Capture the opposing team's triad while guarding your own."
	};

static char *BattleOptionDescriptions[ 9 ] =
	{
	"Adjust the Gravitational Constant of the game universe!",
	"Adjust the top speed for all players in the game",
	"Adjust the amount of ammo in all missile weapons",
	"Adjust the hit points of all players in the game",
	"Radically change the way the game plays",
	"Adjust the light characteristics of the game",
	"Adjust the point goal of the game",
	"Adjust the damage done by environment dangers",
	"Adjust the time limit for the game"
	};

static char *GravityOptionDescriptions[ 3 ] =
	{
	"Similar to gravity on the moon",
	"Normal Gravity (9.81 m/s^2 !)",
	"Similar to gravity on Jupiter"
	};

static char *SpeedOptionDescriptions[ 2 ] =
	{
	"Player speeds are determined by character",
	"All players can move at the fastest possible speed"
	};

static char *AmmoOptionDescriptions[ 3 ] =
	{
	"One piece of ammo per missile weapon",
	"Normal ammo for all missile weapons",
	"Infinite ammo for all missile weapons"
	};

static char *HitPointsOptionDescriptions[ 7 ] =
	{
	"One hit point for each player",
	"25 hit points for each player",
	"Hit points determined by character",
	"100 hit points for each player",
	"250 hit points for each player (default)",
	"500 hit points for each player",
	"4000 hit points for each player",
	};

static char *RadicalOptionDescriptions[ 8 ] =
	{
	"Control spawning of environment dangers",
	"Control spawning of health items",
	"Control spawning of missile weapons",
	"Spawn mines instead of health items",
	"Objects reappear a short time after being picked up",
	"Missile weapons remain when picked up",
	"Weapons are chosen randomly at the start of the game",
	"Killing yourself or a team member counts as a suicide"
	};

static char *LightLevelOptionDescriptions[ 6 ] =
	{
	"Very dark, cave-like",
	"Lighting determined by level design",
	"Full brightness",
	"Bright with fog",
	"Periodic lighting (voobing)",
	"Dark with lightning"
	};

static char *PointGoalOptionDescriptions[ 9 ] =
	{
	"One Point/Kill",
	"5 Points/Kills",
	"11 Points/Kills",
	"21 Points/Kills",
	"50 Points/Kills",
	"100 Points/Kills",
	"Random Points/Kills",
	"Random Points/Kills but goal is not revealed",
	"Infinite Points/Kills"
	};

static char *DangerDamageOptionDescriptions[ 3 ] =
	{
	"Environmental dangers' damage is relatively low",
	"Environmental dangers' damage normal",
	"One touch and you are dead!"
	};

static char *TimeLimitOptionDescriptions[ 8 ] =
	{
	"One Minute",
	"2 Minutes",
	"5 Minutes",
	"10 Minutes",
	"21 Minutes",
	"30 Minutes",
	"99 Minutes",
	"No Time Limit"
	};


static char *BattleModeNames[ battle_NumBattleModes - 1 ] =
	{
	"NORMAL COMM-BAT", "SCORE MORE", "COLLECTOR", "SCAVENGER",
	"HUNTER", "TAG", "ELUDER", "DELUDER", "CAPTURE THE TRIAD"
	};

static int OptionNums[ 12 ] =
	{
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
	};

static int HitPointNums[ 7 ] =
	{
	1, 25, bo_character_hitpoints, 100, 250, 500, 4000
	};

static int KillNums[ 9 ] =
	{
	1, 5, 11, 21, 50, 100, bo_kills_random,
	bo_kills_blind, bo_kills_infinite
	};

static int GravityNums[ 3 ] =
	{
	LOW_GRAVITY, NORMAL_GRAVITY, HIGH_GRAVITY
	};

static int TimeLimitNums[ 8 ] =
	{
	1, 2, 5, 10, 21, 30, 99, bo_time_infinite
	};

static int DangerNums[ 3 ] =
	{
	bo_danger_low, bo_danger_normal, bo_danger_kill
	};

static int MenuNum = 0;
static int handlewhich;
static int CSTactive = 0;
static boolean INFXSETUP = false;
static int MaxVoices;
static int MaxBits;
static int MaxChannels;

//
// MENU CURSOR SHAPES
//

#define MAXCURSORNUM 24

static int cursorwidth;
static int cursorheight;
static int yinc;

static char *FontNames[] = { "itnyfont", "ifnt", "sifont", "lifont" };
static int	FontSize[]  = { 6, 7, 9, 14 };
static char *SmallCursor = "smallc01";
static char *LargeCursor = "cursor01";
static char *CursorLump  = "cursor01";
static int CursorNum = 0;
static int CursorFrame[ MAXCURSORNUM ] =
	{
	0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3,
	4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1
	};

typedef enum
	{
	MOUSEENABLE,
	JOYENABLE,
	USEPORT2,
	PADENABLE,
	SPACEBALLENABLE,
	CYBERMANENABLE,
	THRESSENS,
	MOUSESENS,
	CUSTOMIZE
	} controltypes;


static char *playerwadname[] =
	{
	"cass1", "bars1", "wens1", "lnis1", "ipfs1"
	};

char *colorname[] =
	{
	"Gray", "Brown", "Black", "Tan", "Red", "Olive",
	"Blue", "White", "Green", "Purple", "Orange"
	};

//
// MENU ITEMS
//
#if ( TEXTMENUS == 1 )
CP_MenuNames MainMenuNames[] =
	{
	"NEW GAME",
	"COMM-BAT GAME",
	"RESTORE GAME",
	"SAVE GAME",
	"OPTIONS",
	"ORDERING INFO",
	"VIEW SCORES", //"END GAME"
	"BACK TO DEMO", //"BACK TO GAME"
	"QUIT"
	};
#else
	#define MainMenuNames NULL
#endif

CP_iteminfo MainItems  = { MENU_X, MENU_Y + 1, 9, STARTITEM, 32, MainMenuNames, mn_largefont };
CP_itemtype MainMenu[] =
	{
		{ CP_CursorLocation, "mm_opt1\0",  'N', (menuptr)CP_NewGame },
		{ CP_Active,			"battle\0",	'C', (menuptr)CP_BattleModes },
		{ CP_Active,			"mm_opt2\0",  'R', (menuptr)CP_LoadGame },
		{ CP_Inactive,		 "mm_opt3\0",  'S', (menuptr)CP_SaveGame },
		{ CP_Active,			"mm_opt5\0",  'O', (menuptr)CP_ControlMenu },
		{ CP_Active,			"ordrinfo\0", 'O', (menuptr)CP_OrderInfo },
		{ CP_Active,			"mm_opt7\0",  'V', (menuptr)CP_ViewScores },
		{ CP_Active,			"mm_opt8\0",  'B', (menuptr)NULL },
		{ CP_Active,			"mm_opt9\0",  'Q', (menuptr)CP_Quit }
	};


CP_iteminfo LSItems  = { LSM_X, LSM_Y, NUMSAVEGAMES, 0, 10, NULL, mn_largefont };
CP_itemtype LSMenu[] =
	{
		{ CP_Active, "", 'a', NULL },
		{ CP_Active, "", 'b', NULL },
		{ CP_Active, "", 'c', NULL },
		{ CP_Active, "", 'd', NULL },
		{ CP_Active, "", 'e', NULL },
		{ CP_Active, "", 'f', NULL },
		{ CP_Active, "", 'g', NULL },
		{ CP_Active, "", 'h', NULL },
		{ CP_Active, "", 'i', NULL },
		{ CP_Active, "", 'j', NULL },
		{ CP_Active, "", 'k', NULL },
		{ CP_Active, "", 'l', NULL },
		{ CP_Active, "", 'm', NULL },
		{ CP_Active, "", 'n', NULL },
		{ CP_Active, "", 'o', NULL }
	};


#if ( TEXTMENUS == 1 )
CP_MenuNames CtlMenuNames[] =
	{
	"MOUSE ENABLED",
	"JOYSTICK ENABLED",
	"USE JOYSTICK PORT 2",
	"GAMEPAD ENABLED",
	"SPACEBALL ENABLED",
	"CYBERMAN ENABLED",
	"ADJUST THRESHOLD",
	"MOUSE SENSITIVITY",
	"CUSTOMIZE CONTROLS"
	};
#else
	#define CtlMenuNames NULL
#endif

CP_iteminfo CtlItems  = { CTL_X, MENU_Y, 9, -1, 36, CtlMenuNames, mn_largefont };
CP_itemtype CtlMenu[] =
	{
		{ CP_Inactive, "ctl_mic\0", 'M', NULL },
		{ CP_Inactive, "ctl_jen\0", 'J', NULL },
		{ CP_Inactive, "ctl_jp2\0", 'U', NULL },
		{ CP_Inactive, "ctl_gpd\0", 'G', NULL },
		{ CP_Inactive, "spball\0",  'S', NULL },
		{ CP_Inactive, "cyberman\0",'C', NULL },
		{ CP_Inactive, "ctl_thr\0", 'A', (menuptr)DoThreshold },
		{ CP_Inactive, "ctl_mse\0", 'M', (menuptr)MouseSensitivity },
		{ CP_Active,	"ctl_cus\0", 'C', (menuptr)CP_Custom }
	};

CP_iteminfo CusItems  = { 32, CST_Y + 13 * 2, 9, -1, 0, NULL, mn_largefont };
CP_itemtype CusMenu[] =
	{
		{ CP_Active,	"ctl_mic\0", 'a', NULL },
		{ CP_Inactive, "ctl_mic\0", 'a', NULL },
		{ CP_Inactive, "ctl_mic\0", 'a', NULL },
		{ CP_Active,	"ctl_mic\0", 'a', NULL },
		{ CP_Inactive, "ctl_mic\0", 'a', NULL },
		{ CP_Inactive, "ctl_mic\0", 'a', NULL },
		{ CP_Active,	"ctl_mic\0", 'a', NULL },
		{ CP_Inactive, "ctl_mic\0", 'a', NULL },
		{ CP_Active,	"ctl_mic\0", 'a', NULL }
	};


CP_iteminfo TufItems = { TUF_X, TUF_Y, 7, 0, 80, NULL, mn_largefont };
CP_itemtype TufMenu[ 4 ][ 7 ] =
	{
		{
			{ 2, "new11\0", 'a', NULL },
			{ 3, "new11\0", 'a', NULL },
			{ 1, "new12\0", 'a', NULL },
			{ 3, "new12\0", 'a', NULL },
			{ 1, "new13\0", 'a', NULL },
			{ 3, "new13\0", 'a', NULL },
			{ 1, "new14\0", 'a', NULL },
		},

		{
			{ 2, "new21\0", 'a', NULL },
			{ 3, "new21\0", 'a', NULL },
			{ 1, "new22\0", 'a', NULL },
			{ 3, "new22\0", 'a', NULL },
			{ 1, "new23\0", 'a', NULL },
			{ 3, "new23\0", 'a', NULL },
			{ 1, "new24\0", 'a', NULL },
		},

		{
			{ 2, "new31\0", 'a', NULL },
			{ 3, "new31\0", 'a', NULL },
			{ 1, "new32\0", 'a', NULL },
			{ 3, "new32\0", 'a', NULL },
			{ 1, "new33\0", 'a', NULL },
			{ 3, "new33\0", 'a', NULL },
			{ 1, "new34\0", 'a', NULL },
		},

		{
			{ 2, "stk_1\0", 'a', NULL },
			{ 3, "stk_1\0", 'a', NULL },
			{ 1, "stk_2\0", 'a', NULL },
			{ 3, "stk_2\0", 'a', NULL },
			{ 1, "stk_3\0", 'a', NULL },
			{ 3, "stk_3\0", 'a', NULL },
			{ 1, "stk_4\0", 'a', NULL },
		}
	};


#if ( TEXTMENUS == 1 )
CP_MenuNames CustomMenuNames[] =
	{
	"CUSTOMIZE KEYBOARD",
	"CUSTOMIZE MOUSE",
	"CUSTOMIZE JOYSTICK"
	};
#else
	#define CustomMenuNames NULL
#endif

CP_iteminfo CustomItems = {32, 64, 3, 0, 24, CustomMenuNames, mn_largefont };

CP_itemtype CustomMenu[] =
{
  {2, "custom1\0", 'C', (menuptr)CP_Keyboard},
  {1, "custom2\0", 'C', (menuptr)CP_Mouse},
  {1, "custom3\0", 'C', (menuptr)CP_Joystick}
};

#define KEYNAMEINDEX 21

CP_MenuNames NormalKeyNames[] =
	{
	"LEFT					\x9		",
	"RIGHT				  \x9		",
	"FORWARD				\x9		",
	"BACKWARD			  \x9		",
	"RUN					 \x9		",
	"OPEN					\x9		",
	"FIRE					\x9		",
	"STRAFE				 \x9		",
	"STRAFE LEFT		  \x9		",
	"STRAFE RIGHT		 \x9		",
	"LOOK/FLY UP		  \x9		",
	"LOOK/FLY DOWN		\x9		",
	"AIM					 \x9		",
	"AIM UP				 \x9		",
	"AIM DOWN			  \x9		",
	"TOGGLE WEAPON		\x9		",
	"DROP WEAPON		  \x9		",
	"VOLTE-FACE			\x9		",
	"AUTORUN				\x9		",
	"SEND MESSAGE		 \x9		",
	"DIRECT MESSAGE	  \x9		"
	};

#define NORMALKEY_X  74
#define NORMALKEY_Y  16
CP_iteminfo NormalKeyItems = { NORMALKEY_X, 17, 21, 0, 16, NormalKeyNames, mn_tinyfont };

CP_itemtype NormalKeyMenu[] =
	{
		{ 2, "\0", 'L', (menuptr)DefineKey },
		{ 1, "\0", 'R', (menuptr)DefineKey },
		{ 1, "\0", 'F', (menuptr)DefineKey },
		{ 1, "\0", 'B', (menuptr)DefineKey },
		{ 1, "\0", 'R', (menuptr)DefineKey },
		{ 1, "\0", 'O', (menuptr)DefineKey },
		{ 1, "\0", 'F', (menuptr)DefineKey },
		{ 1, "\0", 'S', (menuptr)DefineKey },
		{ 1, "\0", 'S', (menuptr)DefineKey },
		{ 1, "\0", 'S', (menuptr)DefineKey },
		{ 1, "\0", 'L', (menuptr)DefineKey },
		{ 1, "\0", 'L', (menuptr)DefineKey },
		{ 1, "\0", 'A', (menuptr)DefineKey },
		{ 1, "\0", 'A', (menuptr)DefineKey },
		{ 1, "\0", 'T', (menuptr)DefineKey },
		{ 1, "\0", 'D', (menuptr)DefineKey },
		{ 1, "\0", 'V', (menuptr)DefineKey },
		{ 1, "\0", 'A', (menuptr)DefineKey },
		{ 1, "\0", 'A', (menuptr)DefineKey },
		{ 1, "\0", 'S', (menuptr)DefineKey },
		{ 1, "\0", 'D', (menuptr)DefineKey }
	};

#define NUMCONTROLNAMES 21

CP_MenuNames ControlNames[] =
	{
	"NONE",
	"LEFT",
	"RIGHT",
	"FORWARD",
	"BACKWARD",
	"RUN",
	"OPEN",
	"FIRE",
	"STRAFE",
	"STRAFE LEFT",
	"STRAFE RIGHT",
	"LOOK/FLY UP",
	"LOOK/FLY DOWN",
	"AIM",
	"AIM UP",
	"AIM DOWN",
	"TOGGLE WEAPON",
	"DROP WEAPON",
	"VOLTE-FACE",
	"AUTORUN",
	"MAP"
	};

int controlorder[ NUMCONTROLNAMES ] = {
	bt_nobutton, di_west, di_east, di_north, di_south, bt_run, bt_use,
	bt_attack, bt_strafe, bt_strafeleft, bt_straferight, bt_lookup,
	bt_lookdown, bt_aimbutton, bt_horizonup, bt_horizondown,
	bt_swapweapon, bt_dropweapon, bt_turnaround, bt_autorun, bt_map
	};

#define CONTROLSELECT_X  106
CP_iteminfo ControlSelectItems = { CONTROLSELECT_X, 17, NUMCONTROLNAMES, 0, 16, ControlNames, mn_tinyfont };

CP_itemtype ControlSelectMenu[] =
	{
		{ 2, "\0", 'N', NULL },
		{ 1, "\0", 'L', NULL },
		{ 1, "\0", 'R', NULL },
		{ 1, "\0", 'F', NULL },
		{ 1, "\0", 'B', NULL },
		{ 1, "\0", 'R', NULL },
		{ 1, "\0", 'O', NULL },
		{ 1, "\0", 'F', NULL },
		{ 1, "\0", 'S', NULL },
		{ 1, "\0", 'S', NULL },
		{ 1, "\0", 'S', NULL },
		{ 1, "\0", 'L', NULL },
		{ 1, "\0", 'L', NULL },
		{ 1, "\0", 'A', NULL },
		{ 1, "\0", 'A', NULL },
		{ 1, "\0", 'A', NULL },
		{ 1, "\0", 'T', NULL },
		{ 1, "\0", 'D', NULL },
		{ 1, "\0", 'V', NULL },
		{ 1, "\0", 'A', NULL },
		{ 1, "\0", 'M', NULL }
	};

#define MOUSEBTNINDEX 17

CP_MenuNames MouseBtnNames[] =
	{
	"				 B0  \x9				 ",
	"				 B1  \x9				 ",
	"				 B2  \x9				 ",
	"DOUBLE-CLICK B0  \x9				 ",
	"DOUBLE-CLICK B1  \x9				 ",
	"DOUBLE-CLICK B2  \x9				 "
	};

CP_iteminfo MouseBtnItems = { 19, 52, 6, 0, 11, MouseBtnNames, mn_8x8font };

CP_itemtype MouseBtnMenu[] =
	{
		{ 2, "\0", 'B', (menuptr)DefineMouseBtn },
		{ 1, "\0", 'B', (menuptr)DefineMouseBtn },
		{ 1, "\0", 'B', (menuptr)DefineMouseBtn },
		{ 1, "\0", 'D', (menuptr)DefineMouseBtn },
		{ 1, "\0", 'D', (menuptr)DefineMouseBtn },
		{ 1, "\0", 'D', (menuptr)DefineMouseBtn }
	};


#define JOYBTNINDEX 17

CP_MenuNames JoyBtnNames[] =
	{
	"				 B0  \x9				 ",
	"				 B1  \x9				 ",
	"				 B2  \x9				 ",
	"				 B3  \x9				 ",
	"DOUBLE-CLICK B0  \x9				 ",
	"DOUBLE-CLICK B1  \x9				 ",
	"DOUBLE-CLICK B2  \x9				 ",
	"DOUBLE-CLICK B3  \x9				 "
	};

CP_iteminfo JoyBtnItems = { 19, 48, 8, 0, 11, JoyBtnNames, mn_8x8font };

CP_itemtype JoyBtnMenu[] =
	{
		{ 2, "\0", 'B', (menuptr)DefineJoyBtn },
		{ 1, "\0", 'B', (menuptr)DefineJoyBtn },
		{ 1, "\0", 'B', (menuptr)DefineJoyBtn },
		{ 1, "\0", 'B', (menuptr)DefineJoyBtn },
		{ 1, "\0", 'D', (menuptr)DefineJoyBtn },
		{ 1, "\0", 'D', (menuptr)DefineJoyBtn },
		{ 1, "\0", 'D', (menuptr)DefineJoyBtn },
		{ 1, "\0", 'D', (menuptr)DefineJoyBtn }
	};


#if ( TEXTMENUS == 1 )
CP_MenuNames PlayerMenuNames[] =
	{
	"TARADINO CASSATT",
	"THI BARRETT",
	"DOUG WENDT",
	"LORELEI NI",
	"IAN PAUL FREELEY"
	};
#else
	#define PlayerMenuNames NULL
#endif

CP_iteminfo PlayerItems = {TUF_X, 48, 5, 0, 80, PlayerMenuNames, mn_largefont };

CP_itemtype PlayerMenu[] =
{
	{2, "name1\0", 'T', NULL},
	{1, "name2\0", 'T', NULL},
	{1, "name3\0", 'D', NULL},
	{1, "name4\0", 'L', NULL},
	{1, "name5\0", 'I', NULL},
};

#if ( TEXTMENUS == 1 )
CP_MenuNames ControlMMenuNames[] =
	{
	"CONTROLS",
	"USER OPTIONS",
	"MUSIC VOLUME",
	"SOUND FX VOLUME"
	};
#else
	#define ControlMMenuNames NULL
#endif

CP_iteminfo ControlMItems = {32, 48, 4, 0, 32, ControlMMenuNames, mn_largefont };

CP_itemtype ControlMMenu[] =
{
	{2, "cntl\0",	  'C', (menuptr)CP_Control},
	{1, "uopt\0",	  'U', (menuptr)CP_OptionsMenu},
	{1, "muvolumn\0", 'M', (menuptr)MusicVolume},
	{1, "fxvolumn\0", 'S', (menuptr)FXVolume}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames OptionsNames[] =
	{
	"AUTO DETAIL ADJUST",
	"LIGHT DIMINISHING",
	"BOBBIN'",
	"FLOOR AND CEILING",
	"DOUBLE-CLICK SPEED",
	"MENU FLIP SPEED",
	"DETAIL LEVELS",
	"VIOLENCE LEVEL",
	"SCREEN SIZE"
	};
#else
	#define OptionsNames NULL
#endif
CP_iteminfo OptionsItems = { 20, MENU_Y, 9, 0, 43, OptionsNames, mn_largefont };

CP_itemtype OptionsMenu[] =
{
	{2, "autoadj\0", 'A', NULL},
	{1, "lightdim\0",'L', NULL},
	{1, "bobbin\0",  'B', NULL},
	{1, "fandc\0",	'F', NULL},
	{1, "double\0",  'D', (menuptr)CP_DoubleClickSpeed},
	{1, "menuspd\0", 'M', (menuptr)MenuFlipSpeed},
	{1, "detail\0",  'D', (menuptr)CP_DetailMenu},
	{1, "vlevel\0",  'V', (menuptr)CP_ViolenceMenu},
	{1, "\0",		  'S', (menuptr)CP_ScreenSize}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames DetailMenuNames[] =
	{
	"LOW DETAIL",
	"MEDIUM DETAIL",
	"HIGH DETAIL"
	};
#else
	#define DetailMenuNames NULL
#endif

CP_iteminfo DetailItems = { 32, 64, 3, 0, 43, DetailMenuNames, mn_largefont };

CP_itemtype DetailMenu[] =
{
	{2, "lowdtl\0", 'L', NULL},
	{1, "meddtl\0", 'M', NULL},
	{1, "hidtl\0",  'H', NULL}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames BattleMenuNames[] =
	{
	"PLAY GAME",
	"PLAY TEAM GAME",
	"COMM-BAT OPTIONS"
	};
#else
	#define BattleMenuNames NULL
#endif

CP_iteminfo BattleItems = { 32, 19, 3, 0, 24, BattleMenuNames, mn_largefont };

CP_itemtype BattleMenu[] =
{
	{2, "bplay\0",	 'P', (menuptr)BattleNoTeams},
	{1, "playteam\0", 'P', (menuptr)BattleTeams},
	{1, "comopt\0",	'C', (menuptr)CP_BattleOptions}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames ViolenceMenuNames[] =
	{
	"NONE",
	"SOME",
	"A LOT",
	"EXCESSIVE"
	};
#else
	#define ViolenceMenuNames NULL
#endif

CP_iteminfo ViolenceItems = { 32, 64, 4, 0, 45, ViolenceMenuNames, mn_largefont };

CP_itemtype ViolenceMenu[] =
{
	{2, "vnone\0",	'N', NULL},
	{1, "vsome\0",	'S', NULL},
	{1, "valot\0",	'A', NULL},
	{1, "vexcess\0", 'E', NULL}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames VMenuNames[] =
	{
	"SET VIOLENCE LEVEL",
	NULL // "ENTER PASSWORD" // "CHANGE PASSWORD"
	};
#else
	#define VMenuNames NULL
#endif

CP_iteminfo VItems = { 32, MP_Y, 2, 0, 24, VMenuNames, mn_largefont };

CP_itemtype VMenu[] =
{
	{2, "msetv\0",  'S',  (menuptr)CP_ViolenceLevel},
	{1, "mepass\0", 'E', (menuptr)CP_PWMenu}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames ModeMenuNames[] =
	{
	"NORMAL",
	"SCORE MORE",
	"COLLECTOR",
	"SCAVENGER",
	"HUNTER",
	"TAG",
	"ELUDER",
	"DELUDER",
	"CAPTURE THE TRIAD"
	};
#else
	#define ModeMenuNames NULL
#endif

CP_iteminfo ModeItems = { MENU_X, MENU_Y + 1, 9, 0, 24, ModeMenuNames, mn_largefont };

CP_itemtype ModeMenu[] =
{
	{CP_CursorLocation, "normal\0",	'N', (menuptr)CP_BattleMenu},
	{CP_Active,			"scorem\0",	'S', (menuptr)CP_BattleMenu},
	{CP_Active,			"collect\0",  'C', (menuptr)CP_BattleMenu},
	{CP_Active,			"scaven\0",	'S', (menuptr)CP_BattleMenu},
	{CP_Active,			"hunter\0",	'H', (menuptr)CP_BattleMenu},
	{CP_Active,			"tag\0",		'T', (menuptr)CP_BattleMenu},
	{CP_Active,			"eluder\0",	'E', (menuptr)CP_BattleMenu},
	{CP_Active,			"deluder\0",  'D', (menuptr)CP_BattleMenu},
	{CP_Active,			"captriad\0", 'C', (menuptr)CP_BattleMenu}
};


#if ( TEXTMENUS == 1 )
CP_MenuNames BOptNames[] =
	{
	"GRAVITY",
	"SPEED",
	"AMMO PER WEAPON",
	"HIT POINTS",
	"RADICAL OPTIONS",
	"LIGHT LEVELS",
	"POINT GOAL",
	"DANGER DAMAGE",
	"TIME LIMIT"
	};
#else
	#define BOptNames NULL
#endif

CP_iteminfo BOptItems = { MENU_X, MENU_Y + 1, 9, 0, 24, BOptNames, mn_largefont };

CP_itemtype BOptMenu[] =
{
	{2, "gravity\0",  'G', (menuptr)CP_GravityOptions},
	{1, "speed\0",	 'S', (menuptr)CP_SpeedOptions},
	{1, "ammoper\0",  'A', (menuptr)CP_AmmoPerWeaponOptions},
	{1, "hitp\0",	  'H', (menuptr)CP_HitPointsOptions},
	{1, "radical\0",  'R', (menuptr)CP_SpawnControlOptions},
	{1, "lightl\0",	'L', (menuptr)CP_LightLevelOptions},
	{1, "pntgoal\0",  'P', (menuptr)CP_PointGoalOptions},
	{1, "danger\0",	'D', (menuptr)CP_DangerOptions},
	{1, "timel\0",	 'T', (menuptr)CP_TimeLimitOptions}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames GravityMenuNames[] =
	{
	"LOW",
	"NORMAL",
	"HIGH"
	};
#else
	#define GravityMenuNames NULL
#endif

CP_iteminfo GravityItems = { 32, 26, 3, 0, 45, GravityMenuNames, mn_largefont };

CP_itemtype GravityMenu[] =
{
	{2, "b_low\0",	 'L', NULL},
	{1, "b_normal\0", 'N', NULL},
	{1, "b_high\0",	'H', NULL}
};


#if ( TEXTMENUS == 1 )
CP_MenuNames SpeedMenuNames[] =
	{
	"NORMAL",
	"FAST"
	};
#else
	#define SpeedMenuNames NULL
#endif

CP_iteminfo SpeedItems = { 32, MP_Y, 2, 0, 45, SpeedMenuNames, mn_largefont };

CP_itemtype SpeedMenu[] =
{
	{2, "b_normal\0", 'N', NULL},
	{1, "b_fast\0",	'F', NULL}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames AmmoPerWeaponMenuNames[] =
	{
	"ONE",
	"NORMAL",
	"GUNFINITY"
	};
#else
	#define AmmoPerWeaponMenuNames NULL
#endif

CP_iteminfo AmmoPerWeaponItems = { 32, 26, 3, 0, 45, AmmoPerWeaponMenuNames, mn_largefont };

CP_itemtype AmmoPerWeaponMenu[] =
{
	{2, "b_one\0",	 'O', NULL},
	{1, "b_normal\0", 'N', NULL},
	{1, "b_gunf\0",	'G', NULL}
};


#if ( TEXTMENUS == 1 )
CP_MenuNames HitPointMenuNames[] =
	{
	"ONE",
	"25",
	"BY CHARACTER",
	"100",
	"250",
	"500",
	"4000"
	};
#else
	#define HitPointMenuNames NULL
#endif

CP_iteminfo HitPointItems = { 32, 32, 7, 0, 45, HitPointMenuNames, mn_largefont };

CP_itemtype HitPointMenu[] =
{
	{2, "b_one\0",  'O', NULL},
	{1, "b_25\0",	'a', NULL},
	{1, "b_char\0", 'C', NULL},
	{1, "b_100\0",  'a', NULL},
	{1, "b_250\0",  'a', NULL},
	{1, "b_500\0",  'a', NULL},
	{1, "b_4000\0", 'a', NULL}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames SpawnMenuNames[] =
	{
	"SPAWN DANGERS",
	"SPAWN HEALTH",
	"SPAWN WEAPONS",
	"SPAWN MINES",
	"RESPAWN ITEMS",
	"WEAPON PERSISTENCE",
	"RANDOM WEAPONS",
	"FRIENDLY FIRE"
	};
#else
	#define SpawnMenuNames NULL
#endif

CP_iteminfo SpawnItems = { 20, 24, 8, 0, 35, SpawnMenuNames, mn_largefont };

CP_itemtype SpawnMenu[] =
{
	{2, "b_danger\0", 'S', NULL},
	{1, "b_health\0", 'S', NULL},
	{1, "b_weap\0",	'S', NULL},
	{1, "b_mines\0",  'S', NULL},
	{1, "b_rpawn\0",  'R', NULL},
	{1, "b_persis\0", 'W', NULL},
	{1, "b_rndwpn\0", 'R', NULL},
	{1, "b_friend\0", 'F', NULL}
};


#if ( TEXTMENUS == 1 )
CP_MenuNames LightLevelMenuNames[] =
	{
	"DARK",
	"NORMAL",
	"BRIGHT",
	"FOG",
	"PERIODIC",
	"LIGHTNING"
	};
#else
	#define LightLevelMenuNames NULL
#endif

CP_iteminfo LightLevelItems = { 32, 40, 6, 0, 45, LightLevelMenuNames, mn_largefont };

CP_itemtype LightLevelMenu[] =
{
	{2, "b_dark\0",	'D', NULL},
	{1, "b_normal\0", 'N', NULL},
	{1, "b_bright\0", 'B', NULL},
	{1, "b_fog\0",	 'F', NULL},
	{1, "b_period\0", 'P', NULL},
	{1, "b_light\0",  'L', NULL}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames PointGoalMenuNames[] =
	{
	"1",
	"5",
	"11",
	"21",
	"50",
	"100",
	"RANDOM",
	"RANDOM BLIND",
	"INFINITE"
	};
#else
	#define PointGoalMenuNames NULL
#endif

CP_iteminfo PointGoalItems = { 32, 16, 9, 0, 45, PointGoalMenuNames, mn_largefont };


CP_itemtype PointGoalMenu[] =
{
	{2, "b_1\0",		'a', NULL},
	{1, "b_5\0",		'a', NULL},
	{1, "b_11\0",	  'a', NULL},
	{1, "b_21\0",	  'a', NULL},
	{1, "b_50\0",	  'a', NULL},
	{1, "b_100\0",	 'a', NULL},
	{1, "b_random\0", 'R', NULL},
	{1, "b_randb\0",  'R', NULL},
	{1, "b_inf\0",	 'I', NULL}
};


#if ( TEXTMENUS == 1 )
CP_MenuNames DangerMenuNames[] =
	{
	"LOW",
	"NORMAL",
	"KILL"
	};
#else
	#define DangerMenuNames NULL
#endif

CP_iteminfo DangerItems = { 32, 56, 3, 0, 45, DangerMenuNames, mn_largefont };

CP_itemtype DangerMenu[] =
{
	{2, "b_low\0",	 'L', NULL},
	{1, "b_normal\0", 'N', NULL},
	{1, "b_kill\0",	'K', NULL}
};

#if ( TEXTMENUS == 1 )
CP_MenuNames TimeLimitMenuNames[] =
	{
	"1",
	"2",
	"5",
	"10",
	"21",
	"30",
	"99",
	"NONE"
	};
#else
	#define TimeLimitMenuNames NULL
#endif

CP_iteminfo TimeLimitItems = { 32, 24, 8, 0, 45, TimeLimitMenuNames, mn_largefont };

CP_itemtype TimeLimitMenu[] =
{
	{2, "b_1\0",	 'a', NULL},
	{1, "b_2\0",	 'a', NULL},
	{1, "b_5\0",	 'a', NULL},
	{1, "b_10\0",	'a', NULL},
	{1, "b_21\0",	'a', NULL},
	{1, "b_30\0",	'a', NULL},
	{1, "b_99\0",	'a', NULL},
	{1, "vnone\0",  'N', NULL}
};

CP_MenuNames MultiPageCustomNames[ MAXCUSTOM + 2 ] =
	{
	"NEXT PAGE",
	"PREVIOUS PAGE"
	};

CP_iteminfo MultiPageCustomItems = { 18, 17, 0, 0, 12, MultiPageCustomNames, mn_smallfont };
CP_itemtype MultiPageCustomMenu[] =
{
	{1, "", 'N', NULL},
	{1, "", 'P', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
	{1, "", 'a', NULL},
};

#define COLORX 113
#define COLORY 43
#define COLORW 60
#define COLORH 96

// Custom menu stuff
static int CUSTOM_y[ 7 ] = { 31, 0, 63, 0, 94, 0, 126 };

//
// Save globals
//
static boolean StartGame = false;

static int  SaveGamesAvail[ NUMSAVEGAMES ];
static char SaveGameNames[ NUMSAVEGAMES ][ 32 ];
static char SaveName[ 13 ] = "ROTTGAM?.ROT\0";

static byte *savedscreen;
static mapfileinfo_t * mapinfo;


//******************************************************************************
//
// MN_DrawButtons
//
//******************************************************************************

void MN_DrawButtons
	(
	CP_iteminfo *item_i,
	CP_itemtype *items,
	int check,
	int *nums
	)

	{
	int i;
	int button_on;
	int button_off;

	button_on  = W_GetNumForName( "snd_on" );
	button_off = W_GetNumForName( "snd_off" );

	for( i = 0; i < item_i->amount; i++ )
		{
		if ( items[ i ].active != CP_Active3 )
			{
			if ( nums[ i ] == check )
				{
				DrawMenuBufItem( item_i->x + 27, item_i->y + i *
					FontSize[ item_i->fontsize ] - 1, button_on);
				}
			else
				{
				DrawMenuBufItem( item_i->x + 27, item_i->y + i *
					FontSize[ item_i->fontsize ] - 1, button_off);
				}
			}
		}
	}


//****************************************************************************
//
// MN_GetCursorLocation()
//
//****************************************************************************

void MN_GetCursorLocation
	(
	CP_iteminfo *item_i,
	CP_itemtype *items
	)

	{
	int i;
	int position;

	position = -1;
	for( i = 0; i < item_i->amount; i++ )
		{
		if ( items[ i ].active == CP_CursorLocation )
			{
			position = i;
			break;
			}

		if ( ( items[ i ].active == CP_Active ) && ( position == -1 ) )
			{
			position = i;
			}
		}

	if ( position != -1 )
		{
		item_i->curpos = position;
		items[ position ].active = CP_CursorLocation;
		}
	}


//****************************************************************************
//
// MN_GetActive ()
//
//****************************************************************************

int MN_GetActive
	(
	CP_iteminfo *item_i,
	CP_itemtype *items,
	int check,
	int *nums
	)

	{
	int i;
	int returnval;

	returnval = 0;
	for( i = 0; i < item_i->amount; i++ )
		{
		items[ i ].active = CP_Active;
		if ( nums[ i ] == check )
			{
			item_i->curpos	 = i;
			items[ i ].active = CP_CursorLocation;
			returnval = i;
			}
		}

	return( returnval );
	}


//****************************************************************************
//
// MN_MakeActive ()
//
//****************************************************************************

void MN_MakeActive
	(
	CP_iteminfo *item_i,
	CP_itemtype *items,
	int which
	)

	{
	int i;

	for( i = 0; i < item_i->amount; i++ )
		if (i == which)
		{
			items[i].active = CP_CursorLocation;
			item_i->curpos	 = i;
		}
		else
			items[i].active = CP_Active;
}


//******************************************************************************
//
// DrawMenu ()
//
// Purpose - Draws a menu
//
//******************************************************************************
void DrawMenu
	(
	CP_iteminfo *item_i,
	CP_itemtype *items
	)

	{
	int i;
	int active;
	int color;
	int posx;
	int posy;

	posx = item_i->x + item_i->indent;
	posy = item_i->y;
	WindowX = posx;
	WindowY = posy;
	WindowW = 320;
	WindowH = 200;

	for ( i = 0; i < item_i->amount; i++ )
		{
		posy	= item_i->y + i * FontSize[ item_i->fontsize ];
		active = items[ i ].active;

		color = -1;
		switch( active )
			{
			case CP_CursorLocation :
				color = ACTIVECOLOR;
				break;

			case CP_Inactive :
				color = NOTAVAILABLECOLOR;
				break;

			case CP_Active :
				color = NORMALCOLOR;
				break;

			case CP_SemiActive :
				color = DIMMEDCOLOR;
				break;

			case CP_Highlight :
				color = HIGHLIGHTCOLOR;
				break;
			}

		if ( color != -1 )
			{
			if ( item_i->names == NULL )
				{
				DrawIMenuBufItem( posx, posy, W_GetNumForName( items[ i ].texture ),
					color );
				}
			else
				{
				IFont = ( cfont_t * )W_CacheLumpName( FontNames[ item_i->fontsize ],
					PU_CACHE );
				if ( item_i->fontsize == mn_tinyfont )
					{
					DrawMenuBufIString( posx + 1, posy, item_i->names[ i ], 0 );
					}
				DrawMenuBufIString( posx, posy - 1, item_i->names[ i ], color );
				}
			}
		}
	}


//******************************************************************************
//
// getASCII () - Gets info from Keyboard.
//
//******************************************************************************

int getASCII ( void )
{
//	__debugbreak();
//	return(0);

#if 1
	int i;
	int LS;
	int RS;
	int returnvalue = 0;
	int scancode = 0;

	IN_UpdateKeyboard ();

	LS = Keyboard[sc_LShift];
	RS = Keyboard[sc_RShift];

	Keyboard[sc_LShift] = Keyboard[sc_RShift] = 0;

	scancode = 0;

	for (i = 0; i < 127; i++)
		if (Keyboard[i])
		{
			scancode = i;
			break;
		}

	if (scancode)
	{
		if (LS || RS)
			returnvalue = ShiftNames[scancode];
		else
			returnvalue = ASCIINames[scancode];
	}

	Keyboard[sc_LShift] = LS;
	Keyboard[sc_RShift] = RS;

	return (returnvalue);
#endif

#if 0
	int i;
	int LS;
	int RS;
	int returnvalue = 0;
	int scancode = 0;

	_disable ();		// must disable for SHIFT purposes

	IN_UpdateKeyboard ();

	LS = Keyboard[sc_LShift];
	RS = Keyboard[sc_RShift];

	Keyboard[sc_LShift] = Keyboard[sc_RShift] = 0;

	scancode = 0;

	for (i = 0; i < 127; i++)
		if (Keyboard[i])
		{
			scancode = i;
			break;
		}

	if (scancode)
	{
		if (LS || RS)
			returnvalue = ShiftNames[scancode];
		else
			returnvalue = ASCIINames[scancode];
	}

	Keyboard[sc_LShift] = LS;
	Keyboard[sc_RShift] = RS;

	_enable ();

	return (returnvalue);
#endif
}


//******************************************************************************
//
// ScanForSavedGames ()
//
//******************************************************************************

void ScanForSavedGames ()
{
	MainMenu[loadgame].active = CP_Inactive;

#if 0
	struct find_t f;
	char filename[128];
	char str[45];
	int which;
	boolean found = false;

	//
	// SEE WHICH SAVE GAME FILES ARE AVAILABLE & READ STRING IN
	//
	memset (&SaveGamesAvail[0], 0, sizeof (SaveGamesAvail));
	GetPathFromEnvironment( filename, ApogeePath, SaveName );

	if (!_dos_findfirst (filename, 0, &f))
		do
		{

			strcpy(str,&f.name[7]);
			sscanf((const char *)&str[0],"%x",&which);

			if (which < NUMSAVEGAMES)
			{
				found = true;
				SaveGamesAvail[which] = 1;
				GetSavedMessage (which, &SaveGameNames[which][0]);
			}

		} while (!_dos_findnext (&f));

		if (found)
		{
			if (MainMenu[loadgame].active == CP_Inactive)
				MainMenu[loadgame].active = CP_Active;
		}
		else
			MainMenu[loadgame].active = CP_Inactive;
#endif
}


//******************************************************************************
//
// SetUpControlPanel ()
//
//******************************************************************************

void SetUpControlPanel (void)
{
	int i;
	int j;
//	byte * b;
	unsigned b;
	byte * s;

	// Save the current game screen

	savedscreen = SafeMalloc (16000);

	// Copy the current screen to this buffer

	if (RefreshPause==false)
		{
		GamePaused=false;
		ThreeDRefresh();
		FlipPage();
		FlipPage();
		GamePaused=true;
		}
	s=savedscreen;
	for (i=0;i<320;i+=2)
		{
		VGAREADMAP(i&3);
//		b=(byte *)bufferofs+(i>>2);
		b=bufferofs+(i>>2);
		for (j=0;j<100;j++,s++,b+=SCREENBWIDE<<1)
//			*s=*b;
			*s=VGAREAD(b);
		}

	ScanForSavedGames ();



	if (modemgame == true)
		{
		// Make battle mode active
		//
		MainMenu[battlemode].active = CP_Active;

		// No save or load game in modem game
		//
		MainMenu[newgame].active	 = CP_Inactive;
		MainMenu[backtodemo].active = CP_Inactive;
		MainMenu[loadgame].active	= CP_Inactive;
		MainMenu[savegame].active	= CP_Inactive;

		if ( MainMenu[ MainItems.curpos ].active == CP_Inactive )
			{
			MainItems.curpos = battlemode;
			}

		MainMenu[MainItems.curpos].active = CP_CursorLocation;

		if ( consoleplayer != 0 )
			{
			MainMenu[battlemode].routine = ( void (*)(int) )BattleGamePlayerSetup;
			}
		}
	}

//******************************************************************************
//
// GetMenuInfo ()
//
// Gets the user's password
//
//******************************************************************************

void GetMenuInfo (void)
{
	ConvertPasswordStringToPassword ();

	POK=true;
	if (pword[0]==0)
		POK=false;
}


//******************************************************************************
//
// WriteMenuInfo ()
//
// Writes out password
//
//******************************************************************************

void WriteMenuInfo (void)
{
	ConvertPasswordToPasswordString ();
}

//******************************************************************************
//
// AllocateSavedScreenPtr ()
//
//******************************************************************************

void AllocateSavedScreenPtr (void)
{
	// Save the current game screen

	savedscreen = SafeMalloc(16000);
	inmenu  = true;
	numdone = 0;
}


//******************************************************************************
//
// FreeSavedScreenPtr ()
//
//******************************************************************************

void FreeSavedScreenPtr (void)
{
	SafeFree (savedscreen);
	inmenu  = false;
}


//******************************************************************************
//
// CleanUpControlPanel ()
//
//******************************************************************************

void CleanUpControlPanel (void)
{
	int	joyx, joyy;

	if ((playstate==ex_resetgame) || (loadedgame==true))
		ShutdownClientControls();

	// Free up saved screen image

	FreeSavedScreenPtr ();

	WriteConfig ();

//	INL_GetJoyDelta (joystickport, &joyx, &joyy);

	if (mouseenabled)
		PollMouseMove ();	 // Trying to kill movement

//	if (cybermanenabled)
//		PollCyberman ();

	RefreshPause = true;
}


//******************************************************************************
//
// CP_CheckQuick ()
//
//******************************************************************************
boolean CP_CheckQuick
	(
	byte scancode
	)

	{
	if (demoplayback==true)
		{
		switch ( scancode )
			{
			case sc_Escape:
				inmenu = true;
				return( true );
				break;
			}
		}
	else
		{
		switch ( scancode )
			{
			case sc_Escape:
			case sc_F1:
			case sc_F2:
			case sc_F3:
			case sc_F4:
			case sc_F8:
			case sc_F9:
			case sc_F10:
				inmenu = true;
				return( true );
				break;
			}
		}

	return( false );
	}


//******************************************************************************
//
// ControlPanel
//
//	 ROTT Control Panel!
//
//******************************************************************************
void ControlPanel
	(
	byte scancode
	)

	{
	if ( scancode == sc_Escape )
		{
		CP_MainMenu();
		if ( ( playstate == ex_stillplaying ) && ( loadedgame == false ) )
			{
			fizzlein = true;
			}
		return;
		}

	SetupMenuBuf();

	numdone = 0;
	StartGame = false;

	SetUpControlPanel();
	//
	// F-KEYS FROM WITHIN GAME
	//
	switch( scancode )
		{
		case sc_F1:
			CP_F1Help();
			break;

		case sc_F2:
			CP_SaveGame();
			break;

		case sc_F3:
			CP_LoadGame( 0, 0 );
			break;

		case sc_F4:
			CP_ControlMenu();
			break;

		case sc_F8:
			LastScan			 = 0;
			Keyboard[ sc_F8 ] = 0;
			CP_EndGame();
			break;

		case sc_F9:
			LastScan			 = 0;
			Keyboard[ sc_F9 ] = 0;

			loadsavesound = true;
			CP_LoadGame( 1, 0 );
			break;

		case sc_F10:
			SetMenuTitle ("Quit");

			LastScan			  = 0;
			Keyboard[ sc_F10 ] = 0;
			CP_Quit( -1 );
			break;

		}

	CleanUpControlPanel();
	ShutdownMenuBuf();

	if ( loadedgame == false )
		{
		SetupScreen( false );
		fizzlein = true;
		inmenu = false;
		}

	loadsavesound = false;
	}


//******************************************************************************
//
// CP_MainMenu
//
//******************************************************************************
menuitems CP_MainMenu
	(
	void
	)

	{
	int which;

	SetupMenuBuf();

	numdone = 0;

	SetUpControlPanel();

	DrawMainMenu();

	//
	// Main menu loop.  "Exit options" or "New game" exits
	//
	StartGame = false;
	while( !StartGame )
		{
		StartGame = false;

		IN_ClearKeysDown();

		which = HandleMenu( &MainItems, &MainMenu[ 0 ], NULL );

		switch( which )
			{
			case backtodemo:
				if ( !ingame )
					{
					playstate = ex_titles;
					}

				StartGame = true;
				break;

			case -1:
				CP_Quit( 0 );
				break;

			default:
				if ( !StartGame )
					{
					DoMainMenu();
					}
			}
		}

	// Deallocate everything
	CleanUpControlPanel();
	ShutdownMenuBuf();

	return( which );
	}


//******************************************************************************
//
// DrawMainMenu ()
//
//******************************************************************************

void DrawMainMenu(void)
{

	MenuNum = 1;

	//
	// CHANGE "GAME" AND "DEMO"
	//
	if ( ingame )
		{
		MainMenu[ backtodemo ].texture[ 6 ] = '1';
		MainMenu[ backtodemo ].texture[ 7 ] = '1';
		MainMenu[ backtodemo ].texture[ 8 ] = '\0';
		MainMenuNames[ backtodemo ]			= "BACK TO GAME";
		}
	else
		{
		MainMenu[ backtodemo ].texture[ 6 ] = '8';
		MainMenu[ backtodemo ].texture[ 7 ] = '\0';
		MainMenuNames[ backtodemo ]			= "BACK TO DEMO";
		}

	MN_GetCursorLocation( &MainItems, &MainMenu[ 0 ] );
	SetMenuTitle ("Main Menu");
	DrawMenu (&MainItems, &MainMenu[0]);

	numdone ++;
	DisplayInfo (0);
}


//******************************************************************************
//
// Handle moving triad around a menu
//
//******************************************************************************

int HandleMenu (CP_iteminfo *item_i, CP_itemtype *items, void (*routine)(int w))
{

	char		  key;
	int			i,
					x,
					y,
					basey,
					exit,
					numactive,
					count;
	int			newpos;
	volatile int timer;
	ControlInfo ci;
	boolean	  playsnd = false;

	handlewhich = item_i->curpos;
	x	  = item_i->x;
	if ((MenuNum == 4) || (MenuNum == 6) ||
		( item_i->fontsize == mn_smallfont ) )
		{
		basey = item_i->y;

		CursorLump = SmallCursor;
		yinc = 9;
		cursorwidth = cursorheight = 8;
		}
	else if ( item_i->fontsize == mn_8x8font )
		{
		basey = item_i->y - 1;

		CursorLump = SmallCursor;
		yinc = 7;
		cursorwidth = cursorheight = 8;
		}
	else if ( item_i->fontsize == mn_tinyfont )
		{
		basey = item_i->y - 2;

		CursorLump = SmallCursor;
		yinc = 6;
		cursorwidth = cursorheight = 8;
		}
	else
		{
		basey = item_i->y-2;

		CursorLump = LargeCursor;
		yinc = 14;
		cursorwidth = cursorheight = 16;
		}


	if (MenuNum)
		y = basey + handlewhich*yinc;
	else
		y = CUSTOM_y[handlewhich];


	if (MenuNum != 5)
		DrawMenuBufItem (x, y, W_GetNumForName( CursorLump ) +
			CursorFrame[ CursorNum ] );

	if (routine)
		routine (handlewhich);

	count	 = 2;
	exit	  = 0;
	timer	 = ticcount;
	IN_ClearKeysDown ();

	numactive = GetNumActive (item_i, items);

	do
	{
		ReadAnyControl (&ci);
		RefreshMenuBuf (0);
	  // Change Cursor Shape
		if ((ticcount > (timer+count)) && (MenuNum != 5))
		{
			timer = ticcount;

			CursorNum++;
			if (CursorNum > (MAXCURSORNUM-1))
				CursorNum = 0;

			EraseMenuBufRegion(x, y, cursorwidth, cursorheight);
			DrawMenuBufItem (x, y, W_GetNumForName( CursorLump ) +
				CursorFrame[ CursorNum ] );

		}

	  // Initial char - pass 1
		key = getASCII ();
		if (key)
		{
			int ok = 0;

			key = toupper (key);

			for (i = (handlewhich + 1); i < item_i->amount; i++)
				if ((items+i)->active && (items+i)->letter == key)
				{
					HideCursor (item_i, items, x, y, handlewhich);
					MN_PlayMenuSnd (SD_MOVECURSORSND);
					handlewhich = i;


					if (routine)
						routine (handlewhich);

					ShowCursor (item_i, items, x, &y, handlewhich, basey);
					ok = 1;
					IN_ClearKeysDown();
					break;
				}

		  // Initial char - pass 2
			if (!ok)
			{
				for (i = 0; i < handlewhich; i++)
					if ((items+i)->active && (items+i)->letter == key)
					{
						HideCursor (item_i, items, x, y, handlewhich);
						MN_PlayMenuSnd (SD_MOVECURSORSND);
						handlewhich = i;


						if (routine)
							routine (handlewhich);

						ShowCursor (item_i, items, x,& y, handlewhich, basey);
						IN_ClearKeysDown ();
						break;
					}
			}
		}

		ReadAnyControl (&ci);

		if (numactive > 1)
		{
			switch (ci.dir)
			{
				case dir_North:
					HideCursor (item_i, items, x, y, handlewhich);


					CursorNum++;
					if (CursorNum > (MAXCURSORNUM-1))
						CursorNum = 0;


				  // Do a half step if possible
					if ((handlewhich) &&
						(((items+handlewhich-1)->active == CP_CursorLocation) ||
						((items+handlewhich-1)->active == CP_Active)))
					{
						y -= 6;
						DrawHalfStep (x, y);
						playsnd = false;

						RefreshMenuBuf (0);

						CursorNum++;
						if (CursorNum > (MAXCURSORNUM-1))
							CursorNum = 0;
					}
					else
					{
						playsnd = true;
						RefreshMenuBuf (0);
					}

					do
					{
						if (!handlewhich)
							handlewhich = item_i->amount-1;
						else
							handlewhich--;
					} while (((items+handlewhich)->active == CP_Inactive) || ((items+handlewhich)->active == CP_Active3));

					if (playsnd)
						MN_PlayMenuSnd (SD_MOVECURSORSND);
					ShowCursor (item_i, items, x, &y, handlewhich, basey);

					if (routine)
						routine (handlewhich);

					RefreshMenuBuf(0);
				break;

				case dir_South:
					HideCursor (item_i, items, x, y, handlewhich);

					CursorNum++;
					if (CursorNum > (MAXCURSORNUM-1))
						CursorNum = 0;

					// Do a half step if possible
					if ((handlewhich != item_i->amount-1) &&
						(((items+handlewhich+1)->active == CP_CursorLocation) ||
						((items+handlewhich+1)->active == CP_Active)))
					{
						y += 6;
						DrawHalfStep(x,y);
						playsnd = false;

						RefreshMenuBuf (0);

						CursorNum++;
						if (CursorNum > (MAXCURSORNUM-1))
							CursorNum = 0;
					}
					else
					{
						playsnd = true;
						RefreshMenuBuf (0);
					}

					do
					{
						if (handlewhich==item_i->amount-1)
							handlewhich=0;
						else
							handlewhich++;
					} while (((items+handlewhich)->active == CP_Inactive) || ((items+handlewhich)->active == CP_Active3));

					if (playsnd)
						MN_PlayMenuSnd (SD_MOVECURSORSND);
					ShowCursor(item_i,items,x,&y,handlewhich,basey);

					if (routine)
						routine (handlewhich);

					RefreshMenuBuf (0);
				break;
			}
		}

		ReadAnyControl (&ci);
		if (ci.button0 || Keyboard[sc_Space] || Keyboard[sc_Enter])
		{
			exit = 1;
			WaitKeyUp ();
			MN_PlayMenuSnd (SD_SELECTSND);
		}

		if (ci.button1 || Keyboard[sc_Escape])
		{
			WaitKeyUp ();
			exit = 2;
		}

		if ( ( Keyboard[ sc_Home ] ) && ( numactive > 1 ) )
			{
			newpos = 0;
			while( ( items[ newpos ].active == CP_Inactive ) ||
				( items[ newpos ].active == CP_Active3 ) )
				{
				newpos++;
				}

			if ( newpos != handlewhich )
				{
				HideCursor( item_i, items, x, y, handlewhich );

				CursorNum++;
				if ( CursorNum > ( MAXCURSORNUM - 1 ) )
					{
					CursorNum = 0;
					}

				RefreshMenuBuf( 0 );

				handlewhich = newpos;

				MN_PlayMenuSnd( SD_MOVECURSORSND );

				ShowCursor( item_i, items, x, &y, handlewhich, basey );

				if ( routine )
					{
					routine( handlewhich );
					}

				RefreshMenuBuf( 0 );
				}
			}
		else if ( ( Keyboard[ sc_End ] ) && ( numactive > 1 ) )
			{
			newpos = item_i->amount - 1;
			while( ( items[ newpos ].active == CP_Inactive ) ||
				( items[ newpos ].active == CP_Active3 ) )
				{
				newpos--;
				}

			if ( newpos != handlewhich )
				{
				HideCursor( item_i, items, x, y, handlewhich );

				CursorNum++;
				if ( CursorNum > ( MAXCURSORNUM - 1 ) )
					{
					CursorNum = 0;
					}

				RefreshMenuBuf( 0 );

				handlewhich = newpos;

				MN_PlayMenuSnd( SD_MOVECURSORSND );

				ShowCursor( item_i, items, x, &y, handlewhich, basey );

				if ( routine )
					{
					routine( handlewhich );
					}

				RefreshMenuBuf( 0 );
				}
			}

		// Page Up/Down
		if ( MenuNum == 11 )
			{
			if ( ( Keyboard[ sc_PgUp ] ) &&
				( ( items + 1 )->active != CP_Inactive ) )
				{
				item_i->curpos = handlewhich;
				handlewhich = PAGEUP;
				exit = 3;
				MN_PlayMenuSnd( SD_SELECTSND );
				}
			else if ( ( Keyboard[ sc_PgDn ] ) &&
				( ( items + 0 )->active != CP_Inactive ) )
				{
				item_i->curpos = handlewhich;
				handlewhich = PAGEDOWN;
				exit = 3;
				MN_PlayMenuSnd( SD_SELECTSND );
				}
			}

		// Delete save games
		if ((MenuNum == 4) || (MenuNum == 6))
		{
			if (Keyboard[sc_Delete] && SaveGamesAvail[handlewhich])
			{
				if (CP_DisplayMsg ("Delete saved game?\nAre you sure?", 12) == true)
				{
					char loadname[45] = "ROTTGAM0.ROT";
					char filename[128];

					// Create the proper file name
					itoa (handlewhich, &loadname[7], 16);
					loadname[8]='.';

					GetPathFromEnvironment( filename, ApogeePath, loadname );

					// Delete the file

					unlink (filename);

					memset (&SaveGameNames[handlewhich][0], 0, 32);
					SaveGamesAvail[handlewhich] = 0;
					if (handlewhich==quicksaveslot)
						quicksaveslot=-1;

					PrintX = LSM_X+LSItems.indent+2;
					PrintY = LSM_Y+handlewhich*9+2;
				}
				ScanForSavedGames ();

				LSItems.curpos = handlewhich;
				if (MenuNum == 4)
					DrawLoadSaveScreenAlt (1);
				else
					DrawLoadSaveScreenAlt (0);
				CP_DrawSelectedGame (handlewhich);
			}
		}


#if SAVE_SCREEN
		if (Keyboard[sc_CapsLock] && Keyboard[sc_C])
		{
			inhmenu=true;
			SaveScreen (true);
			inhmenu=false;
		}
		else
			if (Keyboard[sc_CapsLock] && Keyboard[sc_X])
			{
				inhmenu=true;
				SaveScreen (false);
				inhmenu=false;
			}
			else
				if (Keyboard[sc_CapsLock] && Keyboard[sc_Q])
					Error ("Insta-Menu Quit!\n");
#endif

	} while (!exit);


	IN_ClearKeysDown();

	if (routine)
		routine (handlewhich);

	if ( exit != 3 )
		{
		item_i->curpos = handlewhich;
		}

	if (MenuNum == 3)
	{
		if (exit != 2)
			CSTactive = handlewhich;
		else
			CSTactive = -1;
	}

	switch (exit)
	{
		case 1:
			if ((items+handlewhich)->routine!=NULL)
				(items+handlewhich)->routine(0);
			return (handlewhich);

		case 2:
			MN_PlayMenuSnd (SD_ESCPRESSEDSND);
			return (-1);

		case 3:
			return( handlewhich );
	}


	return (0);
}

//******************************************************************************
//
// HideCursor
//
//******************************************************************************
void HideCursor
	(
	CP_iteminfo *item_i,
	CP_itemtype *items,
	int x,
	int y,
	int which
	)

	{
	int time = ticcount;
	int color;
	int delay;
	int posx;
	int posy;

	if ( MenuNum != 5 )
		{
		EraseMenuBufRegion( x, y, cursorwidth, cursorheight );
		}

	if ( MenuNum && ( MenuNum != 4 ) && ( MenuNum != 6 ) )
		{
		posx = item_i->x + item_i->indent;
		posy = item_i->y + ( which * yinc );

		color = -1;
		switch( items[ which ].active )
			{
			case CP_Inactive :
				color = NOTAVAILABLECOLOR;
				break;

			case CP_CursorLocation :
			case CP_Active :
				color = NORMALCOLOR;
				break;

			case CP_SemiActive :
				color = DIMMEDCOLOR;
				break;

			case CP_Highlight :
				color = HIGHLIGHTCOLOR;
				break;
			}

		if ( color != -1 )
			{
			if ( item_i->names == NULL )
				{
				DrawIMenuBufItem( posx, posy,
					W_GetNumForName( items[ which ].texture ), color );
				}
			else
				{
				IFont = ( cfont_t * )W_CacheLumpName( FontNames[ item_i->fontsize ],
					PU_CACHE );
				if ( item_i->fontsize == mn_tinyfont )
					{
					DrawMenuBufIString( posx + 1, posy, item_i->names[ which ], 0 );
					}
				DrawMenuBufIString( posx, posy - 1, item_i->names[ which ],
					color );
				}
			}
		}

	if ( ( items[ which ].active != CP_Inactive ) &&
		( items[ which ].active != CP_SemiActive ) )
		{
		items[ which ].active = CP_Active;
		}

	delay = DELAYAMT - tics;
	while( ( time + delay ) > ticcount )
		{
		RefreshMenuBuf (0);
		}
	}


//******************************************************************************
//
// DrawHalfStep
//
//******************************************************************************

void DrawHalfStep (int x, int y)
{
	MN_PlayMenuSnd (SD_MOVECURSORSND);
	if (MenuNum == 5)
		return;

	DrawMenuBufItem (x, y, W_GetNumForName( CursorLump ) +
		CursorFrame[ CursorNum ] );
}


//******************************************************************************
//
// GetNumActive ()
//
//******************************************************************************

int GetNumActive (CP_iteminfo *item_i, CP_itemtype *items)
{
	int cnt;
	int num = 0;

	for (cnt = 0; cnt < item_i->amount; cnt ++)
	{
		if ((items+cnt)->active != CP_Inactive)
			num++;
	}

	return (num);
}


//******************************************************************************
//
// ShowCursor
//	 Draw triad at new position.
//
//******************************************************************************
void ShowCursor
	(
	CP_iteminfo *item_i,
	CP_itemtype *items,
	int x,
	int *y,
	int which,
	int basey
	)

	{
	int time = ticcount;
	int delay;
	int posx;
	int posy;

	if ( MenuNum )
		{
		EraseMenuBufRegion( x, *y, cursorwidth, cursorheight );
		*y = basey + which * yinc;
		}
	else
		{
		*y = CUSTOM_y[ which ];
		}

	if ( MenuNum != 5 )
		{
		DrawMenuBufItem( x, *y, W_GetNumForName( CursorLump ) +
			CursorFrame[ CursorNum ] );
		}

	if ( items[ which ].active != CP_SemiActive )
		{
		if ( MenuNum && ( MenuNum != 4 ) && ( MenuNum != 6 ) )
			{
			posx = item_i->x + item_i->indent;
			posy = item_i->y + which * yinc;

			if ( item_i->names == NULL )
				{
				DrawIMenuBufItem( posx, posy,
					W_GetNumForName( items[ which ].texture ), ACTIVECOLOR);
				}
			else
				{
				IFont = ( cfont_t * )W_CacheLumpName( FontNames[ item_i->fontsize ],
					PU_CACHE );
				if ( item_i->fontsize == mn_tinyfont )
					{
					DrawMenuBufIString( posx + 1, posy, item_i->names[ which ], 0 );
					}
				DrawMenuBufIString( posx, posy - 1, item_i->names[ which ],
					ACTIVECOLOR );
				}
			}

		items[ which ].active = CP_CursorLocation;
		}

	delay = DELAYAMT - tics;
	while( ( time + delay ) > ticcount )
		{
		RefreshMenuBuf( 0 );
		}
	}

//******************************************************************************
//
// DrawOrderInfo()
//
//******************************************************************************

void DrawOrderInfo
	(
	int which
	)

	{
	int start;
	char *lumpname;

	start = W_GetNumForName( "ORDRSTRT" ) + 1;

	lumpname = W_GetNameForNum( start + which );

	// Screen shots are grabbed as pics
	if ( lumpname[ 0 ] == 'S' )
		{
		VWB_DrawPic( 0, 0, ( pic_t * )W_CacheLumpNum( start + which, PU_CACHE ) );
		}
	else
		{
		VL_DrawPostPic( W_GetNumForName( "trilogo" ) );
		DrawNormalSprite( 0, 0, start );
		DrawNormalSprite( 0, 0, start + which );
		}

	VW_UpdateScreen();
	}


//******************************************************************************
//
// CP_OrderInfo()
//
//******************************************************************************

void CP_OrderInfo
	(
	void
	)

	{
	int maxpage;
	int page;
	int key;
	boolean newpage;

	maxpage = W_GetNumForName( "ORDRSTOP" ) - W_GetNumForName( "ORDRSTRT" ) - 2;
	newpage = false;
	page = 1;

	do
		{
		DrawOrderInfo( page );

		if ( newpage )
			{
			while( Keyboard[ key ] )
				{
				VW_UpdateScreen();
				IN_UpdateKeyboard ();
				}
			}

		LastScan=0;
		while( LastScan == 0 )
			{
			VW_UpdateScreen();
			IN_UpdateKeyboard ();
			}

		key = LastScan;
		switch( key )
			{
			case sc_Home :
				if ( page != 1 )
					{
					page = 1;
					newpage = true;
					MN_PlayMenuSnd( SD_MOVECURSORSND );
					}
				break;

			case sc_End :
				if ( page != maxpage )
					{
					page = maxpage;
					newpage = true;
					MN_PlayMenuSnd( SD_MOVECURSORSND );
					}
				break;

			case sc_PgUp :
			case sc_UpArrow :
			case sc_LeftArrow :
				if ( page > 1 )
					{
					page--;
					newpage = true;
					MN_PlayMenuSnd( SD_MOVECURSORSND );
					}
				break;

			case sc_PgDn :
			case sc_DownArrow :
			case sc_RightArrow :
				if ( page < maxpage )
					{
					page++;
					newpage = true;
					MN_PlayMenuSnd( SD_MOVECURSORSND );
					}
				break;
			}
		}
	while( key != sc_Escape );

	Keyboard[ key ] = 0;
	LastScan = 0;

	MN_PlayMenuSnd( SD_ESCPRESSEDSND );
	}


//******************************************************************************
//
// CP_ViewScores ()
//
//******************************************************************************

void CP_ViewScores (void)
{
	CheckHighScore (0, 0, true);
}


//******************************************************************************
//
// CP_Quit () - QUIT THIS INFERNAL GAME!
//
//******************************************************************************
void CP_Quit ( int which )
{
	int num = 100;
	static int oldnum;

	while ((num >= 7) || (oldnum == num))
		num = (RandomNumber ("CP_QUIT", 0) & 7);

	oldnum = num;

	if (CP_DisplayMsg (endStrings[num], num))
	{
		int handle;

		MU_FadeOut(310);
		handle=SD_Play(SD_QUIT1SND+num);
		VL_FadeOut (0, 255, 0, 0, 0, 10);
		CleanUpControlPanel();
		SD_WaitSound (handle);
		QuitGame ();
	}

	if ( which != -1 )
		{
		ClearMenuBuf();
		DrawMainMenu();
		DrawMenuBufItem (MainItems.x,  ((MainItems.curpos*14)+(MainItems.y-2)),
			W_GetNumForName ( LargeCursor ) + CursorFrame[ CursorNum ] );
		RefreshMenuBuf (0);
		}
}

//******************************************************************************
//
// CP_DisplayMsg ()
//
//******************************************************************************

boolean CP_DisplayMsg
	(
	char *s,
	int number
	)

	{
#define Q_W	 184
#define Q_H	 72
#define Q_X	 ((320-Q_W)/2)-18
#define Q_Y	 ((200-Q_H)/2)-33

#define Q_b1X  (Q_X+85)
#define Q_b2X  (Q_X+135)
#define Q_bY	(Q_Y+45)
#define Q_bW	33
#define Q_bH	10

#define W_X	 72
#define W_Y	 11
#define W_W	 102

#define YES	 "q_yes\0"
#define NO	  "q_no\0"

	ControlInfo ci;
	boolean retval;
	boolean done;
	boolean YESON;
	boolean redraw;
	boolean blowout;
	char	*temp;
	char	*active;
	char	*inactive;
	int	  activex;
	int	  inactivex;
	int	  W_H;
	int	  L_Y;
	int	  tri;
	int	  QUITPIC;
	int	  t;

	W_H = 1;
	retval  = false;
	done	 = false;
	YESON	= true;
	redraw  = false;
	blowout = false;

	IN_ClearKeysDown();
	IN_IgnoreMouseButtons();


	QUITPIC = W_GetNumForName( "quitpic" );

	if ( number < 11 )
		{
		tri = W_GetNumForName( "QUIT01" ) + number;
		MN_PlayMenuSnd( SD_WARNINGBOXSND );
		}
	else
		{
		if ( number == 11 )
			{
			tri = W_GetNumForName( "tri1pic" );
			MN_PlayMenuSnd( SD_INFOBOXSND );
			}
		else
			{
			if ( number == 12 )
				{
				tri = W_GetNumForName( "tri2pic" );
				MN_PlayMenuSnd( SD_QUESTIONBOXSND );
				}
			if ( number == 13 )
				{
				tri = W_GetNumForName( "tri1pic" );
				MN_PlayMenuSnd( SD_WARNINGBOXSND );
				}
			}
		}

	DrawMenuBufPic( Q_X, Q_Y, QUITPIC );
	DrawMenuBufPic( Q_X + 12, Q_Y + 11, tri );

	temp = s;
	while( *temp )
		{
		if ( *temp == '\n' )
			{
			W_H++;
			}
		temp++;
		}

	CurrentFont = tinyfont;
	W_H = ( W_H * CurrentFont->height ) + 3;

	L_Y	  = Q_Y + W_Y;
	WindowX = Q_X + W_X;
	WindowY = L_Y + 2;
	PrintX  = WindowX;
	PrintY  = WindowY;

	WindowW = W_W;
	WindowH = W_H;

	redraw = true;

	IFont = ( cfont_t * )W_CacheLumpName( FontNames[ mn_smallfont ],
		PU_CACHE );
/*
	DrawSTMenuBuf( WindowX, L_Y, W_W, W_H, false );
	MenuBufCPrint( s );

	DrawSTMenuBuf( Q_b1X, Q_bY, Q_bW, Q_bH, false );
	DrawMenuBufIString( Q_b1X + 3, Q_Y + 46, "YES", NORMALCOLOR );
//	DrawIMenuBufItem (PrintX, PrintY, W_GetNumForName (YES), NORMALCOLOR);

	DrawSTMenuBuf( Q_b2X, Q_bY, Q_bW, Q_bH, true );
	DrawMenuBufIString( Q_b2X + 2, Q_Y + 45, "NO", ACTIVECOLOR );
//	DrawIMenuBufItem (PrintX, PrintY, W_GetNumForName (NO), ACTIVECOLOR);
*/
	if (number != 13)
	{
	while ( !done )
		{
		RefreshMenuBuf( 0 );

		ReadAnyControl( &ci );

		if ( ( ci.dir == dir_West ) && ( !YESON ) )
			{
			MN_PlayMenuSnd( SD_MOVECURSORSND );
			YESON = 1;
			redraw = true;
			}
		else if ( ( ci.dir == dir_East ) && ( YESON ) )
			{
			MN_PlayMenuSnd( SD_MOVECURSORSND );
			YESON = 0;
			redraw = true;
			}

		if ( Keyboard[ sc_Y ] )
			{
			YESON  = 1;
			redraw = true;
			Keyboard[ sc_Enter ] = true;
			blowout = true;
			}
		else if ( Keyboard[ sc_N ] )
			{
			YESON  = 0;
			redraw = true;
			Keyboard[ sc_Enter ] = true;
			blowout = true;
			}

		if ( redraw )
			{
			redraw = false;

			DrawMenuBufPic( Q_X, Q_Y, QUITPIC );
			DrawMenuBufPic( Q_X + 12, Q_Y + 11, tri );

			PrintX = Q_X + W_X;
			PrintY = Q_Y + W_Y + 2;
			DrawSTMenuBuf( WindowX, L_Y, W_W, W_H, false );
			CurrentFont = tinyfont;
			MenuBufCPrint( s );

			if ( YESON )
				{
				active	 = "YES";
				inactive  = "NO";
				activex	= Q_b1X;
				inactivex = Q_b2X;
				}
			else
				{
				active	 = "NO";
				inactive  = "YES";
				activex	= Q_b2X;
				inactivex = Q_b1X;
				}

			DrawSTMenuBuf( activex, Q_bY, Q_bW, Q_bH, false );
			DrawMenuBufIString( activex + 3, Q_Y + 46, active, ACTIVECOLOR );
//			DrawIMenuBufItem (PrintX, PrintY, W_GetNumForName (YES), NORMALCOLOR);

			DrawSTMenuBuf( inactivex, Q_bY, Q_bW, Q_bH, true );
			DrawMenuBufIString( inactivex + 2, Q_Y + 45, inactive, NORMALCOLOR );
//			DrawIMenuBufItem (PrintX, PrintY, W_GetNumForName (NO), ACTIVECOLOR);

			for( t = 0; t < 5; t++ )
				{
				RefreshMenuBuf( 0 );
				}
			}

		if ( ( Keyboard[ sc_Space ] || Keyboard[ sc_Enter ] ||
			ci.button0 ) && YESON )
			{
			done	= true;
			retval = true;
			MN_PlayMenuSnd( SD_SELECTSND );
			CP_Acknowledge = CP_YES;
			}
		else if ( Keyboard[ sc_Escape ] || ci.button1 )
			{
			done	= true;
			retval = false;
			CP_Acknowledge = CP_ESC;
			MN_PlayMenuSnd( SD_ESCPRESSEDSND );
			}
		else if ( ( Keyboard[ sc_Space ] || Keyboard[ sc_Enter ] ||
			ci.button0 ) && !YESON )
			{
			done	= true;
			retval = false;
			CP_Acknowledge = CP_NO;

			if ( Keyboard[ sc_N ] )
				{
				MN_PlayMenuSnd( SD_SELECTSND );
				}
			else
				{
				MN_PlayMenuSnd( SD_ESCPRESSEDSND );
				}
			}
		}

	while( ( Keyboard[ sc_Enter ] || Keyboard[ sc_Space ] ||
		Keyboard[ sc_Escape ] ) && !blowout )
		{
		IN_UpdateKeyboard();
		RefreshMenuBuf( 0 );
		}
	}
	else
	{
		PrintX = Q_X + W_X;
		PrintY = Q_Y + W_Y + 2;
		DrawSTMenuBuf( WindowX, L_Y, W_W, W_H, false );
		CurrentFont = tinyfont;
		MenuBufCPrint( s );
		LastScan=0;
		while (LastScan == 0)
			{
			RefreshMenuBuf( 0 );
			}
		LastScan = 0;
		IN_UpdateKeyboard();
	}
	IN_ClearKeysDown();
	return( retval );
	}


//******************************************************************************
//
// EndGameStuff ()
//
//******************************************************************************

void EndGameStuff (void)
{
	Z_FreeTags( PU_LEVELSTRUCT, PU_LEVELEND );

	pickquick = false;
	CheckHighScore (gamestate.score, gamestate.mapon+1, true);
	locplayerstate->lives = 0;
	playstate = ex_died;
	damagecount = 0;
	SetBorderColor (0);

	AdjustMenuStruct ();
	ingame = false;

	GamePaused  = false;
}


//******************************************************************************
//
// START A NEW GAME
//
//******************************************************************************

#define CURGAME	"You are currently in\n"\
		"a game. Continuing will\n"\
		"erase old game. Ok?\0"

int ToughMenuNum;

void CP_NewGame
	(
	void
	)

	{
	int which;

#if ( SHAREWARE == 1 )
	ToughMenuNum = 0;
#else
	int temp;

	temp = ToughMenuNum;

	while( ToughMenuNum == temp )
		{
		temp = ( ( RandomNumber( "TOUGH MENU", 0 ) ) & 3 );
		if ( temp == 3 )
			{
			temp = 1;
			}
		}

	ToughMenuNum = temp;
#endif

	//
	// ALREADY IN A GAME?
	//
	if ( ingame )
		{
		if ( !CP_DisplayMsg( CURGAME, 12 ) )
			{
			return;
			}
		else
			{
			EndGameStuff();
			}
		}
	else
		{
		handlewhich = 100;
		}

	if ( CP_PlayerSelection() == 0 )
		{
		return;
		}

	TufMenu[ ToughMenuNum ][ 0 ].active = CP_Active;
	TufMenu[ ToughMenuNum ][ 2 ].active = CP_Active;
	TufMenu[ ToughMenuNum ][ 4 ].active = CP_Active;
	TufMenu[ ToughMenuNum ][ 6 ].active = CP_Active;

	switch( DefaultDifficulty )
		{
		case gd_baby :
			TufItems.curpos = 0;
			break;

		case gd_easy :
			TufItems.curpos = 2;
			break;

		case gd_medium :
			TufItems.curpos = 4;
			break;

		case gd_hard :
			TufItems.curpos = 6;
			break;

		default :
			TufItems.curpos = 0;
			break;
		}

	TufMenu[ ToughMenuNum ][ TufItems.curpos ].active = CP_CursorLocation;

	DrawNewGame();

	which = HandleMenu( &TufItems, &TufMenu[ ToughMenuNum ][ 0 ],
		DrawNewGameDiff );

	if ( which < 0 )
		{
		handlewhich = 1;
		return;
		}

	handlewhich = 0;

	switch( which )
		{
		case 0 :
			DefaultDifficulty = gd_baby;
			break;

		case 2 :
			DefaultDifficulty = gd_easy;
			break;

		case 4 :
			DefaultDifficulty = gd_medium;
			break;

		case 6 :
			DefaultDifficulty = gd_hard;
			break;
		}

	MainMenu[ savegame ].active = CP_Active;

	gamestate.battlemode = battle_StandAloneGame;
	StartGame = true;
	playstate = ex_resetgame;
	}

//******************************************************************************
//
// CP_EndGame ()
//
//******************************************************************************

#define ENDGAMESTR	"Are you sure you want\n"\
					"to end the game you\n"\
					"are playing? (Y or N):"

void CP_EndGame
	(
	void
	)

	{
	boolean action;

	SetMenuTitle( "End Game" );
	action = CP_DisplayMsg( ENDGAMESTR, 12 );

	StartGame = false;
	if ( action )
		{
		EndGameStuff ();
		pickquick = false;
		}
	}

//******************************************************************************
//
// AdjustMenuStruct ()
//
//******************************************************************************
void AdjustMenuStruct
	(
	void
	)

	{
	MainMenu[ savegame ].active			= CP_Inactive;
	MainMenu[ viewscores ].routine		= ( void * )CP_ViewScores;
	MainMenu[ viewscores ].texture[ 6 ] = '7';
	MainMenu[ viewscores ].texture[ 7 ] = '\0';
	MainMenu[ viewscores ].letter		 = 'V';
	MainMenuNames[ viewscores ]			= "VIEW SCORES";
	}

//******************************************************************************
//
// CP_DrawSelectedGame
//
//******************************************************************************

void CP_DrawSelectedGame (int w)
{
	gamestorage_t game;

	if (SaveGamesAvail[w])
		{
		GetSavedHeader(w,&game);

		DrawStoredGame(&game.picture[0],game.episode,game.area);
		}
	else
		EraseMenuBufRegion(SaveGamePicX,SaveGamePicY,160,124);
}

//******************************************************************************
//
// DrawStoredGame
//
//******************************************************************************

void DrawStoredGame ( byte * pic, int episode, int area )
{
	char str[3];
	int level;
	byte *shape;

	shape = W_CacheLumpNum (W_GetNumForName ("newfnt1"), PU_CACHE);
	newfont1 = (font_t *)shape;
	CurrentFont = newfont1;
	EraseMenuBufRegion (74, 128, 85, 14);

	DrawMenuBufPropString (74, 128, "E");

	itoa (episode, str, 10);
	DrawMenuBufPropString (87, 128, str);

	DrawMenuBufPropString (103, 128, "A");

	if (episode > 1)
		level = (area+1) - ((episode-1) << 3);
	else
		level = area+1;

	ltoa (level, str, 10);
	DrawMenuBufPropString (117, 128, str);
	CurrentFont = tinyfont;

	DrawMenuBufPicture(SaveGamePicX,SaveGamePicY,pic,160,100);
}



//******************************************************************************
//
// DoLoad ()
//
//******************************************************************************

int DoLoad (int which)
{
	gamestorage_t game;
	int exit = 0;

	if ((which >= 0) && SaveGamesAvail[which])
	{
		loadedgame = true;

		if (loadsavesound)
			MN_PlayMenuSnd (SD_SELECTSND);

		if (LoadTheGame (which, &game) == true)
		{
			MenuFixup ();
			StartGame = true;
			exit		= 1;
		}
		else
		{
			if (CP_DisplayMsg ("Saved Game is\n old or incompatible\nDelete it?", 12)==true)
			{
				char loadname[45] = "ROTTGAM0.ROT";
				char filename[128];

				// Create the proper file name
				itoa (which, &loadname[7], 16);
				loadname[8]='.';

				GetPathFromEnvironment( filename, ApogeePath, loadname );

				// Delete the file

				unlink (filename);

				memset (&SaveGameNames[which][0], 0, 32);
				SaveGamesAvail[which] = 0;
			}

			loadedgame = false;
			DrawLoadSaveScreenAlt (0);
		}
	}

	return (exit);
}


//******************************************************************************
//
// LOAD SAVED GAMES
//
//******************************************************************************

int CP_LoadGame (int quick, int dieload)
{
	int which,
		 exit = 0;


	MenuNum = 6;

	SaveTime = ticcount;

	//
	// QUICKLOAD?
	//
	if (quick)
	{
		which = LSItems.curpos;

		if (SaveGamesAvail[which])
		{
			if (dieload)
			{
				DrawLoadSaveScreenAlt (0);
				CP_DrawSelectedGame (which);
				RefreshMenuBuf (0);
				DoLoad (which);

				return (1);
			}
			else
			{
				DrawLoadSaveScreen (0);
				if (CP_DisplayMsg ("Quick load saved game?\nAre you sure?", 12) == true)
				{
					DrawLoadSaveScreen (0);
					CP_DrawSelectedGame (which);
					RefreshMenuBuf (0);
					DoLoad (which);

					return (1);
				}
				else
				{
					return (0);
				}
			}
		}
	}

	DrawLoadSaveScreen (0);
	do
	{
		which = HandleMenu (&LSItems, &LSMenu[0], CP_DrawSelectedGame);

		if (exit = DoLoad (which))
			break;

	} while (which >= 0);

	handlewhich = OUTOFRANGE;

	if (MainMenu[loadgame].active == CP_Inactive)	 // If all the saved games have been
	{
		MainItems.curpos = 0;					//  deleted dehighlight LOADGAME
		MainMenu[newgame].active = CP_CursorLocation;
	}

	return exit;
}

//******************************************************************************
//
// QuickSaveGame ()
//
//******************************************************************************

void QuickSaveGame (void)
{
	int i;
	int j;
//	byte * b;
	unsigned b;
	byte * s;
	int which;
	gamestorage_t game;
	byte * buf;
	int length;

	char	loadname[45]="ROTTGAM0.ROT";
	char	filename[128];

	// Create the proper file name

	itoa(quicksaveslot,&loadname[7],16);
	loadname[8]='.';

	GetPathFromEnvironment( filename, ApogeePath, loadname );
	length=LoadFile(filename,&buf);
	GetPathFromEnvironment( filename, ApogeePath, QUICKSAVEBACKUP );
	SaveFile(filename,buf,length);
	SafeFree(buf);

	s=&game.picture[0];
	for (i=0;i<320;i+=2)
		{
		VGAREADMAP(i&3);
//		b=(byte *)bufferofs+(i>>2);
		b=bufferofs+(i>>2);
		for (j=0;j<100;j++,s++,b+=SCREENBWIDE<<1)
//			*s=*b;
			*s=VGAREAD(b);
		}

	ScanForSavedGames ();
	which = quicksaveslot;

	if (SaveGamesAvail[which])
		{
		game.episode = gamestate.episode;
		game.area	 = gamestate.mapon;
		game.version = ROTTVERSION;
//		strcpy (&game.message, &SaveGameNames[which][0]);
		strcpy (game.message, &SaveGameNames[which][0]);

		if (SaveTheGame (which, &game) == true)
			{
			char str[50];

			strcpy (str, "Game Saved: ");
			strcat (str, &SaveGameNames[which][0]);
			AddMessage(str,MSG_SYSTEM);
			}
		else
			{
			AddMessage("Game Not Saved.",MSG_SYSTEM);
			}
		}
	else
		{
		AddMessage("No Quick Save Slot.",MSG_SYSTEM);
		}

	}

//******************************************************************************
//
// UndoQuickSaveGame ()
//
//******************************************************************************

void UndoQuickSaveGame (void)
{
	byte * buf;
	char	loadname[45]="ROTTGAM0.ROT";
	char	filename[128];
	int length;

	if (quicksaveslot!=-1)
		{
		// Create the proper file name

		itoa(quicksaveslot,&loadname[7],16);
		loadname[8]='.';
		GetPathFromEnvironment( filename, ApogeePath, QUICKSAVEBACKUP );
		length=LoadFile(filename,&buf);
		GetPathFromEnvironment( filename, ApogeePath, loadname );
		SaveFile(filename,buf,length);
		SafeFree(buf);
		AddMessage("Previous Quicksave Game Restored.",MSG_SYSTEM);
		}
	else
		{
		AddMessage("No Quick Save Slot Selected.",MSG_SYSTEM);
		}
}


//******************************************************************************
//
// SAVE CURRENT GAME
//
//******************************************************************************
int CP_SaveGame ( void )
{
	int  which,
		  exit=0;

	char input[32];
	gamestorage_t game;


	MenuNum = 4;


	DrawLoadSaveScreen (1);

	do
	{
		which = HandleMenu (&LSItems, &LSMenu[0], CP_DrawSelectedGame);
		if (which >= 0)
		{
			//
			// OVERWRITE EXISTING SAVEGAME?
			//
			if (SaveGamesAvail[which])
				if (!CP_DisplayMsg (GAMESVD, 12))
				{
					DrawLoadSaveScreenAlt (1);
					continue;
				}
				else
				{
					DrawLoadSaveScreenAlt (1);
					EraseMenuBufRegion (LSM_X+LSItems.indent, LSM_Y+1+which*9, 80, 8);
					PrintLSEntry (which);
				}
			quicksaveslot=which;

			DrawStoredGame (savedscreen, gamestate.episode, gamestate.mapon);

			strcpy (input, &SaveGameNames[which][0]);

			if (!SaveGamesAvail[which])
				EraseMenuBufRegion (LSM_X+LSItems.indent+1, LSM_Y+which*9+2,
										  77, 6);

			if (US_LineInput (LSM_X+LSItems.indent+2, LSM_Y+which*9+2,
									input, input, true, 22, 75, 0))
			{
				SaveGamesAvail[which] = 1;
				memcpy(&game.picture[0],savedscreen,16000);
				game.episode=gamestate.episode;
				game.area=gamestate.mapon;
				game.version=ROTTVERSION;
//				strcpy (&game.message, input);
				strcpy (game.message, input);
				strcpy (&SaveGameNames[which][0], input);

				if (SaveTheGame(which,&game)==true)
					{
					MainMenu[loadgame].active=CP_Active;

//					MN_PlayMenuSnd (SD_SELECTSND);
					exit = 1;
					}
				WaitKeyUp ();
			}
			else
			{
				EraseMenuBufRegion (LSM_X+LSItems.indent+1, LSM_Y+which*9+2,
										  77, 6);

				PrintX = LSM_X+LSItems.indent+2;
				PrintY = LSM_Y+which*9+2;

				if (SaveGamesAvail[which])
					DrawMenuBufPropString (PrintX, PrintY, SaveGameNames[which]);
				else
					DrawMenuBufPropString (PrintX, PrintY, "	  -  -");

//				MN_PlayMenuSnd (SD_ESCPRESSEDSND);
				continue;
			}
			break;
		}

	} while (which >= 0);

	handlewhich = OUTOFRANGE;

	return (exit);
}



//******************************************************************************
//
// DEFINE CONTROLS
//
//******************************************************************************

void CP_Control (void)
{
	#define CTL_SPC	70

	int which;

	DrawCtlScreen ();
	WaitKeyUp ();

	do
	{
		which = HandleMenu (&CtlItems, &CtlMenu[0], NULL);

		switch (CSTactive)
		{
			case MOUSEENABLE:
				if (MousePresent)
				{
					mouseenabled^=1;
					DrawCtlButtons ();
					CusItems.curpos=-1;
				}
				else
					mouseenabled = 0;
			break;

			case JOYENABLE:
				joystickenabled^=1;
				if ( joystickenabled )
					{
					if ( !CalibrateJoystick() )
						{
						joystickenabled = 0;
						joypadenabled = 0;
						}
					}
				else
					{
					joypadenabled = 0;
					}
				DrawCtlScreen();
				break;

			case USEPORT2:
				joystickport^=1;
				if ( joystickport )
					{
					joypadenabled = 0;
					}

				joystickenabled = 1;
				if ( !CalibrateJoystick() )
					{
					joystickenabled = 0;
					joystickport = 0;
					}

				if ( joystickport )
					{
					CtlMenu[ 3 ].active = CP_Inactive;
					joypadenabled = 0;
					}
				else
					{
					CtlMenu[ 3 ].active = CP_Active;
					}

				DrawCtlScreen();
			break;

			case PADENABLE:
				joypadenabled^=1;
				if ( ( joypadenabled ) && ( !joystickenabled ) )
					{
					joystickenabled=1;
					if ( !CalibrateJoystick() )
						{
						joystickenabled = 0;
						joypadenabled = 0;
						}

					DrawCtlScreen();
					}
				else
					{
					DrawCtlButtons ();
					}
			break;

			case SPACEBALLENABLE:
//				spaceballenabled ^= 1;
				DrawCtlButtons ();
			break;

			case CYBERMANENABLE:
  //			 cybermanenabled ^= 1;
				DrawCtlButtons ();
			break;

			case THRESSENS:
			case MOUSESENS:
			case CUSTOMIZE:
				DrawCtlScreen ();
			break;
		}

	} while (which >= 0);

	DrawControlMenu ();

	if (which < 0)
	{
		handlewhich = 1;
		return;
	}
}


//****************************************************************************
//
// CP_Custom ()
//
//****************************************************************************

void CP_Custom (void)
{
	int which;

	DrawCustomMenu();

	do
	{
		which = HandleMenu (&CustomItems, &CustomMenu[0], NULL);
	} while (which >= 0);

	DrawCtlScreen ();
}


//******************************************************************************
//
// CUSTOMIZE CONTROLS
//
//******************************************************************************

//****************************************************************************
//
// CP_Keyboard ()
//
//****************************************************************************
void CP_Keyboard
	(
	void
	)

	{
	int which;

	MenuNum = 1;

	DrawCustomKeyboard ();

	do
		{
		which = HandleMenu( &NormalKeyItems, &NormalKeyMenu[ 0 ], NULL );
		}
	while( which >= 0 );

	DrawCustomMenu();
	}


//******************************************************************************
//
// DEFINE THE KEYBOARD BUTTONS
//
//******************************************************************************

void DefineKey
	(
	void
	)

	{
	boolean tick;
	boolean picked;
	int	  timer;
	int	  x;
	int	  y;

	tick	= false;
	picked = false;
	timer  = ticcount;

	x = NORMALKEY_X + 97;
	y = NORMALKEY_Y + ( handlewhich * FontSize[ NormalKeyItems.fontsize ] );

	strcpy( &NormalKeyNames[ handlewhich ][ KEYNAMEINDEX ],
		"	  " );

//	SetMenuTitle ( "Select which key to use" );
	ClearMenuBuf();
	DrawMenu( &NormalKeyItems, &NormalKeyMenu[ 0 ] );
	DisplayInfo( 0 );

	DrawMenuBufIString( x + 3, y, "?", 0 );
	DrawMenuBufIString( x + 2, y - 1, "?", HIGHLIGHTCOLOR );

	RefreshMenuBuf( 0 );

	do
		{
		//
		// FLASH CURSOR
		//
		if ( ( ticcount - timer ) > 10 )
			{
			int color;

			if ( tick )
				{
				color = HIGHLIGHTCOLOR;
				}
			else
				{
				color = DIMMEDCOLOR;
				}

			DrawMenuBufIString( x + 3, y, "?", 0 );
			DrawMenuBufIString( x + 2, y - 1, "?", color );

			tick  = !tick;
			timer = ticcount;
			}

		RefreshMenuBuf( 0 );


		if ( LastScan )
			{
			int key;

			key = LastScan;
			LastScan = 0;

			buttonscan[ order[ handlewhich ] ] = key;

			strcpy( &NormalKeyNames[ handlewhich ][ KEYNAMEINDEX ],
				IN_GetScanName( key ) );

			picked = true;

			WaitKeyUp();
			Keyboard[ key ] = 0;

			IN_ClearKeysDown();
			}
		}
	while( !picked );

	ClearMenuBuf();
	SetMenuTitle( "Customize Keyboard" );

	DrawMenu( &NormalKeyItems, &NormalKeyMenu[ 0 ] );
	DisplayInfo( 0 );
	RefreshMenuBuf (0);
	}

//****************************************************************************
//
// DrawControlSelect ()
//
//****************************************************************************

void DrawControlSelect
	(
	void
	)

	{
	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Select Button Function");

	MN_GetCursorLocation( &ControlSelectItems, &ControlSelectMenu[ 0 ] );
	DrawMenu( &ControlSelectItems, &ControlSelectMenu[ 0 ] );

	DisplayInfo( 0 );
	FlipMenuBuf();
	}


//****************************************************************************
//
// DefineMouseBtn()
//
//****************************************************************************

void DefineMouseBtn
	(
	void
	)

	{
	int button;
	int which;

	button = handlewhich;

	MN_GetActive( &ControlSelectItems, &ControlSelectMenu[ 0 ],
		buttonmouse[ button ], controlorder );

	DrawControlSelect();

	which = HandleMenu( &ControlSelectItems, &ControlSelectMenu[ 0 ], NULL );
	if ( which != -1 )
		{
		buttonmouse[ button ] = controlorder[ which ];
		}

	handlewhich = OUTOFRANGE;
	}

//****************************************************************************
//
// CP_Mouse ()
//
//****************************************************************************
void CP_Mouse
	(
	void
	)

	{
	int which;

	MenuNum = 1;

	do
		{
		DrawCustomMouse();
		which = HandleMenu( &MouseBtnItems, &MouseBtnMenu[ 0 ], NULL );
		}
	while( which >= 0 );

	handlewhich = OUTOFRANGE;

	DrawCustomMenu();
	}


//****************************************************************************
//
// DrawCustomMouse ()
//
//****************************************************************************

void DrawCustomMouse
	(
	void
	)

	{
	int i;
	int j;
	int num;
	int button;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Customize Mouse");

	for( i = 0; i < 6; i++ )
		{
		num = 0;
		button = buttonmouse[ i ];
		buttonmouse[ i ] = bt_nobutton;
		MouseBtnNames[ i ][ MOUSEBTNINDEX ] = 0;

		for( j = 0; j < NUMCONTROLNAMES; j++ )
			{
			if ( button == controlorder[ j ] )
				{
				buttonmouse[ i ] = button;
				num = j;
				break;
				}
			}

		strcpy( &MouseBtnNames[ i ][ MOUSEBTNINDEX ],
			ControlNames[ num ] );
		}

	MN_GetCursorLocation( &MouseBtnItems, &MouseBtnMenu[ 0 ] );
	DrawMenu( &MouseBtnItems, &MouseBtnMenu[ 0 ] );

	DisplayInfo( 0 );
	FlipMenuBuf();
	}


//****************************************************************************
//
// DefineJoyBtn()
//
//****************************************************************************

void DefineJoyBtn
	(
	void
	)

	{
	int button;
	int which;

	button = handlewhich;

	MN_GetActive( &ControlSelectItems, &ControlSelectMenu[ 0 ],
		buttonjoy[ button ], controlorder );

	DrawControlSelect();

	which = HandleMenu( &ControlSelectItems, &ControlSelectMenu[ 0 ], NULL );
	if ( which != -1 )
		{
		buttonjoy[ button ] = controlorder[ which ];
		}

	handlewhich = OUTOFRANGE;
	}


//****************************************************************************
//
// DrawCustomJoystick ()
//
//****************************************************************************

void DrawCustomJoystick
	(
	void
	)

	{
	int i;
	int j;
	int num;
	int button;
	int active;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Customize Joystick");

	for( i = 0; i < 8; i++ )
		{
		num = 0;
		button = buttonjoy[ i ];
		buttonjoy[ i ] = bt_nobutton;
		JoyBtnNames[ i ][ JOYBTNINDEX ] = 0;

		for( j = 0; j < NUMCONTROLNAMES; j++ )
			{
			if ( button == controlorder[ j ] )
				{
				buttonjoy[ i ] = button;
				num = j;
				break;
				}
			}

		strcpy( &JoyBtnNames[ i ][ JOYBTNINDEX ], ControlNames[ num ] );
		}

	JoyBtnMenu[ 0 ].active = CP_Active;
	JoyBtnMenu[ 1 ].active = CP_Active;
	JoyBtnMenu[ 4 ].active = CP_Active;
	JoyBtnMenu[ 5 ].active = CP_Active;

	if ( joypadenabled )
		{
		active = CP_Active;
		}
	else
		{
		active = CP_Inactive;
		}

	JoyBtnMenu[ 2 ].active = active;
	JoyBtnMenu[ 3 ].active = active;
	JoyBtnMenu[ 6 ].active = active;
	JoyBtnMenu[ 7 ].active = active;

	if ( JoyBtnMenu[ JoyBtnItems.curpos ].active == CP_Inactive )
		{
		MN_GetCursorLocation( &JoyBtnItems, &JoyBtnMenu[ 0 ] );
		}
	else
		{
		JoyBtnMenu[ JoyBtnItems.curpos ].active = CP_CursorLocation;
		}

	DrawMenu( &JoyBtnItems, &JoyBtnMenu[ 0 ] );

	DisplayInfo( 0 );
	FlipMenuBuf();
	}


//****************************************************************************
//
// CP_Joystick ()
//
//****************************************************************************

void CP_Joystick
	(
	void
	)

	{
	int which;

	MenuNum = 1;

	do
		{
		DrawCustomJoystick();
		which = HandleMenu( &JoyBtnItems, &JoyBtnMenu[ 0 ], NULL );
		}
	while( which >= 0 );

	handlewhich = OUTOFRANGE;

	DrawCustomMenu();
	}


//******************************************************************************
//
// PRINT A MESSAGE IN A WINDOW
//
//******************************************************************************

void Message (char *string)
{
	int	h = 0,
			w = 0,
			mw = 0,
			i;
	byte *shape;

	shape = W_CacheLumpNum (W_GetNumForName ("newfnt1"), PU_CACHE);
	newfont1 = (font_t *)shape;
	CurrentFont = newfont1;
	h = CurrentFont->height;

	for (i = 0; i < strlen (string); i++)
		if (string[i] == '\n')
		{
			if (w > mw)
				mw = w;
			w = 0;
			h += CurrentFont->height;
		}
		else
			w += CurrentFont->width[string[i]-31];

	if ((w + 10) > mw)
		mw = w+10;

	PrintY = 78 - (h / 2);
	PrintX = WindowX = 143 - (mw / 2);
	WindowW = mw;

	EraseMenuBufRegion (WindowX-5, PrintY-5, (mw+14)&0xFFFC, h+10);
	DrawSTMenuBuf (WindowX-5, PrintY-5, (mw+14)&0xFFFC, h+10, true);

	MenuBufCPrint (string);
	RefreshMenuBuf (0);
}



//******************************************************************************
//
// DRAW NEW GAME MENU
//
//******************************************************************************

void DrawNewGame (void)
{
	MenuNum = 5;

	SetAlternateMenuBuf ();
	ClearMenuBuf ();
	SetMenuTitle ("Choose Difficulty");
	DrawMenu (&TufItems, &TufMenu[ToughMenuNum][0]);
	DrawNewGameDiff (TufItems.curpos);
	DisplayInfo (0);
	FlipMenuBuf();

}

//******************************************************************************
//
// DRAW NEW GAME GRAPHIC
//
//******************************************************************************

int newgameY[7] = {19, 0, 42, 0, 74, 0, 93};
char *DifficultyStrings[ 4 ] =
	{
	"Easy", "Medium", "Hard", "Crezzy Man"
	};

void DrawNewGameDiff
	(
	int w
	)

	{
	int x;

	switch ( w )
		{
		case 0:
			x = 0;
			break;

		case 2:
			x = 1;
			break;

		case 4:
			x = 2;
			break;

		case 6:
			x = 3;
			break;
		}

	EraseMenuBufRegion( 25, 18, 52, 125 );
	DrawMenuBufPic( 25, newgameY[ w ], W_GetNumForName( "NEWG1" ) +
		( ToughMenuNum * 4 ) + x );
	EraseMenuBufRegion( 25, 149, 64, 8 );
//	DrawMenuBufPic (25, 149, W_GetNumForName( "O_EASY" ) + x );

	CurrentFont = tinyfont;
	DrawMenuBufPropString( 25, 149, DifficultyStrings[ x ] );
	}


//******************************************************************************
//
// DRAW THE LOAD/SAVE SCREEN
//
//******************************************************************************

void DrawLoadSaveScreen (int loadsave)
{
	int i;
	byte *shape;

	shape = W_CacheLumpNum (W_GetNumForName ("newfnt1"), PU_CACHE);
	newfont1 = (font_t *)shape;
	CurrentFont = newfont1;

	if (numdone || (!ingame) || (!inmenu))
		SetAlternateMenuBuf();

	ClearMenuBuf();
	if (loadsave)
		{
		SetMenuTitle ("Save Game");
		}
	else
		{
		SetMenuTitle ("Load Game");
		}

	for (i = 0; i < NUMSAVEGAMES; i++)
		PrintLSEntry (i);
	DrawMenuBufItem (LSItems.x, ((LSItems.curpos*9)+(LSItems.y)),
		W_GetNumForName( SmallCursor ) + CursorFrame[ CursorNum ] );
	DisplayInfo (7);
	if ((!numdone) && ingame && inmenu)
		RefreshMenuBuf (0);
	else
		FlipMenuBuf();

	WaitKeyUp ();

	numdone++;
}

//******************************************************************************
//
// DRAW THE LOAD/SAVE SCREEN - no flip
//
//******************************************************************************

void DrawLoadSaveScreenAlt (int loadsave)
{
	int i;
	byte *shape;

	shape = W_CacheLumpNum (W_GetNumForName ("newfnt1"), PU_CACHE);
	newfont1 = (font_t *)shape;
	CurrentFont = newfont1;

	ClearMenuBuf();
	if (loadsave)
		{
		SetMenuTitle ("Save Game");
		}
	else
		{
		SetMenuTitle ("Load Game");
		}

	for (i = 0; i < NUMSAVEGAMES; i++)
		PrintLSEntry (i);
	DrawMenuBufItem (LSItems.x, ((LSItems.curpos*9)+(LSItems.y)),
		W_GetNumForName( SmallCursor ) + CursorFrame[ CursorNum ] );
	DisplayInfo (7);
	RefreshMenuBuf (0);

	WaitKeyUp ();

	numdone++;
}


//******************************************************************************
//
// PRINT LOAD/SAVE GAME ENTRY W/BOX OUTLINE
//
//******************************************************************************

void PrintLSEntry (int w)
{

	DrawSTMenuBuf (LSM_X+LSItems.indent, LSM_Y+1+w*9, 80, 7, false);

	PrintX = LSM_X+LSItems.indent+2;
	PrintY = LSM_Y+(w*9)+2;

	CurrentFont = tinyfont;

	if (SaveGamesAvail[w])
		DrawMenuBufPropString (PrintX, PrintY, SaveGameNames[w]);
	else
		DrawMenuBufPropString (PrintX, PrintY, "	  -  -");
}



//******************************************************************************
//
// CALIBRATE JOYSTICK
//
//******************************************************************************
int CalibrateJoystick
	(
	void
	)

	{
	#define CALX	45
	#define CALY	22

	word xmax, ymax, xmin, ymin, jb;
	int  checkbits;
	int  status;
	boolean done;

	if ( joypadenabled )
		{
		// Gravis GamePad : Check all buttons
		checkbits = ( 1 << 0 ) + ( 1 << 1 ) + ( 1 << 2 ) + ( 1 << 3 );
		}
	else if ( joystickport )
		{
		// Joystick port 2 : check only buttons 2 and 3
		checkbits = ( 1 << 2 ) + ( 1 << 3 );
		}
	else
		{
		// Joystick port 1 : check only buttons 0 and 1
		checkbits = ( 1 << 0 ) + ( 1 << 1 );
		}

	status = 0;
	done = false;
	while( !done )
		{
		SetAlternateMenuBuf();
		ClearMenuBuf();
		SetMenuTitle ("Calibrate Joystick");
		//DrawMenuBufItem( CALX, CALY, W_GetNumForName( "joystk2" ) );
		WindowW = 288;
		WindowH = 158;
		PrintX = WindowX = 0;
		PrintY = WindowY = 50;

		newfont1 = (font_t *)W_CacheLumpName( "newfnt1", PU_CACHE );
		CurrentFont = newfont1;
		MenuBufCPrint( "MOVE JOYSTICK TO\nUPPER LEFT AND\nPRESS A BUTTON." );

		DisplayInfo( 2 );
		FlipMenuBuf();

		do
			{
			RefreshMenuBuf( 0 );
			jb = IN_JoyButtons();
			IN_UpdateKeyboard();

			if ( Keyboard[ sc_Escape ] )
				{
				return( 0 );
				}
			}
		while( !( jb & checkbits ) );

		IN_GetJoyAbs( joystickport, &xmin, &ymin );
		MN_PlayMenuSnd( SD_SELECTSND );

		while( IN_JoyButtons() & checkbits )
			{
			IN_UpdateKeyboard();

			if ( Keyboard[ sc_Escape ] )
				{
				return( 0 );
				}
			}

		ClearMenuBuf();
//		DrawMenuBufItem( CALX, CALY, W_GetNumForName( "joystk1" ) );
		WindowW = 288;
		WindowH = 158;
		PrintX = WindowX = 0;
		PrintY = WindowY = 50;

		newfont1 = (font_t *)W_CacheLumpName( "newfnt1", PU_CACHE );
		CurrentFont = newfont1;
		MenuBufCPrint( "MOVE JOYSTICK TO\nLOWER RIGHT AND\nPRESS A BUTTON." );

		DisplayInfo( 2 );

		do
			{
			RefreshMenuBuf( 0 );
			jb = IN_JoyButtons();
			IN_UpdateKeyboard();

			if ( Keyboard[ sc_Escape ] )
				{
				return( 0 );
				}
			}
		while( !( jb & checkbits ) );

		IN_GetJoyAbs( joystickport, &xmax, &ymax );
		MN_PlayMenuSnd( SD_SELECTSND );

		while( IN_JoyButtons() & checkbits )
			{
			IN_UpdateKeyboard();

			if ( Keyboard[ sc_Escape ] )
				{
				return( 0 );
				}
			}

		//
		// ASSIGN ACTUAL VALUES HERE
		//
		if ( ( xmin < xmax ) && ( ymin < ymax ) )
			{
			IN_SetupJoy( joystickport, xmin, xmax, ymin, ymax );
			joyxmin = xmin;
			joyxmax = xmax;
			joyymin = ymin;
			joyymax = ymax;

			status = 1;
			done = true;
			}
		else
			{
			CP_ErrorMsg( "Joystick Error",
				"Calibration failed.  The joystick must be moved "
				"to the upper-left first and then the lower-right.",
				mn_smallfont );
			}
		}

	return( status );
	}


//******************************************************************************
//
// ADJUST MOUSE SENSITIVITY
//
//******************************************************************************

void MouseSensitivity
	(
	void
	)

	{
	SliderMenu( &mouseadjustment, 11, 0, 21, 81, 240, 1, "block1", NULL,
		"Mouse Sensitivity", "Slow", "Fast" );
	}

//******************************************************************************
//
// ADJUST MOUSE AND JOYSTICK THRESHOLD
//
//******************************************************************************

void DoThreshold
	(
	void
	)

	{
	SliderMenu (&threshold, 15, 1, 44, 81, 194, 1, "block2", NULL,
		"Adjust Threshold", "Small", "Large" );
	}

//******************************************************************************
//
// DRAW CONTROL MENU SCREEN
//
//******************************************************************************

void DrawCtlScreen (void)
{
	MenuNum = 3;

	if (numdone || (!ingame) || (!inmenu))
		SetAlternateMenuBuf();

	ClearMenuBuf();
	SetMenuTitle ("Options");


	DrawCtlButtons ();

	DisplayInfo (0);
	DrawMenu (&CtlItems, &CtlMenu[0]);
	DrawMenuBufItem (CtlItems.x, ((CtlItems.curpos*14)+(CtlItems.y-2)),
						W_GetNumForName( LargeCursor ) + CursorFrame[ CursorNum ] );

	if (ingame && inmenu && (!numdone))
		RefreshMenuBuf (0);
	else
		FlipMenuBuf();

	numdone++;
}


//******************************************************************************
//
// DrawCtlButtons ()
//
//******************************************************************************

void DrawCtlButtons (void)
{
	int i,
		 x,
		 y;
	static boolean first = true;
	int button_on;
	int button_off;

	button_on  = W_GetNumForName ("snd_on");
	button_off = W_GetNumForName ("snd_off");

	WindowX = 0;
	WindowW = 320;

	if (first)
	{
		if (JoysPresent[0] || JoysPresent[1])
			{
			CtlMenu[JOYENABLE].active = CP_Active;
			CtlMenu[USEPORT2].active  = CP_Active;
			CtlMenu[PADENABLE].active = CP_Active;
			CtlMenu[THRESSENS].active = CP_Active;
			}
		else
		{
			joystickenabled = 0;
			joypadenabled	= 0;
			joystickport	 = 0;
		}

		if (MousePresent)
		{
			CtlMenu[THRESSENS].active = CP_Active;
			CtlMenu[MOUSESENS].active = CP_Active;
			CtlMenu[MOUSEENABLE].active = CP_Active;
		}
		else
		{
			CtlMenu[0].active = CP_Inactive;
			mouseenabled = 0;
		}

//		if (SpaceBallPresent)
//			CtlMenu[SPACEBALLENABLE].active = CP_Active;

//		if (CybermanPresent)
//			CtlMenu[CYBERMANENABLE].active = CP_Active;

		for (x = 0; x < CtlItems.amount; x++)
		{
			if (CtlMenu[x].active)
			{
				CtlMenu[x].active = CP_CursorLocation;
				break;
			}
		}
		first = false;
	}

	x = CTL_X+CtlItems.indent-18;
	y = MENU_Y-1;

	if (mouseenabled)
		DrawMenuBufItem (x, y, button_on);
	else
	{
		EraseMenuBufRegion (x, y, 16, 16);
		DrawMenuBufItem  (x, y, button_off);
	}

	y += 14;
	if (joystickenabled)
		DrawMenuBufItem (x, y, button_on);
	else
	{
		EraseMenuBufRegion (x, y, 16, 16);
		DrawMenuBufItem (x, y, button_off);
	}

	y += 14;
	if (joystickport)
		DrawMenuBufItem (x, y, button_on);
	else
	{
		EraseMenuBufRegion (x, y, 16, 16);
		DrawMenuBufItem (x, y, button_off);
	}

	y += 14;
	if (joypadenabled)
		DrawMenuBufItem (x, y, button_on);
	else
	{
		EraseMenuBufRegion (x, y, 16, 16);
		DrawMenuBufItem (x, y, button_off);
	}

	y += 14;
//	if (spaceballenabled)
//		DrawMenuBufItem (x, y, button_on);
//	else
	{
		EraseMenuBufRegion (x, y, 16, 16);
		DrawMenuBufItem (x, y, button_off);
	}

	y += 14;
//	if (cybermanenabled)
//		DrawMenuBufItem (x, y, button_on);
//	else
	{
		EraseMenuBufRegion (x, y, 16, 16);
		DrawMenuBufItem (x, y, button_off);
	}


	if ((CtlItems.curpos < 0) || (!CtlMenu[CtlItems.curpos].active))
		for (i = 0; i < CtlItems.amount; i++)
			if (CtlMenu[i].active)
			{
				CtlItems.curpos = i;
				break;
			}

}

//******************************************************************************
//
// WAIT FOR CTRLKEY-UP OR BUTTON-UP
//
//******************************************************************************

void WaitKeyUp (void)
{
	ControlInfo ci;
	int timeout;

	IN_IgnoreMouseButtons();
	ReadAnyControl (&ci);
	
	timeout=ticcount+8;

	while (ci.button0 || ci.button1 || ci.button2 || ci.button3 ||
			 Keyboard[sc_Space] || Keyboard[sc_Enter] || Keyboard[sc_Escape])
	{
		ReadAnyControl (&ci);
		RefreshMenuBuf (0);
		if (Keystate[sc_CapsLock] && Keystate[sc_Q])
			Error("Stuck in WaitKeyUp\n");
		
		if(ticcount>=timeout)
		{
			IN_ClearKeysDown();
			break;
		}
	}
}

#define PMOUSE	 3
#define SMOUSE	 4

//******************************************************************************
//
// READ KEYBOARD, JOYSTICK AND MOUSE FOR INPUT
//
//******************************************************************************

void ReadAnyControl (ControlInfo *ci)
{
	IN_UpdateKeyboard ();
	IN_ReadControl (0, ci);

#if 0
	union REGS inregs;
	union REGS outregs;
	int mouseactive = 0;
	word buttons;
//	struct Spw_IntPacket packet;


	IN_UpdateKeyboard ();
	IN_ReadControl (0, ci);

	if (MousePresent && mouseenabled)
	{
		int mousey,
			 mousex;


		// READ MOUSE MOTION COUNTERS
		// RETURN DIRECTION
		// HOME MOUSE
		// CHECK MOUSE BUTTONS

		inregs.w.ax = PMOUSE;
		int386 (MouseInt, &inregs, &outregs);

		mousex = outregs.w.cx;
		mousey = outregs.w.dx;


		if (mousey < (CENTER-SENSITIVE))
		{
			ci->dir = dir_North;

			inregs.w.cx = CENTER;
			inregs.w.dx = CENTER;

			inregs.w.ax = SMOUSE;
			int386 (MouseInt, &inregs, &outregs);

			mouseactive = 1;

		}
		else
		if (mousey > (CENTER+SENSITIVE))
		{
			ci->dir = dir_South;

			inregs.w.cx = CENTER;
			inregs.w.dx = CENTER;

			inregs.w.ax = SMOUSE;
			int386 (MouseInt, &inregs, &outregs);

			mouseactive = 1;
		}

		if (mousex < (CENTER-SENSITIVE))
		{
			ci->dir = dir_West;

			inregs.w.cx = CENTER;
			inregs.w.dx = CENTER;

			inregs.w.ax = SMOUSE;
			int386 (MouseInt, &inregs, &outregs);


			mouseactive = 1;
		}
		else
		if (mousex > (CENTER+SENSITIVE))
		{
			ci->dir = dir_East;

			inregs.w.cx = CENTER;
			inregs.w.dx = CENTER;

			inregs.w.ax = SMOUSE;
			int386 (MouseInt, &inregs, &outregs);

			mouseactive = 1;
		}

		buttons = IN_GetMouseButtons();
		if ( buttons )
			{
			ci->button0 = buttons & 1;
			ci->button1 = buttons & 2;
			ci->button2 = buttons & 4;
			ci->button3 = false;
			mouseactive = 1;
			}
		}

	if (joystickenabled && !mouseactive)
	{
		int jx,jy,jb;


		INL_GetJoyDelta (joystickport, &jx, &jy);

		if (jy<-SENSITIVE)
			ci->dir=dir_North;
		else
		if (jy>SENSITIVE)
			ci->dir=dir_South;

		if (jx<-SENSITIVE)
			ci->dir=dir_West;
		else
		if (jx>SENSITIVE)
			ci->dir=dir_East;

		jb = IN_JoyButtons();
		if (jb)
		{
			ci->button0=jb&1;
			ci->button1=jb&2;
			if (joypadenabled)
			{
				ci->button2=jb&4;
				ci->button3=jb&8;
			}
			else
				ci->button2=ci->button3=false;
		}
	}


#if 0
//	if (SpaceBallPresent && spaceballenabled)
	{
		SP_Get(&packet);

		if (packet.button)
		{
			if (packet.button & SP_BTN_1)
				ci->button0 = true;

			if (packet.button & SP_BTN_2)
				ci->button1 = true;
		}

		if (packet.ty >  MENU_AMT)
			ci->dir = dir_North;
		else
			if (packet.ty < -MENU_AMT)
				ci->dir = dir_South;

		if (packet.tx < (-MENU_AMT* 6))
			ci->dir = dir_West;
		else
			if (packet.tx > (MENU_AMT * 6))
				ci->dir = dir_East;
	}
#endif

#endif

}


//******************************************************************************
//
// IN_GetScanName () - Returns a string containing the name of the
//							specified scan code
//
//******************************************************************************

byte * IN_GetScanName (ScanCode scan)
{
	byte	  **p;
	ScanCode *s;

	for (s = ExtScanCodes, p = ExtScanNames; *s; p++, s++)
		if (*s == scan)
			return (*p);

	return(ScanNames[scan]);
}


//******************************************************************************
//
// DisplayInfo ()
//
//******************************************************************************

void DisplayInfo (int which)
{
	patch_t *p;
	int x;
	int num;

	num = W_GetNumForName ( "info1" ) + which;
	p = (patch_t *) W_CacheLumpNum (num, PU_CACHE);

	x = (288 - p->width) >> 1;

	DrawMenuBufItem (x, 149, num);
}


//******************************************************************************
//
// DrawSTMenuBuf()
//
//******************************************************************************

void DrawSTMenuBuf (int x, int y, int w, int h, boolean up)
{
	if (!up)
	{
		DrawTMenuBufHLine (x,	y,	w+1, false);
		DrawTMenuBufVLine (x,	y+1, h-1, false);
		DrawTMenuBufHLine (x,	y+h, w+1, true);
		DrawTMenuBufVLine (x+w, y+1, h-1, true);
	}
	else
	{
		DrawTMenuBufHLine (x,	y,	w+1, true);
		DrawTMenuBufVLine (x,	y+1, h-1, true);
		DrawTMenuBufHLine (x,	y+h, w+1, false);
		DrawTMenuBufVLine (x+w, y+1, h-1, false);
	}
}


//****************************************************************************
//
// DoMainMenu ()
//
//****************************************************************************

void DoMainMenu (void)
{
	SetAlternateMenuBuf();
	ClearMenuBuf();
	DrawMainMenu();
	DrawMenuBufItem (MainItems.x,  ((MainItems.curpos*14)+(MainItems.y-2)),
						W_GetNumForName( LargeCursor ) + CursorFrame[ CursorNum ] );
	FlipMenuBuf();
}


//****************************************************************************
//
// DrawCustomMenu ()
//
//****************************************************************************

void DrawCustomMenu (void)
{
	MenuNum = 3;
	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Customize Menu");
	MN_GetCursorLocation( &CustomItems, &CustomMenu[ 0 ] );
	DrawMenu (&CustomItems, &CustomMenu[0]);
	DrawMenuBufItem (CustomItems.x, ((CustomItems.curpos*14)+(CustomItems.y-2)),
						W_GetNumForName( LargeCursor ) + CursorFrame[ CursorNum ] );
	DisplayInfo (0);
	FlipMenuBuf();
}



//****************************************************************************
//
// DrawCustomKeyboard ()
//
//****************************************************************************
void DrawCustomKeyboard (void)
{
	int i;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Customize Keyboard");

	for( i = 0; i < NormalKeyItems.amount; i++ )
		{
		strcpy( &NormalKeyNames[ i ][ KEYNAMEINDEX ],
			IN_GetScanName( buttonscan[ order[ i ] ] ) );
		}

	MN_GetCursorLocation( &NormalKeyItems, &NormalKeyMenu[ 0 ] );
	DrawMenu( &NormalKeyItems, &NormalKeyMenu[ 0 ] );

	DisplayInfo( 0 );
	FlipMenuBuf();
	}


//****************************************************************************
//
// MusicVolume ()
//
//****************************************************************************

void MusicVolume
	(
	void
	)

	{
	extern boolean SOUNDSETUP;

	SliderMenu( &MUvolume, 254, 0, 33, 81, 225, 8, "block3", MUSIC_SetVolume,
		"Music Volume", "Low", "High" );

	if ( SOUNDSETUP )
		{
		DrawSoundSetupMainMenu();
		}
	else
		{
		DrawControlMenu();
		}
	}


//****************************************************************************
//
// FXVolume ()
//
//****************************************************************************

void FXVolume
	(
	void
	)

	{
	extern boolean SOUNDSETUP;
	int oldvolume;

	oldvolume = FXvolume;

	SliderMenu( &FXvolume, 254, 0, 33, 81, 225, 8, "block3", FX_SetVolume,
		"Sound Volume", "Low", "High" );

	if ( SOUNDSETUP )
		{
		DrawSoundSetupMainMenu();
		}
	else
		{
		DrawControlMenu();
		}
	}



//****************************************************************************
//
// DrawPlayerMenu ()
//
//****************************************************************************

void DrawPlayerMenu (void)
{
	MenuNum = 5;


	MN_MakeActive( &PlayerItems, &PlayerMenu[0], DefaultPlayerCharacter );

#if ( SHAREWARE == 1 )
	PlayerMenu[ 1 ].active = CP_SemiActive; // Thi Barrett
	PlayerMenu[ 2 ].active = CP_SemiActive; // Doug Wendt
	PlayerMenu[ 3 ].active = CP_SemiActive; // Lorelei Ni
	PlayerMenu[ 4 ].active = CP_SemiActive; // Ian Paul Freeley
#endif

	if (numdone || (!ingame) || (!inmenu))
		SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Choose Player");

	DrawMenu (&PlayerItems, &PlayerMenu[0]);
	DrawNewPlayerDiff (PlayerItems.curpos);

	DisplayInfo (0);


	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}

	if (ingame && inmenu && (!numdone))
		RefreshMenuBuf (0);
	else
		FlipMenuBuf();
}

//******************************************************************************
//
// DRAW NEW PLAYER GRAPHIC
//
//******************************************************************************

int newplayerY[5] = {28, 42, 56, 70, 84};

void DrawNewPlayerDiff (int w)
{
	EraseMenuBufRegion (25, 18, 52, 125);
	DrawMenuBufPic (25, newplayerY[w], W_GetNumForName( "PLAYER1" ) + w );
}


//******************************************************************************
//
// MenuFixup ()
//
//******************************************************************************
void MenuFixup
	(
	void
	)

	{
	MainMenu[ viewscores ].texture[ 6 ] = '1';
	MainMenu[ viewscores ].texture[ 7 ] = '0';
	MainMenu[ viewscores ].texture[ 8 ] = '\0';
	MainMenu[ viewscores ].routine		= ( void * )CP_EndGame;
	MainMenu[ viewscores ].letter		 = 'E';
	MainMenuNames[ viewscores ]			= "END GAME";
	MainMenu[ savegame ].active			= CP_Active;
	ingame = true;
	}

//******************************************************************************
//
// GetEpisode ()
//
//******************************************************************************

int GetEpisode (int level)
{
	if (level < 8)
		gamestate.episode = 1;
	else
		if (level < 16)
			gamestate.episode = 2;
		else
			if (level < 24)
				gamestate.episode = 3;
			else
				gamestate.episode = 4;
	return(gamestate.episode);
}


//****************************************************************************
//
// DrawControlMenu ()
//
//****************************************************************************

void DrawControlMenu (void)
{
	MenuNum = 1;

	if (numdone || (!ingame) || (!inmenu))
		SetAlternateMenuBuf();

	ClearMenuBuf();
	SetMenuTitle ("Options");

	MN_GetCursorLocation( &ControlMItems, &ControlMMenu[ 0 ] );
	DrawMenu (&ControlMItems, &ControlMMenu[0]);
	DisplayInfo (0);

	if (ingame && inmenu && (!numdone))
		RefreshMenuBuf (0);
	else
		FlipMenuBuf();

	numdone ++;
}

//****************************************************************************
//
//  CP_ControlMenu ()
//
//****************************************************************************

void CP_ControlMenu (void)
{
	int which;

	DrawControlMenu();

	do
	{
		which = HandleMenu (&ControlMItems, &ControlMMenu[0], NULL);

	} while (which >= 0);

	handlewhich = OUTOFRANGE;
}



//****************************************************************************
//
// DrawOptionsMenu ()
//
//****************************************************************************

void DrawOptionsMenu (void)
{
	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("User Options");

	MN_GetCursorLocation( &OptionsItems, &OptionsMenu[ 0 ] );
	DrawMenu (&OptionsItems, &OptionsMenu[0]);
	DrawOptionsButtons ();
	DisplayInfo (0);
	FlipMenuBuf();
}

//****************************************************************************
//
// CP_OptionsMenu ()
//
//****************************************************************************

void CP_OptionsMenu (void)
{
	int which;

	DrawOptionsMenu();

	do
	{
		which = HandleMenu (&OptionsItems, &OptionsMenu[0], NULL);

		switch (which)
		{
			case 0: AutoDetailOn  ^= 1; DrawOptionsButtons (); break;
			case 1: fulllight	  ^= 1; DrawOptionsButtons (); break;
			case 2: BobbinOn		^= 1; DrawOptionsButtons (); break;
			case 3: fandc			^= 1; DrawOptionsButtons (); break;
		}

	} while (which >= 0);

	DrawControlMenu();
}

//****************************************************************************
//
// DrawOptionsButtons
//
//****************************************************************************

void DrawOptionsButtons (void)
{
	int i,
		 on;
	int button_on;
	int button_off;

	button_on  = W_GetNumForName ("snd_on");
	button_off = W_GetNumForName ("snd_off");

	for (i = 0; i < OptionsItems.amount-5; i++)
		if (OptionsMenu[i].active != CP_Active3)
		{
			//
			// DRAW SELECTED/NOT SELECTED GRAPHIC BUTTONS
			//

			on = 0;

			switch (i)
			{
				case 0: if (AutoDetailOn  == 1) on = 1; break;
				case 1: if (fulllight	  == 0) on = 1; break;
				case 2: if (BobbinOn		== 1) on = 1; break;
				case 3: if (fandc			== 1) on = 1; break;
			}

			if (on)
				DrawMenuBufItem (20+22, OptionsItems.y+i*14-1, button_on);
			else
				DrawMenuBufItem (20+22, OptionsItems.y+i*14-1, button_off);
		}
}


//****************************************************************************
//
// CP_DoubleClickSpeed()
//
//****************************************************************************

void CP_DoubleClickSpeed
	(
	void
	)

	{
	int temp;

	temp = 50 - ( DoubleClickSpeed - 5 );
	SliderMenu( &temp, 50, 5, 31, 81, 225, 3, "block1", NULL,
		"Double-Click Speed", "Slow", "Fast" );
	DoubleClickSpeed = 50 - ( temp - 5 );

	handlewhich = 100;
	DrawOptionsMenu();
	}

//****************************************************************************
//
// MenuFlipSpeed ()
//
//****************************************************************************

void MenuFlipSpeed
	(
	void
	)

	{
	int temp;

	temp = 50 - ( Menuflipspeed - 5 );

	SliderMenu( &temp, 50, 5, 31, 81, 225, 3, "block1", NULL,
		"Menu Flip Speed", "Slow", "Fast" );

	Menuflipspeed = 50 - ( temp - 5 );

	DrawOptionsMenu ();
	handlewhich = 10;
	}


//****************************************************************************
//
// DrawDetailMenu ()
//
//****************************************************************************

void DrawDetailMenu (void)
{
	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Detail Menu");

	MN_DrawButtons (&DetailItems, &DetailMenu[0], DetailLevel, OptionNums);
	MN_GetCursorLocation( &DetailItems, &DetailMenu[ 0 ] );
	DrawMenu (&DetailItems, &DetailMenu[0]);
	DisplayInfo (0);
	FlipMenuBuf();
}

//****************************************************************************
//
// CP_DetailMenu ()
//
//****************************************************************************

void CP_DetailMenu (void)
{
	int which;

	DrawDetailMenu();

	do
	{
		which = HandleMenu (&DetailItems, &DetailMenu[0], NULL);

		switch (which)
		{
			case 0:
				DetailLevel = 0;
				MN_DrawButtons (&DetailItems, &DetailMenu[0], DetailLevel, OptionNums);
			break;

			case 1:
				DetailLevel = 1;
				MN_DrawButtons (&DetailItems, &DetailMenu[0], DetailLevel, OptionNums);
			break;

			case 2:
				DetailLevel = 2;
				MN_DrawButtons (&DetailItems, &DetailMenu[0], DetailLevel, OptionNums);
			break;
		}

	} while (which >= 0);

	handlewhich = 10;
	DrawOptionsMenu();
}


//****************************************************************************
//
// DrawBattleMenu ()
//
//****************************************************************************

void DrawBattleMenu (void)
{
	MenuNum = 1;

	if (numdone || (!ingame) || (!inmenu))
		SetAlternateMenuBuf();

	ClearMenuBuf();
	SetMenuTitle ("Battle Menu");

	DrawBattleModeName( gamestate.battlemode );

	MN_GetCursorLocation( &BattleItems, &BattleMenu[ 0 ] );
	DrawMenu (&BattleItems, &BattleMenu[0]);
	DisplayInfo (0);

	BATTLE_SetOptions( &BATTLE_Options[ gamestate.battlemode ] );
	ShowBattleOptions( true, MENU_X, MENU_Y + 49 );

	if (ingame && inmenu && (!numdone))
		RefreshMenuBuf (0);
	else
		FlipMenuBuf();
}


//****************************************************************************
//
// BattleGamePlayerSetup()
//
//****************************************************************************

void BattleGamePlayerSetup( void )
	{
	int status;
	int pos;

	pos = 1;
	if ( consoleplayer == 0 )
		{
		pos = 0;
		}

	while( 1 )
		{
		switch( pos )
			{
			case 0 :
				// Select level to play on
				status = CP_LevelSelectionMenu ();
				if ( status >= 0  )
					{
					gamestate.mapon=status;
					pos = 1;
					}
				else
					{
					DrawBattleMenu();
					return;
					}
				break;

			case 1 :
				// Select CodeName
				status = CP_EnterCodeNameMenu();
				pos = 2;
				if ( !status )
					{
					if ( consoleplayer == 0 )
						{
						pos = 0;
						}
					else
						{
						return;
						}
					}
				break;

			case 2 :
				// Select character
				status = CP_PlayerSelection ();
				pos = 1;
				if ( status )
					{
					pos = 3;
					}
				break;

			case 3 :
				// Select color/team
				status = CP_ColorSelection();
				pos = 2;
				if ( status )
					{
					StartGame	= true;
					handlewhich = -2;
					playstate	= ex_resetgame;
					BATTLEMODE  = true;
					// Show please wait
					CP_ModemGameMessage( consoleplayer );
					return;
					}
				break;
			}
		}
	}


//****************************************************************************
//
// BattleNoTeams()
//
//****************************************************************************

void BattleNoTeams( void )
	{
	BattleGamePlayerSetup();
	if ( StartGame )
		{
		gamestate.teamplay = false;
		}
	}


//****************************************************************************
//
// BattleTeams()
//
//****************************************************************************

void BattleTeams( void )
	{
	BattleGamePlayerSetup();
	if ( StartGame )
		{
		gamestate.teamplay = true;
		}
	}


//****************************************************************************
//
// CP_BattleMenu ()
//
//****************************************************************************

void CP_BattleMenu (void)
{
	int which;

	gamestate.battlemode = handlewhich + battle_Normal;

	BattleMenu[0].active = CP_Active;
	BattleMenu[1].active = CP_Active;


	// Tag can't be played in team mode
	// Also, can't play teams if only 1 person is playing
	if ( ( gamestate.battlemode == battle_Tag ) ||
		( numplayers < 2 ) )
		{
		BattleMenu[1].active = CP_Inactive;
		if ( BattleItems.curpos == 1 )
			{
			BattleItems.curpos = 0;
			}
		}

	// Capture the Triad can only be played in team mode
	if ( gamestate.battlemode == battle_CaptureTheTriad )
		{
		BattleMenu[0].active = CP_Inactive;
		if ( BattleItems.curpos == 0 )
			{
			BattleItems.curpos = 1;
			}
		}

	BattleMenu[ BattleItems.curpos ].active = CP_CursorLocation;
	DrawBattleMenu();

	do
		{
		which = HandleMenu (&BattleItems, &BattleMenu[0], NULL);
		}
	while (which >= 0);

	if ( which == -1 )
		{
		DrawBattleModes ();
		handlewhich = OUTOFRANGE;
		}
	}


//****************************************************************************
//
// MN_PlayMenuSnd ()
//
//****************************************************************************

extern boolean dopefish;
void MN_PlayMenuSnd (int which)
{
	if (INFXSETUP || (SD_Started == false))
		return;
#if (SHAREWARE==0)
	if (dopefish==true)
		{
		switch (which)
			{
			case SD_ESCPRESSEDSND:
				which = SD_SOUNDESCSND;
			break;
			case SD_MOVECURSORSND:
				which = SD_SILLYMOVESND;
			break;
			case SD_SELECTSND:
				which = SD_SOUNDSELECTSND;
			break;
			}
		}
#endif
	SD_Play (which);
}


//******************************************************************************
//
// SliderMenu ()
//
//******************************************************************************

boolean SliderMenu
	(
	int *number,
	int upperbound,
	int lowerbound,
	int erasex,
	int erasey,
	int erasew,
	int numadjust,
	char *blockname,
	void ( *routine )( int w ),
	char *title,
	char *left,
	char *right
	)

	{
	ControlInfo ci;
	Direction	lastdir;
	patch_t	 *shape;
	boolean	  returnval;
	boolean	  moved;
	unsigned long scale;
	int			exit;
	int			range;
	int			timer;
	int			width;
	int			height;
	int			blkx;
	int			eraseh;
	int			block;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( title );

	newfont1 = (font_t *)W_CacheLumpName( "newfnt1", PU_CACHE);
	CurrentFont = newfont1;
	PrintX = 25;
	PrintY = 62;
	DrawMenuBufPropString( PrintX, PrintY, left );

	VW_MeasurePropString( right, &width, &height );
	DrawMenuBufPropString( 263 - width, PrintY, right );

	block = W_GetNumForName( blockname );
	shape = ( patch_t * )W_CacheLumpNum( block, PU_CACHE );
	blkx  = erasex - shape->leftoffset;
	eraseh =  shape->height;
	scale = ( erasew + shape->leftoffset - shape->width ) << 16;
	range = upperbound - lowerbound;

	DrawSTMenuBuf( erasex - 1, erasey - 1, erasew + 1, eraseh + 1, false );

	DrawMenuBufItem( blkx + ( ( ( ( *number - lowerbound ) *
		scale ) / range ) >> 16 ), erasey, block );

	DisplayInfo( 1 );
	FlipMenuBuf();

	exit  = 0;
	moved = false;
	timer = ticcount;
	lastdir = dir_None;

	do
		{
		RefreshMenuBuf( 0 );

		ReadAnyControl( &ci );
		if ( ( ( ticcount - timer ) > 5 ) || ( ci.dir != lastdir ) )
			{
			timer = ticcount;

			switch( ci.dir )
				{
				case dir_North:
				case dir_West:
					if ( *number > lowerbound )
						{
						*number = *number - numadjust;

						if ( *number < lowerbound )
							{
							*number = lowerbound;
							}

						moved = true;
						}
					break;

				case dir_South:
				case dir_East:
					if ( *number < upperbound )
						{
						*number = *number + numadjust;

						if ( *number > upperbound )
							{
							*number = upperbound;
							}

						moved = true;
						}
					break;
				}

			lastdir = ci.dir;
			}

		if ( moved )
			{
			moved = false;

			EraseMenuBufRegion( erasex, erasey, erasew, eraseh );

			DrawMenuBufItem( blkx + ( ( ( ( *number - lowerbound ) *
				scale ) / range ) >> 16 ), erasey, block );

			if ( routine )
				{
				routine( *number );
				}

			MN_PlayMenuSnd( SD_MOVECURSORSND );
			}

		if ( ci.button0 || Keyboard[ sc_Space ] || Keyboard[ sc_Enter ] )
			{
			exit = 1;
			}
		else if ( ci.button1 || Keyboard[ sc_Escape ] )
			{
			exit = 2;
			}
		}
	while( !exit );

	if ( exit == 2 )
		{
		MN_PlayMenuSnd( SD_ESCPRESSEDSND );
		returnval = false;
		}
	else
		{
		MN_PlayMenuSnd( SD_SELECTSND );
		returnval = true;
		}

	WaitKeyUp ();
	return( returnval );
	}


//******************************************************************************
//
// DrawF1Help ()
//
//******************************************************************************

void DrawF1Help (void)
{

	VL_DrawPostPic (W_GetNumForName("trilogo"));

	DrawNormalSprite (0, 0, W_GetNumForName("help"));

	VW_UpdateScreen ();
}

//******************************************************************************
//
// CP_F1Help ()
//
//******************************************************************************

void CP_F1Help (void)
{
	LastScan=0;

	DrawF1Help ();

	while (LastScan == 0)
	{
		IN_UpdateKeyboard ();
	}

	LastScan=0;
#if (SHAREWARE==1)
	{
	DrawOrderInfo( 2 );
	while (LastScan == 0)
	{
		IN_UpdateKeyboard ();
	}

	LastScan=0;
	}
#endif
}


//****************************************************************************
//
// CP_ScreenSize()
//
//****************************************************************************

void CP_ScreenSize
	(
	void
	)

	{
	SliderMenu( &viewsize, MAXVIEWSIZES - 1, 0, 33, 81, 225, 1, "block1",
		NULL, "Screen Size", "Small", "Large" );

	handlewhich = 100;
	DrawOptionsMenu();
	}


//****************************************************************************
//
// DrawViolenceMenu ()
//
//****************************************************************************

void DrawViolenceMenu (void)
{
	MenuNum = 1;
	if ( POK )
		{
		memcpy( &VMenu[ 1 ].texture, "mcpass\0", 7 );
		VMenu[ 1 ].letter = 'C';
		VMenuNames[ 1 ]	= "CHANGE PASSWORD";
		}
	else
		{
		memcpy( &VMenu[ 1 ].texture, "mepass\0", 7 );
		VMenu[ 1 ].letter = 'E';
		VMenuNames[ 1 ]	= "ENTER PASSWORD";
		}

	if (VMenu[0].active != CP_CursorLocation)
		VMenu[0].active = CP_Active;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Violence Level");

	MN_GetCursorLocation( &VItems, &VMenu[ 0 ] );
	DrawMenu (&VItems, &VMenu[0]);
	DisplayInfo (0);
	FlipMenuBuf();
}


//****************************************************************************
//
// CP_ViolenceMenu ()
//
//****************************************************************************

void CP_ViolenceMenu (void)
{
	int which;

	CurrentFont = smallfont;
	DrawViolenceMenu ();

	do
	{
		which = HandleMenu (&VItems, &VMenu[0], NULL);

	} while (which >= 0);

	handlewhich = 100;
	DrawOptionsMenu();
}


//****************************************************************************
//
// DrawViolenceLevel ()
//
//****************************************************************************

void DrawViolenceLevel (void)
{
	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Change Violence Level");

	MN_DrawButtons (&ViolenceItems, &ViolenceMenu[0], gamestate.violence, OptionNums);
	MN_GetActive (&ViolenceItems, &ViolenceMenu[0], gamestate.violence, OptionNums);

//	DrawMenuBufItem (58, 24, W_GetNumForName ("blood"));
	IFont = ( cfont_t * )W_CacheLumpName( FontNames[ mn_largefont ],
		PU_CACHE );
	DrawMenuBufIString( 58, 24, "HOW MUCH ", NORMALCOLOR );
	DrawMenuBufIString( PrintX, PrintY, "BLOOD", 51 );
	DrawMenuBufIString( 71, 37, "DO YOU WANT?", NORMALCOLOR );

	DrawMenu (&ViolenceItems, &ViolenceMenu[0]);
	DisplayInfo (0);
	FlipMenuBuf();
}


//****************************************************************************
//
// CP_ViolenceLevel ()
//
//****************************************************************************

void CP_ViolenceLevel (void)
{
	int which;
	char p1[13];
	boolean passok=false;

	if (ingame)
		{
		CP_ErrorMsg( "Change Violence Level",
			"The current game must be ended to change the Violence Level.",
			mn_largefont );
		}
	else if ( POK )
		{
		memset (p1, 0, 13);

		CurrentFont = smallfont;
		DrawViolenceLevelPWord ();

		if (US_lineinput (PBOXX+2, PBOXY+1, p1, NULL, true, 12, 110, 0))
			{
			//compare user entered to password
			if (StringsNotEqual (p1, pword, StringLength (p1)) == false)
				passok=true;
			else
				{
				CP_ErrorMsg( "Violence Password", "Incorrect Password.",
					mn_largefont );
				}
			}
		}
	else
		passok=true;
	if (passok==true)
		{
		DrawViolenceLevel ();
		do
			{
			which = HandleMenu (&ViolenceItems, &ViolenceMenu[0], NULL);

			if (which >= 0)
				gamestate.violence = which;

			MN_DrawButtons (&ViolenceItems, &ViolenceMenu[0], gamestate.violence, OptionNums);

			} while (which >= 0);

		WriteMenuInfo ();
		}

	handlewhich = 100;
	DrawViolenceMenu();
}



//****************************************************************************
//
// DrawViolenceLevelPWord ();
//
//****************************************************************************

void DrawViolenceLevelPWord
	(
	void
	)

	{
	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Violence Password" );

//	CurrentFont = newfont1;
//	DrawMenuBufPropString( PWORDX, PWORDY, "ENTER PASSWORD" );

	IFont = ( cfont_t * )W_CacheLumpName( FontNames[ mn_largefont ],
		PU_CACHE );
	DrawMenuBufIString( PWORDX, PWORDY, "ENTER PASSWORD", NORMALCOLOR );

	DrawSTMenuBuf( PBOXX, PBOXY, PBOXW, PBOXH, false );
	FlipMenuBuf();
	}



//****************************************************************************
//
// DrawPWMenu ()
//
//****************************************************************************

void DrawPWMenu
	(
	void
	)

	{
	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Violence Password" );

//	CurrentFont = newfont1;
	IFont = ( cfont_t * )W_CacheLumpName( FontNames[ mn_largefont ],
		PU_CACHE );

	if ( POK )
		{
//		DrawMenuBufPropString( PWORDX - 24, PWORDY, "ENTER OLD PASSWORD" );
		DrawMenuBufIString( PWORDX - 24, PWORDY, "ENTER OLD PASSWORD", NORMALCOLOR );
		}
	else
		{
//		DrawMenuBufPropString( PWORDX - 24, PWORDY, "ENTER PASSWORD" );
		DrawMenuBufIString( PWORDX - 24, PWORDY, "ENTER PASSWORD", NORMALCOLOR );
		}

	DrawSTMenuBuf( PBOXX, PBOXY, PBOXW, PBOXH, false );
	FlipMenuBuf();
	}


//****************************************************************************
//
// CP_PWMenu ()
//
//****************************************************************************

void CP_PWMenu (void)
	{
	char p1[13];
	char p2[13];
	boolean EnterNewPassword;
	boolean AskForNew;
	boolean RetypePassword;

	memset (p1, 0, 13);
	memset (p2, 0, 13);

	CurrentFont = smallfont;

	EnterNewPassword = true;
	if ( POK )
		{
		DrawPWMenu ();

		// get old password
		//
		EnterNewPassword = false;
		if (US_lineinput (PBOXX+2, PBOXY+1, p1, NULL, true, 12, PSTRW, 0))
			{
			//compare user entered to old
			//
			if (StringsNotEqual (p1, pword, StringLength (p1))==false)
				{

				// Password was correct so they may change it.
				EnterNewPassword = true;
				}
			else
				{
				CP_ErrorMsg( "Violence Password", "Incorrect Password.",
					mn_largefont );
				}
			}
		}

	if ( EnterNewPassword )
		{
		MenuNum = 1;

		// get new password
		//
		AskForNew = true;
		RetypePassword = false;
		while( AskForNew )
			{
			CurrentFont = smallfont;

			SetAlternateMenuBuf ();
			ClearMenuBuf();
			SetMenuTitle ("Violence Password");

			IFont = ( cfont_t * )W_CacheLumpName( FontNames[ mn_largefont ],
				PU_CACHE );
			DrawMenuBufIString( PWORDX - 24, PWORDY, "ENTER NEW PASSWORD", NORMALCOLOR );

//			CurrentFont = newfont1;
//			DrawMenuBufPropString( PWORDX - 24, PWORDY, "ENTER NEW PASSWORD" );
//			DrawMenuBufItem (PWORDX-24, PWORDY, W_GetNumForName ("mnewpass"));

			DrawSTMenuBuf (PBOXX, PBOXY, PBOXW, PBOXH, false);
			FlipMenuBuf();

			memset (p1, 0, 13);

			AskForNew = false;
			if (US_lineinput (PBOXX+2, PBOXY+1, p1, NULL, true, 12, PSTRW, 0))
				{
				// Check for blank password
				if ( p1[ 0 ] == 0 )
					{
					if ( CP_DisplayMsg ( "Clear Password?\nAre you sure?", 12 ) )
						{
						AskForNew = false;
						memset (pword, 0, 13);
						WriteMenuInfo ();
						POK = false;
						}
					else
						{
						AskForNew = true;
						}
					}
				else
					{
					RetypePassword = true;
					}
				}
			}

		if ( RetypePassword )
			{
			SetAlternateMenuBuf();
			ClearMenuBuf();
			SetMenuTitle ("Violence Password");

//			CurrentFont = newfont1;
//			DrawMenuBufPropString( PWORDX, PWORDY, "RETYPE PASSWORD" );

			IFont = ( cfont_t * )W_CacheLumpName( FontNames[ mn_largefont ],
				PU_CACHE );
			DrawMenuBufIString( PWORDX, PWORDY, "RETYPE PASSWORD", NORMALCOLOR );

			DrawSTMenuBuf (PBOXX, PBOXY, PBOXW, PBOXH, false);

			FlipMenuBuf();

			// reenter password
			//
			if ( US_lineinput (PBOXX+2, PBOXY+1, p2, NULL, true, 12, PSTRW, 0) )
				{
				// compare password and retyped password
				//
				if (stricmp (p1, p2) == 0)
					{
					memset (pword, 0, 13);
					strcpy (pword, p1);
					WriteMenuInfo ();

					// If we have a null password, then we don't need to
					// ask for one.
					POK = true;
					if ( pword[ 0 ] == 0 )
						{
						POK = false;
						}
					}
				else
					{
					CP_ErrorMsg( "Violence Password", "Passwords did not match.",
						mn_largefont );
					}
				}
			}
		}

	DrawViolenceMenu ();
	}

//****************************************************************************
//
// DrawOptionDescription()
//
//****************************************************************************

void DrawOptionDescription( char ** options, int w )
	{
	int	  width;
	int	  height;
	char	*string;
	font_t *temp;

	EraseMenuBufRegion (25, 4, 287 - 25, 10 );

	temp = CurrentFont;
	CurrentFont = tinyfont;

	string = options[ w ];

	VW_MeasurePropString ( string, &width, &height );
	DrawMenuBufPropString ( ( 288 - width) / 2, 4, string );

	CurrentFont = temp;
	}

//****************************************************************************
//
// DrawBattleOptionDescription()
//
//****************************************************************************

void DrawBattleOptionDescription( int w )
	{
	DrawOptionDescription( BattleOptionDescriptions, w );
	}
//****************************************************************************
//
// DrawGravityOptionDescription()
//
//****************************************************************************

void DrawGravityOptionDescription( int w )
	{
	DrawOptionDescription( GravityOptionDescriptions, w );
	}
//****************************************************************************
//
// DrawSpeedOptionDescription()
//
//****************************************************************************

void DrawSpeedOptionDescription( int w )
	{
	DrawOptionDescription( SpeedOptionDescriptions, w );
	}
//****************************************************************************
//
// DrawAmmoOptionDescription()
//
//****************************************************************************

void DrawAmmoOptionDescription( int w )
	{
	DrawOptionDescription( AmmoOptionDescriptions, w );
	}
//****************************************************************************
//
// DrawHitPointsOptionDescription()
//
//****************************************************************************

void DrawHitPointsOptionDescription( int w )
	{
	DrawOptionDescription( HitPointsOptionDescriptions, w );
	}
//****************************************************************************
//
// DrawRadicalOptionDescription()
//
//****************************************************************************

void DrawRadicalOptionDescription( int w )
	{
	DrawOptionDescription( RadicalOptionDescriptions, w );
	}
//****************************************************************************
//
// DrawLightLevelOptionDescription()
//
//****************************************************************************

void DrawLightLevelOptionDescription( int w )
	{
	DrawOptionDescription( LightLevelOptionDescriptions, w );
	}
//****************************************************************************
//
// DrawPointGoalOptionDescription()
//
//****************************************************************************

void DrawPointGoalOptionDescription( int w )
	{
	DrawOptionDescription( PointGoalOptionDescriptions, w );
	}
//****************************************************************************
//
// DrawDangerDamageOptionDescription()
//
//****************************************************************************

void DrawDangerDamageOptionDescription( int w )
	{
	DrawOptionDescription( DangerDamageOptionDescriptions, w );
	}

//****************************************************************************
//
// DrawTimeLimitOptionDescription()
//
//****************************************************************************

void DrawTimeLimitOptionDescription( int w )
	{
	DrawOptionDescription( TimeLimitOptionDescriptions, w );
	}



#define TURN_OFF_BATTLE_MODE( x ) \
	ModeMenu[ ( x ) - 1 ].active  = CP_SemiActive; \
	ModeMenu[ ( x ) - 1 ].routine = NULL;


//****************************************************************************
//
// DrawBattleModes ()
//
//****************************************************************************
void DrawBattleModes
	(
	void
	)

	{
	int i;

	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Battle Modes");


	MN_GetActive( &ModeItems, &ModeMenu[ 0 ], gamestate.battlemode -
		battle_Normal, OptionNums );

	#if ( SHAREWARE == 1 )
		TURN_OFF_BATTLE_MODE( battle_ScoreMore );
		TURN_OFF_BATTLE_MODE( battle_Scavenger );
		TURN_OFF_BATTLE_MODE( battle_Tag );
		TURN_OFF_BATTLE_MODE( battle_Eluder );
		TURN_OFF_BATTLE_MODE( battle_Deluder );
		TURN_OFF_BATTLE_MODE( battle_CaptureTheTriad );
	#endif

	// Capture the Triad, Tag, ScoreMore, and Hunter can only be
	// played with 2 or more players
	if ( numplayers < 2 )
		{
		TURN_OFF_BATTLE_MODE( battle_ScoreMore );
		TURN_OFF_BATTLE_MODE( battle_Tag );
		TURN_OFF_BATTLE_MODE( battle_Hunter );
		TURN_OFF_BATTLE_MODE( battle_CaptureTheTriad );
		}

	if ( ModeMenu[ ModeItems.curpos ].active != CP_CursorLocation )
		{
		for( i = 0; i < ModeItems.amount; i++ )
			{
			if ( ModeMenu[ i ].active == CP_Active )
				{
				ModeItems.curpos = i;
				ModeMenu[ i ].active = CP_CursorLocation;
				break;
				}
			}
		}

	DrawMenu( &ModeItems, &ModeMenu[ 0 ] );
	DisplayInfo( 0 );
	DrawBattleModeDescription( ModeItems.curpos );

	FlipMenuBuf();
	}



//****************************************************************************
//
// DrawBattleModeName()
//
//****************************************************************************

void DrawBattleModeName( int which )
	{
	int	  width;
	int	  height;
	char	*string;
	font_t *temp;


	if ( ( which < battle_Normal ) || ( which > battle_CaptureTheTriad ) )
		{
		return;
		}

	string = BattleModeNames[ which - battle_Normal ];

	temp = CurrentFont;
	CurrentFont = tinyfont;

	VW_MeasurePropString ( string, &width, &height );
	DrawMenuBufPropString ( ( 288 - width ) / 2, 4, string );
//	DrawMenuBufPropString ( 270-width, 4, string );

	CurrentFont = temp;
	}


//****************************************************************************
//
// DrawBattleModeDescription()
//
//****************************************************************************

void DrawBattleModeDescription( int w )
	{
	int	  width;
	int	  height;
	char	*string;
	font_t *temp;

	EraseMenuBufRegion (25, 4, 287 - 25, 10 );

	temp = CurrentFont;
	CurrentFont = tinyfont;

	string = BattleModeDescriptions[ w ];

	// Capture the Triad, Tag, ScoreMore, and Hunter can only be
	// played with 2 or more players
	if ( numplayers < 2 )
		{
		switch( w + 1 )
			{
			case battle_ScoreMore :
			case battle_Tag :
			case battle_Hunter :
			case battle_CaptureTheTriad :
				string = "This mode can only be played with 2 or more players.";
				break;
			}
		}

	#if ( SHAREWARE == 1 )
		switch( w + 1 )
			{
			case battle_ScoreMore :
			case battle_Scavenger :
			case battle_Tag :
			case battle_Eluder :
			case battle_Deluder :
			case battle_CaptureTheTriad :
				string = "See Ordering Info to find out how to get this game.";
				break;
			}
	#endif

	VW_MeasurePropString ( string, &width, &height );
	DrawMenuBufPropString ( ( 288 - width ) / 2, 4, string );

	CurrentFont = temp;
	}


//****************************************************************************
//
// CP_BattleModes ()
//
//****************************************************************************

void CP_BattleModes ( void )
	{
	int which;
	static char Warning = 0;

	//
	// ALREADY IN A GAME?
	//
	if ( ingame )
		{
		if ( !CP_DisplayMsg( CURGAME, 12 ) )
			{
			return;
			}
		else
			{
			EndGameStuff();
			}
		}

	if ( ( numplayers==1 ) && ( Warning == 0 ) )
		{
		Warning = 1;
		CP_OnePlayerWarningMessage();
		}

	DrawBattleModes ();

	damagecount = 0;
	BATTLEMODE  = true;

	do
		{
		which = HandleMenu( &ModeItems, &ModeMenu[ 0 ],
			DrawBattleModeDescription );
		}
	while ( which >= 0 );

	handlewhich = 100;

	if ( !StartGame )
		{
		BATTLEMODE = false;
		gamestate.battlemode = battle_StandAloneGame;
		}
	}

//****************************************************************************
//
// DrawBattleOptions ()
//
//****************************************************************************

void DrawBattleOptions (void)
{
	int i;

	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Battle Mode Options");

	MN_MakeActive ( &BOptItems, &BOptMenu[0], BOptItems.curpos );

	switch( gamestate.battlemode )
		{
		case battle_Collector :
			BOptMenu[2].active = CP_Inactive; // Ammo
			BOptMenu[6].active = CP_Inactive; // Point Goal
			break;

		case battle_Scavenger :
			BOptMenu[6].active = CP_Inactive; // Point Goal
			break;

		case battle_Tag :
			BOptMenu[2].active = CP_Inactive; // Ammo
			break;

		case battle_Eluder :
			BOptMenu[2].active = CP_Inactive; // Ammo
			BOptMenu[3].active = CP_Inactive; // Hit points
			BOptMenu[7].active = CP_Inactive; // Danger damage
			break;
		}

	if ( BOptMenu[ BOptItems.curpos ].active == CP_Inactive )
		{
		// Find an available cursor position
		for( i = 0; i < BOptItems.amount; i++ )
			{
			if ( BOptMenu[ i ].active == CP_Active )
				{
				BOptMenu[ i ].active = CP_CursorLocation;
				BOptItems.curpos = i;
				break;
				}
			}
		}

	DrawBattleModeName( gamestate.battlemode );
	DrawBattleOptionDescription( BOptItems.curpos );
	DrawMenu (&BOptItems, &BOptMenu[0]);
	DisplayInfo (0);
	FlipMenuBuf();
}


//****************************************************************************
//
// CP_BattleOptions ()
//
//****************************************************************************

void CP_BattleOptions (void)
{
	int which;

	DrawBattleOptions ();

	do
	{
		which = HandleMenu (&BOptItems, &BOptMenu[0], DrawBattleOptionDescription);

	} while (which >= 0);

	handlewhich = 100;
//	WriteBattleConfig();
	CalcTics();

	DrawBattleMenu ();
}



//****************************************************************************
//
// DrawColorMenu ()
//
//****************************************************************************


void DrawColorMenu( void )
	{
	int	width;
	int	height;
	char *text;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Uniform Color");

	CurrentFont = smallfont;

	text = colorname[ locplayerstate->uniformcolor ];
	VW_MeasurePropString ( text, &width, &height );
	DrawMenuBufPropString ( ( 320 - width ) / 2 - 16, MENU_Y + 5, text );
	DisplayInfo( 8 );
	EraseMenuBufRegion( COLORX, COLORY, COLORW, COLORH );
	DrawTMenuBufBox( COLORX, COLORY, COLORW, COLORH );
	DrawColoredMenuBufItem( COLORX - 36, COLORY - 33,
		W_GetNumForName( playerwadname[ locplayerstate->player ] ),
		locplayerstate->uniformcolor);


	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}

	FlipMenuBuf();
	}


//****************************************************************************
//
// CP_ColorSelection ()
//
//****************************************************************************

int CP_ColorSelection (void)
{
	int status;

	locplayerstate->uniformcolor = DefaultPlayerColor;

	DrawColorMenu ();
	status = ColorMenu();
	return( status );
}

int ColorMenu
	(
	void
	)

	{
	ControlInfo ci;
	int colorindex;
	char *text;
	int width;
	int height;
	int timer;
	int baseshape;
	int status;
	boolean update;
	boolean done;

	colorindex = DefaultPlayerColor;
	timer		= ticcount;
	baseshape  = W_GetNumForName( playerwadname[ locplayerstate->player ] );

	update = false;
	done	= false;
	while( !done )
		{
		ReadAnyControl( &ci );
		if ( ( ci.dir == dir_East ) && ( ( ticcount - timer ) > 5 ) )
			{
			update = true;
			timer = ticcount;

			colorindex++;
			if ( colorindex >= MAXPLAYERCOLORS )
				{
				colorindex = 0;
				}

			MN_PlayMenuSnd( SD_MOVECURSORSND );
			}

		if ( ( ci.dir == dir_West ) && ( ( ticcount - timer ) > 5 ) )
			{
			update = true;
			timer = ticcount;

			colorindex--;
			if ( colorindex < 0 )
				{
				colorindex = MAXPLAYERCOLORS - 1;
				}
			MN_PlayMenuSnd( SD_MOVECURSORSND );
			}

		if ( update )
			{
			update = false;
			DefaultPlayerColor = colorindex;
			locplayerstate->uniformcolor = colorindex;
			text = colorname[ locplayerstate->uniformcolor ];

			EraseMenuBufRegion( 0, MENU_Y + 5, 200, 10 );
			EraseMenuBufRegion( COLORX, COLORY, COLORW, COLORH );
			VW_MeasurePropString( text, &width, &height );
			DrawMenuBufPropString( ( 320 - width ) / 2 - 16, MENU_Y + 5, text );
			DrawTMenuBufBox( COLORX, COLORY, COLORW, COLORH );
			DrawColoredMenuBufItem( COLORX - 36, COLORY - 33,
				baseshape, locplayerstate->uniformcolor );
			}

		if ( ci.button0 || Keyboard[ sc_Space ] || Keyboard[sc_Enter ] )
			{
			Keyboard[ sc_Space ] = 0;
			Keyboard[ sc_Enter ] = 0;
			MN_PlayMenuSnd( SD_SELECTSND );
			status = 1;
			done = true;
			}
		else if ( ci.button1 || Keyboard[ sc_Escape ] )
			{
			MN_PlayMenuSnd( SD_ESCPRESSEDSND );
			status = 0;
			done = true;
			}

		RefreshMenuBuf( 0 );
		}

	IN_ClearKeysDown();
	return( status );
	}


//****************************************************************************
//
// CP_PlayerSelection ()
//
//****************************************************************************
int CP_PlayerSelection
	(
	void
	)

	{
	int which;

	// Do Pick-A-Player menu
	DrawPlayerMenu();

	do
		{
		which = HandleMenu( &PlayerItems, &PlayerMenu[ 0 ], DrawNewPlayerDiff );
		if ( which < 0 )
			{
			handlewhich = 1;
			return( 0 );
			}

		#if ( SHAREWARE == 1 )
			if ( PlayerMenu[ which ].active == CP_SemiActive )
				{
				CP_ErrorMsg( "Choose Player",
					"Read the Ordering Info section from the Main Menu to "
					"find out how to get the other characters.",
					mn_smallfont );

				DrawPlayerMenu();
				}
		#endif
		}
	while( PlayerMenu[ which ].active == CP_SemiActive );


#if ( SHAREWARE == 1 )
	DefaultPlayerCharacter = 0;
	locplayerstate->player = 0;
#else
	DefaultPlayerCharacter = which;
	locplayerstate->player = which;
#endif

	return (1);
}

//****************************************************************************
//
// CP_OnePlayerWarningMessage ()
//
//****************************************************************************

void CP_OnePlayerWarningMessage
	(
	void
	)

	{
	CP_ErrorMsg( "Comm-bat Warning",
		"Comm-bat is designed for modem and network play.  "
		"One player mode is provided for exploration.  The "
		"Collector battle mode is still fun on your own.",
		mn_smallfont );
	}


//****************************************************************************
//
// CP_CaptureTheTriadError()
//
//****************************************************************************

void CP_CaptureTheTriadError
	(
	void
	)

	{
	SetupMenuBuf();
	SetUpControlPanel();

	CP_ErrorMsg( "Comm-bat Warning",
		"Capture the Traid can only be played with 2 teams."
		"  All players must return to the menu to choose their "
		"team colors.", mn_largefont );

	CleanUpControlPanel();
	ShutdownMenuBuf();
	}


//****************************************************************************
//
// CP_TeamPlayErrorMessage()
//
//****************************************************************************

void CP_TeamPlayErrorMessage
	(
	void
	)

	{
	SetupMenuBuf();
	SetUpControlPanel();

	CP_ErrorMsg( "Comm-bat Warning",
		"Team play can only be played with 2 or more teams."
		"  All players must return to the menu to choose their "
		"team colors.", mn_largefont );

	CleanUpControlPanel();
	ShutdownMenuBuf();
	}


//****************************************************************************
//
// CP_ModemGameMessage ()
//
//****************************************************************************

#if (SITELICENSE == 0)

#define SITELINES 8

char *sitemessage[] =
	{
	"HEY! ARE YOU PLAYING ON AN ILLEGAL COPY?",
	"Network players: it's easy to play legally!",
	"Just get a site license.  For a little over",
	"the price of two games, you get 10 more battle",
	"levels, 11 command cards, and a signed Site",
	"License.  We don't charge you for 11 copies--",
	"just for two!  Call 1-800-APOGEE1 to order.",
	"For more on site licenses, see ORDERING INFO."
	};

#endif

void CP_ModemGameMessage
	(
	int player
	)

	{
	int i;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Game Message");

	newfont1 = (font_t *)W_CacheLumpName( "newfnt1", PU_CACHE);
	CurrentFont = newfont1;
	if ( modemgame == false )
		{
		WindowW = 288;
		WindowH = 158;
		PrintX = WindowX = 0;
		PrintY = WindowY = 60;
		MenuBufCPrint ("Please wait.\nLoading game.");
		}
	else
		{
		WindowW = 288;
		WindowH = 158;
		PrintX = WindowX = 0;
		PrintY = WindowY = 50;

		if (networkgame==true)
			{
			PrintY = WindowY = 28;
			}

		if ( player == 0 )
			{
			MenuBufCPrint ("Please wait for\nplayers to choose\ntheir characters.");
			}
		else
			{
			MenuBufCPrint ("Please wait while\nMaster selects\nCOMM-BAT options.");
			}

#if (SITELICENSE == 0)
		if (networkgame==true)
			{
			for( i = 0; i < SITELINES; i++ )
				{
				PrintBattleOption( true, 68, 77 + i * 8,
					sitemessage[ i ] );
				}
			}
#endif
		}

	FlipMenuBuf();
	RefreshMenuBuf (0);
	}


//****************************************************************************
//
// DrawGravityMenu ()
//
//****************************************************************************

void DrawGravityMenu (void)
{
	MenuNum = 1;

	SetAlternateMenuBuf ();
	ClearMenuBuf();
	SetMenuTitle ("Gravity");


	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}

	MN_DrawButtons (&GravityItems, &GravityMenu[0],
		BATTLE_Options[gamestate.battlemode].Gravity, GravityNums);
	MN_GetActive (&GravityItems, &GravityMenu[0],
		BATTLE_Options[gamestate.battlemode].Gravity, GravityNums);

	DrawMenu (&GravityItems, &GravityMenu[0]);
	DrawGravityOptionDescription( GravityItems.curpos );
	PrintBattleOption( true, 32, 79,
		"WARNING: High gravity has an unfortunate side effect in" );
	PrintBattleOption( true, 32, 87,
		"some levels.  It is possible to jump into an area that is" );
	PrintBattleOption( true, 32, 95,
		"impossible, or at least extremely difficult to get out" );
	PrintBattleOption( true, 32, 103,
		"of.  In these situations, the only thing you can do is" );
	PrintBattleOption( true, 32, 111,
		"kill your character, or find some kindly soul to do it" );
	PrintBattleOption( true, 32, 119,
		"for you.  If this fails, you'll just have to end your game." );

	DisplayInfo( 0 );

	FlipMenuBuf();
}


//****************************************************************************
//
// CP_GravityOptions ()
//
//****************************************************************************

void CP_GravityOptions (void)
{
	int which;

	DrawGravityMenu ();

	do
	{
		which = HandleMenu (&GravityItems, &GravityMenu[0], DrawGravityOptionDescription);

		if (which >= 0)
		  BATTLE_Options[gamestate.battlemode].Gravity = GravityNums[ which ];

		MN_DrawButtons (&GravityItems, &GravityMenu[0],
			BATTLE_Options[gamestate.battlemode].Gravity, GravityNums);

	} while (which >= 0);

	handlewhich = 100;
	DrawBattleOptions ();
}


//****************************************************************************
//
// DrawSpeedMenu ()
//
//****************************************************************************

void DrawSpeedMenu (void)
{
	MenuNum = 1;

	SetAlternateMenuBuf ();
	ClearMenuBuf();
	SetMenuTitle ("Speed");


	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}

	MN_DrawButtons (&SpeedItems, &SpeedMenu[0],
						 BATTLE_Options[gamestate.battlemode].Speed, OptionNums );
	MN_GetActive (&SpeedItems, &SpeedMenu[0],
					  BATTLE_Options[gamestate.battlemode].Speed, OptionNums );

	DrawMenu (&SpeedItems, &SpeedMenu[0]);
	DrawSpeedOptionDescription( SpeedItems.curpos );
	DisplayInfo (0);
	FlipMenuBuf();
}


//****************************************************************************
//
// CP_SpeedOptions ()
//
//****************************************************************************

void CP_SpeedOptions (void)
{
	int which;

	DrawSpeedMenu ();

	do
	{
		which = HandleMenu (&SpeedItems, &SpeedMenu[0], DrawSpeedOptionDescription);

		if (which >= 0)
		  BATTLE_Options[gamestate.battlemode].Speed = which;

		MN_DrawButtons (&SpeedItems, &SpeedMenu[0],
			BATTLE_Options[gamestate.battlemode].Speed, OptionNums );
	} while (which >= 0);

	handlewhich = 100;
	DrawBattleOptions ();
}


//****************************************************************************
//
// DrawAmmoPerWeaponMenu ()
//
//****************************************************************************
void DrawAmmoPerWeaponMenu
	(
	void
	)

	{
	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Ammo Per Weapon");

	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}

	MN_DrawButtons( &AmmoPerWeaponItems, &AmmoPerWeaponMenu[ 0 ],
		BATTLE_Options[ gamestate.battlemode ].Ammo, OptionNums );

	MN_GetActive( &AmmoPerWeaponItems, &AmmoPerWeaponMenu[ 0 ],
		BATTLE_Options[ gamestate.battlemode ].Ammo, OptionNums );

	DrawMenu( &AmmoPerWeaponItems, &AmmoPerWeaponMenu[ 0 ] );

	PrintBattleOption( true, 32, 79,
		"WARNING: Infinite ammo can seriously alter the balance of" );
	PrintBattleOption( true, 32, 87,
		"the game.  We recommend that you only use it occasionally." );
	PrintBattleOption( true, 32, 95,
		"It tends to only work well on small levels with lots of" );
	PrintBattleOption( true, 32, 103,
		"weapons, where the action is far more intense.  On large" );
	PrintBattleOption( true, 32, 111,
		"levels, you may find it causes people to wait in easily" );
	PrintBattleOption( true, 32, 119,
		"guardable areas and pick off anyone that comes in the room" );
	PrintBattleOption( true, 32, 127,
		"(creating an unfair advantage)." );

	if ( AmmoPerWeaponItems.curpos == 2 )
		{
		PrintBattleOption( true, 102, 136, "You have been warned." );
		}

	DrawAmmoOptionDescription( AmmoPerWeaponItems.curpos );
	DisplayInfo( 0 );
	FlipMenuBuf();
	}


//****************************************************************************
//
// CP_AmmoPerWeaponOptions ()
//
//****************************************************************************
void CP_AmmoPerWeaponOptions
	(
	void
	)

	{
	int which;

	DrawAmmoPerWeaponMenu();

	do
		{
		which = HandleMenu( &AmmoPerWeaponItems, &AmmoPerWeaponMenu[ 0 ], DrawAmmoOptionDescription);

		if (which >= 0)
			{
			if ( AmmoPerWeaponItems.curpos == 2 )
				{
				MN_PlayMenuSnd( SD_LIGHTNINGSND );
				PrintBattleOption( true, 102, 136, "You have been warned." );
				VL_FillPalette(255,255,255);
				VL_FadeIn(0,255,origpal,10);
				}
			else if ( BATTLE_Options[ gamestate.battlemode ].Ammo == 2 )
				{
				EraseMenuBufRegion( 102, 136, 84, 8 );
				MN_PlayMenuSnd( SD_PLAYERTCSND );
				}

			BATTLE_Options[ gamestate.battlemode ].Ammo = which;
			}

		MN_DrawButtons( &AmmoPerWeaponItems, &AmmoPerWeaponMenu[ 0 ],
			BATTLE_Options[ gamestate.battlemode ].Ammo, OptionNums );
		}
	while( which >= 0 );

	handlewhich = 100;
	DrawBattleOptions();
	}


//****************************************************************************
//
// DrawHitPointsMenu ()
//
//****************************************************************************
void DrawHitPointsMenu
	(
	void
	)

	{
	MenuNum = 1;

	SetAlternateMenuBuf ();
	ClearMenuBuf();
	SetMenuTitle ("Player Hitpoints");

	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}

	MN_DrawButtons( &HitPointItems, &HitPointMenu[ 0 ],
		BATTLE_Options[ gamestate.battlemode ].HitPoints, HitPointNums );

	MN_GetActive( &HitPointItems, &HitPointMenu[ 0 ],
		BATTLE_Options[ gamestate.battlemode ].HitPoints, HitPointNums );

	DrawMenu( &HitPointItems, &HitPointMenu[ 0 ] );
	DrawHitPointsOptionDescription( HitPointItems.curpos );
	DisplayInfo( 0 );
	FlipMenuBuf();
	}


//****************************************************************************
//
// CP_HitPointsOptions ()
//
//****************************************************************************

void CP_HitPointsOptions (void)
{
	int which;

	DrawHitPointsMenu ();

	do
	{
		which = HandleMenu (&HitPointItems, &HitPointMenu[0], DrawHitPointsOptionDescription);

		if (which >= 0)
			BATTLE_Options[gamestate.battlemode].HitPoints = HitPointNums[ which ];

		MN_DrawButtons (&HitPointItems, &HitPointMenu[0],
							 BATTLE_Options[gamestate.battlemode].HitPoints, HitPointNums);

	} while (which >= 0);

	handlewhich = 100;
	DrawBattleOptions ();
}



//****************************************************************************
//
// DrawSpawnControlMenu ()
//
//****************************************************************************
void DrawSpawnControlMenu
	(
	void
	)

	{
	int i;

	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Radical Options");

	MN_MakeActive( &SpawnItems, &SpawnMenu[ 0 ], SpawnItems.curpos );

#if ( SHAREWARE == 1 )
	BATTLE_Options[ gamestate.battlemode ].SpawnMines = false;
	SpawnMenu[ 3 ].active = CP_Inactive; // Mines
#endif

	switch( gamestate.battlemode )
		{
		case battle_Normal :
			break;

		case battle_ScoreMore :
			break;

		case battle_Collector :
			SpawnMenu[ 2 ].active = CP_Inactive; // Weapons
			SpawnMenu[ 5 ].active = CP_Inactive; // Persistence
			SpawnMenu[ 6 ].active = CP_Inactive; // Random Weapons
			SpawnMenu[ 7 ].active = CP_Inactive; // Friendly Fire
			break;

		case battle_Scavenger :
			SpawnMenu[ 7 ].active = CP_Inactive; // Friendly Fire
			break;

		case battle_Hunter :
			break;

		case battle_Tag :
			SpawnMenu[ 2 ].active = CP_Inactive; // Weapons
			SpawnMenu[ 5 ].active = CP_Inactive; // Persistence
			SpawnMenu[ 6 ].active = CP_Inactive; // Random Weapons
			break;

		case battle_Eluder :
			SpawnMenu[ 1 ].active = CP_Inactive; // Health
			SpawnMenu[ 2 ].active = CP_Inactive; // Weapons
			SpawnMenu[ 4 ].active = CP_Inactive; // Respawn
			SpawnMenu[ 5 ].active = CP_Inactive; // Persistence
			SpawnMenu[ 6 ].active = CP_Inactive; // Random Weapons
			SpawnMenu[ 7 ].active = CP_Inactive; // Friendly Fire
			break;

		case battle_Deluder :
			SpawnMenu[ 7 ].active = CP_Inactive; // Friendly Fire
			break;

		case battle_CaptureTheTriad :
			SpawnMenu[ 7 ].active = CP_Inactive; // Friendly Fire
			break;
		}

	if ( SpawnMenu[ SpawnItems.curpos ].active == CP_Inactive )
		{
		// Find an available cursor position
		for( i = 0; i < SpawnItems.amount; i++ )
			{
			if ( SpawnMenu[ i ].active == CP_Active )
				{
				SpawnMenu[ i ].active = CP_CursorLocation;
				SpawnItems.curpos = i;
				break;
				}
			}
		}

	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}

	DrawSpawnControlButtons();

	MN_GetCursorLocation( &SpawnItems, &SpawnMenu[ 0 ] );

	DrawMenu( &SpawnItems, &SpawnMenu[ 0 ] );
	DrawRadicalOptionDescription( SpawnItems.curpos );
	DisplayInfo( 0 );
	FlipMenuBuf();
	}


//****************************************************************************
//
// DrawSpawnControlButtons ()
//
//****************************************************************************
void DrawSpawnControlButtons
	(
	void
	)

	{
	int x;
	int y;
	int button_on;
	int button_off;

	button_on  = W_GetNumForName( "snd_on" );
	button_off = W_GetNumForName( "snd_off" );

	x = SpawnItems.x + 18;
	y = SpawnItems.y - 1;

	if ( BATTLE_Options[ gamestate.battlemode ].SpawnDangers )
		{
		DrawMenuBufItem( x, y, button_on );
		}
	else
		{
		EraseMenuBufRegion( x, y, 16, 16 );
		DrawMenuBufItem( x, y, button_off );
		}

	y += 14;
	if ( BATTLE_Options[ gamestate.battlemode ].SpawnHealth )
		{
		DrawMenuBufItem( x, y, button_on );
		}
	else
		{
		EraseMenuBufRegion( x, y, 16, 16 );
		DrawMenuBufItem( x, y, button_off );
		}

	y += 14;
	if ( BATTLE_Options[ gamestate.battlemode ].SpawnWeapons )
		{
		DrawMenuBufItem( x, y, button_on );
		}
	else
		{
		EraseMenuBufRegion( x, y, 16, 16 );
		DrawMenuBufItem( x, y, button_off );
		}

	y += 14;
	if ( BATTLE_Options[ gamestate.battlemode ].SpawnMines )
		{
		DrawMenuBufItem( x, y, button_on );
		}
	else
		{
		EraseMenuBufRegion( x, y, 16, 16 );
		DrawMenuBufItem( x, y, button_off );
		}

	y += 14;
	if ( BATTLE_Options[ gamestate.battlemode ].RespawnItems )
		{
		DrawMenuBufItem( x, y, button_on );
		}
	else
		{
		EraseMenuBufRegion( x, y, 16, 16 );
		DrawMenuBufItem( x, y, button_off );
		}

	y += 14;
	if ( BATTLE_Options[ gamestate.battlemode ].WeaponPersistence )
		{
		DrawMenuBufItem( x, y, button_on );
		}
	else
		{
		EraseMenuBufRegion( x, y, 16, 16 );
		DrawMenuBufItem( x, y, button_off );
		}

	y += 14;
	if ( BATTLE_Options[ gamestate.battlemode ].RandomWeapons )
		{
		DrawMenuBufItem( x, y, button_on );
		}
	else
		{
		EraseMenuBufRegion( x, y, 16, 16 );
		DrawMenuBufItem( x, y, button_off );
		}

	y += 14;
	if ( BATTLE_Options[ gamestate.battlemode ].FriendlyFire )
		{
		DrawMenuBufItem( x, y, button_on );
		}
	else
		{
		EraseMenuBufRegion( x, y, 16, 16 );
		DrawMenuBufItem( x, y, button_off );
		}
	}


//****************************************************************************
//
// CP_SpawnControlOptions ()
//
//****************************************************************************
void CP_SpawnControlOptions
	(
	void
	)

	{
	int which;

	DrawSpawnControlMenu();

	do
		{
		which = HandleMenu( &SpawnItems, &SpawnMenu[ 0 ], DrawRadicalOptionDescription );
		switch( which )
			{
			case 0 :
				BATTLE_Options[ gamestate.battlemode ].SpawnDangers =
					!BATTLE_Options[ gamestate.battlemode ].SpawnDangers;
				break;

			case 1 :
				BATTLE_Options[ gamestate.battlemode ].SpawnHealth =
					!BATTLE_Options[ gamestate.battlemode ].SpawnHealth;
				break;

			case 2 :
				BATTLE_Options[ gamestate.battlemode ].SpawnWeapons =
					!BATTLE_Options[ gamestate.battlemode ].SpawnWeapons;
				break;

			case 3 :
				BATTLE_Options[ gamestate.battlemode ].SpawnMines =
					!BATTLE_Options[ gamestate.battlemode ].SpawnMines;
				break;

			case 4 :
				BATTLE_Options[ gamestate.battlemode ].RespawnItems =
					!BATTLE_Options[ gamestate.battlemode ].RespawnItems;
				break;

			case 5 :
				BATTLE_Options[ gamestate.battlemode ].WeaponPersistence =
					!BATTLE_Options[ gamestate.battlemode ].WeaponPersistence;
				break;

			case 6 :
				BATTLE_Options[ gamestate.battlemode ].RandomWeapons =
					!BATTLE_Options[ gamestate.battlemode ].RandomWeapons;
				break;

			case 7 :
				BATTLE_Options[ gamestate.battlemode ].FriendlyFire =
					!BATTLE_Options[ gamestate.battlemode ].FriendlyFire;
				break;
			}

		DrawSpawnControlButtons();
		}
	while( which >= 0 );

	handlewhich = 100;
	DrawBattleOptions();
	}



//****************************************************************************
//
// DrawLightLevelMenu ()
//
//****************************************************************************

void DrawLightLevelMenu (void)
{
	MenuNum = 1;

	SetAlternateMenuBuf ();
	ClearMenuBuf();
	SetMenuTitle ("Light Levels");


	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}

	MN_DrawButtons (&LightLevelItems, &LightLevelMenu[0],
		BATTLE_Options[gamestate.battlemode].LightLevel, OptionNums );
	MN_GetActive (&LightLevelItems, &LightLevelMenu[0],
		BATTLE_Options[gamestate.battlemode].LightLevel, OptionNums );

	DrawMenu (&LightLevelItems, &LightLevelMenu[0]);
	DrawLightLevelOptionDescription( LightLevelItems.curpos );
	DisplayInfo (0);
	FlipMenuBuf();
}


//****************************************************************************
//
// CP_LightLevelOptions ()
//
//****************************************************************************

void CP_LightLevelOptions (void)
{
	int which;

	DrawLightLevelMenu ();

	do
	{
		which = HandleMenu (&LightLevelItems, &LightLevelMenu[0], DrawLightLevelOptionDescription);

		if (which >= 0)
		  BATTLE_Options[gamestate.battlemode].LightLevel = which;

		MN_DrawButtons (&LightLevelItems, &LightLevelMenu[0],
			BATTLE_Options[gamestate.battlemode].LightLevel, OptionNums );

	} while (which >= 0);

	handlewhich = 100;
	DrawBattleOptions ();
}



//****************************************************************************
//
// DrawPointGoalMenu()
//
//****************************************************************************

void DrawPointGoalMenu
	(
	void
	)

	{
	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Point Goal");

	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}

	MN_DrawButtons( &PointGoalItems, &PointGoalMenu[ 0 ],
		BATTLE_Options[ gamestate.battlemode ].Kills, KillNums );

	MN_GetActive( &PointGoalItems, &PointGoalMenu[ 0 ],
		BATTLE_Options[ gamestate.battlemode ].Kills, KillNums );

	DrawMenu( &PointGoalItems, &PointGoalMenu[ 0 ] );
	DrawPointGoalOptionDescription( PointGoalItems.curpos );
	DisplayInfo( 0 );
	FlipMenuBuf();
	}


//****************************************************************************
//
// CP_PointGoalOptions()
//
//****************************************************************************

void CP_PointGoalOptions
	(
	void
	)

	{
	int which;

	DrawPointGoalMenu();

	do
		{
		which = HandleMenu( &PointGoalItems, &PointGoalMenu[ 0 ], DrawPointGoalOptionDescription );

		if ( which >= 0 )
			{
			BATTLE_Options[ gamestate.battlemode ].Kills = KillNums[ which ];

			MN_DrawButtons( &PointGoalItems, &PointGoalMenu[ 0 ],
				BATTLE_Options[ gamestate.battlemode ].Kills, KillNums );
			}
		}
	while( which >= 0 );

	handlewhich = 100;
	DrawBattleOptions();
	}


//****************************************************************************
//
// DrawDangerMenu ()
//
//****************************************************************************

void DrawDangerMenu (void)
{
	MenuNum = 1;

	SetAlternateMenuBuf ();
	ClearMenuBuf();
	SetMenuTitle ("Danger Damage");


	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}
	MN_DrawButtons (&DangerItems, &DangerMenu[0],
						 BATTLE_Options[gamestate.battlemode].DangerDamage, DangerNums);
	MN_GetActive (&DangerItems, &DangerMenu[0],
						 BATTLE_Options[gamestate.battlemode].DangerDamage, DangerNums);

	DrawMenu (&DangerItems, &DangerMenu[0]);
	DrawDangerDamageOptionDescription( DangerItems.curpos );
	DisplayInfo (0);
	FlipMenuBuf();
}


//****************************************************************************
//
// CP_DangerOptions ()
//
//****************************************************************************

void CP_DangerOptions (void)
{
	int which;

	DrawDangerMenu ();

	do
	{
		which = HandleMenu (&DangerItems, &DangerMenu[0], DrawDangerDamageOptionDescription);

		if (which >= 0)
		  BATTLE_Options[gamestate.battlemode].DangerDamage = DangerNums[which];

		MN_DrawButtons (&DangerItems, &DangerMenu[0],
			BATTLE_Options[gamestate.battlemode].DangerDamage, DangerNums);

	} while (which >= 0);

	handlewhich = 100;
	DrawBattleOptions ();
}


//****************************************************************************
//
// DrawTimeLimitMenu ()
//
//****************************************************************************

void DrawTimeLimitMenu (void)
{
	MenuNum = 1;

	SetAlternateMenuBuf ();
	ClearMenuBuf();
	SetMenuTitle ("Time Limit");


	if ( ( gamestate.battlemode != battle_StandAloneGame ) &&
		( consoleplayer == 0 ) )
		{
		DrawBattleModeName( gamestate.battlemode );
		}
	MN_DrawButtons (&TimeLimitItems, &TimeLimitMenu[0],
		BATTLE_Options[gamestate.battlemode].TimeLimit, TimeLimitNums);
	MN_GetActive (&TimeLimitItems, &TimeLimitMenu[0],
		BATTLE_Options[gamestate.battlemode].TimeLimit, TimeLimitNums);

	if ( gamestate.battlemode == battle_Hunter )
		{
		TimeLimitMenu[7].active = CP_Inactive; // No time limit
		if ( TimeLimitItems.curpos == 7 )
			{
			TimeLimitMenu[0].active = CP_CursorLocation;
			TimeLimitItems.curpos = 0;
			}
		}

	DrawMenu (&TimeLimitItems, &TimeLimitMenu[0]);
	DrawTimeLimitOptionDescription( TimeLimitItems.curpos );
	DisplayInfo (0);
	FlipMenuBuf();
}


//****************************************************************************
//
// CP_TimeLimitOptions ()
//
//****************************************************************************

void CP_TimeLimitOptions (void)
{
	int which;

	DrawTimeLimitMenu ();

	do
	{
		which = HandleMenu (&TimeLimitItems, &TimeLimitMenu[0], DrawTimeLimitOptionDescription);

		if (which >= 0)
		  BATTLE_Options[gamestate.battlemode].TimeLimit = TimeLimitNums[which];

		MN_DrawButtons (&TimeLimitItems, &TimeLimitMenu[0],
			BATTLE_Options[gamestate.battlemode].TimeLimit, TimeLimitNums);

	} while (which >= 0);

	handlewhich = 100;
	DrawBattleOptions ();
}

void PrintBattleOption
	(
	boolean inmenu,
	int x,
	int y,
	char *text
	)

	{
	if ( inmenu )
		{
		IFont = ( cfont_t * )W_CacheLumpName( "itnyfont", PU_CACHE );
		DrawMenuBufIString( x + 1, y + 1, text, 0 );
		DrawMenuBufIString( x, y, text, ACTIVECOLOR );
		}
	else
		{
		PrintX = x;
		PrintY = y;
		US_BufPrint( text );
		}
	}

void ShowBattleOption
	(
	boolean inmenu,
	int PosX,
	int PosY,
	int column,
	int Line,
	char *text1,
	char *text2
	)

	{
	char text[ 80 ];
	int x;
	int y;

	y = PosY + ( Line * 7 );
	x = PosX + column * 120;

	PrintBattleOption( inmenu, x, y, text1 );

	strcpy( text, ": " );
	strcat( text, text2 );

	PrintBattleOption( inmenu, x + 60, y, text );
	}

void ShowBattleOptions
	(
	boolean inmenu,
	int PosX,
	int PosY
	)

	{
	battle_type *options;
	battle_type BatOps;
	char *string;
	char text[ 80 ];
	int  width;
	int  height;
	int  temp;

	CurrentFont = tinyfont;

	strcpy( text, "CURRENT OPTIONS FOR " );
	strcat( text, BattleModeNames[ gamestate.battlemode - battle_Normal ] );
	VW_MeasurePropString ( text, &width, &height );
	if ( inmenu )
		{
		temp = 288;
		}
	else
		{
		temp = 320;
		}
	PrintBattleOption( inmenu, (temp - width)/2, PosY, text );

	PosY++;

	BATTLE_GetOptions( &BatOps );
	options = &BatOps;

	ShowBattleOption( inmenu, PosX, PosY, 0, 1, "Friendly Fire",
		( options->FriendlyFire ) ? "On" : "Off" );

	ShowBattleOption( inmenu, PosX, PosY, 0, 2, "Weapon Persist",
		( options->WeaponPersistence ) ? "On" : "Off" );

	ShowBattleOption( inmenu, PosX, PosY, 0, 3, "Random Weapons",
		( options->RandomWeapons ) ? "On" : "Off" );

	ShowBattleOption( inmenu, PosX, PosY, 0, 4, "Respawn Items",
		( options->RespawnItems ) ? "On" : "Off" );

	ShowBattleOption( inmenu, PosX, PosY, 0, 5, "Spawn Health",
		( options->SpawnHealth ) ? "On" : "Off" );

	ShowBattleOption( inmenu, PosX, PosY, 0, 6, "Spawn Weapons",
		( options->SpawnWeapons ) ? "On" : "Off" );

	ShowBattleOption( inmenu, PosX, PosY, 0, 7, "Spawn Mines",
		( options->SpawnMines ) ? "On" : "Off" );

	ShowBattleOption( inmenu, PosX, PosY, 0, 8, "Spawn Dangers",
		( options->SpawnDangers ) ? "On" : "Off" );

	switch( options->DangerDamage )
		{
		case bo_danger_low :
			string = "Low";
			break;

		case bo_danger_normal :
			string = "Normal";
			break;

		case bo_danger_kill :
			string = "Kill";
			break;

		default :
			itoa( options->DangerDamage, text, 10 );
			string = text;
		}
	ShowBattleOption( inmenu, PosX, PosY, 0, 9, "Danger Damage", string );

//	GetMapFileName ( &text );
	GetMapFileName ( text );
	ShowBattleOption( inmenu, PosX, PosY, 0, 10, "Filename", text );

	itoa( numplayers, text, 10 );
	ShowBattleOption( inmenu, PosX, PosY, 1, 1, "Players", text );

	if ( options->TimeLimit == bo_time_infinite )
		{
		string = "None";
		}
	else
		{
		itoa( options->TimeLimit, text, 10 );
		string = text;
		}
	ShowBattleOption( inmenu, PosX, PosY, 1, 2, "Time Limit", string );

	if ( ( gamestate.battlemode == battle_Collector ) ||
		( gamestate.battlemode == battle_Scavenger ) )
		{
		string = "?";
		}
	else
		{
		switch( options->Kills )
			{
			case bo_kills_random :
				string = "Random";
				break;

			case bo_kills_blind :
				string = "Blind";
				break;

			case bo_kills_infinite :
				string = "Infinite";
				break;

			default :
				itoa( options->Kills, text, 10 );
				string = text;
			}
		}
	ShowBattleOption( inmenu, PosX, PosY, 1, 3, "Point Goal", string );

	switch( options->Ammo )
		{
		case bo_one_shot :
			string = "One shot";
			break;

		case bo_normal_shots :
			string = "Normal";
			break;

		case bo_infinite_shots :
			string = "Gunfinity";
			break;
		}
	ShowBattleOption( inmenu, PosX, PosY, 1, 4, "Ammo", string );

	if ( options->HitPoints == bo_character_hitpoints )
		{
		string = "Character";
		}
	else
		{
		itoa( options->HitPoints, text, 10 );
		string = text;
		}
	ShowBattleOption( inmenu, PosX, PosY, 1, 5, "Hit Points", string );

	itoa( options->RespawnTime, text, 10 );
	ShowBattleOption( inmenu, PosX, PosY, 1, 6, "Respawn Time", text );

	switch( options->Speed )
		{
		case bo_normal_speed :
			string = "Normal";
			break;

		case bo_fast_speed :
			string = "Fast";
			break;
		}
	ShowBattleOption( inmenu, PosX, PosY, 1, 7, "Speed", string );

	switch( options->LightLevel )
		{
		case bo_light_dark :
			string = "Dark";
			break;

		case bo_light_normal :
			string = "Normal";
			break;

		case bo_light_bright :
			string = "Bright";
			break;

		case bo_light_fog :
			string = "Fog";
			break;

		case bo_light_periodic :
			string = "Periodic";
			break;

		case bo_light_lightning :
			string = "Lightning";
			break;
		}
	ShowBattleOption( inmenu, PosX, PosY, 1, 8, "Light", string );

	if ( options->Gravity == NORMAL_GRAVITY )
		{
		string = "Normal";
		temp = NORMAL_GRAVITY;
		}
	else if ( options->Gravity < NORMAL_GRAVITY )
		{
		string = "Low";
		temp = LOW_GRAVITY;
		}
	else
		{
		string = "High";
		temp = HIGH_GRAVITY;
		}

	strcpy( text, string );
	if ( options->Gravity < temp )
		{
		strcat( text, "-" );
		}

	if ( options->Gravity > temp )
		{
		strcat( text, "+" );
		}
	ShowBattleOption( inmenu, PosX, PosY, 1, 9, "Gravity", text );
	}


//****************************************************************************
//
// SetMenuHeader()
//
//****************************************************************************

void SetMenuHeader
	(
	char *header
	)

	{
	int width;
	int height;

	EraseMenuBufRegion( 16, 0, 256, 16 );

	CurrentFont = tinyfont;
	VW_MeasurePropString ( header, &width, &height );
	DrawMenuBufPropString ( ( 288 - width ) / 2, 4, header );

	RefreshMenuBuf( 0 );
	}


//****************************************************************************
//
// DrawMultiPageCustomMenu()
//
//****************************************************************************

void DrawMultiPageCustomMenu
	(
	char *title,
	void ( *redrawfunc )( void )
	)

	{
	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( title );

	DrawMenu( &MultiPageCustomItems, &MultiPageCustomMenu[ 0 ] );

	DisplayInfo( 0 );

	if ( redrawfunc != NULL )
		{
		redrawfunc();
		}

	CalcTics();
	FlipMenuBuf();
	RefreshMenuBuf( 0 );
	}


//****************************************************************************
//
// HandleMultiPageCustomMenu()
//
//****************************************************************************

int HandleMultiPageCustomMenu
	(
	char **names,
	int	amount,
	int	curpos,
	char *title,
	void  ( *routine )( int w ),
	void ( *redrawfunc )( void ),
	boolean exitonselect
	)

	{
	boolean redraw;
	int  page;
	int  cursorpos;
	int  maxpos;
	int  numpos;
	int  which;
	int  selection;
	int  i;
	char letter;

	MenuNum = 11;

	cursorpos = curpos % MAXCUSTOM;
	page		= curpos - cursorpos;
	MultiPageCustomItems.curpos = cursorpos + 2;

	redraw = true;

	do
		{
		if ( redraw )
			{
			redraw = false;
			MultiPageCustomMenu[ 0 ].active = CP_Active;
			MultiPageCustomMenu[ 1 ].active = CP_Active;
			if ( page == 0 )
				{
				MultiPageCustomMenu[ 1 ].active = CP_Inactive;
				}

			maxpos = page + MAXCUSTOM;
			if ( maxpos >= amount )
				{
				MultiPageCustomMenu[ 0 ].active = CP_Inactive;
				maxpos = amount;
				}

			numpos = maxpos - page + 2;
			MultiPageCustomItems.amount = numpos;

			for( i = 2; i < numpos; i++ )
				{
				MultiPageCustomMenu[ i ].active = CP_Active;

				// Set the name of the level
				MultiPageCustomNames[ i ] = names[ page + i - 2 ];

				// Set the quick key
				letter = *names[ page + i - 2 ];

				// Force it to upper case
				if ( ( letter >= 'a' ) && ( letter <= 'z' ) )
					{
					letter = letter - 'a' + 'A';
					}

				// Only use letters
				if ( ( letter < 'A' ) || ( letter > 'Z' ) )
					{
					letter = 'a';
					}
				MultiPageCustomMenu[ i ].letter = letter;
				}

			// If the cursor is at an invalid position, find a valid one
			cursorpos = MultiPageCustomItems.curpos;
			if ( cursorpos >= numpos )
				{
				cursorpos = numpos - 1;
				}
			else
				{
				while( MultiPageCustomMenu[ cursorpos ].active == CP_Inactive )
					{
					cursorpos++;
					}
				}
			MultiPageCustomItems.curpos = cursorpos;
			MultiPageCustomMenu[ cursorpos ].active = CP_CursorLocation;

			DrawMultiPageCustomMenu( title, redrawfunc );
			}

		which = HandleMenu( &MultiPageCustomItems, &MultiPageCustomMenu[ 0 ],
			NULL );

		switch( which )
			{
			case ESCPRESSED :
				selection = -1;
				break;

			case PAGEDOWN :
			case 0 :
				page += MAXCUSTOM;
				which = 0;
				redraw = true;
				break;

			case PAGEUP :
			case 1 :
				page -= MAXCUSTOM;
				which = 0;
				redraw = true;
				break;

			default :
				selection = page + which - 2;
				if ( routine )
					{
					routine( selection );
					}

				if ( exitonselect )
					{
					which = -1;
					}
				break;
			}
		}
	while( which >= 0 );

	return( selection );
	}


//****************************************************************************
//
// CP_LevelSelectionRedraw()
//
//****************************************************************************

void CP_LevelSelectionRedraw
	(
	void
	)

	{
	if ( gamestate.battlemode >= battle_Normal )
		{
		SetMenuHeader( BattleModeNames[ gamestate.battlemode - battle_Normal ] );
		}
	}


//****************************************************************************
//
// CP_LevelSelectionMenu ()
//
//****************************************************************************
int CP_LevelSelectionMenu
	(
	void
	)

	{
	static char levelcursorpos[ 2 ] = { 0 };

	char *LevelNames[ 100 ];
	int	whichlevels;
	int	numlevels;
	int	level;
	int	i;

	whichlevels = 0;
	if ( BATTLEMODE )
		{
		whichlevels = 1;
		}

	mapinfo = ( mapfileinfo_t * )SafeMalloc( sizeof( mapfileinfo_t ) );
	GetMapInfo( mapinfo );

	numlevels = mapinfo->nummaps;
	if ( numlevels <= 0 )
		{
		Error( "CP_LevelSelectionMenu : No maps found in RTL/RTC file." );
		}

	for( i = 0; i < numlevels; i++ )
		{
		LevelNames[ i ] = mapinfo->maps[ i ].mapname;
		}

	level = HandleMultiPageCustomMenu( LevelNames, numlevels,
		levelcursorpos[ whichlevels ], "Level Selection", NULL,
		CP_LevelSelectionRedraw, true );

	SafeFree( mapinfo );

	if ( level >= 0 )
		{
		levelcursorpos[ whichlevels ] = level;
		}

	return( level );
	}


//****************************************************************************
//
// DrawEnterCodeNameMenu ()
//
//****************************************************************************
void DrawEnterCodeNameMenu
	(
	void
	)

	{
	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Enter CodeName");

	if ( consoleplayer == 0 )
		{
		DrawBattleModeName( gamestate.battlemode );
		}

	WindowW = 288;
	WindowH = 158;
	WindowX = 0;
	WindowY = 50;
	PrintX  = 0;
	PrintY  = 50;

	CurrentFont = smallfont;

	MenuBufCPrint( "Enter CodeName\n" );
	MenuBufCPrint( "maximum 8 letters\n" );

	DrawSTMenuBuf( ( 288 - 92 ) / 2 - 2, 80 - 2, 92 + 4, 10 + 4, false );

	DrawMenuBufPropString( ( 288 - 92 ) / 2, 80, CodeName );

	WindowX = 144 - ( 9 * 4 );
	PrintX  = WindowX;

	FlipMenuBuf();
	RefreshMenuBuf( 0 );
	}

//****************************************************************************
//
// CP_EnterCodeNameMenu ()
//
//****************************************************************************
int CP_EnterCodeNameMenu
	(
	void
	)

	{
	char input[10];

	DrawEnterCodeNameMenu();

	memset(input,0,sizeof(input));
	strcpy(input,CodeName);


	if (US_LineInput ((288-92)/2, 80, input, input, true, 8, 92, 0))
		{
		strcpy (&locplayerstate->codename[0], input);
		strcpy (CodeName, input);
		WaitKeyUp();
		return 1;
		}
	else
		{
		WaitKeyUp();
		return 0;
		}
	}

void SS_DrawSBTypeMenu( void );
void SS_SBTypeMenu( void );
void SS_DrawPortMenu( void );
void SS_PortMenu( void );
void SS_Draw8BitDMAMenu( void );
void SS_8BitDMAMenu( void );
void SS_Draw16BitDMAMenu( void );
void SS_16BitDMAMenu( void );
void SS_DrawIrqMenu( void );
void SS_IrqMenu( void );
void SS_Quit( void );
void DrawSoundSetupMainMenu( void );
void CP_SoundSetup( void );
void SS_MusicMenu( void );
void SS_DrawMusicMenu( void );
void SS_SoundMenu( void );
void SS_DrawSoundMenu( void );
void SS_SetupMusicCardMenu( void );
void DrawMusicCardMenu( void );
void SS_SetupSoundBlaster( int sbmenu );
void SS_SetupSoundCardMenu( void );
void SS_VoiceMenu( int sbmenu );
void SS_DrawVoiceMenu( void );
void SS_ChannelMenu( void );
void SS_DrawChannelMenu( void );
void SS_BitMenu( void );
void SS_DrawBitMenu( void );

extern int musicnums[ 11 ];
extern int fxnums[ 11 ];

static int midinums[ 12 ]  = {
	0x220, 0x230, 0x240, 0x250, 0x300, 0x320,
	0x330, 0x332, 0x334, 0x336, 0x340, 0x360
	};
static int voicenums[8] = {1, 2, 3, 4, 5, 6, 7, 8};
static int resnums[2]	= {8, 16};
static int smnums[2]	 = {1, 2};

//
// MENU ITEMS
//
CP_MenuNames SoundSetupMenuNames[] =
	{
	"SETUP SOUND FX",
	"SETUP MUSIC",
	"SOUND FX VOLUME",
	"MUSIC VOLUME",
	"QUIT"
	};

CP_iteminfo SoundSetupMenuItems  = { MENU_X, 48, 5, STARTITEM, 32, SoundSetupMenuNames, mn_largefont };
CP_itemtype SoundSetupMenu[] =
	{
		{ CP_CursorLocation, "\0",  'S', (menuptr)SS_SoundMenu },
		{ CP_Active,			"\0",  'S', (menuptr)SS_MusicMenu },
		{ CP_Active,			"\0",  'S', (menuptr)FXVolume },
		{ CP_Active,			"\0",  'M', (menuptr)MusicVolume },
		{ CP_Active,			"\0",  'Q', (menuptr)SS_Quit }
	};

CP_MenuNames SoundSetupMusicNames[] =
	{
	"None",
	"Ultrasound",
	"Sound Blaster",
	"Sound Man 16",
	"Pro Audio Spectrum",
	"AWE 32",
	"Soundscape",
	"Wave Blaster",
	"General Midi",
	"Sound Canvas",
	"Adlib"
	};

CP_iteminfo SoundSetupMusicItems  = { 44, MENU_Y + 15, 11, STARTITEM, 16, SoundSetupMusicNames, mn_smallfont };
CP_itemtype SoundSetupMusic[] =
	{
		{ CP_CursorLocation, "\0",  'N', (menuptr)SS_SetupMusicCardMenu },
		{ CP_Active,			"\0",  'U', (menuptr)SS_SetupMusicCardMenu },
		{ CP_Active,			"\0",  'S', (menuptr)SS_SetupMusicCardMenu },
		{ CP_Active,			"\0",  'S', (menuptr)SS_SetupMusicCardMenu },
		{ CP_Active,			"\0",  'P', (menuptr)SS_SetupMusicCardMenu },
		{ CP_Active,			"\0",  'A', (menuptr)SS_SetupMusicCardMenu },
		{ CP_Active,			"\0",  'S', (menuptr)SS_SetupMusicCardMenu },
		{ CP_Active,			"\0",  'W', (menuptr)SS_SetupMusicCardMenu },
		{ CP_Active,			"\0",  'G', (menuptr)SS_SetupMusicCardMenu },
		{ CP_Active,			"\0",  'S', (menuptr)SS_SetupMusicCardMenu },
		{ CP_Active,			"\0",  'A', (menuptr)SS_SetupMusicCardMenu }
	};


CP_MenuNames SoundSetupSoundNames[] =
	{
	"None",
	"Ultrasound",
	"Sound Blaster",
	"Sound Man 16",
	"Pro Audio Spectrum",
	"AWE 32",
	"Soundscape",
	"Adlib",
	"Disney Sound Source",
	"Tandy Sound Source",
	"PC Speaker"
	};

CP_iteminfo SoundSetupSoundItems  = { MENU_X, MENU_Y + 15, 11, STARTITEM, 16, SoundSetupSoundNames, mn_smallfont };
CP_itemtype SoundSetupSound[] =
	{
		{ CP_CursorLocation, "\0",  'N', (menuptr)SS_SetupSoundCardMenu },
		{ CP_Active,			"\0",  'U', (menuptr)SS_SetupSoundCardMenu },
		{ CP_Active,			"\0",  'S', (menuptr)SS_SetupSoundCardMenu },
		{ CP_Active,			"\0",  'S', (menuptr)SS_SetupSoundCardMenu },
		{ CP_Active,			"\0",  'P', (menuptr)SS_SetupSoundCardMenu },
		{ CP_Active,			"\0",  'A', (menuptr)SS_SetupSoundCardMenu },
		{ CP_Active,			"\0",  'S', (menuptr)SS_SetupSoundCardMenu },
		{ CP_Active,			"\0",  'A', (menuptr)SS_SetupSoundCardMenu },
		{ CP_Active,			"\0",  'S', (menuptr)SS_SetupSoundCardMenu },
		{ CP_Active,			"\0",  'T', (menuptr)SS_SetupSoundCardMenu },
		{ CP_Active,			"\0",  'P', (menuptr)SS_SetupSoundCardMenu }
	};

CP_MenuNames SoundSetupMidiPortNames[] =
	{
	"220", "230", "240", "250", "300", "320",
	"330", "332", "334", "336", "340", "360"
	};

CP_iteminfo SoundSetupMidiPortItems = { 108, MENU_Y + 10, 12, STARTITEM, 16, SoundSetupMidiPortNames, mn_smallfont };
CP_itemtype SoundSetupMidiPort[] =
	{
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_CursorLocation, "\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL }
	};

CP_MenuNames SoundSetupVoiceNames[] =
	{
	"1 voice",
	"2 voices",
	"3 voices",
	"4 voices",
	"5 voices",
	"6 voices",
	"7 voices",
	"8 voices"
	};

CP_iteminfo SoundSetupVoiceItems  = { MENU_X + 36, 24, 8, STARTITEM, 32, SoundSetupVoiceNames, mn_largefont };
CP_itemtype SoundSetupVoice[] =
	{
		{ CP_CursorLocation, "\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL }
	};

CP_MenuNames SoundSetupChannelNames[] =
	{
	"  Mono Sound FX",
	"Stereo Sound FX"
	};

CP_iteminfo SoundSetupChannelItems  = { MENU_X, MP_Y, 2, STARTITEM, 32, SoundSetupChannelNames, mn_largefont };
CP_itemtype SoundSetupChannel[] =
	{
		{ CP_CursorLocation, "\0",  'M', NULL },
		{ CP_Active,			"\0",  'S', NULL }
	};

CP_MenuNames SoundSetupResolutionNames[] =
	{
	"8 Bit Mixing",
	"16 Bit Mixing"
	};

CP_iteminfo SoundSetupResolutionItems  = { MENU_X, MP_Y, 2, STARTITEM, 32, SoundSetupResolutionNames, mn_largefont };
CP_itemtype SoundSetupResolution[] =
	{
		{ CP_CursorLocation, "\0",  'a', NULL },
		{ CP_Active,			"\0",  'b', NULL }
	};

static int typenums[ 5 ] =
	{
	fx_SB, fx_SB20, fx_SBPro, fx_SBPro2, fx_SB16
	};

static char typetostring[ 6 ] =
	{
	5, 0, 2, 1, 3, 4
	};

#define UNDEFINED -1

CP_MenuNames TypeNames[] =
	{
	"Sound Blaster or compatible",
	"Sound Blaster 2.0",
	"Sound Blaster Pro (old)",
	"Sound Blaster Pro 2.0 (new)",
	"Sound Blaster 16 or AWE32",
	"Undefined"
	};

CP_iteminfo TypeItems  = { MENU_X - 13, MENU_Y + 36, 5, STARTITEM, 10, TypeNames, mn_smallfont };
CP_itemtype TypeMenu[] =
	{
		{ CP_CursorLocation, "\0",  'S', NULL },
		{ CP_Active,			"\0",  'S', NULL },
		{ CP_Active,			"\0",  'S', NULL },
		{ CP_Active,			"\0",  'S', NULL },
		{ CP_Active,			"\0",  'S', NULL }
	};

static int portnums[ 7 ] =
	{
	0x210, 0x220, 0x230, 0x240, 0x250, 0x260, 0x280
	};

CP_MenuNames PortNames[] =
	{
	"210", "220", "230", "240", "250", "260", "280"
	};

CP_iteminfo PortItems = { 92, 32, 7, STARTITEM, 32, PortNames, mn_largefont };
CP_itemtype PortMenu [] =
	{
		{ CP_CursorLocation, "\0",  '2', NULL },
		{ CP_Active,			"\0",  '2', NULL },
		{ CP_Active,			"\0",  '2', NULL },
		{ CP_Active,			"\0",  '2', NULL },
		{ CP_Active,			"\0",  '2', NULL },
		{ CP_Active,			"\0",  '2', NULL },
		{ CP_Active,			"\0",  '2', NULL }
	};

static int _8BitDMAnums[ 3 ] =
	{
	0, 1, 3
	};

CP_MenuNames _8BitDMANames[] =
	{
	"DMA channel 0",
	"DMA channel 1",
	"DMA channel 3"
	};

CP_iteminfo _8BitDMAItems = { 32, 60, 3, STARTITEM, 32, _8BitDMANames, mn_largefont };
CP_itemtype _8BitDMAMenu [] =
	{
		{ CP_CursorLocation, "\0",  '0', NULL },
		{ CP_Active,			"\0",  '1', NULL },
		{ CP_Active,			"\0",  '3', NULL }
	};

static int _16BitDMAnums[ 3 ] =
	{
	5, 6, 7
	};

CP_MenuNames _16BitDMANames[] =
	{
	"DMA channel 5",
	"DMA channel 6",
	"DMA channel 7"
	};

CP_iteminfo _16BitDMAItems = { 32, 60, 3, STARTITEM, 32, _16BitDMANames, mn_largefont };
CP_itemtype _16BitDMAMenu [] =
	{
		{ CP_CursorLocation, "\0",  '5', NULL },
		{ CP_Active,			"\0",  '6', NULL },
		{ CP_Active,			"\0",  '7', NULL }
	};

static int irqnums[ 8 ] =
	{
	2, 3, 5, 7, 10, 11, 12, 15
	};

CP_MenuNames IrqNames[] =
	{
	"IRQ 2",
	"IRQ 3",
	"IRQ 5",
	"IRQ 7",
	"IRQ 10",
	"IRQ 11",
	"IRQ 12",
	"IRQ 15"
	};

CP_iteminfo IrqItems = { 82, 24, 8, STARTITEM, 32, IrqNames, mn_largefont };
CP_itemtype IrqMenu [] =
	{
		{ CP_CursorLocation, "\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL },
		{ CP_Active,			"\0",  'a', NULL }
	};

CP_MenuNames SBSetupNames[] =
	{
	"Use Current Settings",
	"Custom Setup"
	};

CP_iteminfo SBSetupItems  = { MENU_X - 11, MENU_Y + 76, 2, STARTITEM, 19, SBSetupNames, mn_largefont };
CP_itemtype SBSetupMenu[] =
	{
		{ CP_CursorLocation, "\0",  'U', SS_SetupSoundBlaster },
		{ CP_Active,			"\0",  'C', (menuptr)SS_SBTypeMenu },
	};

extern fx_blaster_config SBSettings;

//******************************************************************************
//
// SS_DrawSBSetupMenu()
//
//******************************************************************************

void SS_DrawSBSetupMenu
	(
	void
	)

	{
	char text[ 80 ];
	char num[ 10 ];
	char *undefined;

	MenuNum = SNDCARDS;
	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Sound Blaster Setup" );

	WindowW = 288;
	WindowH = 158;
	WindowX = 96;
	WindowY = 32;
	PrintX  = 0;
	PrintY  = 32;

	CurrentFont = tinyfont;

	undefined = "Undefined";

	SBSetupMenu[ 0 ].active = CP_Active;

	PrintBattleOption( true, WindowX + 16, PrintY, "Current Settings:" );
	PrintY += 9;

	strcpy( text, "Card Type : " );

	if ( ( SBSettings.Type < fx_SB ) || ( SBSettings.Type > fx_SB16 ) )
		{
		SBSettings.Type = UNDEFINED;
		strcat( text, undefined );
		SBSetupMenu[ 0 ].active = CP_Inactive;
		}
	else
		{
		strcat( text, TypeNames[ typetostring[ SBSettings.Type ] ] );
		}

	PrintBattleOption( true, WindowX, PrintY, text );
	PrintY += 6;

	strcpy( text, "Port : " );
	if ( SBSettings.Address != UNDEFINED )
		{
		itoa( SBSettings.Address, num, 16 );
		strcat( text, num );
		}
	else
		{
		strcat( text, undefined );
		SBSetupMenu[ 0 ].active = CP_Inactive;
		}

	PrintBattleOption( true, WindowX + 19, PrintY, text );
	PrintY += 6;

	strcpy( text, "IRQ : " );
	if ( SBSettings.Interrupt != UNDEFINED )
		{
		itoa( SBSettings.Interrupt, num, 10 );
		strcat( text, num );
		}
	else
		{
		strcat( text, undefined );
		SBSetupMenu[ 0 ].active = CP_Inactive;
		}
	PrintBattleOption( true, WindowX + 23, PrintY, text );
	PrintY += 6;

	strcpy( text, "DMA : " );
	if ( SBSettings.Dma8 != UNDEFINED )
		{
		itoa( SBSettings.Dma8, num, 10 );
		strcat( text, num );
		}
	else
		{
		strcat( text, undefined );
		SBSetupMenu[ 0 ].active = CP_Inactive;
		}
	PrintBattleOption( true, WindowX + 21, PrintY, text );
	PrintY += 6;

	strcpy( text, "16-Bit DMA : " );
	if ( SBSettings.Dma16 != UNDEFINED )
		{
		itoa( SBSettings.Dma16, num, 10 );
		strcat( text, num );
		}
	else
		{
		strcat( text, undefined );
		}
	PrintBattleOption( true, WindowX - 4, PrintY, text );
	PrintY += 6;

	MN_GetCursorLocation( &SBSetupItems, &SBSetupMenu[ 0 ] );
	DrawMenu( &SBSetupItems, &SBSetupMenu[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	RefreshMenuBuf( 0 );
	}


//******************************************************************************
//
// SS_DrawSBTypeMenu()
//
//******************************************************************************

void SS_DrawSBTypeMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;
	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Select Sound Blaster Type" );
	MN_GetActive( &TypeItems, &TypeMenu[ 0 ], SBSettings.Type, typenums );
	DrawMenu( &TypeItems, &TypeMenu[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}

//******************************************************************************
//
// SS_SBTypeMenu()
//
//******************************************************************************

void SS_SBTypeMenu
	(
	void
	)

	{
	int which;

	do
		{
		SS_DrawSBTypeMenu();
		which = HandleMenu( &TypeItems, &TypeMenu[0], NULL );
		if ( which >= 0 )
			{
			SBSettings.Type = typenums[ which ];
			SS_PortMenu();
			if ( handlewhich == -1 )
				{
				continue;
				}
			return;
			}
		}
	while( which >= 0 );

	handlewhich = -2;
	}

//******************************************************************************
//
// SS_DrawPortMenu()
//
//******************************************************************************

void SS_DrawPortMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;
	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Select Sound Blaster Port" );
	MN_GetActive( &PortItems, &PortMenu[ 0 ], SBSettings.Address, portnums );
	DrawMenu( &PortItems, &PortMenu[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}

//******************************************************************************
//
// SS_PortMenu()
//
//******************************************************************************

void SS_PortMenu
	(
	void
	)

	{
	int which;

	do
		{
		SS_DrawPortMenu();
		which = HandleMenu( &PortItems, &PortMenu[0], NULL );
		if ( which >= 0 )
			{
			SBSettings.Address = portnums[ which ];
			SBSettings.Emu = SBSettings.Address;
			SS_8BitDMAMenu();
			if ( handlewhich == -1 )
				{
				continue;
				}
			return;
			}
		}
	while( which >= 0 );

	handlewhich = -1;
	}

//******************************************************************************
//
// SS_Draw8BitDMAMenu()
//
//******************************************************************************

void SS_Draw8BitDMAMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;
	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Select 8-bit DMA Channel" );
	MN_GetActive( &_8BitDMAItems, &_8BitDMAMenu[ 0 ], SBSettings.Dma8, _8BitDMAnums );
	DrawMenu( &_8BitDMAItems, &_8BitDMAMenu[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}

//******************************************************************************
//
// SS_8BitDMAMenu()
//
//******************************************************************************

void SS_8BitDMAMenu
	(
	void
	)

	{
	int which;

	do
		{
		SS_Draw8BitDMAMenu();
		which = HandleMenu( &_8BitDMAItems, &_8BitDMAMenu[0], NULL );
		if ( which >= 0 )
			{
			SBSettings.Dma8 = _8BitDMAnums[ which ];
			SS_16BitDMAMenu();
			if ( handlewhich == -1 )
				{
				continue;
				}
			return;
			}
		}
	while( which >= 0 );

	handlewhich = -1;
	}

//******************************************************************************
//
// SS_Draw16BitDMAMenu()
//
//******************************************************************************

void SS_Draw16BitDMAMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;
	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Select 16-bit DMA Channel" );
	MN_GetActive( &_16BitDMAItems, &_16BitDMAMenu[ 0 ], SBSettings.Dma16, _16BitDMAnums );
	DrawMenu( &_16BitDMAItems, &_16BitDMAMenu[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}

//******************************************************************************
//
// SS_16BitDMAMenu()
//
//******************************************************************************

void SS_16BitDMAMenu
	(
	void
	)

	{
	int which;

	if ( SBSettings.Type != fx_SB16 )
		{
		SS_IrqMenu();
		return;
		}

	do
		{
		SS_Draw16BitDMAMenu();
		which = HandleMenu( &_16BitDMAItems, &_16BitDMAMenu[0], NULL );
		if ( which >= 0 )
			{
			SBSettings.Dma16 = _16BitDMAnums[ which ];
			SS_IrqMenu();
			if ( handlewhich == -1 )
				{
				continue;
				}
			return;
			}
		}
	while( which >= 0 );

	handlewhich = -1;
	}

//******************************************************************************
//
// SS_DrawIrqMenu()
//
//******************************************************************************

void SS_DrawIrqMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;
	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Select Sound Blaster IRQ" );
	MN_GetActive( &IrqItems, &IrqMenu[ 0 ], SBSettings.Interrupt, irqnums );
	DrawMenu( &IrqItems, &IrqMenu[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}

//******************************************************************************
//
// SS_IrqMenu()
//
//******************************************************************************

void SS_IrqMenu
	(
	void
	)

	{
	int which;

	do
		{
		SS_DrawIrqMenu();
		which = HandleMenu( &IrqItems, &IrqMenu[0], NULL );

		if ( which >= 0 )
			{
			SBSettings.Interrupt = irqnums[ which ];
			SS_SetupSoundBlaster( true );

			if ( handlewhich == -1 )
				{
				continue;
				}

			return;
			}
		}
	while( which >= 0 );

	handlewhich = -1;
	}


//******************************************************************************
//
// GetNextWord()
//
//******************************************************************************
char *GetNextWord
	(
	char *dest,
	char *source,
	int  length
	)

	{
	while( ( *source != 0 ) && ( isspace( *source ) ) && ( length > 0 ) )
		{
		*dest = *source;
		length--;
		dest++;
		source++;
		}

	while( ( *source != 0 ) && ( !isspace( *source ) ) && ( length > 0 ) )
		{
		*dest = *source;
		length--;
		dest++;
		source++;
		}

	*dest = 0;
	return( source );
	}

//******************************************************************************
//
// CP_ErrorMsg()
//
//******************************************************************************

void CP_ErrorMsg
	(
	char *title,
	char *error,
	int font
	)

	{
	char wordtext[ 80 ];
	char text[ 10 ][ 80 ];
	int  pos;
	int  length;
	int  line;
	int  w;
	int  h;
	int  y;
	extern void VWL_MeasureIntensityString (char *s, int *width, int *height, cfont_t *font);

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( title );

	WindowW = 288;
	WindowH = 158;
	WindowX = 0;
	WindowY = 40;

	IFont = ( cfont_t * )W_CacheLumpName( FontNames[ font ], PU_CACHE );

	pos = 0;
	line = 0;

	text[ 0 ][ 0 ] = 0;

	while( *error != 0 )
		{
		error = GetNextWord( wordtext, error, 79 );

		pos = 0;
		while( ( wordtext[ pos ] != 0 ) && ( isspace( wordtext[ pos ] ) ) )
			{
			pos++;
			}

		length = strlen( text[ line ] );
		if ( length == 0 )
			{
			strcat( text[ line ], &wordtext[ pos ] );
			}
		else
			{
			strcat( text[ line ], wordtext );
			}

		VWL_MeasureIntensityString( text[ line ], &w, &h, IFont );

		if ( w > WindowW - 32 )
			{
			text[ line ][ length ] = 0;
			if ( line >= 10 )
				{
				break;
				}
			line++;
			strcpy( text[ line ], &wordtext[ pos ] );
			}
		}

	if ( strlen( text[ line ] ) == 0 )
		{
		line--;
		}

	VWL_MeasureIntensityString( text[ 0 ], &w, &h, IFont );

	y = ( WindowH - ( line + 1 ) * h ) / 2;

	for( pos = 0; pos <= line; pos++ )
		{
		VWL_MeasureIntensityString( text[ pos ], &w, &h, IFont );
		DrawMenuBufIString( ( 288 - w ) / 2, y, text[ pos ], ACTIVECOLOR );
		y += h;
		}

	DisplayInfo( 5 );
	FlipMenuBuf();
	RefreshMenuBuf( 0 );

	IN_Ack();
	WaitKeyUp();

	MN_PlayMenuSnd( SD_ESCPRESSEDSND );
	}

//****************************************************************************
//
// DrawSoundSetupMainMenu ()
//
//****************************************************************************
void DrawSoundSetupMainMenu
	(
	void
	)

	{
	MenuNum = 1;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Sound Setup" );
	if ( FXMode == 0 )
		{
		SoundSetupMenu[ 2 ].active = CP_Inactive;
		}
	else if ( SoundSetupMenu[ 2 ].active == CP_Inactive )
		{
		SoundSetupMenu[ 2 ].active = CP_Active;
		}

	if ( MusicMode == 0 )
		{
		SoundSetupMenu[ 3 ].active = CP_Inactive;
		}
	else if ( SoundSetupMenu[ 3 ].active == CP_Inactive )
		{
		SoundSetupMenu[ 3 ].active = CP_Active;
		}

	MN_GetCursorLocation( &SoundSetupMenuItems, &SoundSetupMenu[ 0 ] );
	DrawMenu( &SoundSetupMenuItems, &SoundSetupMenu[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}


//******************************************************************************
//
// Sound Setup Quit
//
//******************************************************************************

void SS_Quit
	(
	void
	)

	{
	extern boolean WriteSoundFile;

	CP_DisplayMsg( "Do you wish to\nsave your changes?\n"
		"Press ESC to return\nto sound setup.", 12 );

	if ( CP_Acknowledge != CP_ESC )
		{
		WriteSoundFile = true;
		if ( CP_Acknowledge == CP_NO )
			{
			WriteSoundFile = false;
			}

		MU_FadeOut(310);
		VL_FadeOut (0, 255, 0, 0, 0, 10);
		ShutdownMenuBuf();
		QuitGame ();
		}

	DrawSoundSetupMainMenu();
	}

//******************************************************************************
//
// Sound Setup
//
//******************************************************************************

void CP_SoundSetup ( void )
	{
	int which;
	extern boolean WriteSoundFile;

	WriteSoundFile = false;

	SetupMenuBuf();
	DrawSoundSetupMainMenu();
	IN_ClearKeysDown();

	if ( MusicMode != 0 )
		{
		MU_StartSong( song_title );
		}

	while( 1 )
		{
		which = HandleMenu( &SoundSetupMenuItems, SoundSetupMenu, NULL );
		if ( which == -1 )
			{
			SS_Quit();
			}
		}
	}

//******************************************************************************
//
// SS_MusicMenu ()
//
//******************************************************************************

void SS_MusicMenu
	(
	void
	)

	{
	int which;

	MN_MakeActive( &SoundSetupMusicItems, &SoundSetupMusic[ 0 ], MusicMode );

	SS_DrawMusicMenu ();
	IN_ClearKeysDown();

	do
		{
		which = HandleMenu( &SoundSetupMusicItems, &SoundSetupMusic[ 0 ], NULL );
		}
	while( which > 0 );

	DrawSoundSetupMainMenu();
	handlewhich = RETURNVAL;
	}


//******************************************************************************
//
// SS_DrawMusicMenu ()
//
//******************************************************************************

void SS_DrawMusicMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Select Music Card" );

	MN_GetCursorLocation( &SoundSetupMusicItems, &SoundSetupMusic[ 0 ] );
	DrawMenu( &SoundSetupMusicItems, &SoundSetupMusic[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}


//******************************************************************************
//
// SS_SetupMusicCardMenu()
//
//******************************************************************************

void SS_SetupMusicCardMenu
	(
	void
	)

	{
	int status;
	int select;
	if ( ( ( musicnums[ handlewhich ] == SoundBlaster ) ||
		( musicnums[ handlewhich ] == WaveBlaster ) ||
		( musicnums[ handlewhich ] == Awe32 ) ) &&
		( fxnums[ FXMode ] != SoundBlaster ) &&
		( fxnums[ FXMode ] != Awe32 ) )
		{
		CP_ErrorMsg( "Music Error",
			"Please set your Sound FX card to Sound Blaster before "
			"selecting this card for music.", mn_smallfont );

		handlewhich = -1;
		return;
		}

	MusicMode = handlewhich;

	MU_Shutdown();

	if ( ( musicnums[ MusicMode ] == GenMidi ) ||
		( musicnums[ MusicMode ] == SoundCanvas ) ||
		( musicnums[ MusicMode ] == WaveBlaster ) ||
		( musicnums[ MusicMode ] == Awe32 ) )
		{
		DrawMusicCardMenu();

		IN_ClearKeysDown ();

		select = HandleMenu( &SoundSetupMidiPortItems,
			&SoundSetupMidiPort[0], NULL );

		if ( select > -1 )
			{
			MidiAddress = midinums[ select ];
			}
		else
			{
			SS_DrawMusicMenu ();
			handlewhich = RETURNVAL;
			MusicMode = 0;
			return;
			}
		}

	if ( MusicMode != 0 )
		{
		if ( ( musicnums[ handlewhich ] == WaveBlaster ) ||
			( musicnums[ handlewhich ] == Awe32 ) )
			{
			SD_Shutdown();
			}

		SetAlternateMenuBuf();
		ClearMenuBuf();
		SetMenuTitle( "Music Card Initialization" );
		WindowW = 288;
		WindowH = 158;
		PrintX = WindowX = 0;
		PrintY = WindowY = 65;
		newfont1 = (font_t *)W_CacheLumpName( "newfnt1", PU_CACHE );
		CurrentFont = newfont1;
		MenuBufCPrint( "Initializing card.\nPlease wait." );
		FlipMenuBuf();
		RefreshMenuBuf( 0 );

		status = MU_Startup( false );
		if ( status )
			{
			MusicMode = 0;

			CP_ErrorMsg( "Music Error", MUSIC_ErrorString( MUSIC_Error ),
				mn_smallfont );
			SS_DrawMusicMenu ();
			handlewhich = RETURNVAL;
			}
		else
			{
			handlewhich = -1;
			MU_StartSong( song_title );
			}

		if ( ( musicnums[ MusicMode ] == WaveBlaster ) ||
			( musicnums[ MusicMode ] == Awe32 ) )
			{
			status = SD_Startup( false );
				if ( status != FX_Ok )
				{
				CP_ErrorMsg( "Sound FX Error", FX_ErrorString( FX_Error ),
					mn_smallfont );

				handlewhich = -2;
				}
			}
		}
	else
		{
		handlewhich = -1;
		MU_Shutdown();
		}
	}


//******************************************************************************
//
// DrawMusicCardMenu()
//
//******************************************************************************

void DrawMusicCardMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;
	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle( "Select MIDI Port Address" );
	MN_GetActive( &SoundSetupMidiPortItems, &SoundSetupMidiPort[ 0 ],
		MidiAddress, midinums );
	DrawMenu( &SoundSetupMidiPortItems, &SoundSetupMidiPort[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}

//******************************************************************************
//
// SS_SoundMenu ()
//
//******************************************************************************

void SS_SoundMenu
	(
	void
	)

	{
	int which;

	MN_MakeActive( &SoundSetupSoundItems, &SoundSetupSound[0], FXMode );

	SS_DrawSoundMenu ();
	IN_ClearKeysDown();

	do {
		which = HandleMenu( &SoundSetupSoundItems, &SoundSetupSound[ 0 ], NULL );
		}
	while( which >= 0 );

	DrawSoundSetupMainMenu();
	handlewhich = RETURNVAL;
	}


//******************************************************************************
//
// SS_DrawSoundMenu ()
//
//******************************************************************************

void SS_DrawSoundMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Select Sound FX Card");

	MN_GetCursorLocation( &SoundSetupSoundItems, &SoundSetupSound[0] );

	DrawMenu( &SoundSetupSoundItems, &SoundSetupSound[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}


//******************************************************************************
//
// SS_SetupSoundBlaster()
//
//******************************************************************************

void SS_SetupSoundBlaster
	(
	int sbmenu
	)

	{
	int status;

	status = FX_SetupSoundBlaster( SBSettings, &MaxVoices,
		&MaxBits, &MaxChannels );

	if ( status == FX_Ok )
		{
		SS_VoiceMenu( sbmenu );

		if ( handlewhich < 0 )
			{
			return;
			}
		SetAlternateMenuBuf();
		ClearMenuBuf();
		SetMenuTitle( "Sound Card Initialization" );
		WindowW = 288;
		WindowH = 158;
		PrintX = WindowX = 0;
		PrintY = WindowY = 65;
		newfont1 = (font_t *)W_CacheLumpName( "newfnt1", PU_CACHE );
		CurrentFont = newfont1;
		MenuBufCPrint( "Initializing card.\nPlease wait." );
		FlipMenuBuf();
		RefreshMenuBuf( 0 );

		status = SD_Startup( false );

		RefreshMenuBuf( 0 );
		}

	if ( status != FX_Ok )
		{
		CP_ErrorMsg( "Sound FX Error", FX_ErrorString( FX_Error ),
			mn_smallfont );

		handlewhich = -2;
		}
	}


//******************************************************************************
//
// SS_SetupSoundCardMenu()
//
//******************************************************************************

void SS_SetupSoundCardMenu
	(
	void
	)

	{
	int which;
	int FXstatus;
	extern int fxnums[];

	INFXSETUP = true;

	FXMode = handlewhich;

	SD_Shutdown();

	if ( FXMode == 0 )
		{
		handlewhich = -1;
		}
	else
		{
		if ( ( fxnums[ FXMode ] == SoundBlaster ) ||
			( fxnums[ FXMode ] == Awe32 ) )
			{
			do
				{
				SS_DrawSBSetupMenu();
				which = HandleMenu( &SBSetupItems, &SBSetupMenu[ 0 ], NULL );
				}
			while( which == -2 );

			if ( which == -1 )
				{
				FXMode = 0;
				handlewhich = 0;
				SS_DrawSoundMenu();
				}
			else
				{
				handlewhich = -1;
				}

			INFXSETUP = false;
			return;
			}

		FXstatus = SD_SetupFXCard( &MaxVoices, &MaxBits, &MaxChannels );
		if ( FXstatus == FX_Ok )
			{
			SS_VoiceMenu( true );

			if ( handlewhich == -1 )
				{
				SS_DrawSoundMenu ();
				handlewhich = RETURNVAL;
				FXMode = 0;
				SD_Shutdown ();
				INFXSETUP = false;
				return;
				}

			SetAlternateMenuBuf();
			ClearMenuBuf();
			SetMenuTitle( "Sound Card Initialization" );
			WindowW = 288;
			WindowH = 158;
			PrintX = WindowX = 0;
			PrintY = WindowY = 65;
			newfont1 = (font_t *)W_CacheLumpName( "newfnt1", PU_CACHE );
			CurrentFont = newfont1;
			MenuBufCPrint( "Initializing card.\nPlease wait." );
			FlipMenuBuf();
			RefreshMenuBuf( 0 );

			FXstatus = SD_Startup( false );

			RefreshMenuBuf( 0 );
			}

		if ( FXstatus != FX_Ok )
			{
			FXMode = 0;
			handlewhich = RETURNVAL;

			CP_ErrorMsg( "Sound FX Error", FX_ErrorString( FX_Error ),
				mn_smallfont );
			SS_DrawSoundMenu();
			}
		else
			{
			handlewhich = -1;
			}
		}

	INFXSETUP = false;
	}


//******************************************************************************
//
// SS_VoiceMenu ()
//
//******************************************************************************

void SS_VoiceMenu
	(
	int sbmenu
	)

	{
	int which;

	if ( MaxVoices < 2 )
		{
		NumVoices = 1;
		SS_ChannelMenu();
		return;
		}

	do
		{
		SS_DrawVoiceMenu ();

		which = HandleMenu( &SoundSetupVoiceItems, &SoundSetupVoice[0],
			NULL );
		if ( which >= 0 )
			{
			NumVoices = voicenums[ which ];
			SS_ChannelMenu();
			if ( handlewhich == -1 )
				{
				continue;
				}
			return;
			}
		}
	while( which >= 0 );

	if ( sbmenu )
		{
		handlewhich = -1;
		}
	else
		{
		handlewhich = -2;
		}
	}

//******************************************************************************
//
// SS_DrawVoiceMenu()
//
//******************************************************************************

void SS_DrawVoiceMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Number of Voices");

	MN_GetActive( &SoundSetupVoiceItems, &SoundSetupVoice[0],
		NumVoices, voicenums );

	DrawMenu( &SoundSetupVoiceItems, &SoundSetupVoice[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}

//******************************************************************************
//
// SS_ChannelMenu ()
//
//******************************************************************************

void SS_ChannelMenu
	(
	void
	)

	{
	int which;

	if ( MaxChannels < 2 )
		{
		NumChannels = 1;
		SS_BitMenu();
		return;
		}

	do
		{
		SS_DrawChannelMenu ();
		which = HandleMenu( &SoundSetupChannelItems, &SoundSetupChannel[0],
			NULL );
		if ( which >= 0 )
			{
			NumChannels = smnums[ which ];
			SS_BitMenu();
			if ( handlewhich == -1 )
				{
				continue;
				}
			return;
			}
		}
	while( which >= 0 );

	handlewhich = -1;
	}

//******************************************************************************
//
// SS_DrawChannelMenu()
//
//******************************************************************************

void SS_DrawChannelMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Number of Channels");

	MN_GetActive( &SoundSetupChannelItems, &SoundSetupChannel[0],
		NumChannels, smnums );

	DrawMenu( &SoundSetupChannelItems, &SoundSetupChannel[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}

//******************************************************************************
//
// SS_BitMenu ()
//
//******************************************************************************

void SS_BitMenu
	(
	void
	)

	{
	int which;

	if ( MaxBits < 16 )
		{
		NumBits = 8;
		return;
		}

	SS_DrawBitMenu ();

	which = HandleMenu( &SoundSetupResolutionItems,
		&SoundSetupResolution[0], NULL );

	if ( which >= 0 )
		{
		NumBits = resnums[ which ];
		return;
		}

	handlewhich = -1;
	}


//******************************************************************************
//
// SS_DrawBitMenu()
//
//******************************************************************************

void SS_DrawBitMenu
	(
	void
	)

	{
	MenuNum = SNDCARDS;

	SetAlternateMenuBuf();
	ClearMenuBuf();
	SetMenuTitle ("Playback Resolution");

	MN_GetActive( &SoundSetupResolutionItems, &SoundSetupResolution[0],
		NumBits, resnums );

	DrawMenu( &SoundSetupResolutionItems, &SoundSetupResolution[ 0 ] );
	DisplayInfo( 0 );

	FlipMenuBuf();
	}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "rt_view.h"
#include "z_zone.h"
#include "w_wad.h"
#include "lumpy.h"
#include "rt_util.h"
#include "rt_vid.h"
#include "rt_str.h"
#include "rt_menu.h"
#include "_rt_msg.h"
#include "rt_msg.h"
#include "rt_playr.h"
#include "isr.h"
#include "rt_main.h"
#include "rt_net.h"
#include "rt_com.h"
// #include <mem.h>
#include <stdlib.h>
//MED
// #include "memcheck.h"


/*
=============================================================================

                               GLOBALS

=============================================================================
*/
messagetype Messages[MAXMSGS];

/*
=============================================================================

                               LOCAL

=============================================================================
*/

static int  UpdateMessageBackground;
static int  MessageSystemStarted=0;
static int  LastMessageTime;
static boolean EraseMessage[ MAXMSGS ];
static int     MessageOrder[ MAXMSGS ];
static int     TotalMessages = 0;
static int     MsgPos = 0;

boolean MessagesEnabled = true;

int StringLength (char *string)
{
	int length=0;

   while ((*string)!=0)
      {
      length++;
      string++;
      }

   length++;

   return length;
}

/*
====================
=
= ResetMessageTime
=
====================
*/

void ResetMessageTime ( void )
{
   LastMessageTime=ticcount;
}

/*
====================
=
= InitializeMessages
=
====================
*/
void InitializeMessages
   (
   void
   )

   {
   int i;
   boolean start;

   start = false;

   if ( MessageSystemStarted == 0 )
      {
      start = true;
      MessageSystemStarted = 1;
      memset( Messages, 0, sizeof( Messages ) );
      }

   for ( i = 0; i < MAXMSGS; i++ )
      {
      if ( Messages[ i ].active == 1 )
         {
         SafeFree( Messages[ i ].text );
         Messages[ i ].active  = 0;
         Messages[ i ].tictime = 0;
         Messages[ i ].flags   = 0;
         Messages[ i ].text    = NULL;
         }
      }

   MSG.messageon = false;

   LastMessageTime = 0;
   UpdateMessageBackground = 0;
   TotalMessages = 0;
   memset( EraseMessage,  0, sizeof( EraseMessage ) );
   memset( MessageOrder, -1, sizeof( MessageOrder ) );

   // Only print startup message if it's the first time in
   if ( start && !quiet )
      {
      printf( "RT_MSG: Message System Started\n" );
      }
   }


/*
====================
=
= GetMessageOrder
=
====================
*/
void GetMessageOrder
   (
   void
   )

   {
   int  i;
   int  lowest;
   int  lowesttime;
   byte done[ MAXMSGS ];
   boolean found;

   memset( &done[ 0 ],    0, sizeof( done ) );
   memset( MessageOrder, -1, sizeof( MessageOrder ) );

   for( TotalMessages = 0; TotalMessages < MAXMSGS; TotalMessages++ )
      {
      found = false;
      lowesttime = 1000;
      lowest = 0;

      for( i = 0; i < MAXMSGS; i++ )
         {
         if ( ( Messages[ i ].active == 1 ) && ( done[ i ] == 0 ) &&
            ( Messages[ i ].tictime < lowesttime ) )
            {
            lowesttime = Messages[ i ].tictime;
            lowest = i;
            found = true;
            }
         }

      if ( !found )
         {
         break;
         }

      done[ lowest ] = 1;
      MessageOrder[ TotalMessages ] = lowest;
      }
   }


/*
====================
=
= DeleteMessage
=
====================
*/
void DeleteMessage
   (
   int num
   )

   {
   int i;
   int msg;
   boolean found;

   found = false;
   for( i = 0; i < TotalMessages; i++ )
      {
      msg = MessageOrder[ i ];

      if ( msg == num )
         {
         found = true;
         }

      if ( found )
         {
         UpdateMessageBackground -= EraseMessage[ i ];
         UpdateMessageBackground += 3;
         EraseMessage[ i ] = 3;
         }
      }

   SafeFree( Messages[ num ].text );
   memset( &Messages[ num ], 0, sizeof( messagetype ) );

   GetMessageOrder();
   }


/*
====================
=
= DeletePriorityMessage
=
====================
*/
void DeletePriorityMessage ( int flags )
{
   int i;

   for (i=0;i<MAXMSGS;i++)
      {
      if (Messages[i].active==1)
         {
         if (Messages[i].flags==flags)
            DeleteMessage(i);
         }
      }
}


/*
====================
=
= GetFreeMessage
=
====================
*/
int GetFreeMessage
   (
   void
   )

   {
   int i;
   int found;

   for( i = 0; i < MAXMSGS; i++ )
      {
      if ( Messages[ i ].active == 0 )
         {
         return( i );
         }
      }

   found = -1;

   for( i = 0; i < MAXMSGS; i++ )
      {
      if ( Messages[ i ].tictime >= 0 )
         {
         if ( found == -1 )
            {
            found = i;
            }
         else
            {
            if ( Messages[ i ].tictime < Messages[ found ].tictime )
               {
               found = i;
               }
            }
         }
      }

   DeleteMessage( found );

   return( found );
   }


/*
====================
=
= SetMessage
=
====================
*/
void SetMessage
   (
   int   num,
   char *text,
   int   flags
   )

   {
   int i;
   int msg;
   int length;
   boolean found;


   length = StringLength( text );

   Messages[ num ].active = 1;
   Messages[ num ].flags  = flags;

   if ( PERMANENT_MSG( flags ) )
      {
      int l;

      l = COM_MAXTEXTSTRINGLENGTH + 1;
      Messages[ num ].text = SafeMalloc( l );
      memset( Messages[ num ].text, 0, l );

      // Hack so that we can place menu in certain order
      Messages[ num ].tictime = -100 + MsgPos;
      }
   else
      {
      Messages[ num ].text = SafeMalloc( length );

      memset( Messages[ num ].text, 0, length );
      Messages[ num ].tictime = MESSAGETIME;
      }

   memcpy( Messages[ num ].text, text, length );

   GetMessageOrder();
   found = false;
   for( i = 0; i < TotalMessages; i++ )
      {
      msg = MessageOrder[ i ];
      if ( msg == num )
         {
         found = true;
         }
      else if ( found )
         {
         UpdateMessageBackground -= EraseMessage[ i - 1 ];
         UpdateMessageBackground += 3;
         EraseMessage[ i - 1 ] = 3;
         }
      }
   }


/*
====================
=
= AddMessage
=
====================
*/
int AddMessage
   (
   char *text,
   int flags
   )

   {
   int new;

   if ( MessageSystemStarted == 0 )
      {
      Error( "Called AddMessage without starting Message system\n" );
      }

   if ( !( flags & MSG_NODELETE ) )
      {
      DeletePriorityMessage( flags );
      }

   new = GetFreeMessage();
   SetMessage( new, text, flags );

   return( new );
   }

/*
====================
=
= UpdateMessages
=
====================
*/
void UpdateMessages
   (
   void
   )

   {
   int messagetics;
   int i;

   messagetics = ticcount - LastMessageTime;
   LastMessageTime = ticcount;

   if ( GamePaused == true )
      {
      return;
      }

   for( i = 0; i < MAXMSGS; i++ )
      {
      if ( ( Messages[ i ].active == 1 ) &&
         ( !PERMANENT_MSG( Messages[ i ].flags ) ) )
         {
         Messages[ i ].tictime -= messagetics;
         if ( Messages[ i ].tictime <= 0 )
            {
            DeleteMessage( i );
            }
         }
      }
   }


/*
====================
=
= DisplayMessage
=
====================
*/

void DisplayMessage
   (
   int num,
   int position
   )

   {
   PrintX = 1;
   PrintY = 2 + ( position * 9 );

   if ( SHOW_TOP_STATUS_BAR() )
      {
      PrintY += 16;
      }
   if ( !MessagesEnabled )
      {
      switch ( Messages[ num ].flags )
         {
         case MSG_QUIT:
         case MSG_MACRO:
         case MSG_MODEM:
         case MSG_NAMEMENU:
         case MSG_MSGSYSTEM:
            break;

         case MSG_REMOTERIDICULE:
         case MSG_REMOTE:
         case MSG_GAME:
         case MSG_DOOR:
         case MSG_BONUS:
         case MSG_BONUS1:
         case MSG_CHEAT:
         case MSG_SYSTEM:
         default :
            DeleteMessage( num );
            return;
         }
      }

   switch ( Messages[ num ].flags )
      {
      case MSG_REMOTERIDICULE:
      case MSG_REMOTE:
         fontcolor = egacolor[ WHITE ];
         break;

      case MSG_MODEM:
         fontcolor = egacolor[ LIGHTBLUE ];
         DrawIString( PrintX, PrintY, "Message>", Messages[ num ].flags );
         PrintX += 8 * 8;
         fontcolor = egacolor[ LIGHTGRAY ];
         break;

      case MSG_GAME:
      case MSG_DOOR:
      case MSG_BONUS:
      case MSG_BONUS1:
      case MSG_NAMEMENU:
         fontcolor = egacolor[ GREEN ];
         break;

      case MSG_CHEAT:
         fontcolor = egacolor[ YELLOW ];
         break;
      case MSG_MSGSYSTEM:
      case MSG_SYSTEM:
      case MSG_QUIT:
      case MSG_MACRO:
         fontcolor = egacolor[ RED ];
         break;

      default :
#if ((DEVELOPMENT == 1))
         Error( "DisplayMessage called with invalid priority number." );
#else
         fontcolor = egacolor[ LIGHTGREEN ];
#endif
      }

   DrawIString( PrintX, PrintY, Messages[ num ].text, Messages[ num ].flags );
   }



/*
====================
=
= RestoreMessageBackground
=
====================
*/
void RestoreMessageBackground
   (
   void
   )

   {
   pic_t *shape;
   int i;
   int y;

   if ( UpdateMessageBackground > 0 )
      {
      y = 18;
      for( i = 0; i < MAXMSGS; i++ )
         {
         if ( EraseMessage[ i ] )
            {
            UpdateMessageBackground--;
            EraseMessage[ i ]--;
            if ( viewsize < 15 )
               {
               shape = W_CacheLumpName( "backtile", PU_CACHE );
               DrawTiledRegion( 0, y, 320, 9, 0, y, shape );
               }
            if ( viewsize == 0 )
               {
               if ( ( y + 9 > YOURCPUSUCKS_Y ) &&
                  ( y < ( YOURCPUSUCKS_Y + YOURCPUSUCKS_HEIGHT ) ) )
                  {
                  DrawCPUJape();
                  }
               }
            }

         y += 9;
         }
      }
   }


/*
====================
=
= DrawMessages
=
====================
*/
void DrawMessages
   (
   void
   )

   {
   int i;

   if ( TotalMessages > 0 )
      {
      IFont = ( cfont_t * )W_CacheLumpName( "ifnt", PU_CACHE );

      for( i = 0; i < TotalMessages; i++ )
         {
         DisplayMessage( MessageOrder[ i ], i );
         }
      }
   UpdateMessages();
   }


/*
====================
=
= UpdateModemMessage
=
====================
*/
void UpdateModemMessage
   (
   int num,
   char c
   )

   {
   int i;

   Messages[ num ].text[ MSG.length - 1 ] = ( byte )c;
   Messages[ num ].text[ MSG.length ]     = ( byte )'_';
   MSG.length++;

   for( i = 0; i < TotalMessages; i++ )
      {
      if ( MessageOrder[ i ] == num )
         {
         UpdateMessageBackground -= EraseMessage[ i ];
         UpdateMessageBackground += 3;
         EraseMessage[ i ] = 3;
         break;
         }
      }
   }


/*
====================
=
= ModemMessageDeleteChar
=
====================
*/
void ModemMessageDeleteChar
   (
   int num
   )

   {
   int i;

   MSG.length--;
   Messages[ num ].text[ MSG.length ]     = ( byte )0;
   Messages[ num ].text[ MSG.length - 1 ] = ( byte )'_';

   for( i = 0; i < TotalMessages; i++ )
      {
      if ( MessageOrder[ i ] == num )
         {
         UpdateMessageBackground -= EraseMessage[ i ];
         UpdateMessageBackground += 3;
         EraseMessage[ i ] = 3;
         break;
         }
      }
   }


/*
====================
=
= DrawPlayerSelectionMenu
=
====================
*/

void DrawPlayerSelectionMenu
   (
   void
   )

   {
   int i;
   int p;
   char str[ 20 ];

   p = 1;
   MsgPos = 1;
   AddMessage( "Press a key from 0 to 9 to select", MSG_NAMEMENU );
   MsgPos++;
   AddMessage( "who to send your message to:", MSG_NAMEMENU );
   MsgPos++;

   for( i = 0; i < numplayers; i++ )
      {
      if ( i != consoleplayer )
         {
         strcpy( str, "0 - " );
         strcat( str, PLAYERSTATE[ i ].codename );
         str[ 0 ] = '0' + p;
         p++;
         if ( p > 9 )
            {
            p = 0;
            }

         AddMessage( str, MSG_NAMEMENU );
         MsgPos++;
         }
      }

   if ( ( MsgPos < MAXMSGS - 1 ) && ( gamestate.teamplay ) )
      {
      AddMessage( "T - All team members", MSG_NAMEMENU );
      MsgPos++;
      }

   if ( MsgPos < MAXMSGS - 1 )
      {
      AddMessage( "A - All players", MSG_NAMEMENU );
      }

   MsgPos = 0;
   }


/*
====================
=
= FinishModemMessage
=
====================
*/
void FinishModemMessage
   (
   int num,
   boolean send
   )
   {
   if ( ( !MSG.inmenu ) && ( MSG.length > 0 ) )
      {
      Messages[ num ].text[ MSG.length - 1 ] = ( byte )0;
      MSG.length--;
      }

   if ( ( send == true ) && ( ( MSG.length > 0 ) ||
      ( MSG.remoteridicule != -1 ) ) )
      {
      if ( ( MSG.directed ) && ( !MSG.inmenu ) )
         {
         DrawPlayerSelectionMenu();
         MSG.messageon = true;
         MSG.inmenu = true;
         return;
         }

      MSG.messageon = false;
      if ( MSG.remoteridicule != -1 )
         {
         AddRemoteRidiculeCommand( consoleplayer, MSG.towho,
            MSG.remoteridicule );
         }
      if ( MSG.length > 0 )
         {
         AddTextMessage( Messages[ num ].text, MSG.length, MSG.towho );
         }
      }

   if ( MSG.inmenu )
      {
      DeletePriorityMessage( MSG_NAMEMENU );
      }

   DeleteMessage( num );
   }
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// #include <dos.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
// #include <io.h>
// #include <fcntl.h>

#include "rt_def.h"
#include "rt_main.h"
#include "rt_net.h"
#include "rt_com.h"
#include "_rt_net.h"
#include "rt_actor.h"
#include "rt_playr.h"
#include "isr.h"
#include "z_zone.h"
#include "develop.h"
#include "rottnet.h"
#include "rt_msg.h"
#include "rt_sound.h"
#include "rt_menu.h"
#include "rt_util.h"
#include "rt_rand.h"
#include "rt_game.h"
#include "rt_draw.h"
#include "myprint.h"
#include "rt_debug.h"
#include "rt_view.h"
#include "rt_battl.h"
#include "rt_dmand.h"
//MED
// #include "memcheck.h"

#if (SYNCCHECK == 1)
int				lastsynccheck;
COM_CheckSyncType PlayerSync[MAXPLAYERS];
#endif


CommandType * LocalCmds;
CommandType * ServerCmds;

volatile int ticcount;
volatile int fasttics;

int		controlupdatestartedtime=-1;
int		controlupdatetime=-1;
int		serverupdatetime=-1;
int		controlupdatestarted=0;
boolean	GamePaused=false;

boolean	modemgame;
boolean	networkgame;
int		numplayers;
int		server;
boolean	IsServer;
boolean	standalone=true;
boolean	restartgame=false;
boolean	respawnactive=false;
boolean	playerdead=false;
boolean	controlschanged=true;
boolean	battlegibs=false;
boolean	remoteridicule = false;

/*
=============================================================================

					LOCAL FUNCTION PROTOTYPES and VARIABLES

=============================================================================
*/
boolean  demorecord,
			demoplayback;
byte	*demoptr,
			*lastdemoptr,
			*demobuffer=NULL;
boolean  demodone = false;
int oldmomx;
int oldmomy;
int oldspdang;

static boolean GameCommandsStarted=false;

static int oldcontrolbuf[3];
static int oldbuttonbits;
static CommandType * PlayerCmds[MAXPLAYERS];
static CommandType * ClientCmds[MAXPLAYERS];

static boolean GotPlayersDesc[MAXPLAYERS];
static boolean PlayersReady[MAXPLAYERS];
static int	LastCommandTime[MAXPLAYERS];

static CommandStatusType * CommandState[MAXPLAYERS+1];

static boolean InProcessServer=false;
static lastcontrolupdatetime;
static largesttime;
static PlayerStatus[MAXPLAYERS];
//static int syncservertime;
//static boolean FixingPackets;
static int controldivisor=1;
static int nextupdatetime;
static boolean UpdateServer=true;

void CheckForPacket ( void );

/*
=============================================================================

						Game Command Section

=============================================================================
*/

//****************************************************************************
//
// ComError ()
//
//****************************************************************************

#define ComError SoftError
#if 0
void ComError (char *error, ...)
{
#if 0
	va_list	argptr;
#endif

	SoftError(error);
#if 0
	if (standalone==true)
		{
		va_start (argptr, error);
		vprintf (error, argptr);
		va_end (argptr);
		}
#endif
}
#endif

//****************************************************************************
//
// ConsoleIsServer()
//
//****************************************************************************
boolean ConsoleIsServer ( void )
{
	if (modemgame==true)
		{
		if (networkgame==true)
			{
			if (rottcom->client==0)
				{
				return true;
				}
			}
		}
	return false;
}

//****************************************************************************
//
// GamePacketSize()
//
//****************************************************************************
int GamePacketSize( void )
{
	if ((remoteridicule == true) || (ConsoleIsServer() == true))
		{
		return GetTypeSize(COM_SOUNDANDDELTA);
		}
	else
		return GetTypeSize(COM_TEXT);
}

//****************************************************************************
//
// InitializeGameCommands()
//
//****************************************************************************
void InitializeGameCommands( void )
{
	int i;
	int j;

	// default to player 0

	if (GameCommandsStarted==true)
		return;

	GameCommandsStarted=true;

	if ((modemgame==true))
		controldivisor=rottcom->ticstep;

	standalone=false;
	IsServer=false;

	if (modemgame==true)
	{
		consoleplayer=rottcom->consoleplayer;

		if (networkgame==true)
		{
			if (rottcom->client==0)
			{
				IsServer=true;
				// turn it on absolutely for the server
				remoteridicule = true;
				if (consoleplayer==0)
					standalone=true;
			}
			if (consoleplayer>0)
				consoleplayer--; // playernumber fixup
		}
	}

	if (standalone==false)
	{
		int size;

		size = GamePacketSize ();

		for (i=0;i<numplayers;i++)
		{
			PlayerCmds[i]=(CommandType *)SafeLevelMalloc(sizeof(CommandType));
			for (j=0;j<MAXCMDS;j++)
			{
				PlayerCommand(i,j)=SafeLevelMalloc(size);
			}
		}
	}

	// allocate local commands

	LocalCmds=(CommandType *)SafeLevelMalloc(sizeof(CommandType));
	for (j=0;j<MAXCMDS;j++)
	{
		int size;

		size = GamePacketSize();

		LocalCommand(j)=SafeLevelMalloc(size);
		memset(LocalCommand(j),COM_DELTANULL,size);
	}

	CommandState[0]=(CommandStatusType *)SafeLevelMalloc(sizeof(CommandStatusType));

	if (modemgame==true)
	{
		for (i=0;i<numplayers;i++)
		{
			PlayerStatus[i]=player_ingame;
		}
		if (networkgame==true)
		{
			server=1;

			// initialize the Server

			if (IsServer==true)
			{
				server=0;
				ServerCmds=(CommandType *)SafeMalloc(sizeof(CommandType));
				for (j=0;j<MAXCMDS;j++)
				{
					int size;
					size=( (numplayers * GetTypeSize(COM_TEXT)) +
							GetTypeSize(COM_SOUNDANDDELTA) +
							sizeof(COM_ServerHeaderType) -
							sizeof(byte)
						);
					ServerCommand(j)=SafeMalloc( size );
					memset(ServerCommand(j),COM_DELTANULL,size);
				}
				for (i=1;i<=numplayers;i++)
				{
					CommandState[i]=(CommandStatusType *)
										SafeMalloc(sizeof(CommandStatusType));
				}
				for (i=0;i<numplayers;i++)
				{
					ClientCmds[i]=(CommandType *)SafeMalloc(sizeof(CommandType));
					for (j=0;j<MAXCMDS;j++)
					{
						int size;

						size=GetTypeSize(COM_SOUNDANDDELTA);
						ClientCommand(i,j)=SafeMalloc(size);
						memset(ClientCommand(i,j),COM_DELTANULL,size);
					}
				}
			}
		}
		else // must be a two player game
		{
			server=consoleplayer^1;
		}
		}
#if 0
#if (DEVELOPMENT == 1)
		if (IsServer)
			ComError("I am the server\n");
		ComError("consoleplayer=%ld\n",consoleplayer);
		ComError("server=%ld mynumber=%ld\n",server,consoleplayer);
#endif
#endif
}


//****************************************************************************
//
// ShutdownGameCommands()
//
//****************************************************************************
void ShutdownGameCommands( void )
{
	int i;
	int j;

	if (GameCommandsStarted==false)
		return;

	GameCommandsStarted=false;

	// free up playercmds;
	if (standalone==false)
		{
		for (i=0;i<numplayers;i++)
			{
			for (j=0;j<MAXCMDS;j++)
				{
				if (PlayerCommand(i,j))
					{
					SafeFree(PlayerCommand(i,j));
					PlayerCommand(i,j)=NULL;
					}
				}
			SafeFree( PlayerCmds[i] );
			PlayerCmds[i]=NULL;
			}
		}

	// free up command status

	SafeFree(CommandState[0]);
	CommandState[0]=NULL;

	if (modemgame==true)
		{

		// free up local commands

		for (j=0;j<MAXCMDS;j++)
			{
			if (LocalCommand(j))
				{
				SafeFree(LocalCommand(j));
				LocalCommand(j)=NULL;
				}
			}
		SafeFree(LocalCmds);
		LocalCmds=NULL;


		// free up Server

		if (networkgame==true)
			{
			if (IsServer==true)
				{
				for (j=0;j<MAXCMDS;j++)
					{
					if (ServerCommand(j))
						{
						SafeFree(ServerCommand(j));
						ServerCommand(j)=NULL;
						}
					}
				SafeFree(ServerCmds);
				ServerCmds=NULL;
				for (i=1;i<=numplayers;i++)
					{
					SafeFree(CommandState[i]);
					CommandState[i]=NULL;
					}
				for (i=0;i<numplayers;i++)
					{
					for (j=0;j<MAXCMDS;j++)
						{
						if (ClientCommand(i,j))
							{
							SafeFree(ClientCommand(i,j));
							ClientCommand(i,j)=NULL;
							}
						}
					SafeFree( ClientCmds[i] );
					ClientCmds[i]=NULL;
					}
				}
			}
		}
}




/*
=============================================================================

						Client Controls Section

=============================================================================
*/


//****************************************************************************
//
// ShutdownClientControls ()
//
//****************************************************************************

void ShutdownClientControls ( void )
{
	int i;
#if (DEVELOPMENT == 1)
	SoftError ("LARGEST time difference=%ld\n",largesttime);
#endif
	controlupdatestarted=0;
	for (i=0;i<numplayers;i++)
		{
		if (PlayerStatus[i] == player_leftgame)
			PlayerStatus[i]=player_ingame;
		}
}


//****************************************************************************
//
// StartupClientControls ()
//
//****************************************************************************

void StartupClientControls ( void )
{
	int i,j;

	if (controlupdatestarted==1)
		return;

	controlupdatestarted=1;

	memset(oldcontrolbuf,-1,sizeof(oldcontrolbuf));
	oldbuttonbits=-1;
	controlschanged=true;

	INL_GetMouseDelta(&i,&i);


	locplayerstate->dmomx = 0;
	locplayerstate->dmomy = 0;
	locplayerstate->angle = 0;
	locplayerstate->topspeed=MaxSpeedForCharacter(locplayerstate);


	CalcTics();
	CalcTics();

//	FixingPackets=false;

	memset (controlbuf, 0, sizeof (controlbuf));
	buttonbits = 0;
	lastpolltime=-1;
	IN_ClearKeyboardQueue ();

	if (modemgame==true)
		{
		controlupdatetime=controlsynctime+(VBLCOUNTER*2);
		SoftError("Controls started at %ld\n",controlupdatetime);
		}
	else if (demoplayback || demorecord)
		{
		ISR_SetTime(20);
		oldtime = 20;
		controlupdatetime=20;
		}
	else
		controlupdatetime=ticcount;

	controlupdatetime-=(controlupdatetime%controldivisor);

	serverupdatetime=controlupdatetime;
	oldpolltime=controlupdatetime;
	nextupdatetime=oldpolltime;
#if (SYNCCHECK == 1)
	lastsynccheck=oldpolltime+CHECKSYNCTIME;
#endif
	controlupdatestartedtime=controlupdatetime;

	for( j = 0; j < numplayers; j++ )
		{
		memset( PLAYERSTATE[ j ].buttonheld, 0,
			sizeof( PLAYERSTATE[ j ].buttonheld ) );
		memset( PLAYERSTATE[ j ].buttonstate, 0,
			sizeof( PLAYERSTATE[ j ].buttonstate ) );
		}

	for (i=0;i<MAXCMDS;i++)
		{
		ServerCommandNumberStatus( i ) = cs_notarrived;
		}

	LastCommandTime[0]=controlupdatetime-controldivisor;
	if (IsServer==true)
		{
		int size;

		UpdateServer=true;
		size=( (numplayers * GetTypeSize(COM_TEXT)) +
					GetTypeSize(COM_SOUNDANDDELTA) +
					sizeof(COM_ServerHeaderType) -
					sizeof(byte)
				);

		for (j=0;j<numplayers;j++)
			{
			for (i=0;i<MAXCMDS;i++)
				{
				ClientCommandNumberStatus( j , i ) = cs_notarrived;
				}
			LastCommandTime[j]=controlupdatetime-controldivisor;
			}
		for (i=0;i<MAXCMDS;i++)
			memset(ServerCommand(i),COM_DELTANULL,size);
		}
	else if (modemgame==true)
		{
		int nump;

		nump=numplayers;
		if (nump<2) nump=2;

		for (i=0;i<nump;i++)
			{
			LastCommandTime[i]=controlupdatetime-controldivisor;
			}
		}


#if (DEVELOPMENT == 1)
//	ComError("StartupClientControls: ticcount=%ld oldtime=%ld controlupdatetime=%ld\n",ticcount,oldtime,controlupdatetime);
#endif

	if ((demoplayback==false) && (standalone==false))
		{
		if (modemgame==true)
			{
			while (ticcount<(controlupdatetime-10))
				{
				CalcTics();
				}
			}
		lastcontrolupdatetime=ticcount;
		largesttime=0;
		PollControls();
		}
	if (standalone==true)
		printf("Packet Server started\n");
}



//****************************************************************************
//
// UpdateClientControls ()
//
//****************************************************************************

static boolean InUCC=false;
void UpdateClientControls ( void )
{
	int time;
//	int delta;

	if (controlupdatestarted==0)
		return;

	if (InUCC)
		return;
	else
		InUCC = true;

	wami(6);

#if 0

	delta=ticcount-lastcontrolupdatetime;
	if (delta>largesttime)
		{
		if (delta>10)
			largesttime=delta;
		largesttime=delta;
		}

#endif
	lastcontrolupdatetime=ticcount;

	if (standalone==false)
	{
		time=ticcount;

		// if we are a fixing the current packet stop update of deltas
		// in non-network games.
		if (
			(networkgame == false) &&
			(ServerCommandStatus(oldpolltime)==cs_fixing)
			)
			{
			time=controlupdatetime-controldivisor;
			}

		while (time>=controlupdatetime)
			{
			MoveType * Delta;
			boolean soundready;

			soundready = SD_SoundDataReady();

			if (demoplayback==true)
				{
				UpdateDemoPlayback(controlupdatetime);
				}
//			else
//				{
//				PollControls();
//				}

			if (
				(memcmp(&controlbuf[0],&oldcontrolbuf[0],sizeof(controlbuf))!=0) ||
				(buttonbits!=oldbuttonbits)
				)
				{
				controlschanged=true;
				memcpy(&oldcontrolbuf[0],&controlbuf[0],sizeof(controlbuf));
				oldbuttonbits=buttonbits;
				}
			else
				{
				controlschanged=false;
				}

			if ((controlschanged==false) && (soundready==false))
				{
				NullMoveType * NullDelta;

				NullDelta=(NullMoveType *)NextLocalCommand();
				NullDelta->type=COM_DELTANULL;
				}
			else
				{
				Delta=(MoveType *)NextLocalCommand();
				Delta->type=COM_DELTA;
				Delta->momx=(controlbuf[0]>>1);
				Delta->momy=(controlbuf[1]>>1);
				Delta->dangle=controlbuf[2]>>11;
				Delta->buttons=buttonbits;

				// See if we need to update sound packet

				if (soundready==true)
					{
					COM_SoundType * sndpkt;
					recordstate status;

					if (remoteridicule == false)
						Error("Attempt to record Remote Ridicule without adequate storage");
					sndpkt=(COM_SoundType *)Delta->Sounddata;

					// Turn the packet into a COM_SOUNDANDDELTA packet

					Delta->type=COM_SOUNDANDDELTA;
					status = SD_GetSoundData ( &(sndpkt->data[0]),
														COM_SOUND_BUFFERSIZE );
					switch (status)
						{
						case rs_nodata:
							Delta->type=COM_DELTA;
							break;
						case rs_newsound:
							sndpkt->type=COM_SOUND_START_TRANSMISSION;
							break;
						case rs_endsound:
							sndpkt->type=COM_SOUND_END_TRANSMISSION;
							break;
						case rs_data:
							sndpkt->type=COM_SOUND_NORMAL_TRANSMISSION;
							break;
						default:
							Error("Illegal return value for SD_GetSoundData");
							break;
						}
					}
				if (demorecord==true)
					RecordDemoCmd();
				}
			PrepareLocalPacket();

			if (
				(controlupdatetime != -1) &&
				(controlupdatetime > (lastpolltime+MAXPOLLTICS)) &&
				(demoplayback==false)
				)
				{
				controlbuf[0] = controlbuf[1] = controlbuf[2] = 0;
				}
			}
		}
	if (modemgame==true)
		{
		CheckForPacket ();
		}

	if ((standalone == false) && (IsServer==true) && (UpdateServer==true))
		ProcessServer();

// take out
	if (modemgame==true)
		{
//#if (DEVELOPMENT == 1)
		if (PanicPressed==true)
			{
			Error("Game Aborted. Scroll Lock pressed\n");
			}
//#endif
		if (Keyboard[sc_Insert] && Keyboard[sc_Q])
			Error("Game Aborted. Insert->Q pressed\n");
		}

	InUCC = false;

	waminot();
}

//****************************************************************************
//
// PlayerInGame()
//
//****************************************************************************
boolean PlayerInGame ( int p )
{
	if (PlayerStatus[p]!=player_ingame)
		return false;
	return true;
}

/*
=============================================================================

						Packet Section

=============================================================================
*/

//****************************************************************************
//
// CheckForPacket()
//
//****************************************************************************
void CheckForPacket ( void )
{
	wami(7);
	while (ReadPacket()==true)
		{
		if (badpacket==0)
			{
			ProcessPacket(&ROTTpacket[0], rottcom->remotenode);
			#if (DEVELOPMENT == 1)
//			ComError("CheckForPacket: from=%ld\n",rottcom->remotenode);
			#endif
			}
		else
			RequestPacket (LastCommandTime[rottcom->remotenode]+controldivisor, rottcom->remotenode, controldivisor);
		}
	waminot();
}


//****************************************************************************
//
// AddRemoteRidiculeCommand()
//
//****************************************************************************
void AddRemoteRidiculeCommand ( int player, int towho, int num )
{
	((COM_RemoteRidiculeType *)NextLocalCommand())->type=COM_REMRID;
	((COM_RemoteRidiculeType *)NextLocalCommand())->num=num;
	((COM_RemoteRidiculeType *)NextLocalCommand())->player=player;
	((COM_RemoteRidiculeType *)NextLocalCommand())->towho=towho;

	PrepareLocalPacket();
}

//****************************************************************************
//
// ProcessRemoteRidicule()
//
//****************************************************************************
void ProcessRemoteRidicule ( void * pkt )
	{
	COM_RemoteRidiculeType * remrot;
	char name[ 50 ];
	int from;
	int who;

	remrot = (COM_RemoteRidiculeType *)pkt;
	from	= remrot->player;
	who	= remrot->towho;
	if ( ( who == consoleplayer ) || ( who == MSG_DIRECTED_TO_ALL ) ||
		( ( who == MSG_DIRECTED_TO_TEAM ) && ( BATTLE_Team[ from ] ==
		BATTLE_Team[ consoleplayer ] ) ) )
		{
		strcpy( name, "( RR from " );
		strcat( name, PLAYERSTATE[from].codename );
		strcat( name, ")" );
		AddMessage( name, MSG_REMOTERIDICULE );

		SD_Play( SD_REMOTEM1SND + remrot->num );
		}
	}

//****************************************************************************
//
// AddEndGameCommand()
//
//****************************************************************************
void AddEndGameCommand ( void )
{
	((COM_EndGameType *)NextLocalCommand())->type=COM_ENDGAME;

	PrepareLocalPacket();
}

//****************************************************************************
//
// AddGameEndCommand()
//
//****************************************************************************
void AddGameEndCommand ( void )
{
	((COM_GameEndType *)NextLocalCommand())->type=COM_GAMEEND;

	PrepareLocalPacket();
}

//****************************************************************************
//
// AddQuitCommand()
//
//****************************************************************************
void AddQuitCommand ( void )
{
	((COM_QuitType *)NextLocalCommand())->type=COM_QUIT;
	PrepareLocalPacket();
}

//****************************************************************************
//
// AddExitCommand()
//
//****************************************************************************
void AddExitCommand ( void )
{
	((COM_ExitType *)NextLocalCommand())->type=COM_EXIT;
	PrepareLocalPacket();
}

//****************************************************************************
//
// AddPauseStateCommand()
//
//****************************************************************************
void AddPauseStateCommand ( int type )
{
	((COM_PauseType *)NextLocalCommand())->type=type;

	PrepareLocalPacket();
}


//****************************************************************************
//
// AddRespawnCommand()
//
//****************************************************************************
void AddRespawnCommand ( void )
{
	if (respawnactive==true)
		return;

	respawnactive=true;

	((COM_RespawnType *)NextLocalCommand())->type=COM_RESPAWN;

	PrepareLocalPacket();
}


//****************************************************************************
//
// AddTextMessage()
//
//****************************************************************************
void AddTextMessage
	(
	char *message,
	int	length,
	int	towho
	)

	{
	COM_TextType *Text;

	Text = ( COM_TextType * )NextLocalCommand();

	Text->type = COM_TEXT;
	memset( &Text->string[ 0 ], 0, COM_MAXTEXTSTRINGLENGTH );

	if ( length >= COM_MAXTEXTSTRINGLENGTH )
		{
		length = COM_MAXTEXTSTRINGLENGTH - 1;
		}

	memcpy( &Text->string[ 0 ], message, length );

	Text->towho = towho;

	PrepareLocalPacket();
	}


//****************************************************************************
//
// PrepareLocalPacket
//
//****************************************************************************

void PrepareLocalPacket ( void )
{
	MoveType * pkt;

	wami(8);

	pkt=(MoveType *)NextLocalCommand();

	pkt->time=controlupdatetime;

	if (networkgame==false) // Whether it is a modem game or not we do this
		{
		AddClientPacket (pkt, consoleplayer);
		if (modemgame==false)
			{
			ServerCommandStatus ( controlupdatetime ) = cs_ready;
			}
		}

	if (modemgame==true)
		SendPacket (pkt, server);

#if (DEVELOPMENT == 1)
//	ComError("packet sent: realtime=%ld time=%ld type=%ld dest=%ld\n",ticcount,pkt->time,pkt->type,server);
#endif

	controlupdatetime+=controldivisor;
	waminot();
}



//****************************************************************************
//
// GetPacketSize ()
//
//****************************************************************************

int GetPacketSize (void * pkt)
{
	int size;

	switch (((MoveType *)pkt)->type)
		{
		case COM_DELTA:
			size=sizeof(MoveType);
			break;
		case COM_DELTANULL:
			size=sizeof(NullMoveType);
			break;
		case COM_REQUEST:
			size=sizeof(COM_RequestType);
			break;
		case COM_FIXUP:
			size=sizeof(COM_FixupType);
			break;
		case COM_TEXT:
			size=sizeof(COM_TextType);
			break;
		case COM_PAUSE:
			size=sizeof(COM_PauseType);
			break;
		case COM_QUIT:
			size=sizeof(COM_QuitType);
			break;
		case COM_EXIT:
			size=sizeof(COM_ExitType);
			break;
		case COM_REMRID:
			size=sizeof(COM_RemoteRidiculeType);
			break;
		case COM_RESPAWN:
			size=sizeof(COM_RespawnType);
			break;
		case COM_UNPAUSE:
			size=sizeof(COM_UnPauseType);
			break;
		case COM_SERVER:
			size=sizeof(COM_ServerHeaderType);
			size-=sizeof(byte);
			break;
		case COM_GAMEDESC:
			size=sizeof(COM_GamePlayerType);
			break;
		case COM_GAMEEND:
			size=sizeof(COM_GameEndType);
			break;
		case COM_GAMEPLAY:
			size=DUMMYPACKETSIZE;
			break;
		case COM_GAMEACK:
			size=sizeof(COM_GameAckType);
			break;
		case COM_GAMEMASTER:
			size=sizeof(COM_GameMasterType);
			break;
		case COM_ENDGAME:
			size=sizeof(COM_EndGameType);
			break;
		case COM_SYNCTIME:
			size=sizeof(COM_SyncType);
			break;
#if (SYNCCHECK == 1)
		case COM_SYNCCHECK:
			size=sizeof(COM_CheckSyncType);
			break;
#endif
		case COM_SOUNDANDDELTA:
			size=sizeof(MoveType)+sizeof(COM_SoundType);
			break;
		default:
			Error("Unhandled packet type in GetPacketSize type=%ld",((MoveType *)pkt)->type);
			break;
		}

	return size;
}

//****************************************************************************
//
// GetTypeSize ()
//
//****************************************************************************

int GetTypeSize (int type)
{
	byte pkt[2];

	pkt[0]=(byte)type;
	return ( GetPacketSize(&(pkt[0])) );
}

//****************************************************************************
//
// GetServerPacketSize ()
//
//****************************************************************************

int GetServerPacketSize (void * pkt)
{
	int i;
	byte * ptr;
	COM_ServerHeaderType * serverpkt;

	serverpkt=(COM_ServerHeaderType *)pkt;
	if (serverpkt->type==COM_SERVER)
		{
		ptr=&serverpkt->data;

		for (i=0;i<serverpkt->numpackets;i++)
			{
			ptr+=GetPacketSize(ptr);
			}
		return (ptr-pkt);
		}
	else
		return GetPacketSize(pkt);
}

//****************************************************************************
//
// SendPacket ()
//
//****************************************************************************

void SendPacket (void * pkt, int dest)
{
	if ((networkgame==false) && (PlayerStatus[dest]!=player_ingame))
		return;
	if ((IsServer==true) && (dest==server) && (standalone==false)) // must be client on top of server
		ProcessPacket(pkt,dest);
	else if ((IsServer==false) && (dest!=server) && (standalone==false)) // We shouldn't be sending as client to anyone else
		ComError("SendPacket:Problems\n");
	else
		WritePacket(pkt,GetPacketSize(pkt),dest);
#if (DEVELOPMENT == 1)
//	ComError( "SendPacket: time=%ld dest=%ld\n",((MoveType *)pkt)->time,dest);
#endif
}

//****************************************************************************
//
// ResetCurrentCommand ()
//
//****************************************************************************

void ResetCurrentCommand ( void )
{
	ServerCommandStatus(oldpolltime)=cs_notarrived;
}

//****************************************************************************
//
// BroadcastServerPacket ()
//
//****************************************************************************

void BroadcastServerPacket (void * pkt, int size)
{
	int i;


	for (i=0;i<numplayers;i++)
		{
		if (PlayerStatus[i]!=player_ingame)
			continue;
//		if ((standalone==false) && (i==consoleplayer))
//			ProcessPacket(pkt,i);
//		else
			WritePacket((byte *)pkt,size,i);
		}
}


//****************************************************************************
//
// ResendLocalPackets ()
//
//****************************************************************************

void ResendLocalPackets (int time, int dest, int numpackets)
{
	int cmd;
	MoveType * pkt;

	cmd = CommandAddress(time);

#if 0
	if (networkgame==false)
		{
		int nump;
		nump=controlupdatetime-time;
		if (nump>numpackets)
			numpackets=nump;
		}
#endif

	if (controlupdatetime<=time)
		return;

	pkt = (MoveType *)LocalCommand(cmd);

	if (pkt->time!=time)
		{
		Error( "CLIENT: Could not find packet to resend\ntime=%ld packettime=%ld controlupdatetime=%ld\n",
				time, pkt->time, controlupdatetime);
		}
	else
		{
		byte * tempbuf;
		byte * tempptr;
		byte * tempstart;
		COM_FixupType * fixup;
		int i;
		int starti;
		int size;
		boolean done;

		// allocate some space

		tempbuf=SafeMalloc(MAXCOMBUFFERSIZE);

		fixup=(COM_FixupType *)tempbuf;

		fixup->type=COM_FIXUP;
		tempstart=&(fixup->data);

		done=false;
		i=0;
		while (done==false)
			{
			tempptr=tempstart;
			starti=i;
			fixup->time=( (MoveType *)LocalCommand(cmd) )->time;
			for (;i<numpackets;i++)
				{
				pkt = (MoveType *)LocalCommand(cmd);
				size=GetPacketSize(pkt);

				if (((tempptr+size)-tempbuf)>MAXCOMBUFFERSIZE)
					{
					break;
					}
				memcpy(tempptr,pkt,size);
				tempptr+=size;
				cmd = (cmd + controldivisor) & (MAXCMDS-1);
				}
			fixup->numpackets=i-starti;
			WritePacket(tempbuf,tempptr-tempbuf,dest);
			if (i==numpackets)
				done=true;
			}

		SafeFree(tempbuf);
		}
}

//****************************************************************************
//
// ResendServerPackets ()
//
//****************************************************************************

void ResendServerPackets (int time, int dest, int numpackets)
{
	int cmd;
	COM_ServerHeaderType * serverpkt;


	cmd = CommandAddress(time);

	if (serverupdatetime<=time)
		return;

	serverpkt = (COM_ServerHeaderType *)ServerCommand(cmd);

	if (serverpkt->time!=time)
		{
		Error( "SERVER: Could not find packet to resend\ntime=%ld packettime=%ld serverupdatetime=%ld\n",
				time, serverpkt->time,serverupdatetime);
		}
	else
		{
		byte * tempbuf;
		byte * tempptr;
		byte * tempstart;
		COM_FixupType * fixup;
		int i;
		int starti;
		int size;
		boolean done;

		// allocate some space

		tempbuf=SafeMalloc(MAXCOMBUFFERSIZE);

		fixup=(COM_FixupType *)tempbuf;

		fixup->type=COM_FIXUP;
		tempstart=&(fixup->data);

		done=false;
		i=0;
		while (done==false)
			{
			tempptr=tempstart;
			starti=i;
			fixup->time=( (MoveType *)ServerCommand(cmd) )->time;
			for (;i<numpackets;i++)
				{
				serverpkt = (COM_ServerHeaderType *)ServerCommand(cmd);
				size=GetServerPacketSize(serverpkt);

				if (((tempptr+size)-tempbuf)>MAXCOMBUFFERSIZE)
					{
					break;
					}
				memcpy(tempptr,serverpkt,size);
				tempptr+=size;
				cmd = (cmd + controldivisor) & (MAXCMDS-1);
				}
			fixup->numpackets=i-starti;
			WritePacket(tempbuf,tempptr-tempbuf,dest);
			if (i==numpackets)
				done=true;
			}

		SafeFree(tempbuf);
		}
}


//****************************************************************************
//
// ResendPacket (incoming packet, whoever requested it)
//
//****************************************************************************

void ResendPacket (void * pkt, int dest)
{
	int time;
	COM_RequestType * request;

	if ((networkgame==false) && (PlayerStatus[dest]!=player_ingame))
		return;

	request=(COM_RequestType * )pkt;
	time=request->time;

	ComError( "RESEND request received at %ld\n packet time=%ld dest=%ld numpackets=%ld\n",
				ticcount, time, dest, request->numpackets);

	if (IsServer==true)
		{
		if ((dest==server) && (standalone==false))
			Error("Trying to resend packets to client on top of server\n");
		ComError( "RESEND SERVER serverupdatetime=%ld\n",serverupdatetime);
		if (IsServerCommandReady ( time ) == true)
			ResendServerPackets(time,dest,request->numpackets);
		else
			ComError( "RESEND SERVER time=%ld is not ready\n",time);
		}
	else
		{
		ResendLocalPackets(time,dest,request->numpackets);
		}
}

//****************************************************************************
//
// FixupPacket ()
//
//****************************************************************************

void FixupPacket (void * pkt, int src)
{
	COM_FixupType * fix;
	int i;
	int time;
	byte * ptr;

	fix=(COM_FixupType *)pkt;

	ComError( "Fixup received at %ld, time=%ld numpackets=%ld\n", ticcount, fix->time, fix->numpackets);
#if 0
	if (networkgame==false)
		FixingPackets=false;
#endif
	time=fix->time;
	ptr=&(fix->data);

	for (i=0;i<fix->numpackets;i++,time+=controldivisor)
		{
		if (time == (LastCommandTime[src]+controldivisor))
			LastCommandTime[src]=time;

		if (IsServer==true)
			{
			if (ClientCommandStatus(src, time)!=cs_fixing)
				{
				ComError("Server Received fixup with no bad packet time=%ld from %ld\n",time,src);
				}
			else
				{
				AddSubPacket(ptr, src);
				}
			ptr+=GetPacketSize(ptr);
			}
		else
			{
			if (ServerCommandStatus(time)!=cs_fixing)
				{
				ComError("Client Received fixup with no bad packet time=%ld from %ld\n",time,src);
				}
			else
				{
				if (networkgame==true)
					{
					AddServerSubPacket( (COM_ServerHeaderType *)ptr );
					}
				else
					{
					AddModemSubPacket(ptr);
					}
				}
			ptr+=GetServerPacketSize(ptr);
			}
		}
}

#if (SYNCCHECK == 1)
//****************************************************************************
//
// CheckForSyncCheck
//
//****************************************************************************

void CheckForSyncCheck ( void )
{
	int i;


	if (modemgame==true)
		{
		if (oldpolltime==lastsynccheck)
			{
			for (i=0;i<numplayers;i++)
				{
				PlayerSync[i].x=PLAYER[i]->x;
				PlayerSync[i].y=PLAYER[i]->y;
				PlayerSync[i].z=PLAYER[i]->z;
				PlayerSync[i].angle=PLAYER[i]->angle;
				}
			PlayerSync[0].randomindex=GetRNGindex();
			PlayerSync[0].synctime=lastsynccheck;
			SendSyncCheckPacket();
			lastsynccheck+=CHECKSYNCTIME;
			}
		if (oldpolltime>lastsynccheck)
			{
			Error("Missed a player sync check time=%ld\n",oldpolltime);
			}
		}
}
#endif

//****************************************************************************
//
// ProcessSyncTimePacket
//
//****************************************************************************

void ProcessSyncTimePacket (void * pkt)
{
	COM_SyncType * sync;

	sync=(COM_SyncType *)pkt;
	ISR_SetTime(sync->synctime);
}

#if (SYNCCHECK == 1)
//****************************************************************************
//
// ProcessSyncCheckPacket
//
//****************************************************************************

void ProcessSyncCheckPacket (void * pkt, int src)
{
	COM_CheckSyncType * sync;

	sync=(COM_CheckSyncType *)pkt;
//	SoftError("Sync packet time=%ld\n",sync->synctime);
	if (sync->synctime!=PlayerSync[0].synctime)
		{
		SoftError("Old sync packet received\n");
		return;
		}
	if (sync->randomindex!=PlayerSync[0].randomindex)
		{
		Error("Player %ld is unsynced localindex=%ld remoteindex=%ld\n"
				"Unsynced Player x=%x y=%x a=%ld z=%ld name=%s\n",
				src, PlayerSync[0].randomindex, sync->randomindex,
				PlayerSync[src].x, PlayerSync[src].y, PlayerSync[src].angle,
				PlayerSync[src].z,PLAYERSTATE[src].codename);
		}
	if (sync->x!=PlayerSync[src].x)
		{
		Error("Player %ld is unsynced local x=%ld remote x=%ld\n"
				"Unsynced Player x=%x y=%x a=%ld z=%ld name=%s\n",
				src,PlayerSync[src].x,sync->x,
				PlayerSync[src].x, PlayerSync[src].y, PlayerSync[src].angle,
				PlayerSync[src].z,PLAYERSTATE[src].codename);
		}
	if (sync->y!=PlayerSync[src].y)
		{
		Error("Player %ld is unsynced local y=%ld remote y=%ld\n"
				"Unsynced Player x=%x y=%x a=%ld z=%ld name=%s\n",
				src,PlayerSync[src].y,sync->y,
				PlayerSync[src].x, PlayerSync[src].y, PlayerSync[src].angle,
				PlayerSync[src].z,PLAYERSTATE[src].codename);
		}
	if (sync->z!=PlayerSync[src].z)
		{
		Error("Player %ld is unsynced local z=%ld remote z=%ld\n"
				"Unsynced Player x=%x y=%x a=%ld z=%ld name=%s\n",
				src,PlayerSync[src].z,sync->z,
				PlayerSync[src].x, PlayerSync[src].y, PlayerSync[src].angle,
				PlayerSync[src].z,PLAYERSTATE[src].codename);
		}
	if (sync->angle!=PlayerSync[src].angle)
		{
		Error("Player %ld is unsynced local angle=%ld remote angle=%ld\n"
				"Unsynced Player x=%x y=%x a=%ld z=%ld name=%s\n",
				src,PlayerSync[src].angle,sync->angle,
				PlayerSync[src].x, PlayerSync[src].y, PlayerSync[src].angle,
				PlayerSync[src].z,PLAYERSTATE[src].codename);
		}
}

//****************************************************************************
//
// SendSyncCheckPacket
//
//****************************************************************************

void SendSyncCheckPacket ( void )
{
	((COM_CheckSyncType *)NextLocalCommand())->type=COM_SYNCCHECK;
	((COM_CheckSyncType *)NextLocalCommand())->synctime=PlayerSync[0].synctime;
	((COM_CheckSyncType *)NextLocalCommand())->x=PlayerSync[consoleplayer].x;
	((COM_CheckSyncType *)NextLocalCommand())->y=PlayerSync[consoleplayer].y;
	((COM_CheckSyncType *)NextLocalCommand())->z=PlayerSync[consoleplayer].z;
	((COM_CheckSyncType *)NextLocalCommand())->angle=PlayerSync[consoleplayer].angle;
	((COM_CheckSyncType *)NextLocalCommand())->randomindex=PlayerSync[0].randomindex;

	PrepareLocalPacket();
}
#endif

#if 0

//****************************************************************************
//
// CheckForSyncTime
//
//****************************************************************************

void CheckForSyncTime ( void )
{
	if ((modemgame==true) && (networkgame==false) && (consoleplayer==0))
		{
		if (controlupdatetime>=syncservertime)
			{
			SendSyncTimePacket();
			syncservertime+=MODEMSYNCSERVERTIME;
			}
		}
}
#endif

#if 0
//****************************************************************************
//
// SendSyncTimePacket
//
//****************************************************************************

void SendSyncTimePacket ( void )
{
	int i;
	COM_SyncType sync;

	return;

	sync.type=COM_SYNCTIME;

	if (networkgame==true)
		{
		for (i=0;i<numplayers;i++)
			{
			if ((PlayerStatus[i]!=player_ingame) || ( (i==consoleplayer) && (standalone==false) ) )
				continue;
			sync.synctime=ticcount+GetTransitTime(i);
			WritePacket ( &sync.type, GetPacketSize(&sync.type), i);
			}
		}
	else
		{
		if (PlayerStatus[server]==player_ingame)
			{
			sync.synctime=ticcount+GetTransitTime(server);
			WritePacket ( &sync.type, GetPacketSize(&sync.type), server);
			}
		}
}
#endif

//****************************************************************************
//
// ProcessSoundAndDeltaPacket
//
//****************************************************************************

void ProcessSoundAndDeltaPacket (void * pkt, int src)
{
	MoveType * packet;
	COM_SoundType * sndpkt;
	byte oldtype;

	packet = (MoveType *)pkt;

	// Trick packet into being a normal delta packet

	oldtype=packet->type;
	packet->type=COM_DELTA;
	AddClientPacket (pkt,src);
	packet->type=oldtype;

	// Don't process sound if it is from us
	if (src==consoleplayer)
		return;

	sndpkt = (COM_SoundType *) (packet->Sounddata);

	if (sndpkt->type==COM_SOUND_START_TRANSMISSION)
		{
		SD_StartIncomingSound ();
		}
	if (sndpkt->type==COM_SOUND_END_TRANSMISSION)
		{
		SD_StopIncomingSound();
		}
	else
		{
		SD_UpdateIncomingSound (&(sndpkt->data[0]), COM_SOUND_BUFFERSIZE);
		}
}
//****************************************************************************
//
// SyncToServer
//
//****************************************************************************
#define NETWORKTIMEAHEADOFSERVER (1)
#define MODEMTIMEAHEADOFSERVER (2)
void SyncToServer( void )
{
	int diff;

	if ((networkgame==false) && (consoleplayer==0))
		return;
	if (IsServer==true)
		return;
//	if (networkgame==true)
//		{
//		diff = (ticcount-controldivisor-LastCommandTime[0])/controldivisor;
//		SoftError("diff=%ld\n",diff);
//		if (abs(diff)>1)
//			ISR_SetTime(ticcount-diff);
#if 0
		diff = controlupdatetime-LastCommandTime[0];
		if (diff>3)
			{
			ISR_SetTime(ticcount-1);
			}
		else if (diff<-3)
			{
			ISR_SetTime(ticcount+1);
			}
#endif
//		}
//	else
//		{
		diff = (ticcount-controldivisor-LastCommandTime[server])/controldivisor;
		if (abs(diff)>0)
			ISR_SetTime(ticcount-diff);
//		}
}

//****************************************************************************
//
// ProcessPacket
//
//****************************************************************************

void ProcessPacket (void * pkt, int src)
{
	switch (((MoveType *)pkt)->type)
		{
		case COM_DELTA:
		case COM_DELTANULL:
		case COM_TEXT:
		case COM_PAUSE:
		case COM_QUIT:
		case COM_EXIT:
		case COM_REMRID:
		case COM_RESPAWN:
		case COM_UNPAUSE:
		case COM_ENDGAME:
#if (SYNCCHECK == 1)
		case COM_SYNCCHECK:
#endif
//			if (FixingPackets==false)
			AddPacket(pkt,src);
			break;
		case COM_SOUNDANDDELTA:
			if (remoteridicule == false )
				{
				((MoveType *)pkt)->type = COM_DELTA;
				}
			AddPacket(pkt,src);
			break;
		case COM_SERVER:
			AddServerPacket(pkt,src);
			break;

		case COM_REQUEST:
			ResendPacket(pkt, src);
			break;

		case COM_FIXUP:
			FixupPacket(pkt, src);
			break;

		case COM_SYNCTIME:
			ProcessSyncTimePacket(pkt);
			break;

		case COM_GAMEEND:
		case COM_GAMEDESC:
		case COM_GAMEACK:
		case COM_GAMEMASTER:
			if (standalone==true)
				restartgame=true;
			break;

		case COM_START:
			break;

		default:
			Error("ProcessPacket: Unknown packet type=%ld\n",((MoveType *)pkt)->type);
		}
}


//****************************************************************************
//
// AddServerSubPacket
//
//****************************************************************************

void AddServerSubPacket(COM_ServerHeaderType * serverpkt)
{
	byte * pkt;
	int i;

	ServerCommandStatus(serverpkt->time)=cs_ready;

	pkt=&serverpkt->data;
	for (i=0;i<serverpkt->numpackets;i++)
		{
		AddClientPacket(pkt,i);
		pkt+=GetPacketSize(pkt);
		}
}

//****************************************************************************
//
// AddModemSubPacket
//
//****************************************************************************

void AddModemSubPacket(void * incoming)
{
	MoveType * pkt;

	pkt=(MoveType *)incoming;
	ServerCommandStatus(pkt->time)=cs_ready;

	AddClientPacket(incoming,server);
}

//****************************************************************************
//
// AddServerPacket
//
//****************************************************************************

void AddServerPacket(void * pkt, int src)
{
	COM_ServerHeaderType * serverpkt;

	// The server uses the client's lgts for communicating

	// Last good time can be set even for the client/server combo

	if (standalone==true)
		{
		Error("standalone should not be here\n");
		}

	if (src!=server)
		{
		Error("Received server packet from non-server src=%ld\n",src);
		}

	serverpkt=(COM_ServerHeaderType *)pkt;

//	if (networkgame==false)
//		SyncToServer(serverpkt->time);

	LastCommandTime[src]+=controldivisor;

	if (serverpkt->time != LastCommandTime[src])
		{
		int numpackets;

		numpackets=serverpkt->time-LastCommandTime[src];
		if (ServerCommandStatus(LastCommandTime[src])!=cs_fixing)
			{
			RequestPacket ( LastCommandTime[src] , src , numpackets );

			ComError("AddServerPacket: Request packet time=%ld lct=%ld numpackets=%ld\n",
						serverpkt->time, LastCommandTime[src], numpackets
					);
			}

		LastCommandTime[src]+=numpackets;
		}

	AddServerSubPacket( serverpkt );
}

//****************************************************************************
//
// AddClientPacket
//
//****************************************************************************

void AddClientPacket (void * pkt, int src)
{
	int size;
	MoveType * packet;

	packet=(MoveType *)pkt;

	switch (packet->type)
		{
		case COM_DELTA:
		case COM_DELTANULL:
		case COM_TEXT:
		case COM_REMRID:
		case COM_PAUSE:
		case COM_QUIT:
		case COM_EXIT:
		case COM_RESPAWN:
		case COM_UNPAUSE:
#if (SYNCCHECK == 1)
		case COM_SYNCCHECK:
#endif
		case COM_ENDGAME:
			size=GetPacketSize(packet);
			memcpy(PlayerCommand(src,CommandAddress(packet->time)),packet,size);
			break;
		case COM_SOUNDANDDELTA:
			ProcessSoundAndDeltaPacket(packet, src);
			break;
		default:
			Error("AddClientPacket: Unknown packet type = %ld\n",packet->type);
		}
}

//****************************************************************************
//
// AddSubPacket
//
//****************************************************************************

void AddSubPacket (void * pkt, int src)
{
	MoveType * packet;

	if (networkgame==false)
		Error("Modem game should not be here in AddSubPacket\n");

	packet = (MoveType *) pkt;

	ClientCommandStatus(src, packet->time)=cs_ready;

	memcpy (
			ClientTimeCommand(src,packet->time),
			pkt,
			GetPacketSize(packet)
			);
}

//****************************************************************************
//
// AddPacket
//
//****************************************************************************

void AddPacket (void * pkt, int src)
{
	MoveType * packet;

	// should only be called by server in network game
	// in modem game we fall through the first condition
	// all packets should be sequential

	if ((IsServer==true) && (PlayerStatus[src]!=player_ingame))
		return;
	packet = (MoveType *) pkt;

//	if ((networkgame==false) && (consoleplayer!=0))
//		SyncToServer();

	if (!((src==server) && (standalone==false) && (IsServer==true)))
		{
		LastCommandTime[src]+=controldivisor;

		if (packet->time != LastCommandTime[src])
			{
			int numpackets;

			numpackets=packet->time-LastCommandTime[src];
			if ( ( (networkgame==false) &&
					(ServerCommandStatus(LastCommandTime[src])!=cs_fixing)
				)
				||
				( (networkgame==true) &&
					(ClientCommandStatus(src,LastCommandTime[src])!=cs_fixing)
				)
				)
				{
				RequestPacket ( LastCommandTime[src] , src , numpackets );

				ComError("AddPacket: Request packet time=%ld lct=%ld numpackets=%ld\n",
							packet->time, LastCommandTime[src], numpackets
							);
				}

			LastCommandTime[src]+=numpackets;
			}
		}

	if (networkgame==true)
		{
		AddSubPacket ( packet, src );
		}
	else
		{
		AddModemSubPacket(packet);
		}
}


//****************************************************************************
//
// RequestPacket ( int time, int dest )
//
//****************************************************************************

void RequestPacket (int time, int dest, int numpackets)
{
	COM_RequestType request;
	int i;


#if (DEVELOPMENT == 1)
	if (modemgame==false)
		Error("Called Request Packet outside of modem game\n");
#endif

	request.type=COM_REQUEST;
	request.time=time;
	request.numpackets=numpackets/controldivisor;

	if (IsServer==true)
		{
		if ((dest==server) && (standalone==false))
			{
			Error("Requesting packet from client on top of server\n");
			}
		if (PlayerStatus[dest]!=player_ingame)
			return;
		for (i=0;i<numpackets;i+=controldivisor)
			{
			ClientCommandStatus( dest , (time+i) ) = cs_fixing;
			}
		}
	else
		{
		if ((networkgame==false) && (PlayerStatus[dest]!=player_ingame))
			return;
		for (i=0;i<numpackets;i+=controldivisor)
			{
			ServerCommandStatus( (time+i) ) = cs_fixing;
			}
		}
//	if (networkgame==false)
//		FixingPackets=true;

	// send out the packet

	WritePacket (&request, GetPacketSize(&request), dest);

#if (DEVELOPMENT == 1)
//	ComError( "BADPKT, request sent at %ld lgt=%ld dest=%ld\n",ticcount,time,dest);
#endif
}

//****************************************************************************
//
// IsServerCommandReady ()
//
//****************************************************************************
boolean IsServerCommandReady ( int time )
{

	if (
		(
		(COM_ServerHeaderType *)
			ServerCommand(CommandAddress (time) ) )->time==time)
		return true;
	else
		{
		return false;
		}
}

//****************************************************************************
//
// AreClientsReady ()
//
//****************************************************************************
boolean AreClientsReady ( void )
{
	int i;
	int timeindex;
	int status;

	timeindex=CommandAddress(serverupdatetime);

	for (i=0;i<numplayers;i++)
		{
		if (PlayerStatus[i]!=player_ingame)
			continue;
		status=ClientCommandStatus(i, serverupdatetime);
		if (status==cs_notarrived)
			return false;
		else if (status==cs_fixing)
			{
//			RequestPacket ( serverupdatetime , i , controldivisor );
			return false;
			}
		else if (((MoveType *)ClientCommand(i, timeindex))->time != serverupdatetime)
			return false;
		}
	return true;
}

//****************************************************************************
//
// IsPlayerCommandReady ()
//
//****************************************************************************
boolean IsPlayerCommandReady (int num, int time)
{
	MoveType * cmd;

	cmd=(MoveType *)PlayerCommand(num,CommandAddress(time));

	if (cmd->time==time)
		return true;
	else
		return false;
}

//****************************************************************************
//
// ResetClientCommands ()
//
//****************************************************************************
void ResetClientCommands ( int player )
{
	int j;

	for (j=0;j<MAXCMDS;j++)
		{
		memset(ClientCommand(player,j),COM_DELTA,GamePacketSize());
		}
}

//****************************************************************************
//
// SendFullServerPacket ()
//
//****************************************************************************
void SendFullServerPacket ( void )
{
	int i;
	int size;
	byte * pkt;
	COM_ServerHeaderType * spkt;
	int timeindex;
	int playerstatus[MAXPLAYERS];

	timeindex=CommandAddress(serverupdatetime);

	spkt=(COM_ServerHeaderType *)ServerCommand(timeindex);

	pkt=&spkt->data;
	spkt->time=serverupdatetime;
	spkt->type=COM_SERVER;
	spkt->numpackets=numplayers;


	memset(playerstatus,-1,sizeof(playerstatus));
	for (i=0;i<numplayers;i++)
		{
		size=GetPacketSize(ClientCommand(i,timeindex));
		if (((MoveType *)ClientCommand(i,timeindex))->type == COM_QUIT)
			{
			playerstatus[i]=player_quitgame;
			}
		if (((MoveType *)ClientCommand(i,timeindex))->type == COM_ENDGAME)
			{
			playerstatus[i]=player_leftgame;
			}
		memcpy(pkt,
				ClientCommand(i,timeindex),
				size
				);
		pkt+=size;
		ClientCommandNumberStatus(i,timeindex)=cs_notarrived;
		}
	BroadcastServerPacket((void *)spkt,(pkt-(byte *)spkt));
	serverupdatetime+=controldivisor;

	for (i=0;i<numplayers;i++)
		{
		if (playerstatus[i]!=-1)
			{
			if ((standalone==false) && (consoleplayer==i))
				{
				UpdateServer=false;
				}
			else
				{
				ResetClientCommands(i);
				PlayerStatus[i]=playerstatus[i];
				}
			}
		}
}



//****************************************************************************
//
// ProcessServer ()
//
//****************************************************************************

void ProcessServer ( void )
{
	boolean done;
	boolean exit;
	int i;
	int time;
	int quittime;

	if (InProcessServer==true)
		return;

	InProcessServer=true;

	if (ticcount<serverupdatetime)
		goto exitProcessServer;

	time=ticcount;
	quittime=ticcount+SERVERTIMEOUT;
	exit=false;

	while (time>=serverupdatetime)
		{
		int savetime;

		savetime=ticcount+NETWORKTIMEOUT;
		done = false;
		while (done == false)
			{
			if (standalone==true)
				AbortCheck("GameServer aborted\n");

			done = AreClientsReady ();

			if ( (standalone==false) && (serverupdatetime>=(controlupdatetime-controldivisor)) && (done==false) )
				break;

			CheckForPacket ();

			if (standalone==false)
				UpdateClientControls();

			if (restartgame==true)
				break;
			if (ticcount>savetime)
				{
				for (i=0;i<numplayers;i++)
					{
					int val;

					val=ClientCommandStatus(i, serverupdatetime);
					if ((val!=cs_ready) && (PlayerStatus[i]==player_ingame))
						{
						SoftError("Server timeout\n");
						RequestPacket(serverupdatetime, i , controldivisor);
						}
					}
				savetime=ticcount+NETWORKTIMEOUT;
				}
//			if (ticcount>quittime)
//				{
//				Error("Server aborting after %ld seconds\n",SERVERTIMEOUT/VBLCOUNTER);
//				}
			if ((standalone==false) && (done==false))
				{
				exit=true;
				done=true;
				}
			}
		if (exit==true)
			break;
		if ( (serverupdatetime>=(controlupdatetime-controldivisor)) && (standalone==false))
			break;
		if (restartgame==true)
			break;
		SendFullServerPacket();
#if 0
		if (serverupdatetime>=syncservertime)
			{
			SendSyncTimePacket();
			syncservertime+=NETSYNCSERVERTIME;
			}
#endif
		}
exitProcessServer:
	InProcessServer=false;
}


//****************************************************************************
//
// SetupCheckForPacket()
//
//****************************************************************************
int SetupCheckForPacket ( void )
{
	int retval=scfp_nodata;

	if ((ReadPacket()==true) && (badpacket==0))
		{
		MoveType * pkt;

		retval=scfp_data;
		pkt=(MoveType *)&ROTTpacket[0];
		if ((IsServer==true) && (standalone==true))
			{
			switch (pkt->type)
				{
				case COM_GAMEEND:
					break;
				case COM_GAMEDESC:
					if (standalone==true)
						printf("Received GameDescription from player#%ld\n",rottcom->remotenode);
					WritePacket(&ROTTpacket[0],GetPacketSize(pkt),0); // Send to player 0
					break;
				case COM_GAMEACK:
					if (standalone==true)
						printf("Received GameAcknowledgement from player#%ld\n",rottcom->remotenode);
					WritePacket(&ROTTpacket[0],GetPacketSize(pkt),0); // Send to player 0
					break;
				case COM_GAMEMASTER:
					if (standalone==true)
						printf("Received GameMasterPacket from player#%ld\n",rottcom->remotenode);
					BroadcastServerPacket(&ROTTpacket[0],GetPacketSize(pkt)); // Send to all
					break;
				case COM_GAMEPLAY:
					if (standalone==true)
						printf("Received StartGamePacket from player#%ld\n",rottcom->remotenode);
					BroadcastServerPacket(&ROTTpacket[0],GetPacketSize(pkt)); // Send to all
					retval=scfp_done;
					break;
				default:
					ComError("Server received unknown packet in Game preamble\n");
					break;
				}
			}
		else
			{
			switch (pkt->type)
				{
				case COM_GAMEPLAY:
					retval=scfp_done;
					break;
				case COM_GAMEMASTER:
					SetGameDescription(pkt);
					retval=scfp_gameready;
					break;
				case COM_GAMEACK:
					PlayersReady[((COM_GameAckType *)pkt)->player]=true;
					break;
				case COM_GAMEDESC:
					GotPlayersDesc[((COM_GamePlayerType *)pkt)->player]=true;
					SetPlayerDescription(pkt);
					break;
				}
			}
		}
	return retval;
}


//****************************************************************************
//
// ServerLoop ()
//
//****************************************************************************
void ServerLoop( void )
{
	boolean done;

	while (1)
		{
		ShutdownClientControls();
		restartgame=false;

		done=false;
		while (done==false)
			{
			AbortCheck("SetupGameServer aborted\n");

			if (SetupCheckForPacket()==scfp_done)
				done=true;
			}
		SetTime();
		StartupClientControls();
		while(1)
			{
			ProcessServer();
#if (DEVELOPMENT == 1)
			Z_CheckHeap();
#endif
			CalcTics();
			if (restartgame==true)
				break;
			}
		}
}

//****************************************************************************
//
// ProcessPlayerCommand()
//
//****************************************************************************
void ProcessPlayerCommand( int player )
{
	MoveType * cmd;

	cmd=(MoveType *)PlayerCommand(player,CommandAddress(oldpolltime));

	if (cmd->type==COM_DELTA)
		{
		UpdatePlayerObj(player);
		}
	else if (cmd->type==COM_RESPAWN)
		{
		if (player==consoleplayer) // reset spawn state
			respawnactive=false;
		RespawnPlayerobj(PLAYER[player]);
		}
	else if (cmd->type==COM_ENDGAME)
		{
		playstate = ex_battledone;
		}
	else if (cmd->type==COM_QUIT)
		{
		if (player==consoleplayer)
			QuitGame();
		else
			{
			char str[50]="Player #";
			char str2[10];

			strcat(str,itoa(player+1,str2,10));
			strcat(str,", ");
			strcat(str,PLAYERSTATE[player].codename);
			strcat(str," has left the game.");
			AddMessage(str,MSG_REMOTE);
			PlayerStatus[player]=player_quitgame;
			}
		}
	else if (cmd->type==COM_EXIT)
		{
		QuitGame();
		}
	else if (cmd->type==COM_REMRID)
		{
		ProcessRemoteRidicule (cmd);
		}
	else if (cmd->type==COM_TEXT)
		{
		int who;

		who = ( ( COM_TextType * )cmd )->towho;
		if ( ( who == consoleplayer ) ||
			( who == MSG_DIRECTED_TO_ALL ) ||
			( ( who == MSG_DIRECTED_TO_TEAM ) &&
			( BATTLE_Team[ player ] == BATTLE_Team[ consoleplayer ] ) ) )
			{
			char string[ 50 ];

			strcpy( string, "\\N9" );
			strcat( string, PLAYERSTATE[player].codename );
			strcat( string, ":\\NF" );
			strcat( string, ((COM_TextType *)cmd)->string );
			SD_PlayPitchedSound ( SD_ENDBONUS1SND, 255, 1200 );

			AddMessage( string, MSG_REMOTE );
			}
		}
#if (SYNCCHECK == 1)
	else if (cmd->type==COM_SYNCCHECK)
		{
		ProcessSyncCheckPacket(cmd, player);
		}
#endif
	else if (cmd->type==COM_PAUSE)
		{
		MUSIC_Pause();
		GamePaused=true;
		pausedstartedticcount = oldpolltime;
		}
	else if (cmd->type==COM_UNPAUSE)
		{
		GamePaused=false;
		MUSIC_Continue ();
		if (RefreshPause == false)		// screen is blanked
			{
			ShutdownScreenSaver();
			SetupScreen (true);
			RefreshPause = true;
			}
		}
}

//****************************************************************************
//
// CheckUnPause ()
//
//****************************************************************************
void CheckUnPause ( void )
{
	if (oldpolltime==nextupdatetime)
		{
		nextupdatetime=oldpolltime+controldivisor;
		while (1)
			{
			if (ServerCommandStatus(oldpolltime)==cs_ready)
				{
				int j;

				for (j=0;j<numplayers;j++)
					{
					if (PlayerStatus[j]==player_ingame)
						ProcessPlayerCommand( j );
					}
				break;
				}
			else
				{
				UpdateClientControls();
				}
			}
		}
}


//****************************************************************************
//
// ControlPlayerObj ()
//
//****************************************************************************
void ControlPlayerObj (objtype * ob)
{
	playertype * pstate;
	int num;
	int savetime;
	int inittick, deltatick;
//	boolean asked;

//	if (GamePaused==true)
//		return;

	M_LINKSTATE(ob,pstate);

	// get player number

	num=ob->dirchoosetime;

	memcpy (pstate->buttonheld, pstate->buttonstate, sizeof(pstate->buttonstate));

	inittick=ticcount;

	if (oldpolltime==nextupdatetime)
		{
		if (num==numplayers-1)
			nextupdatetime=oldpolltime+controldivisor;
		if (networkgame==true)
			savetime=ticcount+NETWORKTIMEOUT;
		else
			savetime=ticcount+MODEMTIMEOUT;

		if (PlayerStatus[num]!=player_ingame)
			return;

		//	asked=false;

		// copy previous state of buttons


		while (1)
			{
			if (ServerCommandStatus(oldpolltime)==cs_ready)
				{
				ProcessPlayerCommand (num);
				if (demoplayback||demorecord)
					SoftError("x=%4lx y=%4lx a=%4lx time=%5ld\n",player->x,player->y,player->angle,oldpolltime);
				break;
				}
	//		else if ((ServerCommandStatus(oldpolltime)==cs_fixing) &&
	//					(networkgame==false) &&
	//					(asked==false)
	//				)
	//			{
	//			asked=true;
	//			RequestPacket(oldpolltime, server, controldivisor);
	//			}
			else
				{
				UpdateClientControls();
				}

			I_PollTimer();
			if (ticcount>savetime)
				{
				SoftError("Client timeout oldpolltime=%ld\n",oldpolltime);
				break;	//BGB: debug
				
				if (IsServer==false)
					RequestPacket(oldpolltime, server, controldivisor);
				if (networkgame==true)
					savetime=ticcount+NETWORKTIMEOUT;
				else
					savetime=ticcount+MODEMTIMEOUT;
				}
			}
		}

	if (!(ob->flags&FL_DYING))
		{
		if (ob->flags&FL_PUSHED)
			{
			ob->flags&=~FL_PUSHED;
#if 0
			if (abs(ob->momentumx)>0)
				{
				if (abs(ob->momentumx+pstate->dmomx)>=abs(ob->momentumx))
					{
					ob->momentumx += pstate->dmomx;
					ob->momentumy += pstate->dmomy;
					}
				}
			else if (abs(ob->momentumy+pstate->dmomy)>=abs(ob->momentumy))
				{
				ob->momentumx += pstate->dmomx;
				ob->momentumy += pstate->dmomy;
				}
#endif
			if (abs(ob->momentumx+pstate->dmomx)>=abs(ob->momentumx))
				{
				ob->momentumx += pstate->dmomx;
				}
			if (abs(ob->momentumy+pstate->dmomy)>=abs(ob->momentumy))
				{
				ob->momentumy += pstate->dmomy;
				}
			}
		else
			{
			ob->momentumx += pstate->dmomx;
			ob->momentumy += pstate->dmomy;
			}
		}
}

//****************************************************************************
//
// MaxSpeedForCharacter ()
//
//****************************************************************************

int MaxSpeedForCharacter(playertype*pstate)
{
	if (BATTLEMODE && (gamestate.BattleOptions.Speed == bo_fast_speed))
		{
		return( FASTSPEED );
		}
	else
		{
		if (pstate->buttonstate[bt_run])
			return (characters[pstate->player].toprunspeed);
		else
			return (characters[pstate->player].topspeed);
		}
}

//****************************************************************************
//
// UpdatePlayerObj ()
//
//****************************************************************************

void UpdatePlayerObj ( int player )
{
	int i, buttonbits;
	playertype * pstate;
	MoveType * MoveCmd;

	MoveCmd=(MoveType *)PlayerCommand(player,CommandAddress(oldpolltime));

	pstate=&PLAYERSTATE[player];

	buttonbits = MoveCmd->buttons;
	for (i = 0; i < NUMTXBUTTONS; i++)
		{
		pstate->buttonstate[i] = buttonbits & 1;
		buttonbits	>>= 1;
		}

	pstate->dmomx = (int)(MoveCmd->momx)<<1;
	pstate->dmomy = (int)(MoveCmd->momy)<<1;
	pstate->angle = MoveCmd->dangle;
	pstate->angle <<= 11;
	pstate->topspeed=MaxSpeedForCharacter(pstate);

	if (demoplayback||demorecord)
		SoftError("  dmx=%4lx dmy=%4lx da=%4lx time=%5ld\n",pstate->dmomx,pstate->dmomy,pstate->angle>>11,oldpolltime);
#if 0
#if (DEVELOPMENT == 1)
			if ((modemgame==true) || (demoplayback==true) || (demorecord==true))
			{
			ComError( "player#%2ld\n",player);
			ComError( "momx = %6ld\n", PLAYER[player]->momentumx);
			ComError( "momy = %6ld\n", PLAYER[player]->momentumy);
			ComError( "	x = %6ld\n", PLAYER[player]->x);
			ComError( "	y = %6ld\n", PLAYER[player]->y);
			ComError( "	z = %6ld\n", PLAYER[player]->z);
			ComError( "	a = %6ld\n", PLAYER[player]->angle);
			if (pstate->buttonstate[bt_attack])
				ComError( "FIRING\n");
			}
#endif
#endif
}


//****************************************************************************
//
// SendPlayerDescription ()
//
//****************************************************************************

void SendPlayerDescription( void )
{
	byte * temp;
	COM_GamePlayerType * desc;
	int length;

	length=sizeof(COM_GamePlayerType);
	temp=SafeMalloc(length);

	memset(temp,0,length);

	desc=(COM_GamePlayerType *)temp;
	desc->type=(byte)COM_GAMEDESC;
	desc->player=consoleplayer;
	desc->violence=gamestate.violence;
	desc->Version = gamestate.Version;
	desc->Product = gamestate.Product;
	desc->playerdescription.character=locplayerstate->player;
	desc->playerdescription.uniformcolor=locplayerstate->uniformcolor;
	strcpy(&(desc->playerdescription.codename[0]),
		&locplayerstate->codename[0]);

	WritePacket(temp,length,server);

	SafeFree(temp);
}

//****************************************************************************
//
// SendGameDescription ()
//
//****************************************************************************

void SendGameDescription( void )
{
	byte * temp;
	COM_GameMasterType * desc;
	int length;
	int i;

	length=sizeof(COM_GameMasterType);
	temp=SafeMalloc(length);

	memset(temp,0,length);

	desc=(COM_GameMasterType *)temp;
	desc->type=(byte)COM_GAMEMASTER;
	desc->level=gamestate.mapon;
	desc->mapcrc=GetMapCRC (gamestate.mapon);
	desc->mode=gamestate.battlemode;
	desc->violence=gamestate.violence;
	desc->Version = gamestate.Version;
	desc->Product = gamestate.Product;
	desc->teamplay = gamestate.teamplay;
	memcpy( &desc->SpecialsTimes, &gamestate.SpecialsTimes, sizeof( specials ) );
	BATTLE_GetOptions( &( desc->options ) );
	GetMapFileName( &(desc->battlefilename[0]) );
	desc->randomseed=GetRNGindex ( );
	gamestate.randomseed=desc->randomseed;
	desc->ludicrousgibs=battlegibs;
	ludicrousgibs=battlegibs;
//	SetRNGindex ( gamestate.randomseed );
	for (i=0;i<numplayers;i++)
		{
		if (gamestate.Product == ROTT_SHAREWARE)
			PLAYERSTATE[i].player = 0;
		desc->players[i].character	=PLAYERSTATE[i].player;
		desc->players[i].uniformcolor =PLAYERSTATE[i].uniformcolor;
		strcpy ( &(desc->players[i].codename[0]),&(PLAYERSTATE[i].codename[0]));
		}

	if (!networkgame)
		AssignTeams();

	if (IsServer==false)
		{
		WritePacket(temp,length,server);
		}
	else
		{
		BroadcastServerPacket(temp,length); // Send to all
		}

	SafeFree(temp);
}

//****************************************************************************
//
// SetGameDescription ()
//
//****************************************************************************

void SetGameDescription( void * pkt )
{
	COM_GameMasterType * desc;
	word localcrc;
	int i;

	desc=(COM_GameMasterType *)pkt;
	gamestate.mapon=desc->level;
	gamestate.battlemode=desc->mode;
	gamestate.violence=desc->violence;
	gamestate.Version = desc->Version;
	gamestate.Product = desc->Product;
	gamestate.teamplay = desc->teamplay;
	memcpy( &gamestate.SpecialsTimes, &desc->SpecialsTimes, sizeof( specials ) );
	BATTLE_SetOptions( &( desc->options ) );
	gamestate.randomseed=desc->randomseed;
	SetRNGindex ( gamestate.randomseed );
	SetBattleMapFileName( &(desc->battlefilename[0]) );
	localcrc=GetMapCRC (gamestate.mapon);
	ludicrousgibs=desc->ludicrousgibs;
	if (localcrc!=desc->mapcrc)
		Error("You have different maps on your system\n");
	for (i=0;i<numplayers;i++)
		{
		PLAYERSTATE[i].player=desc->players[i].character;
		PLAYERSTATE[i].uniformcolor=desc->players[i].uniformcolor;
		strcpy ( &(PLAYERSTATE[i].codename[0]),
					&(desc->players[i].codename[0])
				);
		}
	AssignTeams();
}

//****************************************************************************
//
// SetPlayerDescription ()
//
//****************************************************************************

void SetPlayerDescription( void * pkt )
{
	COM_GamePlayerType * desc;

	desc=(COM_GamePlayerType *)pkt;
	PLAYERSTATE[desc->player].player=desc->playerdescription.character;
	PLAYERSTATE[desc->player].uniformcolor=desc->playerdescription.uniformcolor;
	strcpy ( &(PLAYERSTATE[desc->player].codename[0]),
				&(desc->playerdescription.codename[0])
			);
	if ( gamestate.Version != desc->Version )
		{
		Error("Player %s is using a different version of ROTT\n",PLAYERSTATE[desc->player].codename);
//		gamestate.Version = desc->Version;
		}

	if ( gamestate.violence > desc->violence )
		{
		gamestate.violence = desc->violence;
		}

	if ( gamestate.Product > desc->Product )
		{
		gamestate.Product = desc->Product;
		}
}

//****************************************************************************
//
// SendGameAck ()
//
//****************************************************************************

void SendGameAck( void )
{
	byte * temp;
	int length;
	COM_GameAckType * desc;

	length=sizeof(COM_GameAckType);
	temp=SafeMalloc(length);
	desc=(COM_GameAckType *)temp;
	desc->type=COM_GAMEACK;
	desc->player=consoleplayer;

	WritePacket(temp,length,server);

	SafeFree(temp);
}

//****************************************************************************
//
// SendGameStart ()
//
//****************************************************************************

void SendGameStart( void )
{
	byte * temp;
	int length;

	length=DUMMYPACKETSIZE;
	temp=SafeMalloc(length);
	*(temp)=(byte)COM_GAMEPLAY;

	if (IsServer==false)
		{
		WritePacket(temp,length,server);
		}
	else
		{
		BroadcastServerPacket(temp,length); // Send to all
		}

	SafeFree(temp);
}

//****************************************************************************
//
// SetupGamePlayer ()
//
//****************************************************************************
void SetupGamePlayer ( void )
{
	int savetime;
	boolean done;
	boolean gameready;

	savetime=ticcount;

	done=false;
	gameready=false;

	while (done==false)
		{
		// Setup individual player
		AbortCheck("SetupGamePlayer aborted\n");

		// send Player Description
		if (ticcount >= savetime)
			{
			savetime=ticcount+SETUPTIME;
			if (gameready==false)
				SendPlayerDescription();
			else
				SendGameAck();
			}
		switch (SetupCheckForPacket())
			{
			case scfp_done:
				done=true;
				break;
			case scfp_gameready:
				gameready=true;
				break;
			}
		}
	savetime=ticcount+(VBLCOUNTER/2);

	while (ticcount<savetime)
		{
		SetupCheckForPacket ();
		}
}

//****************************************************************************
//
// AllPlayersReady ()
//
//****************************************************************************
boolean AllPlayersReady ( void )
{
	int i;

	for (i=0;i<numplayers;i++)
		if ((PlayersReady[i]==false) && (PlayerStatus[i]==player_ingame))
			return false;

	return true;
}

//****************************************************************************
//
// GotAllPlayerDescriptions ()
//
//****************************************************************************
boolean GotAllPlayerDescriptions ( void )
{
	int i;

	for (i=0;i<numplayers;i++)
		if ((GotPlayersDesc[i]==false) && (PlayerStatus[i]==player_ingame))
			return false;

	return true;
}

//****************************************************************************
//
// SetupGameMaster ()
//
//****************************************************************************
void SetupGameMaster ( void )
{
	int savetime;
	boolean done;

	memset(GotPlayersDesc,false,sizeof(GotPlayersDesc));
	GotPlayersDesc[consoleplayer]=true;

	memset(PlayersReady,false,sizeof(PlayersReady));
	PlayersReady[consoleplayer]=true;

	savetime=ticcount;

	done=false;

	InitializeRNG ();

	while (done==false)
		{
		// Setup individual player

		AbortCheck("SetupGameMaster aborted\n");

		// send Game Description
		if (ticcount >= savetime)
			{
			savetime=ticcount+SETUPTIME;
			if (GotAllPlayerDescriptions()==true)
				SendGameDescription();
			}
		if (AllPlayersReady ()==true)
			{
			SendGameStart();
			SendGameStart();
			done=true;
			}
		SetupCheckForPacket();
		}
	savetime=ticcount+(VBLCOUNTER/2);

	while (ticcount<savetime)
		{
		SetupCheckForPacket ();
		}
}










/*
=============================================================================

	DEMO CODE

=============================================================================
*/
//****************************************************************************
//
// GetDemoFilename ()
//
//****************************************************************************

void GetDemoFilename (int demonumber, char * filename)
{
	strcpy(filename,"demo0_0.dmo\0");

	filename[4] = (char)('0' + (byte)demonumber);
	filename[6] = (char)('0' + (byte)gamestate.violence);
}
//****************************************************************************
//
// DemoExists ()
//
//****************************************************************************

boolean DemoExists (int demonumber)
{
	char demo[20];

	GetDemoFilename (demonumber, &demo[0]);
//	if (access (demo, F_OK) == 0)
	if (w_chkaccess (demo) == 0)
		return true;
	else
		return false;

}

//****************************************************************************
//
// SaveDemo ()
//
//****************************************************************************

void SaveDemo (int demonumber)
{
	char demo[20];

	RecordDemoCmd ();
	GetDemoFilename (demonumber, &demo[0]);
	SaveFile (demo, demobuffer, (demoptr-demobuffer));
	FreeDemo();
}

//****************************************************************************
//
// LoadDemo ()
//
//****************************************************************************

void LoadDemo (int demonumber)
{
	char demo[20];
	int size;

	GetDemoFilename (demonumber, demo);
	if (demobuffer!=NULL)
		FreeDemo();
	size = LoadFile (demo, &demobuffer);
	playstate = ex_demoplayback;
	demoptr = demobuffer;
	lastdemoptr = (demoptr+size);
	locplayerstate->player=0;
	InitializeWeapons(locplayerstate);
	ResetPlayerstate(locplayerstate);
	InitCharacter();
}

//****************************************************************************
//
// RecordDemo ()
//
//****************************************************************************

void RecordDemo ( void )
{
	DemoHeaderType * DemoHeader;
	int level;

	if (demobuffer!=NULL)
		FreeDemo();
	godmode=0;
	demobuffer = SafeMalloc (DEMOBUFFSIZE);
	demoptr = demobuffer;
	lastdemoptr = demobuffer+DEMOBUFFSIZE;

	// Save off level number

	DemoHeader=(DemoHeaderType *)demoptr;
	demoptr+=sizeof(gamestate);
	memcpy(&(DemoHeader->demostate),&gamestate,sizeof(gamestate));
	demorecord = true;
	locplayerstate->player=0;
	InitializeWeapons(locplayerstate);
	ResetPlayerstate(locplayerstate);
	level=gamestate.mapon;
	InitCharacter();
	gamestate.mapon=level;
	SoftError(">>>>>>>>>>>>Start demo record\n");
}

//****************************************************************************
//
// SetupDemo ()
//
//****************************************************************************

void SetupDemo ( void )
{
	DemoHeaderType * DemoHeader;

	demoplayback = true;
	godmode=0;

	DemoHeader=(DemoHeaderType *)demoptr;
	demoptr+=sizeof(gamestate);
	if (gamestate.violence!=DemoHeader->demostate.violence)
		Error ("This demo has a different difficulty level than your current settings\n");
	memcpy(&gamestate,&(DemoHeader->demostate),sizeof(gamestate));
	SoftError(">>>>>>>>>>>>Start demo playback\n");
}

//****************************************************************************
//
// FreeDemo ()
//
//****************************************************************************

void FreeDemo ( void )
{
	demoplayback = false;
	demorecord = false;
	SafeFree (demobuffer);
	demobuffer=NULL;
}

//****************************************************************************
//
// CheckForDemoDone ()
//
//****************************************************************************

void CheckForDemoDone ( void )
{
	if ((demoplayback==true) && (demoptr >= lastdemoptr))
		{
		FreeDemo();
		playstate = ex_demodone;
		}
}

//****************************************************************************
//
// CheckForDemoOverflowed ()
//
//****************************************************************************

void CheckForDemoOverflowed ( void )
{
	if (demoptr >= (lastdemoptr-sizeof(DemoType)))
		{
		playstate = ex_completed;	// demo is done
		EndDemo();
		}
}

//****************************************************************************
//
// RecordDemoCmd ()
//
//****************************************************************************

void RecordDemoCmd (void)
{
	DemoType * dtime;

	SoftError("Demo command recorded at %ld\n",controlupdatetime);
	dtime=(DemoType *)demoptr;
	dtime->time = controlupdatetime;
	dtime->momx = (controlbuf[0]>>1);
	dtime->momy = (controlbuf[1]>>1);
	dtime->dangle = controlbuf[2]>>11;
	dtime->buttons = buttonbits;

	demoptr+=sizeof(DemoType);

	CheckForDemoOverflowed();
}

//****************************************************************************
//
// AddDemoCmd ()
//
//****************************************************************************

void AddDemoCmd (void)
{
	DemoType * dtime;

	//
	// get info from demo buffer
	//

	SoftError("Demo command played at %ld\n",controlupdatetime);
	if (demoplayback==true)
		{
		dtime=(DemoType *)demoptr;
		controlbuf[0]=dtime->momx<<1;
		controlbuf[1]=dtime->momy<<1;
		controlbuf[2]=dtime->dangle<<11;
		buttonbits	=dtime->buttons;
		demoptr+=sizeof(DemoType);
		}
}

//****************************************************************************
//
// GetNextDemoTime ()
//
//****************************************************************************

int GetNextDemoTime (void)
{
	DemoType * dtime;

	CheckForDemoDone();
	dtime=(DemoType *)demoptr;
	if (demoplayback)
		return dtime->time;
	else
		return -1;
}

//****************************************************************************
//
// UpdateDemoPlayback ()
//
//****************************************************************************

void UpdateDemoPlayback (int time)
{
	if (demoplayback)
		{
		if (GetNextDemoTime()==time)
			AddDemoCmd();
		}
}





/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

// #include <dos.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

#include "rt_def.h"
#include "watcom.h"
#include "rt_sound.h"
#include "gmove.h"
#include "states.h"
#include "rt_sqrt.h"
#include "rt_actor.h"
#include "rt_main.h"
#include "rt_playr.h"
#include "isr.h"
#include "rt_draw.h"
#include "rt_ted.h"
#include "rt_door.h"
#include "rt_menu.h"
#include "rt_view.h"
#include "rt_com.h"
#include "rt_in.h"
#include "rt_util.h"
#include "rt_game.h"
#include "rt_rand.h"
#include "z_zone.h"
// #include "rt_swift.h"
#include "engine.h"
#include "_rt_play.h"
#include "rt_cfg.h"
// #include "rt_spbal.h"
#include "rt_floor.h"
#include "develop.h"
#include "rt_msg.h"
#include "rt_debug.h"
#include "sprites.h"
#include "rt_net.h"
#include "rt_dmand.h"
//MED
// #include "memcheck.h"


#define FLYINGZMOM  350000


#if (DEVELOPMENT == 1)
#include "rt_str.h"
#endif

specials CurrentSpecialsTimes =
		{
		60*VBLCOUNTER, // god
		60*VBLCOUNTER, // dog
		20*VBLCOUNTER, // shrooms
		20*VBLCOUNTER, // elasto
		60*VBLCOUNTER, // asbestos vest
		60*VBLCOUNTER, // bullet proof vest
		GASTICS, // gas mask
		60*VBLCOUNTER, // mercury mode

		300*VBLCOUNTER, // god respawn
		60*VBLCOUNTER, // dog respawn
		60*VBLCOUNTER, // shrooms respawn
		60*VBLCOUNTER, // elasto respawn
		60*VBLCOUNTER, // asbestos vest respawn
		60*VBLCOUNTER, // bullet proof vest respawn
		60*VBLCOUNTER, // gas mask respawn
		60*VBLCOUNTER  // mercury mode respawn
		};

int GRAVITY = NORMAL_GRAVITY;

ROTTCHARS characters[5]={
	{0x2100,0x4800,100,2,25},  // Taradino Cassatt
	{0x2200,0x5200,85,3,32},	// Thi Barrett
	{0x1f00,0x4000,150,3,20},  // Doug Wendt
	{0x2300,0x5500,70,2,33},	// Lorelei Ni
	{0x2000,0x4400,120,3,25}}; // Ian Paul Freeley

static const int TD = MINACTORDIST+0x1000;
static const int STRAFEAMOUNT = ((KEYBOARDNORMALTURNAMOUNT >> 10) + (KEYBOARDNORMALTURNAMOUNT >> 12));


static const int GODYZANGLE	= -(9*FINEANGLES/360);
static const int DOGYZANGLE	=  (4*FINEANGLES/360);
static const int SHROOMYZANGLE  =  (15*FINEANGLES/360);
static const int FALLINGYZANGLE = -(15*FINEANGLES/360);
static const int NORMALYZANGLE  = 0;


/*
=============================================================================

			GLOBAL VARIABLES

=============================================================================
*/

int controlbuf[3];
int buttonbits;
extern _2Dpoint LASTSOUND;
//
// player state info
//

statobj_t		*DEADPLAYER[MAXDEAD];
int				NUMDEAD;
int				lastpolltime;

statobj_t		*BulletHoles[MAXBULLETS];
int				BulletHoleNum;

objtype		*PLAYER[MAXPLAYERS],*player;
playertype	PLAYERSTATE[MAXPLAYERS],*locplayerstate;

gametype		gamestate;

boolean		godmode = false;

boolean		missilecam=false;
objtype		* missobj=NULL;
// Player control variables

int KX = 0;
int KY = 0;
int MX = 0;
int MY = 0;
int JX = 0;
int JY = 0;
int CX = 0;
int CY = 0;
// boolean vrenabled = false;
int VX = 0;
int VY = 0;

int oldcyberx = 0;
int oldcybery = 0;
int CYBERDEADRANGE = 6000;
boolean CYBERLOOKUP,CYBERLOOKDOWN;

int leftmom = 0;
int rightmom = 0;
int lastmom = 0;
int first	= 1;

int pausedstartedticcount;
boolean RefreshPause = true;

boolean  buttonpoll[NUMBUTTONS];

int		buttonscan[NUMBUTTONS] = {sc_Control, sc_Alt, sc_RShift, sc_Space,
											sc_PgUp,sc_PgDn,sc_Enter,sc_Delete,
											sc_Home,sc_End,sc_1,sc_2,sc_3,sc_4,
											sc_CapsLock, sc_F12,
											sc_Comma,sc_Period,sc_BackSpace,sc_A,
											sc_UpArrow, sc_RightArrow,
											sc_DownArrow, sc_LeftArrow,
											sc_Tab, sc_T, sc_Z };

int		joyxmax = 0, joyymax = 0, joyxmin = 0, joyymin = 0;

int		buttonmouse[6] = {bt_attack, bt_strafe, di_north,
									bt_nobutton, bt_use, bt_nobutton };

int		buttonjoy[8] = {bt_attack, bt_strafe, bt_run, bt_use,
								bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton };

williamdidthis FREE = {84,5,0,0,9,{{done,2,1},{done,2,2},{done,2,3},
	{done,2,4},{done,2,5},{done,2,6},{done,2,7},{done,2,8},
	{reset,2,9}}};

williamdidthis DOGSCRATCH = {128,5,0,0,4,{{done,2,8},{at_pulltrigger,2,9},{done,2,10},
									{reset,2,11}}};

williamdidthis DOGLICK =	{128,5,0,0,4,{{done,2,4},{done,2,5},{done,2,6},
									{reset,2,7}}};


williamdidthis WEAPONS[MAXWEAPONS] =

{
	{100,-1,10,0x2000l,3,{{at_pulltrigger,4,1},{done,4,2},{reset,4,0}}}, //single pistol
	{100,-1,10,0x2000l,6,{{at_pulltrigger,2,1},{done,2,2},{done,2,3},
						{at_pulltrigger,2,4},{done,2,5},{reset,2,3}}}, // double pistol
	{70,-1,10,0x2000l,2,{{at_pulltrigger,2,1},{reset,1,2}}}, //mp 40
	{80,5,10,0x50000l,4,{{at_missileweapon,2,1},{done,2,2},{reset,2,3},{reset2,6,0}}}, //bazooka
	{80,5,10,0x10000l,4,{{at_missileweapon,2,1},{done,2,2},{reset,2,3},{reset2,6,0}}}, //firebomb
	{80,5,10,0x50000l,4,{{at_missileweapon,2,1},{done,2,2},{reset,2,3},{reset2,6,0}}}, //heatseeker
	{80,5,10,0x10000l,4,{{at_missileweapon,2,1},{done,2,2},{reset,2,3},{reset2,6,0}}}, //drunk
	{80,5,7,0x10000l,4,{{at_missileweapon,2,1},{done,2,2},{reset,2,2},{reset2,6,0}}}, // firewall
	{125,5,7,0x10000l,7,{{done,3,1},{done,3,2},{done,3,3},{done,3,4},
						{at_missileweapon,3,5},{done,3,6},{reset,3,7}}},	//GODHAND

#if (SHAREWARE == 0)
	{80,5,7,0x10000l,4,{{at_missileweapon,2,1},{done,2,2},{reset,2,3},{reset2,6,0}}}, //split
	{80,5,7,0x10000l,9,{{done,5,1},{done,5,2},{done,5,3},{done,5,4},
						{at_missileweapon,10,5},{done,5,4},{done,5,3}, // kes
						{done,5,2},{reset,5,1}}},
	{200,5,7,0x10000l,6,{{done,1,1},{done,1,2},{at_pulltrigger,1,3},{at_pulltrigger,1,4},
						{at_pulltrigger,1,5},{reset,1,6}}},	//BAT
	{128,5,7,0x10000l,3,{{done,2,1},{at_pulltrigger,2,2},{reset,2,3}}}
#endif
};


/*
=============================================================================

					LOCAL FUNCTION PROTOTYPES and VARIABLES

=============================================================================
*/

void	CheckPlayerSpecials(objtype * ob);
void	CheckWeaponStates(objtype * ob);
boolean  CheckSprite (statobj_t* ,int *);
void	T_Tag (objtype *ob);
void	T_Player (objtype *ob);
void	T_BatBlast(objtype*ob);
void	T_Attack (objtype *ob);
void	T_Free (objtype *ob);
void	T_DogUse (objtype *ob);
void	PlayerMove(objtype * ob);
void	Thrust (objtype * ob);
void	CheckWeaponChange (objtype * ob);
void	PlayerMissileAttack(objtype* );
void	Cmd_Use(objtype*);
//void	ComError (char *error, ...);

statetype s_free = {false,0,0,T_Free,ST_NULL,&s_free};
statetype s_inelevator = {false,0,420,T_Player,ST_NULL,&s_player};

#if (SHAREWARE == 0)
statetype s_dogwait = {true,SERIALDOG_W11,50,T_Player,SF_DOGSTATE,&s_serialdog};

statetype s_doguse = {true,SERIALDOG_W11,140,T_DogUse,SF_DOGSTATE,&s_serialdog};
statetype s_doglick = {true,SERIALDOG_W11,0,T_DogLick,SF_DOGSTATE,&s_doglick};
#endif

statetype s_tag = {false,CASSATT_S1,20,T_Tag,ST_NULL,&s_player};

static SWIFT_3DStatus SWIFTStatus;

//
// curent user input
//

static int turnheldtime;
static int turnaround = 0;
static int turnaroundtime;

//
// Double Click variables
//

static int  DoubleClickTimer[ 3 ]	= { 0 };
static byte DoubleClickCount[ 3 ]	= { 0 };
static byte DoubleClickPressed[ 3 ] = { false };
static int  JoyDblClickTimer[ 4 ]	= { 0 };
static byte JoyDblClickCount[ 4 ]	= { 0 };
static byte JoyDblClickPressed[ 4 ] = { false };


static int PlayerRecording=-1;
static int nettics;

/*
===============
=
= LoadPlayer
=
===============
*/
void LoadPlayer ( void )
{
	memset (locplayerstate->buttonstate, 0, sizeof(locplayerstate->buttonstate));
	locplayerstate->anglefrac=player->angle<<ANGLEBITS;
	areabyplayer[player->areanumber]=true;
	ConnectAreas();
}


int MaxHitpointsForCharacter(playertype*pstate)
{
	if (BATTLEMODE && (gamestate.BattleOptions.HitPoints != bo_character_hitpoints))
		{
		return( gamestate.BattleOptions.HitPoints );
		}
	return characters[pstate->player].hitpoints;
}

void InitializeWeapons(playertype*pstate)
{


#if (SHAREWARE == 0)
	if (gamestate.SpawnEluder)
	{pstate->new_weapon = pstate->weapon = pstate->missileweapon = wp_dog;
	pstate->oldweapon = pstate->oldmissileweapon = wp_dog;
	pstate->bulletweapon = -1;
	pstate->HASBULLETWEAPON[wp_pistol] = 0;
	pstate->HASBULLETWEAPON[wp_twopistol] = 0;
	pstate->HASBULLETWEAPON[wp_mp40] = 0;
	}
	else
#endif
	{if (gamestate.PlayerHasGun[pstate-&PLAYERSTATE[0]])
		{pstate->new_weapon = pstate->weapon = pstate->oldweapon =
		pstate->bulletweapon = wp_pistol;
		pstate->HASBULLETWEAPON[wp_pistol] = 1;
		pstate->HASBULLETWEAPON[wp_twopistol] = 0;
		pstate->HASBULLETWEAPON[wp_mp40] = 0;
		pstate->missileweapon = pstate->oldmissileweapon = -1;
		}
	else
		{pstate->new_weapon = pstate->weapon = pstate->oldweapon =
		pstate->bulletweapon = -1;
		pstate->HASBULLETWEAPON[wp_pistol] = 0;
		pstate->HASBULLETWEAPON[wp_twopistol] = 0;
		pstate->HASBULLETWEAPON[wp_mp40] = 0;
		pstate->missileweapon = pstate->oldmissileweapon = -1;
		}
	}


	pstate->ammo = -1;
}

void ResetPlayerstate(playertype*pstate)
{

	pstate->batblast = 0;
	pstate->poweruptime = pstate->protectiontime = 0;
	pstate->NETCAPTURED = 0;
	MISCVARS->NET_IN_FLIGHT = 0;
	pstate->weaponuptics = 0;
	pstate->weapondowntics = 0;
	if ((insetupgame==false) || NewGame)
	pstate->health = MaxHitpointsForCharacter(pstate);
	pstate->keys = 0;

	// Give players all the keys in battle game

	if ( BATTLEMODE )
	{
	pstate->keys = 0x0f;
	}
	pstate->attackframe = pstate->attackcount =
	pstate->weaponframe = 0;
	if (gamestate.battlemode == battle_Tag)
	pstate->weaponheight = TAGHANDHEIGHT;
	else
	pstate->weaponheight = 0;
	pstate->heightoffset = pstate->oldheightoffset = 0;
	if (gamestate.SpawnEluder)
	pstate->playerheight = 40;
	else
	pstate->playerheight = characters[pstate->player].height;
	pstate->falling = false;
	memset (pstate->buttonstate, 0, sizeof(pstate->buttonstate));
	SetPlayerHorizon(pstate,NORMALYZANGLE);
}


/*
===============
=
= SetupPlayerobj
=
===============
*/
void SetupPlayerobj (int tilex, int tiley, int dir, objtype * ob)
{
	playertype *pstate;

	M_LINKSTATE(ob,pstate);
	
	tilex &= (MAPSIZE-1);	//BGB Debug
	tiley &= (MAPSIZE-1);

	ob->obclass = playerobj;
	ob->tilex = tilex;
	ob->tiley = tiley;
	actorat[tilex][tiley] = ob;
	ob->areanumber = MAPSPOT(tilex,tiley,0)-AREATILE;
	MakeLastInArea(ob);
	ob->x = ((long)tilex<<TILESHIFT)+TILEGLOBAL/2;
	ob->y = ((long)tiley<<TILESHIFT)+TILEGLOBAL/2;
	ob->z = PlatformHeight(tilex,tiley);
	if ((ob->z == -10) || DiskAt(tilex,tiley))
	ob->z = 0;

	ob->angle = (1-dir)*ANG90;
	ob->which = ACTOR;
	Fix(ob->angle);
	ob->yzangle = 0;

	ob->dir	= angletodir[ob->angle];
	ob->flags = (FL_SHOOTABLE|FL_ABP|FL_BLOCK|FL_COLORED);
	ob->drawx=ob->x;
	ob->drawy=ob->y;
	ob->hitpoints = pstate->health;
	pstate->anglefrac= (ob->angle<<ANGLEBITS);
	pstate->angle=0;
	areabyplayer[ob->areanumber]=true;


	if (ob == player)
		{
		playerdead=false; // local player dead flag
		}
	if (!gamestate.SpawnEluder)
	ob->shapeoffset = pstate->player*REMOTEOFFSET;

	memset (pstate->buttonstate, 0, sizeof(pstate->buttonstate));
	if (SCREENEYE != NULL)
		{
		NewState(SCREENEYE,&s_megaremove);
		SCREENEYE = NULL;
		}
}


void SetShapeoffset(objtype*ob)
{playertype *pstate;

	M_LINKSTATE(ob,pstate);
	ob->shapeoffset = pstate->player*REMOTEOFFSET;
	ob->flags |= FL_COLORED;
	ob->flags &= ~FL_DYING;

}


/*
===============
=
= RevivePlayerobj
=
===============
*/
void RevivePlayerobj (int tilex, int tiley, int dir, objtype*ob)
{
	playertype *pstate;
	statetype *tstate;

	M_LINKSTATE(ob,pstate);
	tstate = ob->state;
	RemoveFromArea(ob);
	TurnActorIntoSprite(ob);
	if ((LASTSTAT->z < nominalheight) && (!IsPlatform(LASTSTAT->tilex,LASTSTAT->tiley)))
		{
		SpawnParticles(ob,GUTS,10 + gamestate.difficulty);
		RemoveStatic(LASTSTAT);
		}
	else
	{if (DEADPLAYER[NUMDEAD])
			RemoveStatic(DEADPLAYER[NUMDEAD]);
		DEADPLAYER[NUMDEAD] = LASTSTAT;
		LASTSTAT->linked_to = NUMDEAD;
		NUMDEAD = (NUMDEAD+1)&(MAXDEAD-1);
	}

	ob->state = tstate;

	SetupPlayerobj (tilex, tiley, dir, ob);
	ConnectAreas();

	ResetPlayerstate(pstate);
	InitializeWeapons(pstate);
	SD_PlaySoundRTP(SD_PLAYERSPAWNSND,ob->x,ob->y);
	if (!gamestate.SpawnEluder)
		{
		ob->shapeoffset = 0;
		ob->flags &= ~FL_COLORED;
		ob->flags |= FL_DYING;
		NewState(ob,&s_respawn1);
		if (gamestate.battlemode == battle_Tag)
			{
			if (BATTLE_Team[ob->dirchoosetime] == BATTLE_It)

				{
				pstate->missileweapon = pstate->oldweapon = pstate->new_weapon =
				pstate->oldmissileweapon = pstate->weapon = wp_godhand;
				pstate->bulletweapon = -1;
				ob->flags |= FL_DESIGNATED;
				}
			else
				{
				pstate->weaponheight = 0;
				}
			}
		}
#if (SHAREWARE == 0)
	else
		NewState(ob,&s_serialdog);
#endif
	if (ob==player)
		DrawPlayScreen(false);
	ob->momentumx = ob->momentumy = ob->momentumz = 0;
}


/*
===============
=
= SpawnPlayerobj
=
===============
*/
void SpawnPlayerobj (int tilex, int tiley, int dir, int playerindex)
{
	playertype *pstate;

	tilex &= (MAPSIZE-1);	//BGB Debug
	tiley &= (MAPSIZE-1);

	pstate = &PLAYERSTATE[playerindex];

	GetNewActor();
	MakeActive(new);

	// Set player number

	new->dirchoosetime = playerindex;

	// Save off if local player

	if (playerindex==consoleplayer)
		player=new;

	PLAYER[playerindex] = new;

	SetupPlayerobj (tilex, tiley, dir, new);

	if (!gamestate.SpawnEluder)
		NewState(new,&s_player);
#if (SHAREWARE == 0)
	else
		NewState(new,&s_serialdog);
#endif


}

/*
===============
=
= SetupBulletHoleLink
=
===============
*/
void SetupBulletHoleLink (int num, statobj_t * item)
{
	BulletHoles[num] = item;
}

/*
===============
=
= SpawnBulletHole
=
===============
*/
void SpawnBulletHole (int x, int y, int z)
{
	if (M_ISDOOR(x>>16,y>>16))
		return;
	if (BulletHoles[MISCVARS->BulletHoleNum])
		RemoveStatic(BulletHoles[MISCVARS->BulletHoleNum]);
	SpawnInertStatic(x,y,z,stat_bullethole);
	BulletHoles[MISCVARS->BulletHoleNum]=LASTSTAT;
	LASTSTAT->linked_to=MISCVARS->BulletHoleNum;
	MISCVARS->BulletHoleNum = (MISCVARS->BulletHoleNum+1)&(MAXBULLETS-1);
}


void SpawnGunSmoke(int x, int y, int z, int angle, int bullethole)

{
	int chance;

	if ((x<=0) || (y<=0))
		{
		SoftError("SpawnGunSmoke: xy below angle=%ld\n",angle);
		return;
		}

	if ((bullethole!=0) && (z>=-32) && (z<=maxheight))
		switch (bullethole)
			{
			case 1:
				SpawnBulletHole(x-BULLETHOLEOFFSET,y,z);
				break;
			case 2:
				SpawnBulletHole(x+BULLETHOLEOFFSET,y,z);
				break;
			case 3:
				SpawnBulletHole(x,y-BULLETHOLEOFFSET,z);
				break;
			case 4:
				SpawnBulletHole(x,y+BULLETHOLEOFFSET,z);
				break;
			case 5:
				SpawnBulletHole(x,y,z);
				break;
			default:
				Error("Invalid bullethole value\n");
				break;
			}

	SpawnInertActor(x,y,z);

	NewState(new,&s_gunsmoke1);

	if (angle < ANGLES/4)
	{if ((angle < (3*ANGLES/16)) && (angle > (ANGLES/16)))
		chance = 128;
	else
		chance = 20;
	}
	else if (angle < ANGLES/2)
	{if ((angle < (7*ANGLES/16)) && (angle > (5*ANGLES/16)))
		chance = 128;
	else
		chance = 20;
	}
	else if (angle < 3*ANGLES/4)
	{if ((angle < (11*ANGLES/16)) && (angle > (9*ANGLES/16)))
		chance = 128;
	else
		chance = 20;
	}
	else
	{if ((angle < (15*ANGLES/16)) && (angle > (13*ANGLES/16)))
		chance = 128;
	else
		chance = 20;
	}

	if (RandomNumber("Wall ricochet check",0)<chance)
	{int rand;

	rand = RandomNumber("Spawn Ricochet Sound in SpawnGunSmoke",0);
	if (rand < 80)
		SD_PlaySoundRTP(SD_RICOCHET1SND,new->x,new->y);
	else if (rand < 160)
		SD_PlaySoundRTP(SD_RICOCHET2SND,new->x,new->y);
	else
		SD_PlaySoundRTP(SD_RICOCHET3SND,new->x,new->y);
	}
}

void  SpawnBlood(objtype * ob, int angle)
	{

	SpawnInertActor(ob->x-(costable[angle]>>5),
						ob->y+(sintable[angle]>>5),ob->z);

	NewState(new,&s_bloodspurt1);

	if ((new->x<=0) || (new->y<=0))
		Error("SpawnBlood: bad x,y obj->obclass=%ld\n",ob->obclass);
	}

void  SpawnMetalSparks(objtype * ob, int angle)
	{
	int rand,dispx=0,dispy=0;


	if (ob->which == ACTOR)
		{
		dispx = ob->momentumx;
		dispy = ob->momentumy;
		}

	SpawnInertActor(ob->x-(costable[angle]>>3)+dispx,
						ob->y+(sintable[angle]>>3)+dispy,ob->z);

	if (GameRandomNumber("Spawn Metal Sparks",0)<128)
	NewState(new,&s_hitmetalactor1);
	else
	NewState(new,&s_hitmetalwall1);

	rand = RandomNumber("Spawn Ricochet Sound",0);
	if (rand < 80)
	SD_PlaySoundRTP(SD_RICOCHET1SND,new->x,new->y);
	else if (rand < 160)
	SD_PlaySoundRTP(SD_RICOCHET2SND,new->x,new->y);
	else
	SD_PlaySoundRTP(SD_RICOCHET3SND,new->x,new->y);
	if ((new->x<=0) || (new->y<=0))
		Error("SpawnMetalSparks: bad x,y obj->obclass=%ld\n",ob->obclass);
}

/*
===============
=
= UnTargetActor ( objtype * target )
=
===============
*/
void UnTargetActor ( objtype * target )
{
	int i;

	for (i=0;i<numplayers;i++)
		{
		if (PLAYERSTATE[i].guntarget==target)
			{
			PLAYERSTATE[i].guntarget=NULL;
			SetNormalHorizon(PLAYER[i]);
			}
		}
}


//=============================================================

int GetWeaponForItem(int itemnumber)
	{
	switch (itemnumber)
		{


		case  stat_twopistol:
			return wp_twopistol;

		case  stat_mp40:
			return wp_mp40;

		case  stat_bazooka:
			return wp_bazooka;

		case  stat_heatseeker:
			return wp_heatseeker;

		case  stat_drunkmissile:
			return wp_drunk;

		case  stat_firebomb:
			return wp_firebomb;

		case  stat_firewall:
			return wp_firewall;

		case  stat_godmode:
			return wp_godhand;

#if (SHAREWARE == 0)


		case  stat_splitmissile:
			return wp_split;

		case  stat_kes:
			return wp_kes;

		case  stat_bat:
			return wp_bat;


		case  stat_dogmode:
			return wp_dog;
#endif
		}
	return 0;
	}


int GetItemForWeapon(int weapon)
	{
	switch (weapon)
		{

		case wp_twopistol:
			return stat_twopistol;

		case  wp_mp40:
			return stat_mp40;

		case  wp_bazooka:
			return stat_bazooka;

		case  wp_heatseeker:
			return stat_heatseeker;

		case  wp_drunk:
			return stat_drunkmissile;

		case  wp_firebomb:
			return stat_firebomb;

		case  wp_firewall:
			return stat_firewall;

		case  wp_godhand:
			return stat_godmode;

#if (SHAREWARE == 0)

		case  wp_split:
			return stat_splitmissile;

		case  wp_kes:
			return stat_kes;

		case  wp_bat:
			return stat_bat;


		case  wp_dog:
			return stat_dogmode;
#endif
		}
	return -1;
	}


#define MF_SINGULAR 0x01

missile_stats PlayerMissileData[13] =

	{
	{0,0,0,0,0},
	{0,0,0,0,0},
	{0,0,0,0,0},

	{&s_p_bazooka1,0x6000,p_bazookaobj,0x7000,MF_SINGULAR},
	{&s_p_bazooka1,0x8000,p_heatseekobj,0x7000,MF_SINGULAR},
	{&s_p_bazooka1,0x6000,p_drunkmissileobj,0x7000,0},
	{&s_p_bazooka1,0x8000,p_firebombobj,0x7000,MF_SINGULAR},
	{&s_p_grenade,0x4000,p_firewallobj,0x8000,0},
	{&s_godfire1,0x3800,p_godballobj,0x8000,0},
	{&s_p_bazooka1,0x8000,p_splitmissileobj,0x7000,MF_SINGULAR},
#if (SHAREWARE == 0)
	{&s_kessphere1,0xc000,p_kesobj,0x5000,MF_SINGULAR},
#else
	{0,0,0,0,0},
#endif
	{0,0,0,0,0},
	{0,0,0,0,0}

	};


void MissileAutoTarget(objtype *ob,missile_stats *mdata)
	{
	int dx,dy,angle,mindist,currdist,magangle,saveangle,
		xydist,dz,yzangle,oldyzangle,saveyzangle;
	objtype *target,*temp;

	mindist = 0x7fffffff;
	target = NULL;
	for(temp = firstactive;temp;temp=temp->nextactive)
		{
		if (temp == ob)
			continue;
		if ((!(temp->flags & FL_SHOOTABLE)) || (temp->flags & FL_DYING))
			continue;
		if (!CheckLine(ob,temp,SHOOT))
			continue;

		dx = temp->x-ob->x;
		dy = ob->y-temp->y;
		dz = ob->z-temp->z;
		xydist = FindDistance(dx,dy);
		yzangle = atan2_appx(xydist,dz<<10);

		angle = atan2_appx(dx,dy);

		magangle = abs(ob->angle - angle);
		if (magangle > VANG180)
			magangle = ANGLES - magangle;

		if (magangle > ANGLESDIV8)
			continue;

		currdist = FindDistance(ob->x-temp->x,ob->y-temp->y);
		if (currdist < mindist)
			{
			mindist = currdist;
			target = temp;
			saveangle = angle;
			saveyzangle = yzangle;
			}
		}

	if (target)
		{
		oldyzangle = ob->yzangle;
		ob->yzangle = saveyzangle;
		SpawnMissile(ob,mdata->obclass,mdata->speed,saveangle,
						mdata->state,mdata->offset);
		ob->yzangle = oldyzangle;
		}

	else if (ob->flags&FL_GODMODE)
		{
		int saveangle;

		saveangle=ob->yzangle;
		ob->yzangle -= GODYZANGLE;
		Fix(ob->yzangle);
		SpawnMissile(ob,mdata->obclass,mdata->speed,
						ob->angle,mdata->state,mdata->offset);
		ob->yzangle=saveangle;
		}
	else
		SpawnMissile(ob,mdata->obclass,mdata->speed,ob->angle,
						mdata->state,mdata->offset);

	}


void PlayerMissileAttack(objtype*ob)

	{
	playertype * pstate;
	missile_stats *newmissiledata;
	M_LINKSTATE(ob,pstate);


	MISCVARS->madenoise = true;
	newmissiledata = &PlayerMissileData[pstate->missileweapon];

	// ready to annihilate this poor bastard

	if ((newmissiledata->obclass == p_godballobj) ||
		(newmissiledata->obclass == p_kesobj))
		MissileAutoTarget(ob,newmissiledata);

	else
		{
		SpawnMissile(ob,newmissiledata->obclass,newmissiledata->speed,ob->angle,
						newmissiledata->state,newmissiledata->offset);

		if (newmissiledata->obclass == p_drunkmissileobj)
			{
			int i;

			for(i=0;i<4;i++)
				{
				if (!MissileTryMove(new,new->x+new->momentumx,new->y+new->momentumy,new->z))
					{
					new->x = new->drawx = ob->x + (costable[new->angle]>>3);
					new->y = new->drawy = ob->y - (sintable[new->angle]>>3);

					ob->momentumx = -FixedMul(0x5000l,costable[ob->angle]);
					ob->momentumy = FixedMul(0x5000l,sintable[ob->angle]);
					}

				SpawnMissile(ob,newmissiledata->obclass,newmissiledata->speed,ob->angle,
								newmissiledata->state,newmissiledata->offset);


				}
			}
		}


	if (newmissiledata->flags & MF_SINGULAR)
		PLAYER0MISSILE = new;

	SD_PlaySoundRTP(BAS[new->obclass].fire,ob->x,ob->y);

	// if (new->obclass == p_godballobj)
	//	new->z += 10;

	new->dirchoosetime = 5;
	if (missilecam==true)
		missobj=new;
	if (!MissileTryMove(new,new->x+new->momentumx,new->y+new->momentumy,new->z))
		{
		new->x = new->drawx = ob->x + (costable[new->angle]>>3);
		new->y = new->drawy = ob->y - (sintable[new->angle]>>3);

		ob->momentumx = -FixedMul(0x5000l,costable[ob->angle]);
		ob->momentumy = FixedMul(0x5000l,sintable[ob->angle]);
		}

	}

//====================================================================


boolean InRange (objtype *p, objtype *victim, int distance)
{
	int dx,dy;
	int angle;
	int magangle;

	if (victim->which==SPRITE)
		{
		dx = ((statobj_t *)victim)->x - p->x;
		dy = p->y - ((statobj_t *)victim)->y;
		}
	else
		{
		dx = victim->x - p->x;
		dy = p->y - victim->y;
		}
	angle = atan2_appx (dx,dy);

	magangle = abs(p->angle - angle);
	if (magangle > VANG180)
		magangle = ANGLES - magangle;
	if (magangle<(75-(distance>>16)))
		return true;
	else
		return false;
}


void DogAttack(objtype*ob)
	{
	objtype *temp;
	int dx,dy,dz;

	SD_PlaySoundRTP(SD_DOGMODEBITE1SND+(RandomNumber("DogAttack",0)>>7),ob->x,ob->y);
	for(temp=firstareaactor[ob->areanumber];temp;temp=temp->nextinarea)
		{

		if (temp->obclass > b_heinrichobj)
			continue;


		if ((temp == ob) || (temp->obclass == roboguardobj))
			continue;

		if ((!(temp->flags & FL_SHOOTABLE)) || (temp->flags & FL_DYING))
			continue;
		if (temp->obclass == collectorobj)
			continue;


		dx = abs(temp->x - ob->x);
		if (dx > 0xc000)
			continue;

		dy = abs(temp->y - ob->y);
		if (dy > 0xc000)
			continue;

		dz = abs(temp->z - ob->z);
		if (dz > (0xc000>>10))
			continue;

		DamageThing(temp,30);
		if (gamestate.violence == vl_excessive)
			SpawnParticles(temp,GUTS,15);
		Collision(temp,ob,-temp->momentumx,-temp->momentumy);
		if ((temp->obclass == playerobj) && (temp->flags & FL_DYING))
			BATTLE_PlayerKilledPlayer(battle_kill_with_missile,ob->dirchoosetime,temp->dirchoosetime);

		return;
		}
	}


void DogBlast(objtype*ob)
	{
	int txl,txh,tyl,tyh,radius = 0x70000,x,y,tile;
	objtype*temp;
	statobj_t*tstat;

	txl = ((ob->x - radius)>>TILESHIFT);
	tyl = ((ob->y - radius)>>TILESHIFT);

	txh = ((ob->x + radius)>>TILESHIFT);
	tyh = ((ob->y + radius)>>TILESHIFT);

	if (txl < 1)
		txl = 1;
	if (txh > MAPSIZE-1)
		txh = MAPSIZE-1;
	if (tyl < 1)
		tyl = 1;
	if (tyh > MAPSIZE-1)
		tyh = MAPSIZE-1;

	for(x=txl;x<=txh;x++)
		for(y=tyl;y<=tyh;y++)
			{
			temp = (objtype*)actorat[x][y];

			if (temp && (temp->which == ACTOR) && (temp->flags & FL_SHOOTABLE) &&
				(temp != ob) && (temp->obclass < roboguardobj) &&
				(temp->flags & FL_ABP)
				)
				{
				DamageThing(temp,100);
				if ((temp->hitpoints<=0) && (temp->obclass < roboguardobj))
					{
					MISCVARS->supergibflag = true;
					temp->flags |= FL_HBM;
					}
				Collision(temp,ob,0,0);
				MISCVARS->supergibflag = false;

				if ((temp->obclass == playerobj) && (temp->flags & FL_DYING))
					BATTLE_PlayerKilledPlayer(battle_kill_with_missile,ob->dirchoosetime,temp->dirchoosetime);

				}

			tile = tilemap[x][y];
			if ((tile & 0x4000) && (tile & 0x8000))
				{
				maskedwallobj_t * mw;

				mw=maskobjlist[tile&0x3ff];
				if ((mw->flags & MW_SHOOTABLE) && (mw->flags & MW_ABP))
					UpdateMaskedWall(tile&0x3ff);
				}

			tstat = sprites[x][y];
			if (tstat && (tstat->flags & FL_SHOOTABLE) && (tstat->flags & FL_ABP))
					DamageThing(tstat,50);
			}
	}
/*
void DogBlast(objtype*ob)
	{
	int txl,txh,tyl,tyh,radius = 0x70000,x,y,tile;
	objtype*temp;
	statobj_t*tstat;

	txl = ((ob->x - radius)>>TILESHIFT);
	tyl = ((ob->y - radius)>>TILESHIFT);

	txh = ((ob->x + radius)>>TILESHIFT);
	tyh = ((ob->y + radius)>>TILESHIFT);

	if (txl < 1)
		txl = 1;
	if (txh > MAPSIZE-1)
		txh = MAPSIZE-1;
	if (tyl < 1)
		tyl = 1;
	if (tyh > MAPSIZE-1)
		tyh = MAPSIZE-1;

	for(x=txl;x<=txh;x++)
		for(y=tyl;y<=tyh;y++)
			{
			temp = (objtype*)actorat[x][y];

			if (temp && (temp->which == ACTOR) && (temp->flags & FL_SHOOTABLE) &&
				(temp != ob) && (temp->obclass < roboguardobj))
				{
				DamageThing(temp,100);
				if ((temp->hitpoints<=0) && (temp->obclass < roboguardobj))
					{
					MISCVARS->supergibflag = true;
					temp->flags |= FL_HBM;
					}
				Collision(temp,ob,0,0);
				MISCVARS->supergibflag = false;

				if ((temp->obclass == playerobj) && (temp->flags & FL_DYING))
					BATTLE_PlayerKilledPlayer(battle_kill_with_missile,ob->dirchoosetime,temp->dirchoosetime);

				}

			tile = tilemap[x][y];
			if ((tile & 0x4000) && (tile & 0x8000))
				{
				maskedwallobj_t * mw;

				mw=maskobjlist[tile&0x3ff];
				if (mw->flags & MW_SHOOTABLE)
					UpdateMaskedWall(tile&0x3ff);
				}

			tstat = sprites[x][y];
			if (tstat && (tstat->flags & FL_SHOOTABLE))
				DamageThing(tstat,50);
			}
	}
*/

void BatBlast(objtype*ob)
{int angle;
	playertype *pstate;

	M_LINKSTATE(ob,pstate);

	angle = ob->angle - ANGLES/8 + ((++pstate->batblast)*ANGLES/48);
	Fix(angle);
#if (SHAREWARE == 0)
	SpawnMissile(ob,p_bazookaobj,0x6000,angle,&s_batblast1,0xa000);
#endif

}


void BatAttack(objtype*ob)
{objtype *temp,*temp2;
	objtype *grenadetarget;
	statobj_t*tstat;
	int dx,dy,dz,angle,momx,momy,op,magangle;
	int tilexlow,tilexhigh;
	int tileylow,tileyhigh;
	int radius =0x10000;
	int x,y;

	SD_PlaySoundRTP(SD_EXCALISWINGSND,ob->x,ob->y);
	for(temp=firstareaactor[ob->areanumber];temp;temp=temp->nextinarea)
	{if (temp == ob)
	continue;

	if (temp->flags & FL_DYING)
	continue;

	if ((temp->obclass != grenadeobj) &&
		(!((temp->obclass >= grenadeobj) && (temp->obclass <= p_godballobj))) &&
		(!(temp->flags & FL_SHOOTABLE) ||
		(temp->obclass >= roboguardobj))
		)
	continue;

	dx = abs(temp->x - ob->x);
	dy = abs(temp->y - ob->y);
	dz = abs(temp->z - ob->z);
	if ((dx > 0x10000) || (dy > 0x10000) || (dz > 20))
	continue;

	magangle = abs(ob->angle - AngleBetween(ob,temp));
	if (magangle > VANG180)
		magangle = ANGLES - magangle;

	if (magangle > ANGLES/8)
	continue;


	angle= ob->angle+ANGLES/16;
	Fix(angle);

	if ((temp->obclass >= grenadeobj) && (temp->obclass <= p_godballobj))
	{
		temp->angle += ANGLES/2;
		Fix(temp->angle);
		temp->momentumx = temp->momentumy = temp->momentumz = 0;
		ParseMomentum(temp,temp->angle);
		temp->whatever = ob;
		temp->target = NULL;
		continue;
	}


	else if (temp->obclass != grenadeobj)
	{momx = FixedMul(0x3000l,costable[angle]);
		momy = -FixedMul(0x3000l,sintable[angle]);
		if (levelheight > 2)
		{op = FixedMul(GRAVITY,(maxheight-100)<<16) << 1;
		temp->momentumz = -FixedSqrtHP(op);
		}
		temp->flags |= FL_NOFRICTION;
		SD_PlaySoundRTP(SD_EXCALIHITSND,ob->x,ob->y);
		if ((gamestate.violence == vl_excessive) && (GameRandomNumber("Bat Gibs",0) < 150))
		{temp->flags |= FL_HBM;
			DamageThing(temp,50);
		}
		else
			DamageThing(temp,10);
		if ((temp->flags & FL_HBM) && (temp->hitpoints > 0))
		temp->flags &= ~FL_HBM;
		Collision(temp,ob,momx,momy);
		if ((temp->obclass == blitzguardobj) && (temp->state == &s_blitzplead7))
		{temp->shapeoffset += deathshapeoffset[temp->obclass];
			temp->flags |= FL_ALTERNATE;
			NewState(temp,&s_blitzdie3);
			temp->momentumx = temp->momentumy = 0;
		}
	}
	else // find target to hit grenade back at
	{int rand;

		rand = GameRandomNumber("bat/grenade target",0);
		if (rand < 80)
		{grenadetarget = (objtype*)(temp->whatever); // hit back at george
			GetMomenta(grenadetarget,ob,&(temp->momentumx),&(temp->momentumy),&(temp->momentumz),0x3000);
		}
		else if (rand < 160) // hit back at first eligible
		{

			for(temp2 = firstareaactor[ob->areanumber];temp2;temp2 = temp2->nextinarea)
				{magangle = abs(ob->angle-AngleBetween(ob,temp2));
				if (magangle > VANG180)
					magangle = ANGLES - magangle;

				if (magangle > ANGLES/8)
					continue;
				GetMomenta(temp2,ob,&(temp->momentumx),&(temp->momentumy),&(temp->momentumz),0x3000);
				break;
				}
		}
		else // hit wherever
		{ob->angle += (rand >> 1);
			Fix(ob->angle);
			ob->momentumx = ob->momentumy = 0;
			ParseMomentum(ob,ob->angle);
		}


		temp->temp1 = 0x70000;
		NewState(temp,&s_grenade1);
	}
	break;
	}

	for(tstat=firstactivestat;tstat;tstat=tstat->statnext)
	{
	if (!(tstat->flags & FL_SHOOTABLE))
	continue;

	dx = abs(tstat->x - ob->x);
	dy = abs(tstat->y - ob->y);
	dz = abs(tstat->z - ob->z);

	if ((dx > 0xc000) || (dy > 0xc000) || (dz > 20))
	continue;

	magangle = abs(ob->angle - AngleBetween(ob,(objtype*)tstat));
	if (magangle > VANG180)
		magangle = ANGLES - magangle;

	if (magangle > ANGLES/8)
	continue;

	DamageThing(tstat,50);


	}

	tilexlow = (int)((ob->x-radius) >>TILESHIFT);
	tileylow = (int)((ob->y-radius) >>TILESHIFT);

	tilexhigh = (int)((ob->x+radius) >>TILESHIFT);
	tileyhigh = (int)((ob->y+radius) >>TILESHIFT);

	tilexlow &= (MAPSIZE-1);	//BGB Debug
	tileylow &= (MAPSIZE-1);
	tilexhigh &= (MAPSIZE-1);	//BGB Debug
	tileyhigh &= (MAPSIZE-1);

	for (y=tileylow;y<=tileyhigh;y++)
	for (x=tilexlow;x<=tilexhigh;x++)
		{if ((tilemap[x][y]&0x8000) && (tilemap[x][y]&0x4000))
			{maskedwallobj_t * mw;

			mw=maskobjlist[tilemap[x][y]&0x3ff];
			if (mw->flags&MW_SHOOTABLE)
					UpdateMaskedWall(tilemap[x][y]&0x3ff);
			}
		}

}

void AutoTargetHorizon(objtype *ob)
	{
	int dx,dy,angle,mindist,magangle,
		xydist,dz;
	objtype *temp;
	playertype * pstate;

	M_LINKSTATE(ob,pstate);

	mindist = 0x7fffffff;
	for(temp = firstactive;temp;temp=temp->nextactive)
		{
		if (temp == ob)
			continue;
		if ((!(temp->flags & FL_SHOOTABLE)) || (temp->flags & FL_DYING))
			continue;
		if (!CheckLine(ob,temp,SHOOT))
			continue;

		dx = temp->x-ob->x;
		dy = ob->y-temp->y;
		dz = ob->z-temp->z;//-pstate->playerheight+32;

		xydist = FindDistance(dx,dy);
		if (abs(dz<<10)>xydist)
			continue;


		angle = atan2_appx(dx,dy);

		magangle = ob->angle - angle;
		Fix(magangle);

		if (
			(magangle>=(ANGLESDIV8/4)) &&
			(magangle<=(FINEANGLES-(ANGLESDIV8/4)))
			)
			{
			continue;
			}

		if (xydist < mindist)
			{
			mindist = xydist;
			pstate->guntarget=temp;
			temp->flags |= FL_TARGET;
			pstate->targettime=oldpolltime+(VBLCOUNTER);
			}
		}
	}

void  GunAttack (objtype *ob)
{
	playertype * pstate;
	int		damage;

	M_LINKSTATE(ob,pstate);

	MISCVARS->madenoise = true;

	switch (pstate->weapon)
	{
	case wp_pistol:
		SD_PlaySoundRTP(SD_ATKPISTOLSND,ob->x,ob->y);
		damage=DMG_PISTOL;
		break;

	case wp_mp40:
		SD_PlaySoundRTP(SD_ATKMP40SND,ob->x,ob->y);
		damage=DMG_MP40;
		break;

	case wp_twopistol:
		SD_PlaySoundRTP(SD_ATKTWOPISTOLSND,ob->x,ob->y);
		damage=DMG_PISTOL;
		break;
	}

	AutoTargetHorizon(ob);
	RayShoot (ob, damage, (characters[pstate->player].accuracy+gamestate.difficulty)<<3);

}


/*
===============
=
= Cmd_Fire
=
===============
*/
void Cmd_Fire (objtype*ob)
	{
	playertype *pstate;

	M_LINKSTATE(ob,pstate);

//	pstate->buttonheld[bt_attack] = true;

	if (pstate->NETCAPTURED && (!pstate->HASKNIFE))
		return;

	if (W_CHANGE(pstate))
		return;

	pstate->attackframe = 0;

	if ((ob==player) && (pstate->weapon < wp_mp40) && (!pstate->NETCAPTURED))
		gamestate.DODEMOCRATICBONUS1 = false;

	if (!pstate->NETCAPTURED)
		{
		if (pstate->weapon <= wp_mp40)
			NewState(ob,&s_pgunattack1);
	#if (SHAREWARE == 0)
		else if ((pstate->weapon == wp_bat) && (pstate->batblast >= BBTIME))
			{
			pstate->batblast = 0;
			NewState(ob,&s_pbatblast);
			}
		else if (pstate->weapon == wp_dog)
			NewState(ob,&s_serialdogattack);
	#endif
		else
			NewState(ob,&s_pmissattack1);

	#if (SHAREWARE == 0)

		if ((pstate->weapon == wp_dog) && (!ob->momentumz))
			ob->momentumz = -0x50000;
	#endif
		pstate->attackcount = WEAPONS[pstate->weapon].attackinfo[0].mtics;
		pstate->weaponframe = WEAPONS[pstate->weapon].attackinfo[0].frame;
		}

	else if (pstate->NETCAPTURED == 1)
		{
		NewState(player,&s_free);
		pstate->attackcount = FREE.attackinfo[0].mtics;
		pstate->weaponframe = FREE.attackinfo[0].frame;
		}

	}

void PlayNoWaySound ( void )
	{
	if (player->flags & FL_DOGMODE)
		SD_Play(SD_DOGMODEBITE2SND);
	else if ((locplayerstate->player == 1) || (locplayerstate->player == 3))
		SD_Play(SD_PLAYERTBHURTSND);
	else
		SD_Play(SD_NOWAYSND);
	}


/*
===============
=
= Cmd_Use
=
===============
*/

void Cmd_Use (objtype*ob)
{
	int				checkx,checky,doorn,
						/*newtilex,newtiley,oldtilex,oldtiley,*/elevnum,
						wallx,wally;
//		statobj_t*		tempsprite=NULL;
	objtype*		tempactor= NULL;
	doorobj_t*		tempdoor=NULL;
	pwallobj_t*		temppwall=NULL;
	wall_t*			tempwall=NULL;
	int				index;
	playertype * pstate;


	M_LINKSTATE(ob,pstate);

#if (SHAREWARE == 0)

	if ((pstate->weapon == wp_dog) && (ob->state != &s_doguse) &&
		(ob->state != &s_dogwait) && (!W_CHANGE(pstate))
		)
		{
		pstate->attackframe = 0;
		NewState(ob,&s_doguse);
		pstate->attackcount = DOGSCRATCH.attackinfo[0].mtics;
		pstate->weaponframe = DOGSCRATCH.attackinfo[0].frame;
		ob->momentumz = -0x40000;
		return;

		}

	else
#endif
	if ((ob->flags & FL_DESIGNATED) && (BATTLEMODE) && (gamestate.battlemode == battle_Tag))
		{
		NewState(ob,&s_tag);
		//return;
		}
//
// find which cardinal direction the player is facing
//
	if (ob->angle < FINEANGLES/8 || ob->angle > 7*FINEANGLES/8)
		{
				checkx = ob->tilex + 1;
				checky = ob->tiley;
				ob->dir = east;
				wallx = (checkx << TILESHIFT);
				wally = (checky << TILESHIFT) + TILEGLOBAL/2;
		}
	else if (ob->angle < 3*FINEANGLES/8)
		{
				checkx = ob->tilex;
				checky = ob->tiley-1;
				ob->dir = north;
				wally = (checky << TILESHIFT) + TILEGLOBAL;
				wallx = (checkx << TILESHIFT) + TILEGLOBAL/2;
		}
	else if (ob->angle < 5*FINEANGLES/8)
		{
				checkx = ob->tilex - 1;
				checky = ob->tiley;
				ob->dir = west;
				wallx = (checkx << TILESHIFT) + TILEGLOBAL;
				wally = (checky << TILESHIFT) + TILEGLOBAL/2;
		}
	else
		{
				checkx = ob->tilex;
				checky = ob->tiley + 1;
				ob->dir = south;
				wally = (checky << TILESHIFT);
				wallx = (checkx << TILESHIFT) + TILEGLOBAL/2;
		}


	if (actorat[checkx][checky])
		{
		tempdoor=(doorobj_t*)actorat[checkx][checky];
		tempactor = (objtype*)actorat[checkx][checky];
		tempwall = (wall_t*)actorat[checkx][checky];
		}
	doorn = tilemap[checkx][checky] & ~0x2000;
//		if (sprites[checkx][checky])
//		tempsprite = sprites[checkx][checky];
//	if (doorn == (elevatorstart + 6))
//	if (!strcmp(W_GetNameForNum(doorn&0x0FFF), "ELEV6"))
	if (W_CheckLumpIsNameP(doorn, "ELEV6"))
		return;

	if (pstate->buttonheld[bt_use])
		return;

//	if (doorn == (elevatorstart + 1))
//	if (!strcmp(W_GetNameForNum(doorn&0x0FFF), "ELEV1"))
	if (W_CheckLumpIsNameP(doorn, "ELEV1"))
		{
		tilemap[checkx][checky]++;				// flip switch
		if (MAPSPOT(ob->tilex,ob->tiley,1) == ALTELEVATORTILE);
			// playstate = ex_secretlevel;
		else if (ob==player)
			playstate = ex_completed;
		}


//	else if (doorn == (elevatorstart + 5))
//	else if (!strcmp(W_GetNameForNum(doorn&0x0FFF), "ELEV5"))
	else if (W_CheckLumpIsNameP(doorn, "ELEV5"))

		{
		elevnum = MAPSPOT(ob->tilex,ob->tiley,1) - 90;
		tempwall->flags |= FL_S_FLIPPED;
		OperateElevatorSwitch(ob,elevnum,checkx,checky);
		}
	else if (tempdoor && tempdoor->which==PWALL)
		{
		temppwall=(pwallobj_t *)tempdoor;
		OperatePushWall (temppwall->num,ob->dir, ob == player );
		}
	else if ((doorn&0x8000) && (!(doorn&0x4000)))
		{
		doorobj_t* dptr = doorobjlist[doorn&0x3ff];
		int dnum = doorn&0x3ff;
		int lock;

		OperateDoor (pstate->keys, dnum, (ob == player));
		if (dptr->eindex != -1)
			{
			elevator_t*eptr;


			lock = dptr->lock;
			if ( lock && !( pstate->keys & ( 1 << ( lock - 1 ) ) ) )
				{
				if (ob==player)
					{
					// locked
					switch (lock)
						{
						case 1:
							AddMessage("You need the \\EGOLD key",MSG_DOOR);
							break;

						case 2:
							AddMessage("You need the \\FSILVER key",MSG_DOOR);
							break;

						case 3:
							AddMessage("You need the \\8IRON key",MSG_DOOR);
							break;

						case 4:
							AddMessage("You need the \\AOSCURO key",MSG_DOOR);
							break;

						default:
							AddMessage("This door appears to be locked",MSG_DOOR);
							break;
						}

					SD_Play( SD_NOITEMSND );
					}
				return;
				}

			eptr = &ELEVATOR[dptr->eindex];
			if (((dnum == eptr->door1) && (eptr->state == ev_rad)) ||
				((dnum == eptr->door2) && (eptr->state == ev_ras))
				)
				if (ob == player)
					AddMessage("Elevator is on the way.",MSG_GAME);

			OperateElevatorDoor(dnum);
			}

		}

	else if ((tempactor) && (tempactor->which == ACTOR) &&
				(tempactor->obclass == pillarobj) &&
				DISTOK(ob->x,tempactor->x,TD) &&
				DISTOK(ob->y,tempactor->y,TD) &&
				(!(tempactor->flags & FL_DONE)) &&
				(!MAPSPOT(tempactor->tilex,tempactor->tiley,2))
			)

		{if ((tempactor->dir == nodir) ||
			(tempactor->dir == ob->dir))
				{if (tempactor->dir == nodir)
					{
					tempactor->dir = ob->dir;
					ParseMomentum(tempactor,dirangle8[tempactor->dir]);
					}
				SD_PlaySoundRTP ( SD_PUSHWALLSND, tempactor->x, tempactor->y );
				tempactor->flags |= FL_ACTIVE;
				tempactor->flags |= FL_FLIPPED;
//					MakeActive(tempactor);
				tempactor->whatever = ob;
				gamestate.secretcount++;
				}

		}
	else if ((tempwall) && (tempwall->which == WALL) &&
				(tempwall->flags & FL_SWITCH) )
		{
		tempwall->flags |= FL_S_FLIPPED;
		if ((tempwall->flags & FL_W_INVERTED) &&
				DISTOK(ob->x,wallx,TD) &&
				DISTOK(ob->y,wally,TD) &&
				DISTOK(ob->z,0,32)
			)
			{
			index = touchindices[checkx][checky]-1;
			if (!(tempwall->flags & FL_ON))
				{
				maskobjlist[tilemap[checkx][checky]&0x3ff]->toptexture++;
				tempwall->flags |= FL_ON;
				TRIGGER[index] = 1;
				SD_PlaySoundRTP(SD_TOUCHPLATESND,ob->x,ob->y);
				if (ob==player)
					AddMessage("Switch turned on.",MSG_GAME);
				}
			else if (tempwall->flags & FL_REVERSIBLE)
				{
				maskobjlist[tilemap[checkx][checky]&0x3ff]->toptexture--;
				tempwall->flags &= ~FL_ON;
				TRIGGER[index] = 1;
				SD_PlaySoundRTP(SD_TOUCHPLATESND,ob->x,ob->y);
				if (ob==player)
					AddMessage("Switch turned off.",MSG_GAME);
				}

			}
		else if (DISTOK(ob->x,wallx,TD) &&
					DISTOK(ob->y,wally,TD) &&
					!(tempwall->flags & FL_W_INVERTED)
				)
			{
			index = touchindices[checkx][checky]-1;
			if (!(tempwall->flags & FL_ON))
				{
				tilemap[checkx][checky]++;
				tempwall->flags |= FL_ON;
				TRIGGER[index] = 1;
				SD_PlaySoundRTP(SD_TOUCHPLATESND,ob->x,ob->y);
				if (ob==player)
					AddMessage("Switch turned on.",MSG_GAME);
				}
			else if (tempwall->flags & FL_REVERSIBLE)
				{
				tilemap[checkx][checky]--;
				tempwall->flags &= ~FL_ON;
				TRIGGER[index] = 1;
				SD_PlaySoundRTP(SD_TOUCHPLATESND,ob->x,ob->y);
				if (ob==player)
					AddMessage("Switch turned off.",MSG_GAME);
				}

			}
		}
	else if ((tempwall) && (tempwall->which == WALL) && (ob==player))
		PlayNoWaySound();
//		else
//			SD_PlaySoundRTP (SD_NOWAYSND,ob->x,ob->y);
//	pstate->buttonheld[bt_use] = true;
}


/*
=============================================================================

						USER CONTROL

=============================================================================
*/


//******************************************************************************
//
// PollKeyboardButtons
//
//******************************************************************************

void PollKeyboardButtons (void)
{
	int i;

	QueueLetterInput ();
	IN_UpdateKeyboard();

	for (i = 0; i < NUMBUTTONS; i++)
		if (Keystate[buttonscan[i]])
			buttonpoll[i] = true;
}

//******************************************************************************
//
// PollMouseButtons
//
//******************************************************************************

void PollMouseButtons (void)
	{
	int i;
	int buttons;
	int mask;
	int press;

	buttons = IN_GetMouseButtons();

	mask = 1;
	for( i = 0; i < 3; i++, mask <<= 1 )
		{
		press = buttons & mask;

		if ( press )
			{
//			if ( ( buttonmouse[ i ] != bt_nobutton ) &&
//				( DoubleClickCount[ i ] != 2 ) )
			if ( buttonmouse[ i ] != bt_nobutton )
				{
				buttonpoll[ buttonmouse[ i ] ] = true;
				}
			}

		// Check double-click
		if ( buttonmouse[ i + 3 ] != bt_nobutton )
			{
			if ( press )
				{
				// Was the button pressed last tic?
				if ( !DoubleClickPressed[ i ] )
					{
					// Yes, take note of it
					DoubleClickPressed[ i ] = true;

					// Is this the first click, or a really late click?
					if ( ( DoubleClickCount[ i ] == 0 ) ||
						( ticcount >= DoubleClickTimer[ i ] ) )
						{
						// Yes, now wait for a second click
						DoubleClickTimer[ i ] = ticcount + DoubleClickSpeed;

							//( tics << 5 );
						DoubleClickCount[ i ] = 1;
						}
					else
						{
						// Second click
						buttonpoll[ buttonmouse[ i + 3 ] ] = true;
						DoubleClickTimer[ i ] = 0;
						DoubleClickCount[ i ] = 2;
						}
					}
				else
					{
					// After second click, button remains pressed
					// until user releases it
					if ( DoubleClickCount[ i ] == 2 )
						{
						buttonpoll[ buttonmouse[ i + 3 ] ] = true;
						}
					}
				}
			else
				{
				if ( DoubleClickCount[ i ] == 2 )
					{
					DoubleClickCount[ i ] = 0;
					}
				DoubleClickPressed[ i ] = false;
				}
			}
		}
	}


//******************************************************************************
//
// PollJoystickButtons
//
//******************************************************************************
void PollJoystickButtons
	(
	void
	)

	{
	int i;
	int buttons;
	int mask;
	int num;
	int press;

	buttons = IN_JoyButtons ();

	if ( joypadenabled )
		{
		num = 4;
		mask = 1;
		}
	else
		{
		num = 2;
		if ( joystickport )
			{
			mask = 4;
			}
		else
			{
			mask = 1;
			}
		}

	for( i = 0; i < num; i++, mask <<= 1 )
		{
		press = buttons & mask;

		if ( press )
			{
//			if ( ( buttonjoy[ i ] != bt_nobutton ) &&
//				( JoyDblClickCount[ i ] != 2 ) )
			if ( buttonjoy[ i ] != bt_nobutton )
				{
				buttonpoll[ buttonjoy[ i ] ] = true;
				}
			}

		// Check double-click
		if ( buttonjoy[ i + 4 ] != bt_nobutton )
			{
			if ( press )
				{
				// Was the button pressed last tic?
				if ( !JoyDblClickPressed[ i ] )
					{
					// Yes, take note of it
					JoyDblClickPressed[ i ] = true;

					// Is this the first click, or a really late click?
					if ( ( JoyDblClickCount[ i ] == 0 ) ||
						( ticcount >= JoyDblClickTimer[ i ] ) )
						{
						// Yes, now wait for a second click
						JoyDblClickTimer[ i ] = ticcount + DoubleClickSpeed;

							//( tics << 5 );
						JoyDblClickCount[ i ] = 1;
						}
					else
						{
						// Second click
						buttonpoll[ buttonjoy[ i + 4 ] ] = true;
						JoyDblClickTimer[ i ] = 0;
						JoyDblClickCount[ i ] = 2;
						}
					}
				else
					{
					// After second click, button remains pressed
					// until user releases it
					if ( JoyDblClickCount[ i ] == 2 )
						{
						buttonpoll[ buttonjoy[ i + 4 ] ] = true;
						}
					}
				}
			else
				{
				if ( JoyDblClickCount[ i ] == 2 )
					{
					JoyDblClickCount[ i ] = 0;
					}
				JoyDblClickPressed[ i ] = false;
				}
			}
		}
	}


//===========================================================================

//******************************************************************************
//
// PollKeyboardMove
//
//******************************************************************************

void PollKeyboardMove
	(
	void
	)

	{
	if ( ( buttonpoll[ bt_turnaround ] ) && ( turnaround == 0 ) )
		{
		turnaround = 1;
		turnaroundtime = 15 + tics;
		turnheldtime = 0;
		}
	if ( turnaround == 0 )
		{
		if ( buttonpoll[ di_east ] )
			{
			turnheldtime+=tics;
			if (turnheldtime>=TURBOTURNTIME)
				{
				KX = -KEYBOARDNORMALTURNAMOUNT;
				}
			else
				{
				KX = -KEYBOARDPREAMBLETURNAMOUNT;
				}
			}
		else if ( buttonpoll[ di_west ] )
			{
			turnheldtime+=tics;
			if (turnheldtime>=TURBOTURNTIME)
				{
				KX = KEYBOARDNORMALTURNAMOUNT;
				}
			else
				{
				KX = KEYBOARDPREAMBLETURNAMOUNT;
				}
			}
		else
			{
			KX = 0;
			turnheldtime=0;
			}
		if ( (buttonpoll[bt_run]) &&
			( (turnheldtime>=TURBOTURNTIME) || (turnheldtime==0) )
			)
			KX = FixedMul(KX,TURBOTURNAMOUNT);
		}
	else
		{
		KX=TURNAROUNDSPEED;
		turnaroundtime-=tics;
		if (turnaroundtime<=0)
			{
			turnaround=0;
			KX=((turnaroundtime*TURNAROUNDSPEED)>>1);
			}
		}

	if ( buttonpoll[ di_north ] )
		{
		KY = -BASEMOVE;
		}
	else if ( buttonpoll[ di_south ] )
		{
		KY = BASEMOVE;
		}
	else
		KY = 0;

	if (buttonpoll[bt_run])
		{
		KY <<= 1;
		}
}

//******************************************************************************
//
// PollMouseMove
//
//******************************************************************************

//#define MOUSE_RY_SHIFT 12
//#define MOUSE_TZ_SHIFT 3
#define MOUSE_TZ_SENSITIVITY_SCALE 65535
#define MOUSE_RY_SENSITIVITY_SCALE 18725
//#define MOUSE_RY_INPUT_SCALE 6000
#define MOUSE_TZ_INPUT_SCALE 20
int mouse_ry_input_scale = 5000;

int sensitivity_scalar[15] =
	{
	0,1,2,3,4,5,6,8,11,13,15,18,12,13,14
	};

//#define MOUSE_RY_SCALE 65535

//#define MOUSE_TZ_SCALE 65535
#define MAXMOUSETURN 7000000

#if 0
void PollMouseMove (void)
{
	union REGS inregs;
	union REGS outregs;
	short int  mousexmove,
				mouseymove;

	inregs.x.eax = MDelta;
	int386 (0x33, &inregs, &outregs);

	mousexmove = outregs.w.cx;
	mouseymove = outregs.w.dx;

	if (abs(mousexmove)>abs(mouseymove))
		mouseymove/=2;
	else
		mousexmove/=2;
	MX = 0;
	MY = 0;


	if ((abs (mouseymove)) >= threshold)
		{
		MY =  MOUSE_TZ_INPUT_SCALE*mouseymove;

	// MY += FixedMul(MY,mouseadjustment*MOUSE_TZ_SENSITIVITY_SCALE);
		if (abs(mouseymove)>200)
			{
			buttonpoll[bt_run]=true;
			}
		}

	if ((abs (mousexmove)) >= threshold)
		{
		//MX = -MOUSE_RY_INPUT_SCALE*mousexmove;
		MX = -mouse_ry_input_scale*mousexmove;
		MX += FixedMul(MX,sensitivity_scalar[mouseadjustment]*MOUSE_RY_SENSITIVITY_SCALE);
	//	if (abs(MX) > MAXMOUSETURN)
	//	MX = MAXMOUSETURN*SGN(MX);
		if (abs(mouseymove)>10)
			{
			buttonpoll[bt_run]=true;
			}
		}

//	if (MY > 0)
//		MX -= (MX/2);

}
#endif


//******************************************************************************
//
// PollJoystickMove
//
//******************************************************************************

#if 0
void PollJoystickMove (void)
{
	int	joyx,joyy;

	INL_GetJoyDelta (joystickport, &joyx, &joyy);
	if ( joypadenabled )
		{
		if (joyx >= threshold)
			{
			buttonpoll[ di_east ] = true;
			}
		if (-joyx >= threshold)
			{
			buttonpoll[ di_west ] = true;
			}
		if ( joyy >= threshold )
			{
			buttonpoll[ di_south ] = true;
			}
		if ( -joyy >= threshold )
			{
			buttonpoll[ di_north ] = true;
			}
		}
	else
		{
		if ((abs (joyx)) >= threshold)
			{
			JX = ((-joyx)<<13)+((-joyx)<<11);
			turnheldtime += tics;
			}
		else
			JX = 0;

		if ((abs (joyy)) >= threshold)
			{
			JY = joyy<<4;
			}
		else
			JY = 0;
		if (buttonpoll[bt_run])
			{
			JX <<= 1;
			JY <<= 1;
			}
		}
	}
#endif

//******************************************************************************
//
// StartVRFeedback
//
//******************************************************************************

#if 0
void StartVRFeedback (int guntype)
{
	union REGS inregs;
	union REGS outregs;

	inregs.x.eax = VR_FEEDBACK_SERVICE;
	inregs.x.ebx = 1;
	inregs.x.ecx = guntype;
	int386 (0x33, &inregs, &outregs);
}
#endif

//******************************************************************************
//
// StopVRFeedback
//
//******************************************************************************

#if 0
void StopVRFeedback (void)
{
	union REGS inregs;
	union REGS outregs;

	inregs.x.eax = VR_FEEDBACK_SERVICE;
	inregs.x.ebx = 0;
	int386 (0x33, &inregs, &outregs);
}
#endif

//******************************************************************************
//
// PollVirtualReality
//
//******************************************************************************

#define VR_BUTTON(x) ((vr_buttons>>x) & 1)

#if 0
void PollVirtualReality (void)
{
	union REGS inregs;
	union REGS outregs;
	short int  mousexmove,
				mouseymove;
	word vr_buttons;

	inregs.x.eax = VR_INPUT_SERVICE;

	inregs.x.ebx = player->angle;
	inregs.x.ecx = player->yzangle;

	int386 (0x33, &inregs, &outregs);

	vr_buttons = outregs.w.bx;

	buttonpoll[bt_run			] |= VR_BUTTON(VR_RUNBUTTON			);
	buttonpoll[bt_strafeleft	] |= VR_BUTTON(VR_STRAFELEFTBUTTON	);
	buttonpoll[bt_straferight  ] |= VR_BUTTON(VR_STRAFERIGHTBUTTON  );
	buttonpoll[bt_attack		] |= VR_BUTTON(VR_ATTACKBUTTON		);
	buttonpoll[bt_lookup		] |= VR_BUTTON(VR_LOOKUPBUTTON		);
	buttonpoll[bt_lookdown	] |= VR_BUTTON(VR_LOOKDOWNBUTTON	);
	buttonpoll[bt_swapweapon	] |= VR_BUTTON(VR_SWAPWEAPONBUTTON	);
	buttonpoll[bt_use			] |= VR_BUTTON(VR_USEBUTTON			);
	buttonpoll[bt_horizonup	] |= VR_BUTTON(VR_HORIZONUPBUTTON	);
	buttonpoll[bt_horizondown  ] |= VR_BUTTON(VR_HORIZONDOWNBUTTON  );
	buttonpoll[bt_map			] |= VR_BUTTON(VR_MAPBUTTON			);
	buttonpoll[bt_pistol		] |= VR_BUTTON(VR_PISTOLBUTTON		);
	buttonpoll[bt_dualpistol	] |= VR_BUTTON(VR_DUALPISTOLBUTTON	);
	buttonpoll[bt_mp40			] |= VR_BUTTON(VR_MP40BUTTON			);
	buttonpoll[bt_missileweapon] |= VR_BUTTON(VR_MISSILEWEAPONBUTTON);
	buttonpoll[bt_recordsound  ] |= VR_BUTTON(VR_RECORDBUTTON		);

	mousexmove = outregs.w.cx;
	mouseymove = outregs.w.dx;

	VX = 0;
	VY = 0;


	if ((abs (mouseymove)) >= threshold)
		{
		VY =  MOUSE_TZ_INPUT_SCALE*mouseymove;
		if (abs(mouseymove)>200)
			{
			buttonpoll[bt_run]=true;
			}
		}

	if ((abs (mousexmove)) >= threshold)
		{
		VX = -mouse_ry_input_scale*mousexmove;
		VX += FixedMul(MX,sensitivity_scalar[mouseadjustment]*MOUSE_RY_SENSITIVITY_SCALE);
		if (abs(mousexmove)>10)
			{
			buttonpoll[bt_run]=true;
			}
		}
}
#endif

int scaleamt[16] = {0x10000,  0x10000,  0x10000,  0x20000,  0x12000,
						0x14000,  0x14000, 0x16000, 0x16000, 0x18000,
						0x18000, 0x18000, 0x18000};


//******************************************************************************
//
// PollMove ()
//
//******************************************************************************

boolean aimbuttonpressed=false;
void PollMove (void)
{
	int angle;
	int x, y;


	x = KX + MX + JX + CX + VX;
	y = KY + MY + JY + CY + VY;

	if (buttonpoll[bt_aimbutton])
		{
		if (y>0)
			{
			buttonpoll[bt_horizonup]=1;
			y=0;
			aimbuttonpressed=true;
			}
		else if (y<0)
			{
			buttonpoll[bt_horizondown]=1;
			y=0;
			aimbuttonpressed=true;
			}
		else if (aimbuttonpressed==false)
			{
			buttonpoll[bt_lookup]=1;
			buttonpoll[bt_lookdown]=1;
			}
		}
	else
		{
		aimbuttonpressed=false;
		}

	if (player->flags & FL_FLEET)
		y += y>>1;

	if ((locplayerstate->NETCAPTURED == 1) && (!locplayerstate->HASKNIFE))
	{
		if (first)
		{
			nettics = ticcount + (VBLCOUNTER * 4);
			first = 0;
		}

		if (x > 0)
			{
			rightmom += NETMOM;
			if (lastmom!=0)
				controlbuf[2]=x<<1;
			lastmom=0;
			}
		else
			if (x < 0)
				{
				leftmom += NETMOM;
				if (lastmom!=1)
					controlbuf[2]=x<<1;
				lastmom=1;
				}
			else
			{
				rightmom -= (NETMOM >> 2);
				if (rightmom < 0)
					rightmom = 0;
				leftmom  -= (NETMOM >> 2);
				if (leftmom < 0)
					leftmom = 0;
			}

		if ((ticcount > nettics) && (rightmom > (NETMOM * 2)) &&
											(leftmom > (NETMOM * 2)))
		{
			rightmom = 0;
			leftmom  = 0;
			first	= 1;
			lastmom^=1;
			locplayerstate->NETCAPTURED = 0;
			MISCVARS->NET_IN_FLIGHT = false;
			NewState(player, &s_player);
			locplayerstate->weaponuptics = WEAPONS[locplayerstate->weapon].screenheight/GMOVE;
			locplayerstate->weaponheight = locplayerstate->weaponuptics*GMOVE ;
		}
	}
	else if ((buttonpoll[bt_strafe]) && (turnaround==0))
	{
		// strafing
		if (x < 0)
			{
			angle = (player->angle - FINEANGLES/4)&(FINEANGLES-1);

			x = (x>>10) + (x >> 11);

			controlbuf[0] = -(FixedMul (x, costable[angle]));
			controlbuf[1] = FixedMul (x, sintable[angle]);
			}
		else if (x > 0)
			{
			angle = (player->angle + FINEANGLES/4)&(FINEANGLES-1);

			x = (x>>10) + (x >> 11);

			controlbuf[0] = FixedMul (x, costable[angle]);
			controlbuf[1] = -(FixedMul (x, sintable[angle]));
			}
		if (y != 0)
			{
			controlbuf[0] += -(FixedMul (y, viewcos));
			controlbuf[1] += (FixedMul (y, viewsin));
			}
	}
	else
	{
		if (y != 0)
			{
			controlbuf[0] = -FixedMul (y, viewcos);
			controlbuf[1] = FixedMul (y, viewsin);
			}

		if (x != 0)
			controlbuf[2] = x;
	}

	if (buttonpoll[bt_strafeleft])
		{
		angle = (player->angle - FINEANGLES/4)&(FINEANGLES-1);
		controlbuf[0] += -(FixedMul (STRAFEAMOUNT, costable[angle]));
		controlbuf[1] +=	FixedMul (STRAFEAMOUNT, sintable[angle]);
		}
	else if (buttonpoll[bt_straferight])
		{
		angle = (player->angle + FINEANGLES/4)&(FINEANGLES-1);
		controlbuf[0] += -(FixedMul (STRAFEAMOUNT, costable[angle]));
		controlbuf[1] +=	FixedMul (STRAFEAMOUNT, sintable[angle]);
		}
}


//******************************************************************************
//
// PollCyberman ()
//
//******************************************************************************

#if 0
void PollCyberman (void)
{
	int i;
	int mask;
	int press;

	SWIFT_Get3DStatus (&SWIFTStatus);

	mask = 4;
	for( i = 0; i < 3; i++, mask >>= 1 )
		{
		press = SWIFTStatus.buttons & mask;

		if ( press )
			{
//			if ( ( buttonmouse[ i ] != bt_nobutton ) &&
//				( DoubleClickCount[ i ] != 2 ) )
			if ( buttonmouse[ i ] != bt_nobutton )
				{
				buttonpoll[ buttonmouse[ i ] ] = true;
				}
			}

		// Check double-click
		if ( buttonmouse[ i + 3 ] != bt_nobutton )
			{
			if ( press )
				{
				// Was the button pressed last tic?
				if ( !DoubleClickPressed[ i ] )
					{
					// Yes, take note of it
					DoubleClickPressed[ i ] = true;

					// Is this the first click, or a really late click?
					if ( ( DoubleClickCount[ i ] == 0 ) ||
						( ticcount >= DoubleClickTimer[ i ] ) )
						{
						// Yes, now wait for a second click
						DoubleClickTimer[ i ] = ticcount + DoubleClickSpeed;

							//( tics << 5 );
						DoubleClickCount[ i ] = 1;
						}
					else
						{
						// Second click
						buttonpoll[ buttonmouse[ i + 3 ] ] = true;
						DoubleClickTimer[ i ] = 0;
						DoubleClickCount[ i ] = 2;
						}
					}
				else
					{
					// After second click, button remains pressed
					// until user releases it
					if ( DoubleClickCount[ i ] == 2 )
						{
						buttonpoll[ buttonmouse[ i + 3 ] ] = true;
						}
					}
				}
			else
				{
				if ( DoubleClickCount[ i ] == 2 )
					{
					DoubleClickCount[ i ] = 0;
					}
				DoubleClickPressed[ i ] = false;
				}
			}
		}

	if (SWIFTStatus.pitch > 0)
	CYBERLOOKUP = true;
	else if (SWIFTStatus.pitch < 0)
	CYBERLOOKDOWN = true;

	if ((abs (SWIFTStatus.x)) > CYBERDEADRANGE)
	{
		CX = -(SGN (SWIFTStatus.x) * (( (abs(SWIFTStatus.x)-CYBERDEADRANGE) ) << 10));
		turnheldtime += tics;
	}
	else
		if (SWIFTStatus.x != oldcyberx)
		{
			turnheldtime += tics;
			if (SWIFTStatus.x > oldcyberx)
				CX = -(0xB8000);
			else
				CX = 0xB8000;

			oldcyberx = SWIFTStatus.x;
		}
		else
			CX = 0;

	if ((abs (SWIFTStatus.y)) > CYBERDEADRANGE)
	{
		CY = SWIFTStatus.y >> 2;
	}
	else
		CY = 0;
}
#endif

//******************************************************************************
//
// PollAssassin ()
//
//******************************************************************************

#if 0

#define MAXRAMPS 5
typedef struct
	{
	int  min;
	int  factor;
	} RampType;
void PollAssassin (void)
{
	int i;
	int mask;
	int press;
	int yaw;
	int strafeAngle;
	int acc;
	int numramps=4;
	RampType ramp[MAXRAMPS]={
										{0,280000},
										{4,380000},
										{10,480000},
										{25,680000},
//										{25,( (1<<26)/80  )}
									};

	SWIFT_Get3DStatus (&SWIFTStatus);

	mask = 4;
	for( i = 0; i < 3; i++, mask >>= 1 )
		{
		press = SWIFTStatus.buttons & mask;

		if ( press )
			{
//			if ( ( buttonmouse[ i ] != bt_nobutton ) &&
//				( DoubleClickCount[ i ] != 2 ) )
			if ( buttonmouse[ i ] != bt_nobutton )
				{
				buttonpoll[ buttonmouse[ i ] ] = true;
				}
			}

		// Check double-click
		if ( buttonmouse[ i + 3 ] != bt_nobutton )
			{
			if ( press )
				{
				// Was the button pressed last tic?
				if ( !DoubleClickPressed[ i ] )
					{
					// Yes, take note of it
					DoubleClickPressed[ i ] = true;

					// Is this the first click, or a really late click?
					if ( ( DoubleClickCount[ i ] == 0 ) ||
						( ticcount >= DoubleClickTimer[ i ] ) )
						{
						// Yes, now wait for a second click
						DoubleClickTimer[ i ] = ticcount + DoubleClickSpeed;

							//( tics << 5 );
						DoubleClickCount[ i ] = 1;
						}
					else
						{
						// Second click
						buttonpoll[ buttonmouse[ i + 3 ] ] = true;
						DoubleClickTimer[ i ] = 0;
						DoubleClickCount[ i ] = 2;
						}
					}
				else
					{
					// After second click, button remains pressed
					// until user releases it
					if ( DoubleClickCount[ i ] == 2 )
						{
						buttonpoll[ buttonmouse[ i + 3 ] ] = true;
						}
					}
				}
			else
				{
				if ( DoubleClickCount[ i ] == 2 )
					{
					DoubleClickCount[ i ] = 0;
					}
				DoubleClickPressed[ i ] = false;
				}
			}
		}

	buttonpoll[bt_horizonup] |=	((SWIFTStatus.buttons>>7) & 1);
	buttonpoll[bt_horizondown] |= ((SWIFTStatus.buttons>>8) & 1);

	if ( abs(SWIFTStatus.pitch) < (20<<6) )
		{
		SWIFTStatus.pitch = 0;
		}
	else
		{
		SWIFTStatus.pitch -= SGN(SWIFTStatus.pitch)*(20<<6);
		}

	if ( abs(SWIFTStatus.pitch) > (60<<6) )
		{
		buttonpoll[bt_run] = 1;
		}

	if ( abs(SWIFTStatus.roll) > (80<<6) )
		{
		buttonpoll[bt_run] = 1;
		}


	if ( abs(SWIFTStatus.roll) < (20<<6) )
		{
		SWIFTStatus.roll = 0;
		}
	else
		{
		SWIFTStatus.roll -= SGN(SWIFTStatus.roll)*(20<<6);
		}

	strafeAngle = (player->angle - FINEANGLES/4)&(FINEANGLES-1);

	controlbuf[0] += -(FixedMulShift (SWIFTStatus.pitch, viewcos,16))+
						FixedMulShift (-SWIFTStatus.roll, costable[strafeAngle], 16);

	controlbuf[1] +=  FixedMulShift (SWIFTStatus.pitch, viewsin,16) -
						FixedMulShift (-SWIFTStatus.roll, sintable[strafeAngle], 16);

	yaw = abs(SWIFTStatus.yaw);
	acc = 0;
	for (i=0;i<numramps;i++)
		{
		if (yaw > ramp[i].min)
			{
			if (i>0)
				{
				acc += ramp[i].min*(ramp[i].factor-ramp[i-1].factor);
				}
			}
		else
			{
			i++;
			break;
			}
		}
	controlbuf[2]= SWIFTStatus.yaw * ramp[i-1].factor - acc;
}

#endif

//******************************************************************************
//
// PollControls
//
// Gets user or demo input, call once each frame
//
// controlx	set between -100 and 100 per tic
// controly
//
//******************************************************************************


void PollControls (void)
{
	int	i;

	if (standalone==true)
		return;

	lastpolltime=controlupdatetime;

	memset (buttonpoll, 0, sizeof(buttonpoll));

	controlbuf[0] = controlbuf[1] = controlbuf[2] = 0;
	CYBERLOOKUP = CYBERLOOKDOWN = false;

	if (gamestate.autorun==1)
		buttonpoll[bt_run] = true;


//
// get button states
//
	PollKeyboardButtons ();

//	if (mouseenabled && !cybermanenabled)
	if (mouseenabled)
		PollMouseButtons ();

	if (joystickenabled)
		PollJoystickButtons ();


//
// get movements
//
	if (joystickenabled)
		PollJoystickMove ();

//	if (cybermanenabled)
//		PollCyberman ();

	else if (mouseenabled && MousePresent)
		PollMouseMove ();

	PollKeyboardMove ();

//	if (vrenabled)
//		PollVirtualReality ();

	PollMove ();

//	if (spaceballenabled)
//		PollSpaceBall ();

//	else if (assassinenabled)
//		PollAssassin ();


	buttonbits = 0;
	if (player->flags & FL_DYING) // Player has died
		{
		if ((playerdead==true) &&
			( buttonpoll[ bt_strafe ] ||
				buttonpoll[ bt_attack ] ||
				buttonpoll[ bt_use ] ||
				((gamestate.battlemode == battle_Hunter) &&
				(BATTLE_Team[player->dirchoosetime] == BATTLE_It)
				)
			)
			)
			{
			AddRespawnCommand();
			}
		memset (buttonpoll, 0, sizeof(buttonpoll));
		controlbuf[0] = controlbuf[1] = controlbuf[2] = 0;
		}

	if ((PausePressed==true) && (modemgame==false))
		{
		PausePressed=false;
		if (GamePaused==true)
			AddPauseStateCommand(COM_UNPAUSE);
		else
			{
			AddPauseStateCommand(COM_PAUSE);
			}
		}
	if (Keyboard[sc_Insert] && Keyboard[sc_X])
		AddExitCommand();

	for (i = (NUMTXBUTTONS-1); i >= 0; i--)
		{
		buttonbits <<= 1;
		if (buttonpoll[i])
			buttonbits |= 1;
		}

	UpdateClientControls();
}


void ResetWeapons(objtype *ob)
{playertype *pstate;

	M_LINKSTATE(ob,pstate);

	pstate->weapondowntics = WEAPONS[pstate->weapon].screenheight/GMOVE;
	pstate->new_weapon = pstate->oldweapon;
	pstate->missileweapon = pstate->oldmissileweapon;
	ob->shapeoffset = pstate->oldshapeoffset;
	pstate->attackframe = pstate->weaponframe = 0;

	if ((ob==player) && SHOW_BOTTOM_STATUS_BAR() )
	DrawBarAmmo (false);
}


void SaveWeapons(objtype*ob)
{playertype *pstate;

	if ((ob->flags&FL_DOGMODE) || (ob->flags&FL_GODMODE))
	return;

	//pstate = (ob==player)?(&playerstate):(&remoteplayerstate);
	M_LINKSTATE(ob,pstate);

	pstate->weapondowntics = WEAPONS[pstate->weapon].screenheight/GMOVE;
	pstate->oldweapon = pstate->new_weapon;
	pstate->oldmissileweapon = pstate->missileweapon;
	pstate->oldshapeoffset = ob->shapeoffset;

}

/*
void SaveWeapons(objtype*ob)
{playertype *pstate;

	if ((ob->flags&FL_DOGMODE) || (ob->flags&FL_GODMODE))
	return;

	//pstate = (ob==player)?(&playerstate):(&remoteplayerstate);
	M_LINKSTATE(ob,pstate);

	pstate->weapondowntics = WEAPONS[pstate->weapon].screenheight/GMOVE;
	pstate->oldweapon = pstate->weapon;
	pstate->oldmissileweapon = pstate->missileweapon;
	pstate->oldshapeoffset = ob->shapeoffset;

}
*/


#define GiveProtection(flag,time,sound)						\
	{																	\
	if ((ob->flags & flag) || (ob->flags & FL_GODMODE) || \
		(ob->flags & FL_DOGMODE))								\
		return;														\
	ob->flags &= ~(FL_BPV|FL_GASMASK|FL_AV);				\
	ob->flags |= flag;												\
	SD_PlaySoundRTP(sound,ob->x, ob->y);						\
	pstate->protectiontime = time;								\
	gamestate.supercount ++;										\
	}


boolean GivePowerup(objtype *ob,int flag,int time,int sound)
	{
	playertype *pstate;


	if ((ob->flags & flag) ||
		(ob->flags & FL_GODMODE) ||
		(ob->flags & FL_DOGMODE)
		)
		return false;


	M_LINKSTATE(ob,pstate);

	/*
	if (ob->flags & FL_DOGMODE)
		{
		ob->temp2 = DOGMODERISE;
		ResetWeapons(ob);
		if (ob->state->condition & SF_DOGSTATE)
			NewState(ob,&s_player);
		}
	else if (ob->flags & FL_GODMODE)
		{
		ob->temp2 = GODMODEFALL;
		ResetWeapons(ob);
		}
	*/
	ob->flags &= ~(FL_SHROOMS|FL_FLEET|FL_ELASTO|FL_GODMODE|FL_DOGMODE);
	ob->flags |= flag;
	pstate->poweruptime = time;
	pstate->soundtime = 0;
	SD_PlaySoundRTP(sound,ob->x, ob->y);
	gamestate.supercount ++;
	return true;

	}


void GiveLifePoints(objtype *ob,int points)
	{
	SD_PlaySoundRTP(SD_GETBONUSSND,ob->x, ob->y);

	UpdateTriads (ob,points);
	if (ob==player)
		DrawTriads (false);

	}


boolean GiveBulletWeapon(objtype *ob,int bulletweapon,statobj_t*check)
	{
	playertype *pstate;

	M_LINKSTATE(ob,pstate);

	if ((ob->flags & FL_DOGMODE) || (ob->flags & FL_GODMODE))
		return false;

	if (!ARMED(ob->dirchoosetime))
		return false;

	if (pstate->HASBULLETWEAPON[bulletweapon])
		return false;

	GiveWeapon(ob,bulletweapon);
	if ( gamestate.BattleOptions.WeaponPersistence )
		{
		LASTSTAT->z = check->z;
		}
	SD_PlaySoundRTP(SD_GETWEAPONSND,ob->x, ob->y);
	return true;

	}


boolean GivePlayerMissileWeapon(objtype *ob, playertype *pstate,
										statobj_t *check)
	{
	if  ((ob->flags & FL_DOGMODE) || (ob->flags & FL_GODMODE))
		return false;


	if (!ARMED(ob->dirchoosetime))
		return false;

	if ((GetWeaponForItem(check->itemnumber) == pstate->missileweapon) &&
		(check->ammo == stats[check->itemnumber].ammo) &&
		(pstate->ammo == stats[check->itemnumber].ammo)
		)
		return false;

	SD_PlaySoundRTP(SD_GETWEAPONSND,ob->x, ob->y);
	GiveMissileWeapon(ob,GetWeaponForItem(check->itemnumber));
	if (gamestate.BattleOptions.WeaponPersistence)
			LASTSTAT->z = check->z;

	gamestate.missilecount ++;

	if (BATTLEMODE && (gamestate.BattleOptions.Ammo != bo_normal_shots))
		{if (gamestate.BattleOptions.Ammo == bo_one_shot)
			pstate->ammo = 1;
		else
			pstate->ammo = -1;
		}
	else
		pstate->ammo = check->ammo;
	if ((ob==player) && SHOW_BOTTOM_STATUS_BAR() )
		DrawBarAmmo (false);

	return true;

	}


#define LocalBonusMessage(string)  \
	{										\
	if (ob == player)					\
	AddMessage(string,MSG_BONUS); \
	}
#define LocalBonus1Message(string)  \
	{										\
	if (ob == player)					\
	AddMessage(string,MSG_BONUS1); \
	}


/*
=================================
=
=	GetBonusTimeForItem
=
=================================
*/

int GetBonusTimeForItem(int itemnumber)
	{
	specials *which;

	if ( BATTLEMODE )
		{
		which = &gamestate.SpecialsTimes;
		}
	else
		{
		which = &CurrentSpecialsTimes;
		}

	switch(itemnumber)
		{
		case stat_godmode:
			return which->GodModeTime;

		case stat_dogmode:
			return which->DogModeTime;

		case stat_mushroom:
			return which->ShroomsModeTime;

		case stat_elastic:
			return which->ElastoModeTime;

		case stat_asbesto:
			return which->AsbestosVestTime;

		case stat_bulletproof:
			return which->BulletProofVestTime;

		case stat_gasmask:
			return which->GasMaskTime;

		case stat_fleetfeet:
			return which->MercuryModeTime;
		}

	return -1;

	}


/*
=================================
=
=	GetRespawnTimeForItem
=
=================================
*/


int GetRespawnTimeForItem(int itemnumber)
	{
	switch(itemnumber)
		{
		case stat_godmode:
			return gamestate.SpecialsTimes.GodModeRespawnTime;

		case stat_dogmode:
			return gamestate.SpecialsTimes.DogModeRespawnTime;

		case stat_mushroom:
			return gamestate.SpecialsTimes.ShroomsModeRespawnTime;

		case stat_elastic:
			return gamestate.SpecialsTimes.ElastoModeRespawnTime;

		case stat_asbesto:
			return gamestate.SpecialsTimes.AsbestosVestRespawnTime;

		case stat_bulletproof:
			return gamestate.SpecialsTimes.BulletProofVestRespawnTime;

		case stat_gasmask:
			return gamestate.SpecialsTimes.GasMaskRespawnTime;

		case stat_fleetfeet:
			return gamestate.SpecialsTimes.MercuryModeRespawnTime;

		}

	return gamestate.BattleOptions.RespawnTime * VBLCOUNTER;


	}


/*
===================
=
= GetBonus
=
===================
*/
void GetBonus (objtype*ob,statobj_t *check)
{
	int heal;
	playertype * pstate;
	boolean randompowerup;

	M_LINKSTATE(ob,pstate);

	randompowerup=false;

randomlabel:
	switch (check->itemnumber)
	{

	case	stat_knifestatue:
		SD_PlaySoundRTP(SD_GETKNIFESND,ob->x, ob->y);
		if (ob==player)
			locplayerstate->HASKNIFE = 1;
		SD_PlaySoundRTP(PlayerSnds[locplayerstate->player], ob->x, ob->y);
		LocalBonusMessage("You found a knife.");
		break;
	case	stat_pedgoldkey:
		LocalBonusMessage("You found the \\EGold key.");
		goto keys;
	case	stat_pedsilverkey:
		LocalBonusMessage("You got the \\FSilver key.");
		goto keys;
	case	stat_pedironkey:
		LocalBonusMessage("You got the \\8Iron key.");
		goto keys;
	case	stat_pedcrystalkey:
		LocalBonusMessage("You got the \\4Oscuro key.");
keys:
		GiveKey (check->itemnumber - stat_pedgoldkey);
		SD_PlaySoundRTP (SD_GETKEYSND,ob->x, ob->y);
		break;
	case	stat_monkmeal:
		if (pstate->health == MaxHitpointsForCharacter(pstate))
			return;
		SD_PlaySoundRTP (SD_GETHEALTH1SND,ob->x, ob->y);
		LocalBonusMessage("You ate some Monk Meal.");
		HealPlayer (10,ob);
		gamestate.healthcount ++;
		break;
	case	stat_monkcrystal1:
		if (pstate->health == MaxHitpointsForCharacter(pstate))
			return;
		SD_PlaySoundRTP (SD_GETHEALTH2SND,ob->x, ob->y);
		LocalBonusMessage("You picked up a small Monk Crystal.");

		HealPlayer (10,ob);
		gamestate.healthcount ++;
		break;
	case	stat_monkcrystal2:
		if (pstate->health == MaxHitpointsForCharacter(pstate))
			return;
		SD_PlaySoundRTP (SD_GETHEALTH2SND,ob->x, ob->y);
		LocalBonusMessage("You picked up a large Monk Crystal.");

		HealPlayer (50,ob);
		gamestate.healthcount ++;
		break;
	case	stat_priestporridge:
		if (pstate->health == MaxHitpointsForCharacter(pstate))
			return;
		SD_PlaySoundRTP (SD_GETHEALTH1SND,ob->x, ob->y);
		if (check->flags & FL_ACTIVE)
			{
			HealPlayer (50,ob);
			LocalBonusMessage("You ate some Priest Porridge Hot.");
			}
		else
			{
			HealPlayer (20,ob);

			LocalBonusMessage("You ate some Priest Porridge.");
			}
		gamestate.healthcount ++;
		break;

	case	stat_healingbasin:
		if (pstate->health == MaxHitpointsForCharacter(pstate))
			return;
		SD_PlaySoundRTP (SD_GETHEALTH2SND,ob->x, ob->y);
		heal = 25 + (GameRandomNumber("GetBonus",0) >> 2);
		HealPlayer (heal,ob);
		LocalBonusMessage("You drank from the healing basin.");

		gamestate.healthcount ++;
		gamestate.democraticcount ++;
		break;

	case stat_oneup:
		if (abs(pstate->health - MaxHitpointsForCharacter(pstate))
			< (MaxHitpointsForCharacter(pstate)>>2) )
			{
			GiveLives(1);
			LocalBonusMessage("Extra Life!");
			}
		else
			{
			HealPlayer(MaxHitpointsForCharacter(pstate),ob);
			LocalBonusMessage("Full Health!");
			}
		SD_PlaySoundRTP(SD_GET1UPSND,ob->x, ob->y);
		break;
	case stat_threeup:
		if (abs(pstate->health - MaxHitpointsForCharacter(pstate))
			< (MaxHitpointsForCharacter(pstate)>>2) )
			{
			GiveLives(3);
			LocalBonusMessage("Three Extra Lives!");

			}
		else
			{
			HealPlayer(MaxHitpointsForCharacter(pstate),ob);
			GiveLives(2);
			LocalBonusMessage("Full Health AND Two Extra Lives!");

			}
		SD_PlaySoundRTP(SD_GET3UPSND,ob->x, ob->y);
		break;

	case stat_scotthead:
		// Give Apogee's phone number as points
		GivePoints( 2764331 );
		LocalBonusMessage( "Whoa...Scott's Mystical Head!");
		LocalBonus1Message( "You get 2,764,331 points!");
		SD_PlaySoundRTP(SD_GETHEADSND,ob->x, ob->y);
		break;

	case stat_twopistol:
		if (GiveBulletWeapon(ob,wp_twopistol,check)==false)
			return;
		LocalBonusMessage("You got an extra pistol.");

		break;
	case stat_mp40:
		if (GiveBulletWeapon(ob,wp_mp40,check)==false)
			return;
		LocalBonusMessage("You picked up an MP40.");

		break;

	case stat_bazooka:
		if (GivePlayerMissileWeapon(ob,pstate,check)==false)
			return;

		LocalBonusMessage("You bagged a bazooka!");
		break;

	case stat_firebomb:
		if (GivePlayerMissileWeapon(ob,pstate,check)==false)
			return;

		LocalBonusMessage("You found a Firebomb!");
		break;


	case stat_heatseeker:
		if (GivePlayerMissileWeapon(ob,pstate,check)==false)
			return;

		LocalBonusMessage("You have a Heat-seeker!");
		break;


	case stat_drunkmissile:
		if (GivePlayerMissileWeapon(ob,pstate,check)==false)
			return;

		LocalBonusMessage("You recovered a Drunk Missile!");
		break;

	case stat_firewall:
		if (GivePlayerMissileWeapon(ob,pstate,check)==false)
			return;

		LocalBonusMessage("You filched a FlameWall!");
		break;

	case stat_splitmissile:
		if (GivePlayerMissileWeapon(ob,pstate,check)==false)
			return;

		LocalBonusMessage("You snagged a Split Missile!");
		break;

	case stat_kes:
		if (GivePlayerMissileWeapon(ob,pstate,check)==false)
			return;

		LocalBonusMessage("You wield the Dark Staff!");
		break;

	case stat_bat:
		if (GivePlayerMissileWeapon(ob,pstate,check)==false)
			return;

		LocalBonusMessage("You picked up the Excalibat.");
		break;


	case stat_lifeitem1:
		GiveLifePoints(ob,1);
		if (timelimitenabled)
			timelimit+=(VBLCOUNTER);

		break;

	case stat_lifeitem2:
		GiveLifePoints(ob,5);
		if (timelimitenabled)
			timelimit+=(2*VBLCOUNTER);
		break;

	case stat_lifeitem3:
		GiveLifePoints(ob,10);
		if (timelimitenabled)
			timelimit+=(5*VBLCOUNTER);
		break;

	case stat_lifeitem4:
		GiveLifePoints(ob,25);
		if (timelimitenabled)
			timelimit+=(10*VBLCOUNTER);
		break;

	case stat_random:
		switch (GameRandomNumber("GetBonus",0)>>6)
			{
			case 0:
				check->itemnumber=stat_godmode;
				break;
			case 1:
				check->itemnumber=stat_elastic;
				break;
			case 2:
				check->itemnumber=stat_dogmode;
				break;
			case 3:
				check->itemnumber=stat_mushroom;
				break;
			}
		randompowerup=true;
		LocalBonus1Message("Random powerup gives you . . .");
		goto randomlabel;
		break;

	case stat_bulletproof:
		GiveProtection(FL_BPV, GetBonusTimeForItem(stat_bulletproof),
			SD_GETBVESTSND);
		LocalBonusMessage("Bulletproof Armor!");

		goto drw;

	case stat_gasmask:
		GiveProtection(FL_GASMASK, GetBonusTimeForItem(stat_gasmask),
							SD_GETMASKSND);
		LocalBonusMessage("You put on a Gas Mask.");

		goto drw;

	case stat_asbesto:
		GiveProtection(FL_AV,GetBonusTimeForItem(stat_asbesto),
							SD_GETAVESTSND);
		LocalBonusMessage("Asbestos Armor! Oh so itchy!");

		goto drw;

	case stat_elastic:
		if (GivePowerup(ob,FL_ELASTO,GetBonusTimeForItem(stat_elastic),
						SD_GETELASTSND) == false)
			return;
		LocalBonusMessage("Elasto Mode!");

		ob->flags |= FL_NOFRICTION;
		goto drw;

	case stat_fleetfeet:
		if (GivePowerup(ob,FL_FLEET,GetBonusTimeForItem(stat_fleetfeet),
						SD_GETFLEETSND) == false)
			return;

		LocalBonus1Message("Mercury Mode!");
		LocalBonusMessage("Press Look Up and Down to fly.");

		ob->flags &= ~FL_NOFRICTION;
		goto drw;


	case stat_mushroom:
		if (GivePowerup(ob,FL_SHROOMS,GetBonusTimeForItem(stat_mushroom),
						SD_GETSHROOMSSND) == false)
			return;
		LocalBonusMessage("Shrooms Mode!");

		ob->flags &= ~FL_NOFRICTION;
		gamestate.democraticcount ++;
		goto drw;


	case stat_godmode:

		if (ob->flags & FL_GODMODE)
			return;

		if (!ARMED(ob->dirchoosetime))
			return;

		ob->flags &= ~FL_NOFRICTION;

		if (ob->flags & FL_DOGMODE)
			{
			ob->temp2 = DOGMODERISE;
			ResetWeapons(ob);
			if (ob->state->condition & SF_DOGSTATE)
				NewState(ob,&s_player);
			}

		SaveWeapons(ob);
		SpawnNewObj(ob->tilex,ob->tiley,&s_flash1,inertobj);
		new->flags |= FL_ABP;
		new->x = new->drawx = ob->x;
		new->y = new->drawy = ob->y;
		MakeActive(new);
		new->z = ob->z;


		SetPlayerHorizon(pstate,GODYZANGLE);

		ob->flags &= ~(FL_GODMODE|FL_SHROOMS|FL_ELASTO|FL_FLEET|FL_DOGMODE);
		ob->flags |= FL_GODMODE;
		ob->temp2 = GODMODERISE;
		pstate->poweruptime = GetBonusTimeForItem(stat_godmode);
		pstate->soundtime = 0;
		GiveMissileWeapon(ob,wp_godhand);
		SD_PlaySoundRTP(SD_GETGODSND,ob->x, ob->y);
		gamestate.supercount ++;
		LocalBonusMessage("God Mode!");

		goto drw;


#if (SHAREWARE == 0)
	case stat_dogmode:
		if (ob->flags & FL_DOGMODE)
			return;

		if (!ARMED(ob->dirchoosetime))
			return;

		ob->flags &= ~FL_NOFRICTION;

		if (ob->flags & FL_GODMODE)
			{
			ob->temp2 = GODMODEFALL;
			ResetWeapons(ob);
			}


		SaveWeapons(ob);
		ob->shapeoffset = 0;
		NewState(ob,&s_serialdog);

		SpawnNewObj(ob->tilex,ob->tiley,&s_flash1,inertobj);
		new->flags |= FL_ABP;
		new->x = new->drawx = ob->x;
		new->y = new->drawy = ob->y;
		MakeActive(new);
		new->z = ob->z;

		SetPlayerHorizon(pstate,DOGYZANGLE);

		ob->flags &= ~(FL_DOGMODE|FL_SHROOMS|FL_ELASTO|FL_FLEET|FL_GODMODE);
		ob->flags |= FL_DOGMODE;
		ob->temp2 = DOGMODEFALL;
		pstate->poweruptime = GetBonusTimeForItem(stat_dogmode);
		pstate->soundtime = 0;
		GiveMissileWeapon(ob,wp_dog);
		SD_PlaySoundRTP(SD_GETDOGSND,ob->x, ob->y);
		gamestate.supercount ++;
		LocalBonusMessage("Dog Mode!");

		goto drw;
	#endif

	drw:

		if (ob==player)
			GM_DrawBonus (check->itemnumber);

		break;

	case stat_dipball1:
	case stat_dipball2:
	case stat_dipball3:
		SD_PlaySoundRTP(SD_GETBONUSSND,ob->x, ob->y);
		gamestate.dipballs++;
		LocalBonusMessage("You discovered a Developer Ball!");

	break;

	case stat_collector:
		if (gamestate.battlemode==battle_CaptureTheTriad)
		{if (pstate->team == check->hitpoints)
			return;
			ob->flags |= FL_DESIGNATED;
			UpdateKills = true;
			LocalBonusMessage( "You picked up a triad!  RUN!!!");
		}
		else
		BATTLE_CheckGameStatus(battle_get_collector_item,ob->dirchoosetime);

		SD_PlaySoundRTP(SD_GETBONUSSND,ob->x, ob->y);
		break;
#if (SHAREWARE == 0)
	case stat_mine:
		SpawnNewObj(check->tilex,check->tiley,&s_grexplosion1,inertobj);
		new->flags |= FL_ABP;
		new->whatever = check;
		new->temp2 = 100;
		MakeActive(new);
		SD_PlaySoundRTP(SD_EXPLODESND,check->x,check->y);
		break;
#endif
	default:
		SD_PlaySoundRTP(SD_GETHEADSND,ob->x, ob->y);
		break;
	}
	//StartBonusFlash ();
	if (check->flags & FL_CHANGES)
		{
		switch (check->itemnumber)
			{
			case stat_pedgoldkey:
			case stat_pedsilverkey:
			case stat_pedironkey:
			case stat_pedcrystalkey:
				check->itemnumber = stat_emptypedestal;
				check->shapenum = stats[stat_emptypedestal].picnum;
				check->flags = stats[stat_emptypedestal].flags|FL_ABP;
				check->count = 0;
				check->numanims = 0;
				break;
			case stat_healingbasin:
				check->itemnumber = stat_emptybasin;
				check->shapenum = stats[stat_emptybasin].picnum;
				check->flags = stats[stat_emptybasin].flags|FL_ABP;
				check->count = 0;
				check->numanims = 0;
				break;
			/*
				case stat_tablebullets:
				check->itemnumber = stat_emptytable;
				check->shapenum = stats[stat_emptytable].picnum;
				check->flags = stats[stat_emptytable].flags|FL_ABP;
				break;
			case stat_statuewithpole:
				check->itemnumber = stat_armornopole;
				check->shapenum = stats[stat_armornopole].picnum;
				check->flags = stats[stat_armornopole].flags|FL_ABP;
				break; */
			case stat_pit:
				check->shapenum ++;
				check->flags &= ~FL_CHANGES;
				check->flags &= ~FL_BONUS;
				break;
			case stat_knifestatue:
				check->itemnumber = stat_emptystatue;
				check->shapenum = stats[stat_emptystatue].picnum;
				check->flags = stats[stat_emptystatue].flags|FL_ABP;
				break;


			}
		}
	else
	{if (check == sprites[check->tilex][check->tiley])
			{
			statobj_t *checkstat;

			checkstat = (statobj_t*)DiskAt(check->tilex,check->tiley);
			if (checkstat && (checkstat->which == SPRITE))
				sprites[check->tilex][check->tiley] = checkstat;
			else
				sprites[check->tilex][check->tiley] = NULL;
			}

		if (randompowerup==true)
			check->itemnumber = stat_random;
		RemoveStatic(check);
	}
}


/*
===================
=
= DropWeapon
=
===================
*/

void DropWeapon(objtype *ob)
{playertype *pstate;
	int dtilex,dtiley;


	M_LINKSTATE(ob,pstate);

	if ((pstate->missileweapon == -1) || (pstate->missileweapon == wp_godhand)
#if (SHAREWARE == 0)
	|| (pstate->missileweapon == wp_dog)
#endif
	)
	return;

	pstate->weapondowntics = WEAPONS[pstate->weapon].screenheight/3;
	pstate->new_weapon = pstate->bulletweapon;

	dtilex = ob->tilex;
	dtiley = ob->tiley;

	FindEmptyTile(&dtilex, &dtiley);


	SpawnStatic(dtilex,dtiley,GetItemForWeapon(pstate->missileweapon),9);
	gamestate.missiletotal ++;

	LASTSTAT->ammo = pstate->ammo;
	LASTSTAT->flags |= FL_ABP;
	LASTSTAT->flags &= ~FL_RESPAWN;
	MakeStatActive(LASTSTAT);
	pstate->weaponx = ob->tilex;
	pstate->weapony = ob->tiley;
	pstate->ammo = -1;
	pstate->missileweapon = -1;
	if ((ob==player) && SHOW_BOTTOM_STATUS_BAR() )
	DrawBarAmmo (false);
}


/*
===================
=
= Thrust
=
===================
*/

void Thrust ( objtype * ob )
{statobj_t *tstat;
	int dx,dy,dz,rad,index,otherteam;
	objtype*temp;
	playertype * pstate;

	PlayerMove(ob);
	M_LINKSTATE(ob,pstate);

	if ((gamestate.battlemode == battle_CaptureTheTriad) &&
		(ob->flags & FL_DESIGNATED) &&
		(ob->tilex == TEAM[pstate->team].tilex) &&
		(ob->tiley == TEAM[pstate->team].tiley))
		{if (ob == player)
			SD_Play(PlayerSnds[locplayerstate->player]);

		if (BATTLE_CheckGameStatus(battle_captured_triad,ob->dirchoosetime)==
			battle_no_event)
			{
			ob->flags &= ~FL_DESIGNATED;
			UpdateKills = true;
			otherteam = (pstate->team ^ 1);
			SpawnStatic(TEAM[otherteam].tilex,TEAM[otherteam].tiley,stat_collector,9);
			LASTSTAT->flags |= FL_COLORED;
			LASTSTAT->hitpoints = otherteam;
			LASTSTAT->flags |= FL_ABP;
			MakeStatActive(LASTSTAT);
			}
		return;
		}

	if ((ob->tilex != pstate->weaponx) || (ob->tiley != pstate->weapony))
	pstate->weaponx = pstate->weapony = 0;

	index = touchindices[ob->tilex][ob->tiley];
	if (index && (abs(ob->z - nominalheight) < 5))
	{
//		if (!TRIGGER[index-1])
		if (!TRIGGER[index-1] && touchplate[index-1])
		{
			if (touchplate[index-1]->complete)
				SD_PlaySoundRTP(SD_BADTOUCHSND,ob->x,ob->y);
			else
			{
				SD_PlaySoundRTP(SD_TOUCHPLATESND,ob->x,ob->y);
				if (ob == player)
					AddMessage("Touchplate triggered.",MSG_GAME);
			}
		}
		TRIGGER[index-1] = 1;
	}

	tstat = sprites[ob->tilex][ob->tiley];
	if (tstat)
	{
		dx = abs(ob->x - tstat->x);
		dy = abs(ob->y - tstat->y);
		dz = abs(ob->z - tstat->z);
		if ((dx < 0x8000) && (dy < 0x8000) && (dz<=35))
		{
#define OBJECT_IS_BONUS( tstat )						( ( tstat )->flags & FL_BONUS )
#define PLAYER_IS_SWITCHING_WEAPONS( pstate )	( W_CHANGE( pstate ) )
//#define IS_ATTACKING( ob )								( ( ( ob )->state->think == T_Attack ) || ( ( ob )->state->think == T_BatBlast ) )
#define IS_WEAPON( tstat )								( ( tstat )->flags & FL_WEAPON )
#define PLAYER_MAY_NOT_GET_WEAPON( pstate, ob )	( PLAYER_IS_SWITCHING_WEAPONS( pstate ))// || IS_ATTACKING( ob ) )
#define OK_TO_PICK_UP( tstat, pstate, ob )		( !( IS_WEAPON( tstat ) && PLAYER_MAY_NOT_GET_WEAPON( pstate, ob ) ) )
#define WHERE_PLAYER_DROPPED_WEAPON( ob, pstate ) ( ( ( ob )->tilex == ( pstate )->weaponx ) && ( ( ob )->tiley == ( pstate )->weapony ) )

		if ( OBJECT_IS_BONUS( tstat ) &&
			OK_TO_PICK_UP( tstat, pstate, ob ) &&
			(!WHERE_PLAYER_DROPPED_WEAPON( ob, pstate ))
			)
			{
			GetBonus(ob,tstat);
			if (PLAYER_IS_SWITCHING_WEAPONS( pstate ))
				{statetype *nstate;
#if (SHAREWARE == 0)
				if (ob->state->condition & SF_DOGSTATE)
					nstate = &s_serialdog;
				else
#endif
					nstate = &s_player;
				pstate->attackframe = pstate->weaponframe = pstate->batblast = 0;
				NewState(ob,nstate);
				}


			}
		else if ((tstat->itemnumber == stat_pit) &&
					(ob->temp2 != PITFALL) &&
					(!(ob->flags & FL_FLEET))
					)
			{ob->temp2 = PITFALL;
			ob->momentumx = ob->momentumy = 0;
			//ob->momentumz = 4;
			ob->momentumz = GRAVITY;

			if (ob->whatever == NULL)
				{ob->whatever = tstat;
					SD_PlaySoundRTP(SD_PITTRAPSND,ob->x,ob->y);
					tstat->shapenum = stats[tstat->itemnumber].picnum + 1;
					MakeStatInactive(tstat);
			//tstat->flags &= ~FL_ABP;
				}
			}
		else if ((tstat->itemnumber == stat_heatgrate) &&
					(!(ob->flags & FL_DYING)) && (!(ob->flags & FL_AV))
					)
			{DamageThing(ob,1);
			Collision(ob,(objtype*)tstat,0,0);
			M_CheckPlayerKilled(ob);
			}


		}
	}

//================ Check special player/actor links ======================

	if (ob->whatever)
	{
		temp = (objtype*)(ob->whatever);

		dx = abs(ob->x - temp->x);
		dy = abs(ob->y - temp->y);
		dz = abs(ob->z - temp->z);
		if (ob->flags & FL_RIDING)
			rad = MINACTORDIST;
		else
			rad = 0x8000;

		if ((dx >rad) || (dy > rad) || (dz > 64))
			{
			if ((temp->obclass == bladeobj) || (temp->obclass == diskobj))
			{temp->whatever = NULL;
			ob->flags &= ~FL_RIDING;
			}

			else if (ob->temp2 == COLUMNCRUSH)
			ob->temp2 = RENORMALIZE;
			else if (ob->z < nominalheight)
			ob->momentumz = 40000;
			else if (temp->which == SPRITE)
			{tstat = (statobj_t*)(ob->whatever);
			MakeStatActive(tstat);
			SetNormalHorizon(ob);
			}
			ob->whatever = NULL;
		}
	}

//=========================================================================


	if (BATTLEMODE && (MAPSPOT(ob->tilex,ob->tiley,1) == EXITTILE))
	{
		Move_Player_From_Exit_To_Start(ob);
		return;
	}

	if (ob==player)
	{
		if (MAPSPOT(ob->tilex,ob->tiley,1) == EXITTILE)
			playstate=ex_completed;
		else if ( ( MAPSPOT( ob->tilex, ob->tiley, 2 ) & 0xff00 ) == 0xe400 )
			playstate = ex_secretdone;
		else if (MAPSPOT(ob->tilex,ob->tiley,1) == SECRETEXITTILE)
			playstate=ex_secretlevel;
	}
}


void Move_Player_From_Exit_To_Start(objtype *ob)
{
	int i = 0,oldarea,newarea;
	objtype *tplayer;
	int travelangle,dangle;
	playertype *pstate;

	M_LINKSTATE(ob,pstate);


	oldarea = ob->areanumber;
	newarea = AREANUMBER(FIRST.x,FIRST.y);
	if (oldarea != newarea)
	{
		RemoveFromArea(ob);
		ob->areanumber = newarea;
		MakeLastInArea(ob);
	}

	SetTilePosition(ob,FIRST.x,FIRST.y);
	ob->z = PlatformHeight(ob->tilex,ob->tiley);
	if ((ob->z == -10) || DiskAt(ob->tilex,ob->tiley))
		ob->z = 0;

	ConnectAreas();
	travelangle = atan2_appx(ob->momentumx,ob->momentumy);
	dangle = ob->angle - travelangle;

	ob->angle = (1-FIRST.dir)*ANG90 + dangle;
	Fix(ob->angle);

	ob->dir	= angletodir[ob->angle];
	pstate->anglefrac= (ob->angle<<ANGLEBITS);
	pstate->angle=0;


	for(i=0;i<numplayers;i++)
	{
		tplayer = PLAYER[i];

		if (ob == tplayer)
			continue;

		if (
			(tplayer->tilex == FIRST.x) &&
			(tplayer->tiley == FIRST.y) &&
			(!(tplayer->flags & FL_DYING))
			)
		{
			playertype *pstate;

			M_LINKSTATE(tplayer,pstate);

			pstate->health = tplayer->hitpoints = 0;
			tplayer->flags |= FL_HBM;
			Collision(tplayer,ob,0,0);
			BATTLE_PlayerKilledPlayer(battle_kill_by_crushing,
				ob->dirchoosetime, tplayer->dirchoosetime);
		}
	}
}

boolean		player_noclip = false;

void PlayerSlideMove(objtype * ob)
{
	int tryx, tryy, tryz;
	
	if(player_noclip)
		return;

	tryx = ob->x + ob->momentumx;
	tryy = ob->y + ob->momentumy;
	tryz = ob->z + (ob->momentumz >> 16);

	if (ActorTryMove(ob,ob->x,tryy,tryz))
	{
		if (ob->momentumx>HITWALLSPEED)
			SD_PlaySoundRTP(SD_HITWALLSND,ob->x,ob->y);
		ob->momentumx=0;
	}
	else if (ActorTryMove(ob,tryx,ob->y,tryz))
	{
		if (ob->momentumy>HITWALLSPEED)
			SD_PlaySoundRTP(SD_HITWALLSND,ob->x,ob->y);
		ob->momentumy=0;
	}
	else
	{
		if (FindDistance(ob->momentumx,ob->momentumy)>(HITWALLSPEED*3/2))
			SD_PlaySoundRTP(SD_HITWALLSND,ob->x,ob->y);
		ob->momentumx=0;
		ob->momentumy=0;
	}
}

/*
===================
=
= SetNormalHorizon
=
===================
*/

void SetNormalHorizon (objtype * ob)
{
	playertype * pstate;

	M_LINKSTATE(ob,pstate);

	if (ob->flags&FL_DOGMODE)
	{
		SetPlayerHorizon(pstate,DOGYZANGLE);
	}
	else if (ob->flags&FL_GODMODE)
	{
		SetPlayerHorizon(pstate,GODYZANGLE);
	}
	else
	{
		SetPlayerHorizon(pstate,NORMALYZANGLE);
	}
}

/*
===================
=
= PlayerTiltHead
=
===================
*/

void PlayerTiltHead (objtype * ob)
{
	playertype * pstate;
	int dyz=0;
	int yzangle;

	M_LINKSTATE(ob,pstate);

	yzangle=ob->yzangle+HORIZONYZOFFSET;
	Fix(yzangle);

	if (
		(pstate->lastmomz!=ob->momentumz) &&
		(ob->momentumz==0) &&
		(
			(!(ob->flags&FL_FLEET)) ||
			(
				(ob->flags&FL_FLEET) &&
				(ob->z==nominalheight)
			)
		)
		)
		SetNormalHorizon(ob);

	pstate->lastmomz=ob->momentumz;

	if (ob->flags&FL_SHROOMS)
	{
		ob->yzangle = FixedMulShift(SHROOMYZANGLE,
			sintable[(oldpolltime<<6)&(FINEANGLES-1)], 16);
		Fix(ob->yzangle);
		return;
	}
	else if (pstate->guntarget)
	{
		int dx,dy,dz;
		int xydist;
		int yzangle;

		dx = ob->x - pstate->guntarget->x;
		dy = ob->y - pstate->guntarget->y;
		xydist = FindDistance(dx,dy)-0x8000;
		if (ob->z==pstate->guntarget->z)
			dz = 0;
		else
		{
			dz = (ob->z-pstate->guntarget->z)<<10;
		}
		yzangle = atan2_appx(xydist,dz);

		yzangle += HORIZONYZOFFSET;
		Fix(yzangle);
		SetPlayerHorizon(pstate,yzangle-HORIZONYZOFFSET);

		if (oldpolltime>pstate->targettime)
		{
			if (pstate->guntarget)
				pstate->guntarget->flags &= ~FL_TARGET;
			pstate->guntarget=NULL;
			SetNormalHorizon(ob);
		}
	}
	else
	{
		if (pstate->buttonstate[bt_horizonup])
		{
			if (yzangle!=pstate->horizon)
			{
				SetPlayerHorizon(pstate,yzangle-HORIZONYZOFFSET);
			}
			else
			{
				SetPlayerHorizon(pstate,
					(pstate->horizon-HORIZONYZOFFSET+YZHORIZONSPEED));
			}
		}
		else if (pstate->buttonstate[bt_horizondown])
		{
			if (yzangle!=pstate->horizon)
			{
				SetPlayerHorizon(pstate,yzangle-HORIZONYZOFFSET);
			}
			else
			{
				SetPlayerHorizon(pstate,(pstate->horizon-HORIZONYZOFFSET-YZHORIZONSPEED));
			}
		}
		if (pstate->buttonstate[bt_lookup] || CYBERLOOKUP)
		{
			if (!(ob->flags & FL_FLEET))
			{
				dyz=YZTILTSPEED;
				if (pstate->buttonstate[bt_lookdown] || CYBERLOOKDOWN)
				{
					dyz=0;
				}

				SetNormalHorizon(ob);
			}
		}
		if (pstate->buttonstate[bt_lookdown] || CYBERLOOKDOWN)
		{
			if (!(ob->flags & FL_FLEET))
			{
				dyz=-YZTILTSPEED;
				if (pstate->buttonstate[bt_lookup] || CYBERLOOKUP)
				{
					dyz=0;
				}
				SetNormalHorizon(ob);
			}
		}
		if (	!(ob->flags&FL_DOGMODE) &&
				!(ob->flags&FL_GODMODE) &&
				!(ob->flags&FL_FLEET)	&&
				!(ob->flags&FL_RIDING)  &&
				(ob->momentumz > (GRAVITY<<1))//(ob->momentumz>0x1000)
				)
		{
			SetPlayerHorizon(pstate,FALLINGYZANGLE);
		}
	}


	if ((yzangle!=pstate->horizon) && (dyz==0))
	{
		int speed;

		speed=SNAPBACKSPEED;
		if (yzangle<pstate->horizon)
			yzangle+=speed;
		else
			yzangle-=speed;
		if ((abs(yzangle-pstate->horizon))<SNAPBACKSPEED)
			yzangle=pstate->horizon;
	}
	yzangle+=dyz;
	if (yzangle-HORIZONYZOFFSET>YZANGLELIMIT)
		yzangle=HORIZONYZOFFSET+YZANGLELIMIT;
	else if (yzangle-HORIZONYZOFFSET<-YZANGLELIMIT)
		yzangle=HORIZONYZOFFSET-YZANGLELIMIT;

	ob->yzangle=yzangle-HORIZONYZOFFSET;
	Fix(ob->yzangle);
}

/*
===================
=
= UpdatePlayers
=
===================
*/
void UpdatePlayers ( void )
{
	objtype * obj;
//	playertype * pstate;

	for (obj = FIRSTACTOR; obj && (obj->obclass==playerobj); obj = obj->next)
	{
		obj->speed=FindDistance(obj->momentumx, obj->momentumy);
//		M_LINKSTATE(obj,pstate);
//		pstate->steptime-=obj->speed;
//		if (pstate->steptime<0)
//		{
//			while (pstate->steptime<0)
//				pstate->steptime+=PLAYERSTEPTIME;
//			pstate->stepwhich^=1;
//			SD_PlaySoundRTP(SD_WALK1SND+pstate->stepwhich,obj->x,obj->y);
//		}
	}
}


/*
===================
=
= PlayerMove
=
===================
*/

void PlayerMove ( objtype * ob )
{
	playertype *pstate;

	M_LINKSTATE(ob,pstate);
	if (ob->flags & FL_FLEET)
		CheckFlying(ob,pstate);
	ActorMovement(ob);
	pstate->anglefrac = (pstate->anglefrac+pstate->angle)&
		((FINEANGLES<<ANGLEBITS)-1);
	ob->angle = (pstate->anglefrac >> ANGLEBITS);
	ob->dir = angletodir[ob->angle];
	if (ob==player)
		UpdateLightLevel(player->areanumber);

	PlayerTiltHead(ob);

	if (IsWindow(ob->tilex,ob->tiley))
	{
		if (!(ob->flags & FL_DYING))
		{
			pstate->health = 0;
			pstate->falling=true;
			if ((ob->flags & FL_GODMODE) || (ob->flags & FL_DOGMODE) ||
				(gamestate.battlemode == battle_Eluder) || (godmode==true))
			{
				KillActor(ob);
				NewState(ob,&s_remotedie1);
			}
			else
				Collision(ob,(objtype*)NULL,0,0);
			ob->flags |= FL_DYING;
			M_CheckPlayerKilled(ob);
		}
	}
}

/*
===============
=
= T_Tag
=
===============
*/

void  T_Tag (objtype *ob)
{
	playertype *pstate;

	CheckPlayerSpecials(ob);
	//CheckWeaponStates(ob);
	M_LINKSTATE(ob,pstate);
	Thrust(ob);

	if (ob->ticcount > 4)
		pstate->weaponheight -= GMOVE;
	else
		pstate->weaponheight += GMOVE;

	if ((ob->ticcount > 1) && (ob->ticcount < 8) && (!(ob->flags & FL_DIDTAG)))
	{
		int i,dx,dy,magangle;

		for(i=0;i<numplayers;i++)
		{
			if (PLAYER[i] == ob)
				continue;

			dx = abs(PLAYER[i]->x - ob->x);
			dy = abs(PLAYER[i]->y - ob->y);
			if ((dx > 0xc000) || (dy > 0xc000))
				continue;
			magangle = abs(ob->angle - AngleBetween(ob,PLAYER[i]));
			if (magangle > VANG180)
				magangle = ANGLES - magangle;

			if (magangle > ANGLES/8)
				continue;
			CheckTagGame(ob,PLAYER[i]);
			break;
		}
	}

//Commented out until we find if it's valid
/*
	if (!ob->ticcount)
	{if ( pstate->buttonstate[bt_use] && !pstate->buttonheld[bt_use] )
			pstate->buttonstate[bt_use] = false;
		if ( pstate->buttonstate[bt_attack] && !pstate->buttonheld[bt_attack])
			pstate->buttonstate[bt_attack] = false;
	}
*/
}

#if (SHAREWARE == 0)
#define GET_RESETSTATE(ob,resetstate)		\
	{													\
	if (ob->state->condition & SF_DOGSTATE) \
		resetstate = &s_serialdog;			\
	else												\
		resetstate = &s_player;				\
	}
#else
#define GET_RESETSTATE(ob,resetstate)		\
	{													\
	resetstate = &s_player;					\
	}
#endif

/*
===============
=
= T_Attack
=
===============
*/

void  T_Attack (objtype *ob)
{
	attack_t	*cur;

	playertype *pstate;
	statetype *resetstate;


	Thrust(ob);
	if (ob->flags & FL_DYING)
	return;

	resetstate = ob->state;
	CheckPlayerSpecials(ob);
	if (resetstate != ob->state)
	{
		return;
	}

	if ((ob->flags & FL_PAIN) && (!ob->ticcount))
	ob->flags &= ~FL_PAIN;

	CheckWeaponStates(ob);
	M_LINKSTATE(ob,pstate);
	GET_RESETSTATE(ob,resetstate);


	if (ARMED(ob->dirchoosetime)
	//(gamestate.battlemode != battle_Tag)
		)

	{
		if (pstate->weapondowntics == 1)  // change to up; during change, up and down
										// are never zero at the same time
		{
	#if (SHAREWARE == 0)
			if (pstate->weapon == wp_kes)
			{
				pstate->weapondowntics = 0;
				pstate->weaponuptics = KESTICS/(2*GMOVE);
			}
			else
	#endif
			{
				pstate->weapondowntics = 0;
				pstate->weaponframe = pstate->attackframe = 0;

				if (pstate->NETCAPTURED == -1)
				{
					pstate->weaponuptics = FREE.screenheight/GMOVE;
					pstate->weaponheight = pstate->weaponuptics*GMOVE ;
					pstate->NETCAPTURED = 1;
	//			return;
				}
				else if (pstate->NETCAPTURED == -2)
				{
					pstate->weaponuptics = WEAPONS[pstate->weapon].screenheight/GMOVE;
					pstate->weaponheight = pstate->weaponuptics*GMOVE ;
					pstate->NETCAPTURED = 0;

				//return;
				}
				else
				{
					pstate->weaponuptics = WEAPONS[pstate->new_weapon].screenheight/GMOVE;
					pstate->weapon = pstate->new_weapon;
					pstate->weaponheight = pstate->weaponuptics*GMOVE ;
				}
			}
		}
	}
	else if (gamestate.battlemode == battle_Hunter)
	{
		if (pstate->weapondowntics == 1)
		{
			pstate->weapondowntics = 0;
			pstate->weaponframe = pstate->attackframe = pstate->batblast = 0;
			pstate->weapon = pstate->new_weapon;
			NewState(ob,resetstate);
			return;
		}
	}

#if (SHAREWARE==0)
	if ((pstate->buttonstate[bt_use]) &&
		(pstate->weapon != wp_dog)
		)
#else
	if (pstate->buttonstate[bt_use])
#endif
		Cmd_Use (ob);

	if (pstate->attackframe >= WEAPONS[pstate->weapon].numattacks)
		Error("\n attackframe %d for weapon %d gt numattacks %d",
				pstate->attackframe,pstate->weapon,
				WEAPONS[pstate->weapon].numattacks
			);

	cur = &(WEAPONS[pstate->weapon].attackinfo[pstate->attackframe]);
	if (! pstate->attackcount)
	{
		switch (cur->attack)
		{
			case reset:
//				if (vrenabled && (ob==player))
//				{
//					StopVRFeedback();
//				}
				ob->flags &= ~FL_FULLLIGHT;
				if (pstate->ammo)
				{
					if (BATTLEMODE && (pstate->weapon == wp_firewall))
						break;
					if (BATTLEMODE && (pstate->weapon == wp_firebomb))
						break;
					if ((pstate->buttonstate[bt_attack]) && (pstate->weapon <= wp_firewall))
					{
						if (pstate->weapon <= wp_mp40)
							{
							if (pstate->weapon == wp_twopistol)
								pstate->attackframe -= 6;
							else if (pstate->weapon == wp_pistol)
								pstate->attackframe -= 3;
							else if (pstate->weapon == wp_mp40)
								pstate->attackframe -= 2;

							if (ob->state == &s_pmissattack2)
								NewState(ob,&s_pmissattack1);
							else if (ob->state == &s_pgunattack2)
								NewState(ob,&s_pgunattack1);

						}
					}
					else
					{
						NewState(ob,resetstate);
						pstate->attackframe = pstate->weaponframe = 0;
						pstate->batblast = 0;
						return;
					}
				}
				else
				{
					NewState(ob,resetstate);
					pstate->attackframe = pstate->weaponframe = 0;
					pstate->new_weapon = pstate->bulletweapon;
					pstate->batblast = 0;
					pstate->ammo = -1;
					pstate->missileweapon = -1;
					pstate->weapondowntics = WEAPONS[pstate->weapon].screenheight/GMOVE;

					if ((ob==player) && SHOW_BOTTOM_STATUS_BAR() )
							DrawBarAmmo (false);

					return;
				}
				break;

			case reset2:
//				if (vrenabled && (ob==player))
//				{
//					StopVRFeedback();
//				}
				ob->flags &= ~FL_FULLLIGHT;
				if (pstate->buttonstate[bt_attack] && pstate->ammo)
				{
					pstate->attackframe -= 4;
					if (ob->state == &s_pmissattack2)
						NewState(ob,&s_pmissattack1);
					else if (ob->state == &s_pgunattack2)
						NewState(ob,&s_pgunattack1);
				}
				else
				{
					NewState(ob,resetstate);
					pstate->attackframe = pstate->weaponframe = 0;
					pstate->batblast = 0;
					return;
				}
				break;

			case at_pulltrigger:
//				if (vrenabled && (ob==player))
//				{
//					StartVRFeedback(1);
//				}
				ob->flags |= FL_FULLLIGHT;

		#if (SHAREWARE == 0)

				if (pstate->batblast >= BBTIME)
					DogBlast(ob);

				else if (pstate->weapon == wp_dog)
					DogAttack(ob);
				else if (pstate->weapon == wp_bat)
					BatAttack (ob);
				else
		#endif
					GunAttack(ob);

				break;

			case at_missileweapon:
				if (!pstate->ammo)
				{
					pstate->attackframe = pstate->weaponframe = 0;
					pstate->batblast = 0;
					return;
				}

//				if (vrenabled && (ob==player))
//				{
//					StartVRFeedback(1);
//				}
				ob->flags |= FL_FULLLIGHT;
				if (ob==player)
					SetIllumination(2);
				PlayerMissileAttack(ob);


				if (!(ob->flags & FL_GODMODE) && !godmode)
				{
					if (!BATTLEMODE || (gamestate.BattleOptions.Ammo != bo_infinite_shots))
						pstate->ammo--;

					if ((ob==player) && SHOW_BOTTOM_STATUS_BAR() )
						DrawBarAmmo (false);
				}
	#if (SHAREWARE == 0)
				if (pstate->weapon == wp_kes)
					pstate->weapondowntics = KESTICS/(2*GMOVE);
	#endif
				break;

		}

		pstate->attackframe++;
		cur = &(WEAPONS[pstate->weapon].attackinfo[pstate->attackframe]);
		pstate->weaponframe = cur->frame;
		pstate->attackcount = cur->mtics;

	}
	else
		pstate->attackcount --;
}

/*
===============
=
= T_BatBlast
=
===============
*/

void  T_BatBlast (objtype *ob)
{
	attack_t	*cur;
	playertype *pstate;

	Thrust(ob);
	CheckPlayerSpecials(ob);
	M_LINKSTATE(ob,pstate);

//Commented out until we find if it's valid
/*
	if (!ob->ticcount)
	{if ( pstate->buttonstate[bt_use] && !pstate->buttonheld[bt_use] )
		pstate->buttonstate[bt_use] = false;

	if ( pstate->buttonstate[bt_attack] && !pstate->buttonheld[bt_attack])
		pstate->buttonstate[bt_attack] = false;
	}
*/
//
// change frame and fire
//

	BatBlast(ob);

	if (pstate->attackframe >= WEAPONS[pstate->weapon].numattacks)
		Error("\n attackframe %d for weapon %d gt numattacks %d",
				pstate->attackframe,pstate->weapon,
				WEAPONS[pstate->weapon].numattacks
			);


	cur = &(WEAPONS[pstate->weapon].attackinfo[pstate->attackframe]);
	if (! pstate->attackcount)
	{
		if (cur->attack == reset)
		{
			if (!(ob->flags & FL_GODMODE) && (!godmode))
			{
				pstate->ammo --;
				if ((ob==player) && SHOW_BOTTOM_STATUS_BAR() )
					DrawBarAmmo (false);
			}

			if (!pstate->ammo)
			{
				pstate->new_weapon = pstate->bulletweapon;
				pstate->ammo = -1;
				pstate->missileweapon = -1;
				pstate->weapondowntics =
					WEAPONS[pstate->weapon].screenheight/GMOVE;
			}

			NewState(ob,&s_player);
			pstate->attackframe = pstate->weaponframe = 0;
			pstate->batblast = 0;
			return;
		}
		pstate->attackframe++;
		pstate->weaponframe =
			WEAPONS[pstate->weapon].attackinfo[pstate->attackframe].frame;
		cur = &(WEAPONS[pstate->weapon].attackinfo[pstate->attackframe]);
		pstate->attackcount = cur->mtics;
	}
	else
		pstate->attackcount --;
}

void  T_Free (objtype *ob)
{
	attack_t	*cur;

	if (!ob->ticcount)
	{

//Commented out until we find if it's valid
/*
	if ( locplayerstate->buttonstate[bt_use] && !locplayerstate->buttonheld[bt_use] )
		locplayerstate->buttonstate[bt_use] = false;

	if ( locplayerstate->buttonstate[bt_attack] && !locplayerstate->buttonheld[bt_attack])
		locplayerstate->buttonstate[bt_attack] = false;
*/
		Thrust(ob);
	}
	CheckPlayerSpecials(ob);

	cur = &(FREE.attackinfo[locplayerstate->attackframe]);

	if (!locplayerstate->attackcount)
	{
		if ((locplayerstate->weaponframe > 3) &&
			(locplayerstate->weaponframe < 8))
		{
			locplayerstate->NETCAPTURED ++;
		}
		else if (locplayerstate->weaponframe == 8)
		{
			locplayerstate->NETCAPTURED = -2;
			MISCVARS->NET_IN_FLIGHT = false;
			NewState(ob,&s_player);
			locplayerstate->weapondowntics = FREE.screenheight/GMOVE;
			return;
		}

		locplayerstate->attackframe++;
		cur = &(FREE.attackinfo[locplayerstate->attackframe]);
		locplayerstate->weaponframe = cur->frame;

		locplayerstate->attackcount = cur->mtics;

	}
	else
		locplayerstate->attackcount --;
}


void Switch_Who_Is_It_For_Tag(objtype *actor1,objtype *actor2)
{
	playertype *pstate;

	M_LINKSTATE(actor1,pstate);
	if (pstate->buttonstate[bt_use])
	{
		playertype *pstate2;

		M_LINKSTATE(actor2,pstate2);
		pstate2->oldmissileweapon = pstate2->oldweapon = pstate2->new_weapon =
		pstate2->missileweapon = pstate2->weapon = wp_godhand;
		pstate2->weaponheight = 144;
		pstate2->weaponuptics = (144 - TAGHANDHEIGHT)/GMOVE;
		pstate2->weapondowntics = 0;
		actor1->flags |= FL_DIDTAG;
		actor2->flags |= FL_DESIGNATED;
		UpdateKills = true;

		actor1->flags &= ~FL_DESIGNATED;
		BATTLE_PlayerKilledPlayer(battle_player_tagged,
			actor1->dirchoosetime, actor2->dirchoosetime);
	}
}


void CheckTagGame(objtype *actor1,objtype*actor2)
{
	//if ((actor1->obclass != playerobj) || (actor2->obclass != playerobj))
	//return;

	if (!BATTLEMODE)
		return;

	if (gamestate.battlemode != battle_Tag)
		return;

	SD_PlaySoundRTP(SD_GETBONUSSND,actor1->x,actor1->y);

	if (actor1->flags & FL_DESIGNATED)
		Switch_Who_Is_It_For_Tag(actor1,actor2);
	else if (actor2->flags & FL_DESIGNATED)
		Switch_Who_Is_It_For_Tag(actor2,actor1);
}


/*
======================
=
= CheckWeaponChange
=
= Keys 1-4 change weapons
=
======================
*/

void CheckWeaponChange (objtype * ob)
{
//	int	i;

	playertype * pstate;

	M_LINKSTATE(ob,pstate);
	//pstate = (ob == player)?(&playerstate):(&remoteplayerstate);
	if (W_CHANGE(pstate))
		return;

	if (!ARMED(ob->dirchoosetime))
		return;

	if ((ob->flags & FL_DOGMODE) || (ob->flags & FL_GODMODE))
		return;

#if (WEAPONCHEAT==1)
		if (godmode && Keyboard[sc_Insert])
			{
			SD_Play(SD_SELECTWPNSND);

			// FOR DEBUG only
			/*
			if (pstate->buttonstate[bt_run])
			{
			if (pstate->weapon == 0)
			pstate->new_weapon = wp_bat;
			else
			pstate->new_weapon --;
			}
			else
			{*/
			if (pstate->weapon == MAXWEAPONS-1)
			pstate->new_weapon = 0;
			else
			pstate->new_weapon ++;
			//}
			if (pstate->new_weapon <= wp_mp40)
			{pstate->bulletweapon = pstate->new_weapon;
			pstate->HASBULLETWEAPON[pstate->new_weapon] = 1;
			}
			else
			pstate->missileweapon = pstate->new_weapon;

			pstate->ammo = stats[GetItemForWeapon(pstate->missileweapon)].ammo;
			if (pstate->ammo<1)
				pstate->ammo=5;
			StartWeaponChange;
			//pstate->weapondowntics = WEAPONS[pstate->weapon].screenheight/GMOVE;
			//if ((ob==player) && SHOW_BOTTOM_STATUS_BAR() )
			//		DrawBarAmmo (false);
			}
		else if (pstate->buttonstate[bt_swapweapon])
#else
		if (pstate->buttonstate[bt_swapweapon])
#endif
		{
		if ((pstate->weapon == pstate->bulletweapon) &&
				(pstate->missileweapon != -1))
			{pstate->new_weapon = pstate->missileweapon;
				StartWeaponChange;
			}

		else if (pstate->weapon != pstate->bulletweapon)
			{pstate->new_weapon = pstate->bulletweapon;
			StartWeaponChange;
			}
		}
		else if ((pstate->buttonstate[bt_dropweapon]) &&
			(!gamestate.BattleOptions.WeaponPersistence))
			{
			if (pstate->weapon==pstate->bulletweapon)
				{
				if ((ob==player) && (!(pstate->buttonheld[bt_dropweapon])))
					PlayNoWaySound();
				}
			else
				{
				if (sprites[ob->tilex][ob->tiley])
					{
					if ((ob==player) && (!(pstate->buttonheld[bt_dropweapon])))
						PlayNoWaySound();
					}
				else
					{
					DropWeapon(ob);
					}
				}
			}


	if (pstate->buttonstate[bt_pistol])
	{
		if (pstate->weapon != wp_pistol)
		{
			pstate->new_weapon = pstate->bulletweapon = wp_pistol;
			StartWeaponChange;
		}
	}

	else if (pstate->buttonstate[bt_dualpistol])
	{
		if ((pstate->weapon != wp_twopistol) && pstate->HASBULLETWEAPON[wp_twopistol])
		{
			pstate->new_weapon = pstate->bulletweapon = wp_twopistol;
			StartWeaponChange;
		}
	}
	else if (pstate->buttonstate[bt_mp40])
	{
		if ((pstate->weapon != wp_mp40) &&
			pstate->HASBULLETWEAPON[wp_mp40])
		{
			pstate->new_weapon = pstate->bulletweapon = wp_mp40;
			StartWeaponChange;
		}
	}
	else if (pstate->buttonstate[bt_missileweapon])
	{
		if ((pstate->weapon != pstate->missileweapon) &&
			(pstate->missileweapon != -1))
		{
			pstate->new_weapon = pstate->missileweapon;
			StartWeaponChange;
		}
	}
}


void SetWhoHaveWeapons(void)
	{
	playertype *pstate;
	objtype	*ob;
	int		i;

	for ( i = 0; i < numplayers; i++ )
		{
		ob = PLAYER[ i ];
		M_LINKSTATE( ob, pstate );

		if ( ARMED( ob->dirchoosetime ))
			{
			if (pstate->weapon == -1)
				{
				if (( pstate->missileweapon != -1 ) && (pstate->ammo>0))
					pstate->new_weapon = pstate->missileweapon;

				else
					{
					if ( pstate->bulletweapon == -1 )
						{
						pstate->HASBULLETWEAPON[ wp_pistol ] = 1;
						pstate->bulletweapon = wp_pistol;
						}
					pstate->new_weapon = pstate->bulletweapon;
					pstate->ammo = -1;
					}

				pstate->weapon = pstate->new_weapon;
				pstate->weapondowntics = 0;
				pstate->weaponuptics = WEAPONS[pstate->new_weapon].screenheight/GMOVE;
				pstate->weaponheight = pstate->weaponuptics*GMOVE ;
				pstate->attackframe = pstate->weaponframe =
				pstate->batblast = 0;
				if (i == consoleplayer)
					DrawBarAmmo(false);
				}
			}
		else
			{
			if (ob->flags & FL_DOGMODE)
				{
				ob->temp2 = DOGMODERISE;
				pstate->oldweapon = -1;
				ResetWeapons(ob);
				if (ob->state->condition & SF_DOGSTATE)
					NewState(ob,&s_player);
				}
			else if (ob->flags & FL_GODMODE)
				{
				ob->temp2 = GODMODEFALL;
				pstate->oldweapon = -1;
				ResetWeapons(ob);
				}
			else
				{
				pstate->new_weapon = -1;
				StartWeaponChange;
				}
			pstate->attackframe = pstate->weaponframe =
			pstate->batblast = 0;
			}
		}
	}


void CheckWeaponStates(objtype*ob)
{
	playertype *pstate;

	M_LINKSTATE(ob,pstate);

	if (gamestate.battlemode == battle_Tag)
	{
		if (pstate->weapondowntics)
		{
			pstate->weaponheight += GMOVE;
			pstate->weapondowntics --;
			if (!pstate->weapondowntics)
			{
				pstate->weapon = pstate->missileweapon =
					pstate->bulletweapon =
					pstate->new_weapon =
					pstate->oldweapon =
					pstate->oldmissileweapon = -1;
			}
		}

		if (pstate->weaponuptics)
		{
			pstate->weaponheight -= GMOVE;
			pstate->weaponuptics --;
		}
		return;
	}

	if (pstate->weapondowntics)
	{
		pstate->weaponheight += GMOVE;
#if (SHAREWARE == 0)
		if ((pstate->weapon == wp_kes) && pstate->attackframe)
			pstate->weaponheight += GMOVE;
#endif
		pstate->weapondowntics --;
	}
	else if (pstate->weaponuptics)
	{
		pstate->weaponheight -= GMOVE;
#if (SHAREWARE == 0)
		if ((pstate->weapon == wp_kes) && pstate->attackframe)
			pstate->weaponheight -= GMOVE;
#endif

		pstate->weaponuptics --;
	}
	else if ((pstate->weapon == pstate->new_weapon) && (!pstate->NETCAPTURED))
		pstate->weaponheight = 0;

}


/*
=============================
=
= CheckSpecialSounds
=
=============================
*/

#define REGDOGSTATE(ob) \
	((ob->state == &s_serialdog) || (ob->state == &s_serialdog2) || \
	(ob->state == &s_serialdog3) || (ob->state == &s_serialdog4)	\
	)

static int dyingvolume=255;
void CheckSpecialSounds(objtype *ob, playertype *pstate)
{
	int shift;

	if ((!BATTLEMODE) && (ob == player))
	{
		if (pstate->health < MaxHitpointsForCharacter(locplayerstate)/5)
		{
			pstate->healthtime ++;
			if (pstate->healthtime > 2*VBLCOUNTER)
			{
				pstate->healthtime = 0;
				SD_PlayPitchedSound ( SD_PLAYERDYINGSND, dyingvolume, 0 );
				if (dyingvolume>80)
					dyingvolume-=40;
			}
		}
		else
		{
			dyingvolume=255;
		}
	}

	if (((ob->flags & FL_GODMODE) || (ob->flags & FL_DOGMODE)) &&
		(!W_CHANGE(pstate))
		)
	{
		pstate->soundtime++;
		if (pstate->soundtime > (2*VBLCOUNTER))
		{
			int rand;

			rand = GameRandomNumber("player special sound",0);
			shift = (pstate->soundtime>>5);
			if ((rand << shift) > 3500)
			{
				int sound;

				pstate->soundtime = 0;

				rand = GameRandomNumber("player god scare",0);

				if (ob->flags & FL_GODMODE)
				{
					sound = SD_GODMODE1SND;
					if (rand < 160)
						sound++;
					if (rand < 80)
						sound ++;
					SD_PlaySoundRTP(sound,ob->x,ob->y);
				}
#if (SHAREWARE == 0)
				else if ((!pstate->batblast) && (!ob->momentumz) &&
							(REGDOGSTATE(ob))
						)
				{
					sound = SD_DOGMODEPANTSND;
					if (rand < 128)
						sound += 2;
					NewState(ob,&s_doglick);
					pstate->attackframe = pstate->weaponframe =
					pstate->batblast = 0;
					SD_PlaySoundRTP(sound,ob->x,ob->y);
				}
#endif
			}
		}
	}
	else if (ob->flags & FL_GASMASK)
	{
		pstate->soundtime ++;

		if (pstate->soundtime > (3*VBLCOUNTER))
		{
			pstate->soundtime = 0;
			SD_PlaySoundRTP(SD_GASMASKSND,ob->x,ob->y);
		}
	}
	else if (MISCVARS->GASON)
	{
		pstate->soundtime ++;
		if (pstate->soundtime > (2*VBLCOUNTER))
		{
			int rand;

			rand = GameRandomNumber("player cough sound",0);
			shift = (pstate->soundtime>>5);
			if ((rand << shift) > 2000)
			{
				pstate->soundtime = 0;
				if ((pstate->player == 1) || (pstate->player == 3))
					SD_PlaySoundRTP(SD_PLAYERCOUGHFSND,ob->x,ob->y);
				else
					SD_PlaySoundRTP(SD_PLAYERCOUGHMSND,ob->x,ob->y);
			}
		}
	}
}

/*
static int dyingvolume=255;
void CheckSpecialSounds(objtype *ob, playertype *pstate)
	{
	int shift;

	if ((!BATTLEMODE) && (ob == player))
		{
		if (pstate->health < MaxHitpointsForCharacter(locplayerstate)/5)
			{
			pstate->healthtime ++;
			if (pstate->healthtime > 2*VBLCOUNTER)
				{
				pstate->healthtime = 0;
				SD_PlayPitchedSound ( SD_PLAYERDYINGSND, dyingvolume, 0 );
				if (dyingvolume>80)
					dyingvolume-=40;
				}
			}
		else
			{
			dyingvolume=255;
			}
		}

	if (((ob->flags & FL_GODMODE) || (ob->flags & FL_DOGMODE)) &&
		(!W_CHANGE(pstate))
		)
		{
		pstate->soundtime++;
		if (pstate->soundtime > (2*VBLCOUNTER))
			{
			int rand;

			rand = GameRandomNumber("player special sound",0);
			shift = (pstate->soundtime>>5);
			if ((rand << shift) > 3500)
				{
				int sound;

				pstate->soundtime = 0;

				rand = GameRandomNumber("player god scare",0);

				if (ob->flags & FL_GODMODE)
					{
					sound = SD_GODMODE1SND;
					if (rand < 160)
						sound++;
					if (rand < 80)
						sound ++;
					SD_PlaySoundRTP(sound,ob->x,ob->y);
					}
#if (SHAREWARE == 0)
				else if (!pstate->batblast)
					{
					sound = SD_DOGMODEPANTSND;
					if (rand < 128)
						sound += 2;
					NewState(ob,&s_doglick);
					pstate->attackframe = pstate->weaponframe =
					pstate->batblast = 0;
					SD_PlaySoundRTP(sound,ob->x,ob->y);
					}
#endif
				}
			}
		}


	else if (ob->flags & FL_GASMASK)
		{
		pstate->soundtime ++;

		if (pstate->soundtime > (3*VBLCOUNTER))
			{
			pstate->soundtime = 0;
			SD_PlaySoundRTP(SD_GASMASKSND,ob->x,ob->y);
			}
		}


	else if (MISCVARS->GASON)
		{
		pstate->soundtime ++;
		if (pstate->soundtime > (2*VBLCOUNTER))
			{
			int rand;

			rand = GameRandomNumber("player cough sound",0);
			shift = (pstate->soundtime>>5);
			if ((rand << shift) > 2000)
				{
				pstate->soundtime = 0;
				if ((pstate->player == 1) || (pstate->player == 3))
					SD_PlaySoundRTP(SD_PLAYERCOUGHFSND,ob->x,ob->y);
				else
					SD_PlaySoundRTP(SD_PLAYERCOUGHMSND,ob->x,ob->y);
				}
			}
		}
	}

*/


/*
=============================
=
= CheckProtectionsAndPowerups
=
=============================
*/


void CheckProtectionsAndPowerups(objtype *ob, playertype *pstate)
{
	if (pstate->poweruptime)
	{
		pstate->poweruptime --;
		if (pstate->poweruptime < 0)
			pstate->poweruptime = 0;
		if (ob==player)
			GM_UpdateBonus (pstate->poweruptime, true);
	}
	else
	{
		if (ob->flags & FL_ELASTO)
		{
			ob->flags &= ~FL_NOFRICTION;
			if (ob==player)
				GM_UpdateBonus (pstate->poweruptime, true);
			SD_PlaySoundRTP(SD_LOSEMODESND,ob->x, ob->y);
		}
		else if (ob->flags & FL_GODMODE)
		{
			ob->temp2 = GODMODEFALL;
			if ((pstate->player == 1) || (pstate->player == 3))
				SD_PlaySoundRTP(SD_GODWOMANSND,ob->x, ob->y);
			else
				SD_PlaySoundRTP(SD_GODMANSND,ob->x, ob->y);
			ResetWeapons(ob);
		}
		else if (ob->flags & FL_DOGMODE)
		{
			int wall;

			wall = tilemap[ob->tilex][ob->tiley];
			if ((wall & 0x4000) && (wall & 0x8000))
			{
				maskedwallobj_t * mw;
				mw=maskobjlist[wall&0x3ff];
				if (mw->flags&MW_NONDOGBLOCKING)
					return;
			}

			ob->temp2 = DOGMODERISE;
			if ((pstate->player == 1) || (pstate->player == 3))
				SD_PlaySoundRTP(SD_DOGWOMANSND,ob->x, ob->y);
			else
				SD_PlaySoundRTP(SD_DOGMANSND,ob->x, ob->y);
			ResetWeapons(ob);
			if (ob->state->condition & SF_DOGSTATE)
			{
				NewState(ob,&s_player);
				pstate->attackframe = pstate->weaponframe = pstate->batblast = 0;
			}
		}
		else if (ob->flags & FL_SHROOMS)
		{
			ResetFocalWidth ();
			SD_PlaySoundRTP(SD_LOSEMODESND,ob->x, ob->y);
		}
		else if (ob->flags & FL_FLEET)
			SD_PlaySoundRTP(SD_LOSEMODESND,ob->x, ob->y);

		ob->flags &= ~(FL_SHROOMS|FL_ELASTO|FL_FLEET|FL_GODMODE|FL_DOGMODE);
	}

	if (pstate->protectiontime)
	{
		pstate->protectiontime --;
		if (pstate->protectiontime <= 0)
		{
			SD_PlaySoundRTP(SD_LOSEMODESND,ob->x, ob->y);
			pstate->protectiontime = 0;
		}
		if (ob==player)
			GM_UpdateBonus (pstate->protectiontime, false);
	}
	else
		ob->flags &= ~(FL_BPV|FL_AV|FL_GASMASK);
}


/*
=============================
=
= CheckFlying
=
=============================
*/

void CheckFlying(objtype*ob,playertype *pstate)
{


	if (pstate->buttonstate[bt_lookup] || CYBERLOOKUP)
	{
		ob->momentumz = -FLYINGZMOM;
	}
	if (pstate->buttonstate[bt_lookdown] || CYBERLOOKDOWN)
	{
		ob->momentumz = FLYINGZMOM;
	}

	/*
	if (!M_ISDOOR(((ob->x + costable[ob->angle])>>16),
			((ob->y - sintable[ob->angle])>>16)) &&
			(pstate->buttonstate[bt_use]) &&
			(!pstate->buttonheld[bt_use])
		)
		{
		int op;
		int dist;

		dist=JETPACKTHRUST;
		if (ob->z-dist<-15)
			dist=ob->z+15;
		if (dist>0)
			{
			op = FixedMul(GRAVITY,(dist<<16)) << 1;
			ob->momentumz = -FixedSqrtHP(op);
			SD_PlaySoundRTP(SD_FLYINGSND,ob->x,ob->y);
			}
		}
	*/
}


/*
=============================
=
= CheckTemp2Codes
=
=============================
*/


#define IN_AIR(ob) \
				(!((ob->z == nominalheight) ||				\
					(IsPlatform(ob->tilex,ob->tiley)) ||	\
					(DiskAt(ob->tilex,ob->tiley))			\
					)													\
				)														\


void CheckTemp2Codes(objtype *ob,playertype *pstate)
{
	int pitheight;
	int godheight;
	int dogheight;
	int height;
	int oldz;
	int destheightoffset;

	pitheight	= maxheight - 8;
	height = ob->z + pstate->playerheight;
	dogheight	= ob->z + DOGOFFSET;
	godheight	= ob->z + GODOFFSET;

	//SoftError("\nheightoffset: %d, temp2: %d",pstate->heightoffset,ob->temp2);

	if (!((ob->temp2 == PITFALL) || (ob->temp2 == PITRISE)))
	{

		oldz = ob->z;
		//SoftError("\n zmom %d, oldz %d, newz %d",ob->momentumz,oldz,ob->z);

		if (ob->flags & FL_FLEET)
		{
			if (IN_AIR(ob))
				pstate->heightoffset = FixedMulShift(0x4000,sintable[(oldpolltime<<6)&2047],28);

			ob->z += ((ob->momentumz+0x8000)>>16);
			ob->momentumz = 0;

		}
		else
		{
			ob->z += (ob->momentumz>>16);
			ob->momentumz += GRAVITY;
		}

		if (ob->z >= nominalheight)
		{
			ob->z = nominalheight;
			ob->momentumz = 0;
			//if (platform == nominalheight)
			//{//ob->temp2 = 0;
				//ob->momentumz = 0;
			if ((oldz < nominalheight) && (!(ob->flags & FL_RIDING)))
			{
				SD_PlaySoundRTP(SD_PLAYERLANDSND,ob->x,ob->y);
			}

			if (!(ob->flags & FL_ELASTO))
				ob->flags &= ~FL_NOFRICTION;
			//  }
		}
		else if (height < 1)
		{
			ob->momentumz = 0;
			ob->z = 1-pstate->playerheight;
		}

		switch (ob->temp2)
		{
		case RENORMALIZE:
			pstate->heightoffset --;

			if (ob->flags & FL_DOGMODE)
				destheightoffset = DOGOFFSET-pstate->playerheight;
			else
				destheightoffset = 0;

			if (pstate->heightoffset <= destheightoffset)
			{
				ob->temp2 = 0;
				pstate->heightoffset = 0;
			}
			pstate->oldheightoffset = pstate->heightoffset;

			break;

		case COLUMNCRUSH:
			pstate->heightoffset += 4;
			if (pstate->heightoffset >= 30)
				pstate->heightoffset = 30;

			pstate->oldheightoffset = pstate->heightoffset;
			break;

		case GODMODERISE:
			pstate->heightoffset --;
			pstate->oldheightoffset = pstate->heightoffset;
			if ((height+pstate->heightoffset) <= godheight)
			{
				ob->temp2 = 0;
				pstate->poweruptime = POWERUPTICS;
			}
			break;


		case GODMODEFALL:
			pstate->heightoffset ++;
			pstate->oldheightoffset = pstate->heightoffset;
			SetPlayerHorizon(pstate,NORMALYZANGLE);
			if (pstate->heightoffset >= 0)
			{
				ob->temp2 = 0;
				ob->flags &= ~FL_GODMODE;
				SetNormalHorizon(ob);
			}
			break;

		case DOGMODERISE:
			pstate->heightoffset --;
			pstate->oldheightoffset = pstate->heightoffset;
			SetPlayerHorizon(pstate,NORMALYZANGLE);
			if (pstate->heightoffset <= 0)
			{
				ob->temp2 = 0;
				ob->flags &= ~FL_DOGMODE;
				SetNormalHorizon(ob);
			}
			break;


		case DOGMODEFALL:
			pstate->heightoffset ++;
			pstate->oldheightoffset = pstate->heightoffset;
			if (pstate->heightoffset >= (DOGOFFSET-pstate->playerheight))
			{
				ob->temp2 = 0;
				pstate->poweruptime = POWERUPTICS;
			}
			break;

		case STEPUP:
			//Debug("\n\n heightoffset adjusted from %d to %d",
				//	pstate->heightoffset,pstate->heightoffset - STEPADJUST);
			pstate->heightoffset -= STEPADJUST;
			if (pstate->heightoffset <= pstate->oldheightoffset)
			{
				ob->temp2 = 0;
				//Debug("\n done adjusting heightoffset");
				pstate->heightoffset = pstate->oldheightoffset;
			}
			break;

		case STEPDOWN:
			pstate->heightoffset += STEPADJUST;
			if (pstate->heightoffset >= pstate->oldheightoffset)
			{
				ob->temp2 = 0;
				pstate->heightoffset = pstate->oldheightoffset;
			}
			break;

		case 0:
			if (!((ob->flags & FL_FLEET) ||
					(ob->flags & FL_DOGMODE) ||
					(ob->flags & FL_GODMODE)
					)
				)
				pstate->heightoffset = 0;
			break;
		}
	}
	else if (ob->temp2 == PITFALL)
	{
		if (ob->z != pitheight)
		{
			ob->z += (ob->momentumz>>16);
			ob->momentumz += GRAVITY;
			if (ob->z >= pitheight)
			{
				ob->z = pitheight;
				ob->momentumz = 0;
				if (!(ob->flags & FL_DYING))
				{
					DamageThing(ob,10);
					Collision(ob,(objtype*)NULL,0,0);
					M_CheckPlayerKilled(ob);
				}
			}
		}
		else if (ob->momentumx || ob->momentumy)
		{
			ob->temp2 = PITRISE;
			ob->momentumz = -2;
		}
	}
	else if (ob->temp2 == PITRISE)
	{
		ob->z += ob->momentumz;
		if (ob->z <= nominalheight)
		{
			ob->z = nominalheight;
			ob->temp2 = 0;
			ob->momentumz = 0;
			if (pstate->heightoffset)
				ob->temp2 = RENORMALIZE;
		}
	}
}


/*
=============================
=
= CheckRemoteRecording
=
=============================
*/

void CheckRemoteRecording(objtype *ob,playertype *pstate)
	{
	if (networkgame==true)
		{
		if ( (pstate->buttonstate[bt_recordsound]) &&
			(!pstate->buttonheld[bt_recordsound])
			)
			{
			if (SD_RecordingActive()==false)
				{
				SD_SetRecordingActive ();
				PlayerRecording=ob->dirchoosetime;
				if (ob==player)
					{
						SD_StartRecordingSound();
						UpdateClientControls();
					}
				}
			}
		else if ( (pstate->buttonheld[bt_recordsound]) &&
					(!pstate->buttonstate[bt_recordsound])
				)
			{
			if (SD_RecordingActive()==true)
				{
				if (ob->dirchoosetime==PlayerRecording)
					{
					if (ob==player)
						SD_StopRecordingSound();
					SD_ClearRecordingActive();
					PlayerRecording=-1;
						UpdateClientControls();
						}
				}
			}
		}
	}


/*
=============================
=
= CheckPlayerSpecials
=
=============================
*/


void CheckPlayerSpecials(objtype * ob)
	{
	playertype * pstate;

	M_LINKSTATE(ob,pstate);

	// Check for recording of sound

	CheckRemoteRecording(ob,pstate);
	CheckTemp2Codes(ob,pstate);

	if (ob->flags & FL_DYING)
	return;

	CheckSpecialSounds(ob,pstate);
	CheckProtectionsAndPowerups(ob,pstate);
	}

#if (SHAREWARE == 0)
/*
===============
=
= T_DogUse
=
===============
*/

void  T_DogUse (objtype *ob)
{
	attack_t	*cur;
	playertype *pstate;
	statetype *oldstate;

	M_LINKSTATE(ob,pstate);

	Thrust(ob);
	oldstate = ob->state;
	CheckPlayerSpecials(ob);
	if (ob->state != oldstate)
	{
	return;
	}


//Commented out until we find if it's valid
/*
	if (!ob->ticcount)
	{if ( pstate->buttonstate[bt_use] && !pstate->buttonheld[bt_use] )
		pstate->buttonstate[bt_use] = false;
	}
*/

	if (pstate->attackframe >= DOGSCRATCH.numattacks)
		Error("\n attackframe %d for DOGSCRATCH gt numattacks %d",
				pstate->attackframe,DOGSCRATCH.numattacks
			);


	cur = &(DOGSCRATCH.attackinfo[pstate->attackframe]);
	if (! pstate->attackcount)
	{switch (cur->attack)
		{case reset:
			{
			NewState(ob,&s_dogwait);
			pstate->attackframe = pstate->weaponframe = pstate->batblast = 0;
			return;
			}
			break;
		case at_pulltrigger:
			pstate->buttonheld[bt_use]=false;
			Cmd_Use(ob);
			break;

		}
	pstate->attackframe++;
	cur = &(DOGSCRATCH.attackinfo[pstate->attackframe]);
	pstate->weaponframe = cur->frame;
	pstate->attackcount = cur->mtics;

	}
	else
	pstate->attackcount --;


}

/*
===============
=
= T_DogLick
=
===============
*/


void  T_DogLick (objtype *ob)
{
	attack_t	*cur;
	playertype *pstate;
	statetype *oldstate;

	M_LINKSTATE(ob,pstate);

	Thrust(ob);
	oldstate = ob->state;
	CheckPlayerSpecials(ob);
	if (ob->state != oldstate)
	{
	return;
	}


//Commented out until we find if it's valid
/*
	if (!ob->ticcount)
	{if ( pstate->buttonstate[bt_use] && !pstate->buttonheld[bt_use] )
		pstate->buttonstate[bt_use] = false;
	}
*/


	if (pstate->attackframe >= DOGLICK.numattacks)
		Error("\n attackframe %d for DOGLICK gt numattacks %d",
				pstate->attackframe,DOGLICK.numattacks
			);


	cur = &(DOGLICK.attackinfo[pstate->attackframe]);
	if (! pstate->attackcount)
	{if (cur->attack == reset)
		{
		NewState(ob,&s_serialdog);
		pstate->attackframe = pstate->weaponframe = 0;
		return;
		}
	pstate->attackframe++;
	cur = &(DOGLICK.attackinfo[pstate->attackframe]);
	pstate->weaponframe = cur->frame;
	pstate->attackcount = cur->mtics;

	}
	else
	pstate->attackcount --;

	//	if ( playerstate.buttonstate[bt_attack] && (!playerstate.buttonheld[bt_attack]) && (!W_CHANGE))
	//		Cmd_Fire (ob);


}

#endif

void T_DeadWait(objtype*ob)
{
	playertype *pstate;

	M_LINKSTATE(ob,pstate);
	if ((ob->flags & FL_DESIGNATED) && (gamestate.battlemode == battle_CaptureTheTriad))
	{int otherteam = (pstate->team ^ 1);

		ob->flags &= ~FL_DESIGNATED;
		UpdateKills = true;
		SpawnStatic(TEAM[otherteam].tilex,TEAM[otherteam].tiley,stat_collector,9);
		LASTSTAT->flags |= FL_COLORED;
		LASTSTAT->hitpoints = otherteam;
		LASTSTAT->flags |= FL_ABP;
		MakeStatActive(LASTSTAT);

	}
	//ob->momentumx=0;
	//ob->momentumy=0;

	if (pstate->heightoffset<36)
		{pstate->heightoffset++;
		pstate->oldheightoffset = pstate->heightoffset;
		}

	if (ob==player)
		{
		UpdateLightLevel(player->areanumber);
		if ((pstate->falling==true) || (ob->momentumz==0))
			{
			if (BATTLEMODE)
				playerdead=true;
			else
				playstate = ex_died;
			}
		}
	/*
	if (BATTLEMODE)
		{
		objtype * killer=(objtype *)ob->target;

		dx = killer->x - ob->x;
		dy = ob->y - killer->y;

		if (dx && dy)
			ob->angle = atan2_appx (dx,dy);
		}
	*/
	//CheckPlayerSpecials(ob);
}

/*
===============
=
= T_Player
=
===============
*/

void  T_Player (objtype *ob)
{
	playertype *pstate;
	statetype *oldstate;

#if (SHAREWARE == 0)
	int eluder;
#endif

	M_LINKSTATE(ob,pstate);


#if (SHAREWARE == 0)
	eluder = ((pstate->weapon == wp_dog) && gamestate.SpawnEluder);
#endif

	oldstate = ob->state;

	if (ob->flags&FL_DYING)
	{

		CheckPlayerSpecials(ob);
		PlayerMove(ob);
		if (
			(pstate->falling==true) ||
			(
			(!ob->momentumx) &&
			(!ob->momentumy) &&
			(!ob->momentumz) &&
			(!ob->state->tictime)
			)
			)
		{
			KillActor(ob);
			if (ob->state == &s_remoteguts12)
			NewState(ob,&s_gutwait);
			else
			NewState(ob,&s_deadwait);
		}
		return;
	}

	Thrust(ob);
	if (ob->flags & FL_DYING)
	return;

	oldstate = ob->state;
	CheckPlayerSpecials(ob);
	if (ob->state != oldstate)
	{
	if (ob->flags & FL_DYING)
		return;
	}

	if (!(ob->flags & FL_PAIN))
	{if (!(ob->state->condition & SF_DOGSTATE))
		{if ((ob->momentumx || ob->momentumy) && (ob->state->condition != SF_DOWN))
			NewState(ob,&s_remotemove1);
		else if (NOMOM && (ob->state != &s_player))
			NewState(ob,&s_player);
		}
	else if (NOMOM
#if (SHAREWARE == 0)

	&& (ob->state != &s_dogwait)
#endif

	)

			NewState(ob,ob->state);

	}
	else if (!ob->ticcount)
	{if (!(ob->state->condition & SF_DOGSTATE))
		NewState(ob,&s_player);

	ob->flags &= ~FL_PAIN;

	}

	if (ob->flags & FL_DIDTAG)
	{ob->flags &= ~FL_DIDTAG;
	pstate->weapondowntics = (144 - TAGHANDHEIGHT)/GMOVE;
	}


	CheckWeaponStates(ob);


	if (ARMED(ob->dirchoosetime)
	//(gamestate.battlemode != battle_Tag)
	)
	{
	if (pstate->weapondowntics == 1)  // change to up; during change, up and down
									// are never zero at the same time
		{
		pstate->weapondowntics = 0;
		pstate->weaponframe = pstate->attackframe = 0;

		if (pstate->NETCAPTURED == -1)
			{
			pstate->weaponuptics = FREE.screenheight/GMOVE;
			pstate->weaponheight = pstate->weaponuptics*GMOVE ;
			pstate->NETCAPTURED = 1;
	//			return;
			}
		else if (pstate->NETCAPTURED == -2)
			{
			pstate->weaponuptics = WEAPONS[pstate->weapon].screenheight/GMOVE;
			pstate->weaponheight = pstate->weaponuptics*GMOVE ;
			pstate->NETCAPTURED = 0;

			//return;
			}
		else
			{
			pstate->weaponuptics = WEAPONS[pstate->new_weapon].screenheight/GMOVE;
			pstate->weapon = pstate->new_weapon;

			pstate->weaponheight = pstate->weaponuptics*GMOVE ;
			}
		}

	else
		CheckWeaponChange (ob);
	}

	else if (gamestate.battlemode == battle_Hunter)
	{
	if (pstate->weapondowntics == 1)

		{
		pstate->weapondowntics = 0;
		pstate->weaponframe = pstate->attackframe = pstate->batblast = 0;
		pstate->weapon = pstate->new_weapon;
		}
	}

//	if ( pstate->buttonstate[bt_use] && (!W_CHANGE(pstate)) )

	if ( pstate->buttonstate[bt_use] )
		Cmd_Use (ob);


	if (W_CHANGE(pstate))
	return;


	if ((!ARMED(ob->dirchoosetime))
#if (SHAREWARE == 0)
		&& (pstate->weapon != wp_dog)
#endif
		)
		return;

	if (pstate->buttonstate[bt_attack])
		{
#if (SHAREWARE == 0)

		if (eluder)
			Cmd_Fire(ob);

		else if ((pstate->weapon == wp_bat) ||
					(pstate->weapon == wp_dog)
				)
			{
			int oldblast=pstate->batblast;

			pstate->batblast ++;

			if (pstate->weapon==wp_bat)
				{
				if (pstate->batblast == 20)
					SD_PlaySoundRTP(SD_EXCALIBUILDSND,ob->x,ob->y);
				}
			else
				{
				if ((pstate->batblast>>4)!=(oldblast>>4))
					{
					int handle;

					handle=SD_PlaySoundRTP(SD_DOGMODEPREPBLASTSND,ob->x,ob->y);
					SD_SetSoundPitch(handle,-(BBTIME<<3)+(pstate->batblast<<3));
					}
				}
			if (pstate->batblast < BBTIME)
			return;

			if (pstate->weapon == wp_bat)
				SD_PlaySoundRTP(SD_EXCALIBLASTSND,ob->x,ob->y);
			else
				SD_PlaySoundRTP(SD_DOGMODEBLASTSND,ob->x,ob->y);
			}

		if ((pstate->weapon != wp_split) || (!pstate->buttonheld[bt_attack]))
#endif
	//	if (!pstate->buttonheld[bt_attack])
//#endif
			{

#if (SHAREWARE == 0)

			if (pstate->weapon == wp_kes)
			SD_PlaySoundRTP(SD_GRAVBUILDSND,ob->x,ob->y);
#endif

			Cmd_Fire (ob);
			}
		}

#if (SHAREWARE == 0)

	else if (
				((pstate->weapon == wp_bat) ||
				((pstate->weapon == wp_dog) && (!eluder))
				) &&
				(pstate->buttonheld[bt_attack])
			)
		{
		if (pstate->weapon == wp_bat)
			SD_StopSound(SD_EXCALIBUILDSND);
		pstate->batblast = 0;
		Cmd_Fire(ob);
		}
#endif

}


/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "_rt_rand.h"
#include "rt_rand.h"
#include "develop.h"
#include "rt_util.h"
#include <time.h>

#if (DEVELOPMENT == 1)
#include "rt_main.h"
#endif
//MED
// #include "memcheck.h"

//****************************************************************************
//
// GLOBALS
//
//****************************************************************************

// static int rndindex;
static int rndindex = 0;
static int sndindex = 0;


//****************************************************************************
//
// GetRandomSeed ()
//
//****************************************************************************

int GetRandomSeed ( void )
{
	return ( time (NULL) % (SIZE_OF_RANDOM_TABLE) );
}

//****************************************************************************
//
// InitializeRNG ()
//
//****************************************************************************

void  InitializeRNG ( void )
{
	SetRNGindex(GetRandomSeed());
	sndindex=GetRandomSeed();
}

//****************************************************************************
//
// SetRNGindex ()
//
//****************************************************************************

void  SetRNGindex ( int i )
{
	rndindex=i;
//#if (DEVELOPMENT == 1)
	SoftError("RNG index set at %ld\n",i);
//#endif
}

//****************************************************************************
//
// GetRNGindex ()
//
//****************************************************************************

int GetRNGindex ( void )
{
	return rndindex;
}


#if (RANDOMTEST==1)
//****************************************************************************
//
// int GameRNG ( char * string, int val )
//
//****************************************************************************
int	GameRNG ( char * string, int val )
{
	rndindex = (rndindex+1)&(SIZE_OF_RANDOM_TABLE-1);
	SoftError("RNG - num=%3ld called from=%s val=%ld\n",RandomTable[rndindex],string,val);
	return RandomTable[rndindex];
}
#else
//****************************************************************************
//
// int GameRNG (void)
//
//****************************************************************************
int	GameRNG ( void )
{
	int i;

	rndindex = (rndindex+1)&(SIZE_OF_RANDOM_TABLE-1);
	return RandomTable[rndindex];

//	i=(rndindex>>24)&255;
//	rndindex=(rndindex*251+7)*65521+13;
//	return(i);
}
#endif



#if (RANDOMTEST==1)
//****************************************************************************
//
// int RNG ( char * string, int val )
//
//****************************************************************************

int	RNG ( char * string, int val )
{
	sndindex = (sndindex+1)&(SIZE_OF_RANDOM_TABLE-1);
//	SoftError("SRNG - num=%3ld called from=%s val=%ld\n",RandomTable[sndindex],string,val);
	return RandomTable[sndindex];
}
#else
//****************************************************************************
//
// int RNG (void)
//
//****************************************************************************

int	RNG( void )
{
	sndindex = (sndindex+1)&(SIZE_OF_RANDOM_TABLE-1);

	return RandomTable[sndindex];
}
#endif

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "watcom.h"
// #include <malloc.h>
// #include <dos.h>
#include <stdio.h>
// #include <conio.h>
#include <string.h>
#include "modexlib.h"
#include "rt_util.h"
#include "rt_draw.h"
#include "rt_scale.h"
#include "_rt_scal.h"
#include "rt_sc_a.h"
#include "engine.h"
#include "w_wad.h"
#include "z_zone.h"
#include "lumpy.h"
#include "rt_main.h"
#include "rt_ted.h"
#include "rt_vid.h"
#include "rt_view.h"
#include "rt_playr.h"
//MED
// #include "memcheck.h"

/*
=============================================================================

										GLOBALS

=============================================================================
*/

// Draw Column vars

int dc_texturemid;
int dc_iscale;
int dc_invscale;
int sprtopoffset;
int dc_yl;
int dc_yh;
//byte * dc_firstsource;
byte * dc_source;
int centeryclipped;
int transparentlevel=0;

/*
==========================
=
= SetPlayerLightLevel
=
==========================
*/

void SetPlayerLightLevel (void)
{
	int i;
	int lv;
	int intercept;
	int height;

	whereami=23;
	if (MISCVARS->GASON==1)
		{
		shadingtable=greenmap+(MISCVARS->gasindex<<8);
		return;
		}

	if (fulllight || fog)
		{
		shadingtable=colormap+(1<<12);
		return;
		}

	height=PLAYERHEIGHT;

	if (player->angle < FINEANGLES/8 || player->angle > 7*FINEANGLES/8)
		intercept=(player->x>>11)&0x1c;
	else if (player->angle < 3*FINEANGLES/8)
		intercept=(player->y>>11)&0x1c;
	else if (player->angle < 5*FINEANGLES/8)
		intercept=(player->x>>11)&0x1c;
	else
		intercept=(player->y>>11)&0x1c;

	if (lightsource)
		{
		lv=(((LightSourceAt(player->x>>16,player->y>>16)>>intercept)&0xf)>>1);
		i=maxshade-(height>>normalshade)-lv;
		if (i<minshade) i=minshade;
		shadingtable=colormap+(i<<8);
		}
	else
		{
		i=maxshade-(height>>normalshade);
		if (i<minshade) i=minshade;
		shadingtable=colormap+(i<<8);
		}
}



/*
==========================
=
= SetLightLevel
=
==========================
*/

void SetLightLevel (int height)
{
	int i;

	whereami=24;
	if (MISCVARS->GASON==1)
		{
		shadingtable=greenmap+(MISCVARS->gasindex<<8);
		return;
		}

	if (fulllight)
		{
		shadingtable=colormap+(1<<12);
		return;
		}
	if (fog)
		{
		i=(height>>normalshade)+minshade;
		if (i>maxshade) i=maxshade;
		shadingtable=colormap+(i<<8);
		}
	else
		{
		i=maxshade-(height>>normalshade);
		if (i<minshade) i=minshade;
		shadingtable=colormap+(i<<8);
		}
}

/*
==========================
=
= ScaleTransparentPost
=
==========================
*/
//void ScaleTransparentPost (byte * src, byte * buf, int level)
void ScaleTransparentPost (byte * src, unsigned buf, int level)
{
	int  offset;
	int  length;
	int  topscreen;
	int  bottomscreen;
	byte * oldlevel;
	byte * seelevel;
#if (DEVELOPMENT == 1)
	boolean found=false;
	int  i;
#endif

	whereami=25;
#if (DEVELOPMENT == 1)
	if ((shadingtable>=colormap) && (shadingtable<=(colormap+(31*256))))
		{
		found=true;
		}
	else if ((shadingtable>=redmap) && (shadingtable<=(redmap+(31*256))))
		{
		found=true;
		}
	else
		{
		for (i=0;i<MAXPLAYERCOLORS;i++)
			{
			if ((shadingtable>=playermaps[i]) || (shadingtable<=(playermaps[i]+(31*256))))
				found=true;
			}
		}
	if (found==false)
		{
		Error ("Shadingtable out of range\n");
		}
	if ((level<0) || (level>=64))
		{
		Error ("translucent level out of range\n");
		}
#endif

	seelevel=colormap+(((level+64)>>2)<<8);
	oldlevel=shadingtable;
	offset=*(src++);
	for (;offset!=255;)
		{
		length=*(src++);
		topscreen = sprtopoffset + (dc_invscale*offset);
		bottomscreen = topscreen + (dc_invscale*length);
		dc_yl = (topscreen+SFRACUNIT)>>SFRACBITS;
		dc_yh = ((bottomscreen-1)>>SFRACBITS);
		if (dc_yh >= viewheight)
			dc_yh = viewheight-1;
		if (dc_yl < 0)
			dc_yl = 0;
		if ((*src)==254)
			{
			shadingtable=seelevel;
			if (dc_yl <= dc_yh)
				R_TransColumn (buf);
			src++;
			offset=*(src++);
			shadingtable=oldlevel;
			}
		else
			{
			if (dc_yl <= dc_yh)
				{
				dc_source=src-offset;
				R_DrawColumn (buf);
				}
			src+=length;
			offset=*(src++);
			}
		}

	whereami=-2;
}


// void ScaleMaskedPost (byte * src, byte * buf)
void ScaleMaskedPost (byte * src, unsigned buf)
{
	int  offset;
	int  length;
	int  topscreen;
	int  bottomscreen;

	whereami=26;
	offset=*(src++);
	for (;offset!=255;)
		{
		length=*(src++);
		topscreen = sprtopoffset + (dc_invscale*offset);
		bottomscreen = topscreen + (dc_invscale*length);
		dc_yl = (topscreen+SFRACUNIT)>>SFRACBITS;
		dc_yh = ((bottomscreen-1)>>SFRACBITS);
		if (dc_yh >= viewheight)
			dc_yh = viewheight-1;
		if (dc_yl < 0)
			dc_yl = 0;
		if (dc_yl <= dc_yh)
			{
			dc_source=src-offset;
			R_DrawColumn (buf);
#if (DEVELOPMENT == 1)
//			if (dc_firstsource<src)
//				SoftError("dc_firstsource=%p src=%p\n",dc_firstsource,src);
#endif
			}
		src+=length;
		offset=*(src++);
		}
}

// void ScaleClippedPost (byte * src, byte * buf)
void ScaleClippedPost (byte * src, unsigned buf)
{
	int  offset;
	int  length;
	int  topscreen;
	int  bottomscreen;

	whereami=27;
	offset=*(src++);
	for (;offset!=255;)
		{
		length=*(src++);
		topscreen = sprtopoffset + (dc_invscale*offset);
		bottomscreen = topscreen + (dc_invscale*length);
		dc_yl = (topscreen+SFRACUNIT-1)>>SFRACBITS;
		dc_yh = ((bottomscreen-1)>>SFRACBITS);
		if (dc_yh >= viewheight)
			dc_yh = viewheight-1;
		if (dc_yl < 0)
			dc_yl = 0;
		if (dc_yl <= dc_yh)
			{
			dc_source=src-offset;
			R_DrawClippedColumn (buf);
			}
		src+=length;
		offset=*(src++);
		}
}

// void ScaleSolidMaskedPost (int color, byte * src, byte * buf)
void ScaleSolidMaskedPost (int color, byte * src, unsigned buf)
{
	int  offset;
	int  length;
	int  topscreen;
	int  bottomscreen;

	whereami=28;
	offset=*(src++);
	for (;offset!=255;)
		{
		length=*(src++);
		topscreen = sprtopoffset + (dc_invscale*offset);
		bottomscreen = topscreen + (dc_invscale*length);
		dc_yl = (topscreen+SFRACUNIT)>>SFRACBITS;
		dc_yh = ((bottomscreen-1)>>SFRACBITS);
		if (dc_yh >= viewheight)
			dc_yh = viewheight-1;
		if (dc_yl < 0)
			dc_yl = 0;
		if (dc_yl <= dc_yh)
			{
			dc_source=src-offset;
			R_DrawSolidColumn (color, buf);
			}
		src+=length;
		offset=*(src++);
		}

}


// void ScaleTransparentClippedPost (byte * src, byte * buf, int level)
void ScaleTransparentClippedPost (byte * src, unsigned buf, int level)
{
	int  offset;
	int  length;
	int  topscreen;
	int  bottomscreen;
	byte * oldlevel;
	byte * seelevel;

	whereami=29;

	seelevel=colormap+(((level+64)>>2)<<8);
	oldlevel=shadingtable;
	offset=*(src++);
	for (;offset!=255;)
		{
		length=*(src++);
		topscreen = sprtopoffset + (dc_invscale*offset);
		bottomscreen = topscreen + (dc_invscale*length);
		dc_yl = (topscreen+SFRACUNIT)>>SFRACBITS;
		dc_yh = ((bottomscreen-1)>>SFRACBITS);
		if (dc_yh >= viewheight)
			dc_yh = viewheight-1;
		if (dc_yl < 0)
			dc_yl = 0;
		if ((*src)==254)
			{
			shadingtable=seelevel;
			if (dc_yl <= dc_yh)
				R_TransColumn (buf);
			src++;
			offset=*(src++);
			shadingtable=oldlevel;
			}
		else
			{
			if (dc_yl <= dc_yh)
				{
				dc_source=src-offset;
				R_DrawClippedColumn (buf);
				}
			src+=length;
			offset=*(src++);
			}
		}

}


// void ScaleMaskedWidePost (byte * src, byte * buf, int x, int width)
void ScaleMaskedWidePost (byte * src, unsigned buf, int x, int width)
{
	int  ofs;
	int  msk;

	whereami=30;
	buf+=x>>2;
	ofs=((x&3)<<3)+(x&3)+width-1;
	VGAMAPMASK(*((byte *)mapmasks1+ofs));
	ScaleMaskedPost(src,buf);
	msk=(byte)*((byte *)mapmasks2+ofs);
	if (msk==0)
		return;
	buf++;
	VGAMAPMASK(msk);
	ScaleMaskedPost(src,buf);
	msk=(byte)*((byte *)mapmasks3+ofs);
	if (msk==0)
		return;
	buf++;
	VGAMAPMASK(msk);
	ScaleMaskedPost(src,buf);
}

// void ScaleClippedWidePost (byte * src, byte * buf, int x, int width)
void ScaleClippedWidePost (byte * src, unsigned buf, int x, int width)
{
	int  ofs;
	int  msk;

	whereami=31;
	buf+=x>>2;
	ofs=((x&3)<<3)+(x&3)+width-1;
	VGAMAPMASK(*((byte *)mapmasks1+ofs));
	ScaleClippedPost(src,buf);
	msk=(byte)*((byte *)mapmasks2+ofs);
	if (msk==0)
		return;
	buf++;
	VGAMAPMASK(msk);
	ScaleClippedPost(src,buf);
	msk=(byte)*((byte *)mapmasks3+ofs);
	if (msk==0)
		return;
	buf++;
	VGAMAPMASK(msk);
	ScaleClippedPost(src,buf);
}


/*
=======================
=
= ScaleShape
=
=======================
*/

void ScaleShape (visobj_t * sprite)
{
	byte *shape;
	int		frac;
	patch_t *p;
	int		x1,x2;
	int		tx;
	int		size;
	int		plane;

	whereami=32;
//	shape=W_CacheLumpNum(sprite->shapenum,PU_CACHE);
	shape=W_CacheWallLumpNum(sprite->shapenum,PU_CACHE);
	p=(patch_t *)shape;
	size=p->origsize>>7;
//	sprite->viewheight<<=1;
	dc_invscale=sprite->viewheight<<((10-HEIGHTFRACTION)-size);
	tx=-p->leftoffset;
	sprite->viewx=(sprite->viewx<<SFRACBITS)-(sprite->viewheight<<(SFRACBITS-HEIGHTFRACTION-1))+(SFRACUNIT>>1);
//
// calculate edges of the shape
//
		x1 = (sprite->viewx+(tx*dc_invscale))>>SFRACBITS;
		if (x1 >= viewwidth)
			{
			return;					// off the right side
			}
		tx+=p->width;
		x2 = ((sprite->viewx+(tx*dc_invscale)) >>SFRACBITS) - 1 ;
		if (x2 < 0)
			{
			return;			// off the left side
			}

// dc_iscale=(1<<(16+6+HEIGHTFRACTION+size))/sprite->viewheight;
	dc_iscale=0xffffffffu/(unsigned)dc_invscale;
	dc_texturemid=(((sprite->h1<<size) + p->topoffset)<<SFRACBITS);//+(SFRACUNIT>>1);
	sprtopoffset=centeryfrac -  FixedMul(dc_texturemid,dc_invscale);
	shadingtable=sprite->colormap;

	if (x1<0)
		{
		frac=dc_iscale*(-x1);
		x1=0;
		}
	else
		frac=0;
	x2 = x2 >= viewwidth ? viewwidth-1 : x2;

	if (sprite->viewheight>((1<<(HEIGHTFRACTION+6))<<size))
		{
		int		texturecolumn;
		int		lastcolumn;
		int		startx;
		int		width;

		width=1;
		startx=0;
		lastcolumn=-1;
		for (; x1<=x2 ; x1++, frac += dc_iscale)
		{
			if (posts[x1].wallheight>sprite->viewheight)
				{
				if (lastcolumn>=0)
					{
					ScaleMaskedWidePost(
						((p->collumnofs[lastcolumn])+shape),
						bufferofs,startx,width);
					width=1;
					lastcolumn=-1;
					}
				continue;
				}
					texturecolumn = frac>>SFRACBITS;
			if ((texturecolumn==lastcolumn)&&(width<9))
				{
				width++;
				continue;
				}
			else
				{
				if (lastcolumn>=0)
					{
					ScaleMaskedWidePost(
						((p->collumnofs[lastcolumn])+shape),
						bufferofs,startx,width);
					width=1;
					startx=x1;
					lastcolumn=texturecolumn;
					}
				else
					{
					startx=x1;
					lastcolumn=texturecolumn;
					}
				}
			}
		if (lastcolumn!=-1)
			ScaleMaskedWidePost(
				((p->collumnofs[lastcolumn])+shape),
				bufferofs,startx,width);
		}
	else
		{
		unsigned b;
		int	startfrac;
		int	startx;

		startx=x1;
		startfrac=frac;
		if (doublestep>1)
			{
			for (plane=startx;plane<startx+4;plane+=2,startfrac+=(dc_iscale<<1))
				{
				frac=startfrac;
//	VGAWRITEMAP(plane&3);
				for (x1=plane;x1<=x2;x1+=4, frac += (dc_iscale<<2))
					{
					if (
						(posts[x1].wallheight>sprite->viewheight) &&
						(posts[x1+1].wallheight>sprite->viewheight)
						)
						continue;
					if (x1==viewwidth-1)
						ScaleMaskedWidePost(
							((p->collumnofs[frac>>SFRACBITS])+shape),
							bufferofs,x1,1);
					else
						ScaleMaskedWidePost(
							((p->collumnofs[frac>>SFRACBITS])+shape),
							bufferofs,x1,2);
					}
				}
			}
		else
			{
			for (plane=startx;plane<startx+4;plane++,startfrac+=dc_iscale)
				{
				frac=startfrac;
				b=bufferofs+(plane>>2);
				VGAWRITEMAP(plane&3);
				for (x1=plane;x1<=x2;x1+=4, frac += (dc_iscale<<2),b++)
					{
					if (posts[x1].wallheight>sprite->viewheight)
						continue;
					ScaleMaskedPost(((p->collumnofs[frac>>SFRACBITS])+shape),b);
					}
				}
			}
		}
}


/*
=======================
=
= ScaleTranparentShape
=
=======================
*/

void ScaleTransparentShape (visobj_t * sprite)
{
	byte *shape;
	int		frac;
	transpatch_t *p;
	int		x1,x2;
	int		tx;
	int		size;
	unsigned	b;
	int	startfrac;
	int	startx;
	int	plane;

	whereami=33;
//	shape=W_CacheLumpNum(sprite->shapenum,PU_CACHE);
	shape=W_CacheWallLumpNum(sprite->shapenum,PU_CACHE);
	p=(transpatch_t *)shape;
	size=p->origsize>>7;
	dc_invscale=sprite->viewheight<<((10-HEIGHTFRACTION)-size);
	tx=-p->leftoffset;
	sprite->viewx=(sprite->viewx<<SFRACBITS)-(sprite->viewheight<<(SFRACBITS-HEIGHTFRACTION-1));
//
// calculate edges of the shape
//
		x1 = (sprite->viewx+(tx*dc_invscale))>>SFRACBITS;
		if (x1 >= viewwidth)
			{
			return;					// off the right side
			}
		tx+=p->width;
		x2 = ((sprite->viewx+(tx*dc_invscale)) >>SFRACBITS) - 1 ;
		if (x2 < 0)
			{
			return;			// off the left side
			}

//	dc_iscale=(1<<(16+6+HEIGHTFRACTION+size))/sprite->viewheight;
	dc_iscale=0xffffffffu/(unsigned)dc_invscale;
	dc_texturemid=(((sprite->h1<<size)+p->topoffset)<<SFRACBITS);//+(SFRACUNIT>>1);
	sprtopoffset=centeryfrac - FixedMul(dc_texturemid,dc_invscale);
	shadingtable=sprite->colormap;

	if (x1<0)
		{
		frac=dc_iscale*(-x1);
		x1=0;
		}
	else
		frac=0;
	x2 = x2 >= viewwidth ? viewwidth-1 : x2;

#if 0
	for (; x1<=x2 ; x1++, frac += dc_iscale)
		{
		if (posts[x1].wallheight>sprite->viewheight)
			continue;
		VGAWRITEMAP(x1&3);
		VGAREADMAP(x1&3);
		ScaleTransparentPost(((p->collumnofs[frac>>SFRACBITS])+shape),(byte *)bufferofs+(x1>>2),sprite->h2);
		}
#endif
	startx=x1;
	startfrac=frac;

	for (plane=startx;plane<startx+4;plane++,startfrac+=dc_iscale)
		{
		frac=startfrac;
		b=bufferofs+(plane>>2);
		VGAWRITEMAP(plane&3);
		VGAREADMAP(plane&3);
		for (x1=plane;x1<=x2;x1+=4, frac += (dc_iscale<<2),b++)
			{
			if (posts[x1].wallheight>sprite->viewheight)
				continue;
			ScaleTransparentPost(((p->collumnofs[frac>>SFRACBITS])+shape),b,sprite->h2);
			}
		}
}

/*
=======================
=
= ScaleSolidShape
=
=======================
*/

void ScaleSolidShape (visobj_t * sprite)
{
	byte *shape;
	int		frac;
	patch_t *p;
	int		x1,x2;
	int		tx;
	int		size;
	int		plane;
	unsigned	b;
	int	startfrac;
	int	startx;

	whereami=34;
//	shape=W_CacheLumpNum(sprite->shapenum,PU_CACHE);
	shape=W_CacheWallLumpNum(sprite->shapenum,PU_CACHE);
	p=(patch_t *)shape;
	size=p->origsize>>7;
	dc_invscale=sprite->viewheight<<((10-HEIGHTFRACTION)-size);
	tx=-p->leftoffset;
	sprite->viewx=(sprite->viewx<<SFRACBITS)-(sprite->viewheight<<(SFRACBITS-HEIGHTFRACTION-1))+(SFRACUNIT>>1);
//
// calculate edges of the shape
//
		x1 = (sprite->viewx+(tx*dc_invscale))>>SFRACBITS;
		if (x1 >= viewwidth)
			{
			return;					// off the right side
			}
		tx+=p->width;
		x2 = ((sprite->viewx+(tx*dc_invscale)) >>SFRACBITS) - 1 ;
		if (x2 < 0)
			{
			return;			// off the left side
			}

//	dc_iscale=(1<<(16+6+HEIGHTFRACTION+size))/sprite->viewheight;
	dc_iscale=0xffffffffu/(unsigned)dc_invscale;
	dc_texturemid=(((sprite->h1<<size)+p->topoffset)<<SFRACBITS);//+(SFRACUNIT>>1);
	sprtopoffset=centeryfrac - FixedMul(dc_texturemid,dc_invscale);
	shadingtable=sprite->colormap;

	if (x1<0)
		{
		frac=dc_iscale*(-x1);
		x1=0;
		}
	else
		frac=0;
	x2 = x2 >= viewwidth ? viewwidth-1 : x2;

	startx=x1;
	startfrac=frac;
	for (plane=startx;plane<startx+4;plane++,startfrac+=dc_iscale)
		{
		frac=startfrac;
		b=bufferofs+(plane>>2);
		VGAWRITEMAP(plane&3);
		for (x1=plane;x1<=x2;x1+=4, frac += (dc_iscale<<2),b++)
			{
			if (posts[x1].wallheight>sprite->viewheight)
				continue;
			ScaleSolidMaskedPost(sprite->h2,((p->collumnofs[frac>>SFRACBITS])+shape),b);
			}
		}
}


/*
=======================
=
= ScaleWeapon
=
=======================
*/

void ScaleWeapon (int xoff, int y, int shapenum)
{
	byte *shape;
	int		frac;
	int		h;
	patch_t *p;
	int		x1,x2;
	int		tx;
	int		xcent;
	unsigned	b;
	int	startfrac;
	int	startx;
	int	plane;


	whereami=35;
	SetPlayerLightLevel();
//	shape=W_CacheLumpNum(shapenum,PU_CACHE);
	shape=W_CacheWallLumpNum(shapenum,PU_CACHE);
	p=(patch_t *)shape;
	h=((p->origsize*weaponscale)>>17);
	centeryclipped=(viewheight-h)+FixedMul(y,weaponscale);
	xcent=centerx+FixedMul(xoff,weaponscale);
	dc_invscale=(h<<17)/p->origsize;

	tx=-p->leftoffset;
	xcent=(xcent<<SFRACBITS)-(h<<SFRACBITS);
//
// calculate edges of the shape
//
		x1 = (xcent+(tx*dc_invscale))>>SFRACBITS;
		if (x1 >= viewwidth)
					return;					// off the right side
		tx+=p->width;
		x2 = ((xcent+(tx*dc_invscale)) >>SFRACBITS) - 1 ;
		if (x2 < 0)
					return;			// off the left side

	dc_iscale=0xffffffffu/(unsigned)dc_invscale;
	dc_texturemid=(((p->origsize>>1)+p->topoffset)<<SFRACBITS)+(SFRACUNIT>>1);
	sprtopoffset=(centeryclipped<<16) - FixedMul(dc_texturemid,dc_invscale);

//
// store information in a vissprite
//
	if (x1<0)
		{
		frac=dc_iscale*(-x1);
		x1=0;
		}
	else
		frac=0;

	x2 = x2 >= viewwidth ? viewwidth-1 : x2;

	startx=x1;
	startfrac=frac;
	for (plane=startx;plane<startx+4;plane++,startfrac+=dc_iscale)
		{
		frac=startfrac;
		b=bufferofs+(plane>>2);
		VGAWRITEMAP(plane&3);
		for (x1=plane; x1<=x2 ; x1+=4, frac += dc_iscale<<2,b++)
			ScaleClippedPost(((p->collumnofs[frac>>SFRACBITS])+shape),b);
		}
}




/*
=======================
=
= DrawUnScaledSprite
=
=======================
*/

void DrawUnScaledSprite (int x, int y, int shapenum, int shade)
{
	byte *shape;
	int		frac;
	patch_t *p;
	int		x1,x2;
	int		tx;
	int		xcent;
	unsigned	b;
	int	startfrac;
	int	startx;
	int	plane;


	whereami=36;
	shadingtable=colormap+(shade<<8);
	centeryclipped=y;
	xcent=x;
//	shape=W_CacheLumpNum(shapenum,PU_CACHE);
	shape=W_CacheWallLumpNum(shapenum,PU_CACHE);
	p=(patch_t *)shape;
	dc_invscale=0x10000;

	tx=-p->leftoffset;
	xcent-=p->origsize>>1;
//
// calculate edges of the shape
//
		x1 = xcent+tx;
		if (x1 >= viewwidth)
					return;					// off the right side
		tx+=p->width;
		x2 = xcent+tx - 1;
		if (x2 < 0)
					return;			// off the left side

	dc_iscale=0x10000;
	dc_texturemid=(((p->height>>1)+p->topoffset)<<SFRACBITS);//+(SFRACUNIT>>1);
	sprtopoffset=(centeryclipped<<16) - dc_texturemid;

//
// store information in a vissprite
//
	if (x1<0)
		{
		frac=dc_iscale*(-x1);
		x1=0;
		}
	else
		frac=0;

	x2 = x2 >= viewwidth ? viewwidth-1 : x2;

	startx=x1;
	startfrac=frac;
	for (plane=startx;plane<startx+4;plane++,startfrac+=dc_iscale)
		{
		frac=startfrac;
		b=bufferofs+(plane>>2);
		VGAWRITEMAP(plane&3);
		for (x1=plane; x1<=x2 ; x1+=4, frac += dc_iscale<<2,b++)
			ScaleClippedPost(((p->collumnofs[frac>>SFRACBITS])+shape),b);
		}
}


/*
=======================
=
= DrawScreenSprite
=
=======================
*/

void DrawScreenSprite (int x, int y, int shapenum)
{
	whereami=37;
	ScaleWeapon (x-160, y-200, shapenum);
}

/*
=======================
=
= DrawPositionedScaledSprite
=
=======================
*/

void DrawPositionedScaledSprite (int x, int y, int shapenum, int height, int type)
{
	byte *shape;
	int		frac;
	patch_t *p;
	transpatch_t *tp;
	int		x1,x2;
	int		tx;
	int		xcent;
	unsigned	b;
	int	startfrac;
	int	startx;
	int	plane;
	int	size;


	whereami=38;
	shadingtable=colormap+(1<<12);
	centeryclipped=y;
	xcent=x;
//	shape=W_CacheLumpNum(shapenum,PU_CACHE);
	shape=W_CacheWallLumpNum(shapenum,PU_CACHE);
	p=(patch_t *)shape;
	tp=(transpatch_t *)shape;

	size=p->origsize>>7;
	dc_invscale=height<<(10-size);

	tx=-p->leftoffset;
	xcent=(xcent<<SFRACBITS)-(height<<(SFRACBITS-1));

//
// calculate edges of the shape
//
		x1 = (xcent+(tx*dc_invscale))>>SFRACBITS;
		if (x1 >= viewwidth)
					return;					// off the right side
		tx+=p->width;
		x2 = ((xcent+(tx*dc_invscale)) >>SFRACBITS) - 1 ;
		if (x2 < 0)
					return;			// off the left side

	dc_iscale=0xffffffffu/(unsigned)dc_invscale;
//	dc_iscale=(1<<(16+6+size))/height;
	dc_texturemid=(((32<<size)+p->topoffset)<<SFRACBITS)+(SFRACUNIT>>1);
	sprtopoffset=(centeryclipped<<16) - FixedMul(dc_texturemid,dc_invscale);

//
// store information in a vissprite
//
	if (x1<0)
		{
		frac=dc_iscale*(-x1);
		x1=0;
		}
	else
		frac=0;

	x2 = x2 >= viewwidth ? viewwidth-1 : x2;

	startx=x1;
	startfrac=frac;
	for (plane=startx;plane<startx+4;plane++,startfrac+=dc_iscale)
		{
		frac=startfrac;
		b=bufferofs+(plane>>2);
		VGAWRITEMAP(plane&3);
		VGAREADMAP(plane&3);
		for (x1=plane; x1<=x2 ; x1+=4, frac += dc_iscale<<2,b++)
			if (type==0)
				ScaleClippedPost(((p->collumnofs[frac>>SFRACBITS])+shape),b);
			else
				ScaleTransparentClippedPost(((tp->collumnofs[frac>>SFRACBITS])+shape),b,transparentlevel);
		}
}


/*
=================
=
= DrawScreenSizedSprite
=
=================
*/
void DrawScreenSizedSprite (int lump)
{
	byte *shape;
	int		frac;
	patch_t *p;
	int		x1,x2;
	int		tx;
	int		plane;
	unsigned	b;
	int	startfrac;


	whereami=39;
	shadingtable=colormap+(1<<12);
//	shape=W_CacheLumpNum(lump,PU_CACHE);
	shape=W_CacheWallLumpNum(lump,PU_CACHE);
	p=(patch_t *)shape;
	dc_invscale=(viewwidth<<16)/p->origsize;
	tx=-p->leftoffset;
	centeryclipped=viewheight>>1;
//
// calculate edges of the shape
//
		x1 = (tx*dc_invscale)>>SFRACBITS;
		if (x1 >= viewwidth)
			{
			return;					// off the right side
			}
		tx+=p->width;
		x2 = ((tx*dc_invscale) >>SFRACBITS) - 1 ;
		if (x2 < 0)
			{
			return;			// off the left side
			}

	dc_iscale=0xffffffffu/(unsigned)dc_invscale;
	dc_texturemid=(((p->origsize>>1) + p->topoffset)<<SFRACBITS)+(SFRACUNIT>>1);
	sprtopoffset=(centeryclipped<<16) -  FixedMul(dc_texturemid,dc_invscale);

	x2 = (viewwidth-1);

	startfrac=0;
	for (plane=0;plane<4;plane++,startfrac+=dc_iscale)
		{
		frac=startfrac;
		b=bufferofs+(plane>>2);
		VGAWRITEMAP(plane&3);
		for (x1=plane;x1<=x2;x1+=4, frac += (dc_iscale<<2),b++)
			{
			ScaleClippedPost(((p->collumnofs[frac>>SFRACBITS])+shape),b);
			}
		}
}

#if 0
	byte *shape;
	int		frac;
	patch_t *p;
	int		x1,x2;
	int		tx;
	int		xdc_invscale;
	int		xdc_iscale;
	byte *	buf;
	byte *	b;
	int		plane;
	int		startx,startfrac;

	whereami=39;
	SetPlayerLightLevel();
	buf=(byte *)bufferofs;
//	shape=W_CacheLumpNum(lump,PU_CACHE);
	shape=W_CacheWallLumpNum(lump,PU_CACHE);
	p=(patch_t *)shape;
	dc_invscale=(viewheight<<16)/200;
	xdc_invscale=(viewwidth<<16)/320;

	tx=-p->leftoffset;
	centeryclipped=viewheight>>1;
//
// calculate edges of the shape
//
		x1 = (tx*xdc_invscale)>>SFRACBITS;
		if (x1 >= viewwidth)
					return;					// off the right side
		tx+=p->width;
		x2 = ((tx*xdc_invscale)>>SFRACBITS) - 1 ;
		if (x2 < 0)
					return;			// off the left side

	dc_iscale=(200*65536)/viewheight;
	xdc_iscale=(320*65536)/viewwidth;
	dc_texturemid=(((p->height>>1)+p->topoffset)<<SFRACBITS)+(SFRACUNIT>>1);
	sprtopoffset=(centeryclipped<<16) - FixedMul(dc_texturemid,dc_invscale);

//
// store information in a vissprite
//
	if (x1<0)
		{
		frac=xdc_iscale*(-x1);
		x1=0;
		}
	else
		frac=0;
		x2 = x2 >= viewwidth ? viewwidth-1 : x2;

	startx=x1;
	startfrac=frac;
	for (plane=startx;plane<startx+4;plane++,startfrac+=xdc_iscale)
		{
		frac=startfrac;
		b=(byte *)bufferofs+(plane>>2);
		VGAWRITEMAP(plane&3);
		for (x1=plane; x1<=x2 ; x1+=4, frac += xdc_iscale<<2,b++)
			ScaleClippedPost(((p->collumnofs[frac>>SFRACBITS])+shape),b);
		}
}
#endif



//******************************************************************************
//
// DrawNormalPost
//
//******************************************************************************

// void DrawNormalPost (byte * src, byte * buf)
void DrawNormalPost (byte * src, unsigned buf)
{
	int  offset;
	int  length;
	int  s;

	whereami=40;

	while (1)
		{
		offset=*(src++);
		if (offset==0xff)
			return;
		else
			{
			length=*(src++);
			for (s=0;s<length;s++)
//				*(buf+ylookup[offset+s])=*(src+s);
				VGAWRITE(buf+ylookup[offset+s], *(src+s));
			src+=length;
			}
		}
}



//******************************************************************************
//
// DrawNormalSprite
//
//******************************************************************************

void DrawNormalSprite (int x, int y, int shapenum)
{
	unsigned buffer;
	int cnt;
	byte *shape;
	patch_t *p;
	int plane;
	unsigned b;
	int startx;

	whereami=41;

//	shape = W_CacheLumpNum (shapenum, PU_CACHE);
	shape = W_CacheWallLumpNum (shapenum, PU_CACHE);
	p = (patch_t *)shape;

	if (((x-p->leftoffset)<0) || ((x-p->leftoffset+p->width)>320))
		Error ("DrawNormalSprite: x is out of range x=%ld\n",x-p->leftoffset+p->width);
	if (((y-p->topoffset)<0) || ((y-p->topoffset+p->height)>200))
		Error ("DrawNormalSprite: y is out of range y=%ld\n",y-p->topoffset+p->height);

	startx=x-p->leftoffset;
	buffer = bufferofs+ylookup[y-p->topoffset];

	for (plane=startx;plane<startx+4;plane++)
		{
		b=buffer+(plane>>2);
		VGAWRITEMAP(plane&3);
		for (cnt = plane-startx; cnt < p->width; cnt+=4,b++)
			DrawNormalPost ((byte *)(p->collumnofs[cnt]+shape), b);
		}
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "rt_sound.h"
#include "_rt_soun.h"
#include "fx_man.h"
#include "music.h"
#include "z_zone.h"
#include "w_wad.h"
#include "rt_main.h"
#include "rt_ted.h"
#include "rt_menu.h"
#include "rt_playr.h"
#include "rt_util.h"
#include "rt_rand.h"
#include "rt_draw.h"
#include "watcom.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
// #include <mem.h>
// #include <io.h>
#include "rt_cfg.h"
#include "isr.h"
#include "develop.h"
#include "rt_net.h"

#include "rt_str.h"

// #if (SHAREWARE==0)
#if 1
#include "snd_reg.h"
#else
#include "snd_shar.h"
#endif
//MED
//#include "memcheck.h"

// Local Variables

static soundstart;
static soundtype;
int SD_Started=false;
static boolean PositionStored=false;
static int NumBadSounds=0;
static int remotestart;
static boolean SoundsRemapped = false;

// int rott_sndcache[512];
// int rott_sndstrt;
// int rott_sndstop;

int musicnums[ 11 ] = {
	-1, UltraSound, SoundBlaster, SoundMan16, ProAudioSpectrum,
	Awe32, SoundScape, WaveBlaster, GenMidi, SoundCanvas, Adlib
	};

int fxnums[ 11 ] = {
	-1, UltraSound, SoundBlaster, SoundMan16, ProAudioSpectrum,
	Awe32, SoundScape, Adlib, SoundSource, TandySoundSource, PC
	};

#if 1
char *sound_names[]={
"DIGISTRT",		"M_FLIP",		"M_ESC",		"M_MOVE",		
"M_SELECT",		"M_WARNIN",		"M_QUEST",		"M_INFO",		
"M_NOPE",		"Q_FIRING",		"Q_GUILL",		"Q_CYANI",		
"Q_TRAPDO",		"Q_CAROFF",		"Q_PLUG",		"Q_ECHAIR",		
"G_START",		"G_END",		"G_OVER",		"G_ENDB1",		
"G_NOBONU",		"G_100PCT",		"C_HITWAL",		"P_SELWPN",		
"C_NOWAY",		"C_BADSW",		"P_DYING",		"P_TBDIE",		
"P_TCDIE",		"P_LNDIE",		"P_DWDIE",		"P_IPDIE",		
"P_TB_OW",		"P_TC_OW",		"P_LN_OW",		"P_DW_OW",
"P_IP_OW",		"P_TB",			"P_TC",			"P_LN",		
"P_DW",			"P_IPF",		"P_BURNED",		"P_LAND",		
"P_COUGHM",		"P_COUGHF",		"P_NETWIG",		"P_NETFAL",		
"P_APISTL",		"P_A2PIST",		"P_AMP40",		"P_RICOCH",		
"P_RICOC2",		"P_RICOC1",		"P_BAZOOK",		"P_FIREBM",		
"P_HEATSK",		"P_DRUNK",		"P_FWFIRE",		"P_FWALL",		
"P_SPMSLF",		"P_SPLITS",		"P_GRAVUP",		"P_GRAVFI",		
"P_GRAVGO",		"P_GRAVHT",		"P_FIREHT",		"P_MISFLY",		
"P_MISHIT",		"P_BATBOU",		"P_BATSWI",		"P_BATHIT",		
"P_BATUP",		"P_BATBLA",		"P_AGOD",		"P_GOD1",		
"P_GOD2",		"P_GOD3",		"P_LOSE",		"P_DOGPAN",		
"P_DOGBIT",		"P_DOGBRK",		"P_DOGLIK",		"P_DOGBLA",		
"P_DOGPRP",		"P_DOGMAN",		"P_DOGWOM",		"P_GODMAN",
"P_GODWOM",		"P_MERFLY",		"C_GLASS",		"C_ITMBRK",
"C_BONBAR",		"C_TOUCHP",		"C_NOTOUC",		"C_EXPFLO",		
"C_EXPLOD",		"C_GASHIS",		"C_GASEND",		"C_GASMSK",		
"G_KEY",		"G_LIFE2",		"G_HEAL3",		"G_HEAL1",		
"G_COOK",		"G_WEAPON",		"G_KNIFE",		"G_PGOD",		
"G_PDOG",		"G_PFLEET",		"G_PELAST",		"G_PSHROO",		
"G_ABVEST",		"G_AAVEST",		"G_AMASK",		"G_BAT",		
"G_HEAD",		"G_1UP",		"G_3UP",		"N_SPAWN2",		
"P_PLAYSP",		"LG_1SEE",		"LG_1SEEA",		"LG_1SEE3",		
"LG_OUCH",		"LG_1DIE",		"LG_1BOO",		"HG_1SEE",		
"HG_2SEE",		"HG_OUCH",		"HG_DIE",		"OP_1SEE",		
"OP_FNET",		"OP_OUCH",		"OP_DIE",		"ST_1SEE",		
"ST_ROLL",		"ST_OUCH",		"ST_DIE",		"BL_1SEE",		
"BL_2SEE",		"BL_STEAL",		"BL_OUCH",		"BL_DIE",
"BL_PLEAD",		"BL_PLEA2",		"BL_PLEA3",		"EN_SEE",	
"EN_FIRE",		"EN_THROW",		"EN_OUCH",		"EN_DIE",
"MO_SEE",		"MO_DRAIN",		"MO_OUCH",		"MO_DIE",		
"FM_SEE",		"FM_FIRE",		"FM_OUCH",		"FM_DIE",		
"RO_SEE",		"RO_FIRE",		"RO_DIE",		"DA_SEE",		
"DA_WARN",		"DA_HIDE",		"DA_DIE",		"DA_SAY1",		
"DA_SAY2",		"DA_SAY3",		"KR_SEE",		"KR_MOTOR",		
"KR_TURN",		"KR_DROP",		"KR_MINE",		"KR_MIHIT",		
"KR_DIE",		"KR_SAY1",		"KR_SAY2",		"KR_SAY3",		
"NM_SEE",		"NM_READY",		"NM_APART",		"NM_UFO",		
"DM_SEE",		"DM_FIRE1",		"DM_FIRE2",		"DM_FIRE3",		
"DM_FIRE4",		"DM_CHARG",		"DM_FLOAT",		"DM_DIE",
"DM_SAY1",		"DM_SAY2",		"DM_SAY3",		"SN_SEE",		
"SN_READY",		"SN_CHARG",		"SN_OUCH",		"SN_DIE",		
"SN_FIRE",		"SN_SAY1",		"SN_SAY2",		"SN_SAY3",		
"E_EMPUP",		"E_EMPFIR",		"E_BIGEMP",		"D_OPEN",		
"D_CLOSE",		"D_DRHIT",		"E_FCHUTE",		"E_FBALL",		
"E_FBALHT",		"E_SPINBL",		"E_PWALL",		"E_WALHIT",		
"E_WALL",		"E_TWALL",		"E_BOULST",		"E_BOULRL",		
"E_PITFAL",		"E_FJET",		"A_SQUISH",		"A_BURNED",		
"A_SKELTN",		"E_SPEAR",		"E_CYLIN",		"E_ELEVST",		
"E_ELEVEN",		"E_SPRING",		"E_THUND2",		"E_WIND7",		
"SE_DFISH",		"SE_USUCK",		"SE_SILMV",		"SE_SILSL",		
"SE_SILES",		"A_THUMP",		"A_GIBSPL",		"A_OOF",		
NULL
};
#endif

int MUSIC_GetPosition( void )
{
	songposition pos;

	MUSIC_GetSongPosition( &pos );
	return pos.milliseconds;
}

void MUSIC_SetPosition( int time )
{
	MUSIC_SetSongTime( ( unsigned long )time );
}


//***************************************************************************
//
// SoundNumber
//
//***************************************************************************

int SoundNumber ( int x )
{
//	if ((x>=SD_REMOTEM1SND) && (x<=SD_REMOTEM10SND))
//		return remotestart + x - SD_REMOTEM1SND;
//		sounds[x].snds[soundtype]+remotestart;
//	else
//		return sounds[x].snds[soundtype]+soundstart;
	return sounds[x].snds[soundtype];
}


//***************************************************************************
//
// SD_MakeCacheable - Make a sound that has just finished playing cacheable again
//
//***************************************************************************
void SD_MakeCacheable( unsigned long sndnum )
{
	if (sndnum == (unsigned long) -1)
		{
		return;
		}

	if (sndnum>=MAXSOUNDS)
		{
		SoftError ("Illegal sound value in SD_MakeCacheable value=%ld\n",sndnum);
		return;
		}
	sounds[sndnum].count--;
	if (sounds[sndnum].count>0)
		return;
	else
	{
//		W_CacheLumpNum(SoundNumber(sndnum),PU_CACHE);
		W_CacheSoundLumpNum(SoundNumber(sndnum),PU_CACHE);
		sounds[sndnum].count=0;
	}
}

#if 0
//***************************************************************************
//
// SD_PrintActive
//
//***************************************************************************
void SD_PrintActive ( void )
{
	int i;

	myprintf("Active Sounds\n");
	for (i=0;i<MAXSOUNDS;i++)
		{
		if (sounds[i].count>0)
			{
			myprintf("sound active #%ld\n",i);
			}
		}
}
#endif

//***************************************************************************
//
// SD_SetupFXCard - Initialize sound Tables and start up sound card
//
//***************************************************************************

int SD_SetupFXCard ( int * numvoices, int * numbits, int * numchannels)
{
	fx_device device;
	int status;
	int card;

	FXMode = 2;

	if (SD_Started==true)
		SD_Shutdown();

	if ( ( FXMode < 0 ) || ( FXMode >= 11 ) )
		{
		return( 0 );
		}

	card = fxnums[ FXMode ];
	if (card==-1) // Check if it is off
		return (0);
//	if ( ( card == SoundBlaster ) || ( card == Awe32 ) )
	if(0)
	{
//		extern fx_blaster_config SBSettings;
//		status = FX_SetupSoundBlaster( SBSettings, numvoices,
//			numbits, numchannels );
	}
	else
	{
		status=FX_SetupCard( card, &device );
		if ( status == FX_Ok )
		{
			*numvoices=device.MaxVoices;
			*numbits=device.MaxSampleBits;
			*numchannels=device.MaxChannels;
		}
	}

	return (status);
	}

//***************************************************************************
//
// SD_Startup - Initialize sound Tables and start up sound card
//
//***************************************************************************

int SD_Startup ( boolean bombonerror )
{
	int status;
	int card;
	int voices;
	int channels;
	int bits;
	int i;
	extern boolean IS8250;

	if (SD_Started==true)
		SD_Shutdown();

	if ( ( FXMode < 0 ) || ( FXMode >= 11 ) )
		{
		return( 0 );
		}
	card = fxnums[ FXMode ];
	if (card==-1) // Check if it is off
		return (0);

	switch (card)
		{
		case UltraSound:
		case SoundBlaster:
		case SoundMan16:
		case ProAudioSpectrum:
		case Awe32:
		case SoundSource:
		case TandySoundSource:
		case SoundScape:
			soundstart=W_GetNumForName("digistrt")+1;
			soundtype=fx_digital;
			break;
		case Adlib:
			soundstart=W_GetNumForName("adstart")+1;
			soundtype=fx_muse;
			break;
		case PC:
			soundstart=W_GetNumForName("pcstart")+1;
			soundtype=fx_muse;
			break;
		default:
			Error("FX: Unsupported Card number %d",FXMode);
			break;
		}
	
//	rott_sndstrt = soundstart;
//	rott_sndstop = soundstart + SD_LASTSOUND;

	if ( soundtype == fx_digital )
	{
		if ( SoundsRemapped == false )
		{
			for( i = 0; i < SD_LASTSOUND; i++ )
			{
				int snd;

				snd = sounds[ i ].snds[ fx_digital ];
				if ( snd >= 0)
				{
//					sounds[ i ].snds[ fx_digital ] = W_GetNumForName(
//						W_GetNameForNum( snd + soundstart ) );
					
					sounds[ i ].snds[ fx_digital ] =
						W_CheckNumForName( sound_names[snd+1] );
				}
			}
			SoundsRemapped = true;
		}
		soundstart = 0;
	}

	voices	= NumVoices;
	channels = NumChannels;
	bits	= NumBits;

	if ( IS8250 )
		{
		voices	= max( voices, 4 );
		channels = 1;
		bits	= 8;
		}

	status=FX_Init( card, voices, channels, bits, 11000 );

	if (status != FX_Ok)
		{
		if (bombonerror)
			{
			DeleteSoundFile ();
			Error( "%s\n", FX_ErrorString( status ) );
			}

		return (status);
		}

	if (stereoreversed == true)
		{
		FX_SetReverseStereo(!FX_GetReverseStereo());
		}

	FX_SetCallBack( SD_MakeCacheable );

//	remotestart=W_GetNumForName("remostrt")+1;

	SD_Started=true;

	FX_SetVolume (FXvolume);

	return (0);
}

//***************************************************************************
//
// SD_SoundOkay - checks to see if the sound is okay
//
//***************************************************************************

boolean SD_SoundOkay ( int sndnum )
{
	if (SD_Started==false)
		return false;

	if (sndnum>=MAXSOUNDS)
		Error ("Illegal sound number, sound number = %d\n",sndnum);

	if (SoundOffset(sndnum)==-1)
		return false;

	if ( ( sounds[ sndnum ].flags & SD_PLAYONCE ) &&
		( SD_SoundActive( sounds[ sndnum ].prevhandle ) ) )
		{
		return false;
		}

	return true;
}

//***************************************************************************
//
// SD_PlayIt - Play a pre-setup sound
//
//***************************************************************************

int SD_PlayIt ( int sndnum, int angle, int distance, int pitch )
{
	int voice;
	byte * snd;

#if (DEVELOPMENT == 1)
#if (SOUNDTEST == 1)
	SoftError("SOUND =%d \n",sndnum);
#endif
#endif

	if (!(sounds[sndnum].flags & SD_WRITE))
	{
		if (sounds[sndnum].count)
		{
			if (distance<=sounds[sndnum].prevdistance)
				FX_StopSound(sounds[sndnum].prevhandle);
			else
			{
//				printf("SD_PlayIt: Count Cull, %X\n", sndnum);
				return 0;
			}
		}
	}

	if ( !FX_VoiceAvailable( sounds[sndnum].priority ) )
	{
		printf("SD_PlayIt: No Voice Available, %d\n", sounds[sndnum].priority);
		return( 0 );
	}

	sounds[sndnum].count++;

	printf("SD_PlayIt: %X %s\n", sndnum,
		W_GetNameForNum(SoundNumber(sndnum)));

//	snd=W_CacheLumpNum(SoundNumber(sndnum),PU_STATIC);
	snd=W_CacheSoundLumpNum(SoundNumber(sndnum),PU_STATIC);

	if ( *snd == 'C' )
		{
		voice = FX_PlayVOC3D( snd, pitch, angle, distance,
			sounds[sndnum].priority, (unsigned long) sndnum );
		}
	else
		{
		voice = FX_PlayWAV3D( snd, pitch, angle, distance,
			sounds[sndnum].priority, (unsigned long) sndnum );
		}

	if ( voice < FX_Ok )
		{
#if (DEVELOPMENT == 1)
/*
		if (MV_ErrorCode == MV_InvalidVOCFile)
			{
			Error("SD_PlayIt: Invalid VOC File snd=%p sndnum=%ld lump=%ld\n",snd,sndnum,SoundNumber(sndnum));
			}
*/
		NumBadSounds++;
		SoftError("SD_PlayIt: Error/Warning %s\n",FX_ErrorString( FX_Error ));
		SoftError("BadSoundNumber %ld time %ld\n",NumBadSounds,ticcount);
#endif
		SD_MakeCacheable( sndnum );

		return 0;
		}

	NumBadSounds=0;

	if (!(sounds[sndnum].flags & SD_WRITE))
		{
		sounds[sndnum].prevhandle=voice;
		sounds[sndnum].prevdistance=distance;
		}
	return voice;
}


//***************************************************************************
//
// SD_Play - Play a sample
//
//***************************************************************************

int SD_Play ( int sndnum )
{
	int voice;
	int pitch;

	if ( SD_SoundOkay ( sndnum ) == false )
	{
		printf("SD_Play3D: Not OK, %X\n", sndnum);
		return 0;
	}

	pitch = 0;

	if ( !( sounds[ sndnum ].flags & SD_PITCHSHIFTOFF ) )
		{
		pitch = PitchOffset();
		}

	voice = SD_PlayIt ( sndnum, 0, 0, pitch );

	return voice;

}

//***************************************************************************
//
// SD_Play3D - Play a positioned sample
//
//***************************************************************************

int SD_Play3D ( int sndnum, int angle, int distance )
{
	int voice;
	int pitch;

	if ( SD_SoundOkay ( sndnum ) == false )
	{
		printf("SD_Play3D: Not OK, %X\n", sndnum);
		return 0;
	}

	pitch = 0;
	if ( !( sounds[ sndnum ].flags & SD_PITCHSHIFTOFF ) )
		{
		pitch = PitchOffset();
		}

	voice = SD_PlayIt ( sndnum, angle, distance, pitch );

	return voice;

}

//***************************************************************************
//
// SD_PlayPositionedSound - Play a positioned sample
//
//***************************************************************************

int SD_PlayPositionedSound ( int sndnum, int px, int py, int x, int y )
{
	int voice;
	int angle;
	int distance;
	int dx;
	int dy;
	int pitch;

	if ( SD_SoundOkay ( sndnum ) == false )
	{
		printf("SD_PlayPositionedSound: Not OK, %X\n", sndnum);
		return 0;
	}

	dx=(x-px);
	dy=(py-y);

	distance=FindDistance(dx,dy) >> SD_DISTANCESHIFT;

	if (distance>255)
		return 0;

	if (distance!=0)
		{
		angle = ( atan2_appx(dx,dy) & (FINEANGLES-1) ) >> 6;
		}
	else
		{
		angle=0;
		}

	pitch = 0;

	if ( !( sounds[ sndnum ].flags & SD_PITCHSHIFTOFF ) )
		{
		pitch = PitchOffset();
		}

	voice = SD_PlayIt ( sndnum, angle, distance, pitch );

	return voice;

}

//***************************************************************************
//
// SD_PlaySoundRTP - Play a positioned sample relative to the player
//
//***************************************************************************

int SD_PlaySoundRTP ( int sndnum, int x, int y )
{
	int voice;
	int angle;
	int distance, dist2;
	int dx;
	int dy;
	int pitch;


	if ( SD_SoundOkay ( sndnum ) == false )
	{
//		printf("SD_PlaySoundRTP: Not OK, %X\n", sndnum);
		return 0;
	}

//	dx=(x-player->x);
//	dy=(player->y-y);

	dx=(x-viewx);
	dy=(viewy-y);

	distance=FindDistance(dx,dy) >> SD_DISTANCESHIFT;
	
//	dist2=((int)sqrt(((1.0*dx)*dx)+((1.0*dy)*dy))) >> SD_DISTANCESHIFT;
	dist2=distance;

#if 1
	if (distance>255)
	{
//		printf("SD_PlaySoundRTP: Distance Cull, %X, %d %d %d/%d\n",
//			sndnum,
//				dx>>SD_DISTANCESHIFT,
//				dy>>SD_DISTANCESHIFT,
//				distance, dist2);
		return 0;
	}
#endif

	if (distance!=0)
		{
		angle = ( (player->angle - atan2_appx(dx,dy)) & (FINEANGLES-1) ) >> 6;
		}
	else
		{
		angle=0;
		}

	pitch = 0;

	if ( !( sounds[ sndnum ].flags & SD_PITCHSHIFTOFF ) )
		{
		pitch = PitchOffset();
		}

	voice = SD_PlayIt ( sndnum, angle, distance, pitch );

	return voice;
}

//***************************************************************************
//
// SD_PlayPitchedSound - Play a pitched sample
//
//***************************************************************************

int SD_PlayPitchedSound ( int sndnum, int volume, int pitch )
{
	int voice;
	int distance;

	if ( SD_SoundOkay ( sndnum ) == false )
	{
		printf("SD_PlayPitchedSound: Not OK, %X\n", sndnum);
		return 0;
	}

	distance = 255 - volume;

	voice = SD_PlayIt ( sndnum, 0, distance, pitch );

	return voice;
}

//***************************************************************************
//
// SD_SetSoundPitch - sets the pitch of a sound
//
//***************************************************************************

void SD_SetSoundPitch ( int sndnum, int pitch )
{
	int status;

	if (SD_Started==false)
		return;

	if (!FX_SoundActive(sndnum))
		return;

	status=FX_SetPitch( sndnum, pitch );
	if (status != FX_Ok)
		{
#if (DEVELOPMENT == 1)
		SoftError("SD_SetSoundPitch : %s\n",FX_ErrorString( status ));
#endif
		}
}

//***************************************************************************
//
// SD_PanRTP Sound - pan a positioned sample relative to the player
//
//***************************************************************************

void SD_PanRTP ( int handle, int x, int y )
{
	int angle;
	int distance;
	int dx;
	int dy;
	int status;

	if (SD_Started==false)
		return;

	if (!FX_SoundActive(handle))
		return;

	dx=(x-player->x);
	dy=(player->y-y);

	distance=FindDistance(dx,dy) >> SD_DISTANCESHIFT;

	if (distance>255)
		return;

	if (distance!=0)
		{
		angle = ( (player->angle - atan2_appx(dx,dy)) & (FINEANGLES-1) ) >> 6;
		}
	else
		{
		angle = 0;
		}

	status = FX_Pan3D ( handle, angle, distance );

	if (status != FX_Ok)
		{
#if (DEVELOPMENT == 1)
		SoftError("SD_PanPositionedSound: %s\n",FX_ErrorString( status ));
#endif
		}
}

//***************************************************************************
//
// SD_SetPan - set the pan of a sample
//
//***************************************************************************

void SD_SetPan ( int handle, int vol, int left, int right )
{
	int status;

	if (SD_Started==false)
		return;

	if (!FX_SoundActive(handle))
		return;

	status=FX_SetPan( handle, vol, left, right );

	if (status != FX_Ok)
		{
#if (DEVELOPMENT == 1)
		SoftError("SD_SetPan: %s\n",FX_ErrorString( status ));
#endif
		}
}

//***************************************************************************
//
// SD_PanPositioned Sound - pan a positioned sample
//
//***************************************************************************

void SD_PanPositionedSound ( int handle, int px, int py, int x, int y )
{
	int angle;
	int distance;
	int dx;
	int dy;
	int status;

	if (SD_Started==false)
		return;

	if (!FX_SoundActive(handle))
		return;

	dx=(x-px);
	dy=(py-y);

	distance=FindDistance(dx,dy) >> SD_DISTANCESHIFT;

	if (distance>255)
		return;

	if (distance!=0)
		{
		angle = ( atan2_appx(dx,dy) & (FINEANGLES-1) ) >> 6;
		}
	else
		{
		angle = 0;
		}

	status=FX_Pan3D( handle, angle, distance );

	if (status != FX_Ok)
		{
#if (DEVELOPMENT == 1)
		SoftError("SD_PanPositionedSound: %s\n",FX_ErrorString( status ));
#endif
		}
}


//***************************************************************************
//
// SD_StopSound - Stop the current sound from playing
//
//***************************************************************************

void SD_StopSound ( int handle )
{
	int status;

	if (SD_Started==false)
		return;

	status=FX_StopSound( handle);

	if (status != FX_Ok)
		{
#if (DEVELOPMENT == 1)
		SoftError("SD_StopSound: %s\n",FX_ErrorString( status ));
#endif
		}
}

//***************************************************************************
//
// SD_StopAllSounds - Stop All the sounds currently playing
//
//***************************************************************************

void  SD_StopAllSounds ( void )
{
	int status;

	if (SD_Started==false)
		return;

	status=FX_StopAllSounds();

	if (status != FX_Ok)
		{
#if (DEVELOPMENT == 1)
		SoftError("SD_StopAllSounds: %s\n",FX_ErrorString( status ));
#endif
		}
}

//***************************************************************************
//
// SD_SoundActive - See if a sound is active
//
//***************************************************************************

int SD_SoundActive ( int handle )
{
	if (SD_Started==false)
		{
		return false;
		}
	else
		{
		return (FX_SoundActive(handle));
		}
}

//***************************************************************************
//
// SD_WaitSound - wait until a sound has finished
//
//***************************************************************************
void SD_WaitSound ( int handle )
{
	int time;

	IN_ClearKeysDown();

	while (FX_SoundActive(handle)!=0)
	{
		time=ticcount+1;
		while (time>ticcount)
		{
			I_PollTimer();
			I_HandleInput();
		}
		if ((LastScan) || IN_GetMouseButtons())
			break;
	}
}


//***************************************************************************
//
// SD_Shutdown - Shutdown the sound system
//
//***************************************************************************

void SD_Shutdown (void)
{
	if (SD_Started==false)
		return;

	FX_Shutdown();
	SD_Started=false;
}


//***************************************************************************
//
// SD_PreCacheSound - PreCache sound
//
//***************************************************************************

void SD_PreCacheSound ( int num )
{
	if ( SD_SoundOkay ( num ) == false )
		return;

	PreCacheLump(SoundNumber(num),PU_CACHESOUNDS+sounds[num].priority);
}

//***************************************************************************
//
// SD_PreCacheSoundGroup - PreCache sound group
//
//***************************************************************************

void SD_PreCacheSoundGroup ( int lo, int hi )
{
	int i;

	if (SD_Started==false)
		return;

	for (i=lo;i<=hi;i++)
		SD_PreCacheSound(i);
}


#if (SHAREWARE == 1)
#define MAXSONGS 18
static song_t rottsongs[MAXSONGS] = {
		{ loop_no,  song_apogee  ,"FANFARE2","Apogee Fanfare"},
		{ loop_yes, song_title	,"RISE",	"Rise"},
		{ loop_yes, song_menu	,"MMMENU",  "MMMenu"},
		{ loop_yes, song_christmas,"DEADLY", "Deadly Gentlemen"},
		{ loop_yes, song_elevator,"GOINGUP", "Going up?"},
		{ loop_yes, song_endlevel,"HOWDIDO", "How'd I do?"},
		{ loop_yes, song_secretmenu,"FISHPOLK","Fish Polka"},
		{ loop_yes, song_gameover,"YOUSUCK", "You Suck"},
		{ loop_yes, song_youwin  ,"WATZNEXT","Watz Next?"},
		{ loop_no,  song_gason	,"GAZZ!",	"Gazz!"},
		{ loop_yes, song_level	,"FASTWAY", "Goin' Down The Fast Way"},
		{ loop_yes, song_level	,"MISTACHE","Mist Ache"},
		{ loop_yes, song_level	,"OWW",	"Oww!!!"},
		{ loop_yes, song_level	,"SMOKE",	"Smoke And Mirrors"},
		{ loop_yes, song_level	,"SPRAY",	"Spray"},
		{ loop_yes, song_level	,"RUNLIKE", "Run Like Smeg"},
		{ loop_yes, song_level	,"SMOOTH",  "Havana Smooth"},
		{ loop_yes, song_level	,"CHANT",	"Chant"},
		};
#else
#define MAXSONGS 34
static song_t rottsongs[MAXSONGS] = {
		{ loop_no,  song_apogee  ,"FANFARE2","Apogee Fanfare"},
		{ loop_yes, song_title	,"RISE",	"Rise"},
		{ loop_yes, song_menu	,"MMMENU",  "MMMenu"},
		{ loop_yes, song_christmas,"DEADLY", "Deadly Gentlemen"},
		{ loop_yes, song_elevator,"GOINGUP", "Going up?"},
		{ loop_yes, song_secretmenu,"FISHPOLK","Fish Polka"},
		{ loop_yes, song_endlevel,"HOWDIDO", "How'd I do?"},
		{ loop_yes, song_gameover,"YOUSUCK", "You Suck"},
		{ loop_yes, song_cinematic2,"WATZNEXT","Watz Next?"},
		{ loop_no,  song_gason	,"GAZZ!",	"Gazz!"},
		{ loop_yes, song_level	,"FASTWAY", "Goin' Down The Fast Way"},
		{ loop_yes, song_level	,"MISTACHE","Mist Ache"},
		{ loop_yes, song_level	,"OWW",	"Oww!!!"},
		{ loop_yes, song_level	,"SMOKE",	"Smoke And Mirrors"},
		{ loop_yes, song_level	,"SPRAY",	"Spray"},
		{ loop_yes, song_level	,"RUNLIKE", "Run Like Smeg"},
		{ loop_yes, song_level	,"SMOOTH",  "Havana Smooth"},
		{ loop_yes, song_level	,"CHANT",	"Chant"},
		{ loop_yes, song_level	,"MEDIEV1A","Funeral of Queen Mary"},
		{ loop_yes, song_level	,"TASKFORC","Task Force"},
		{ loop_yes, song_level	,"KISSOFF", "KISS Off"},
		{ loop_yes, song_level	,"RADAGIO", "Adagio For Strings"},
		{ loop_yes, song_level	,"SHARDS",  "Shards"},
		{ loop_yes, song_level	,"STAIRS",  "I Choose the Stairs"},
		{ loop_yes, song_level	,"SUCKTHIS","Suck This"},
		{ loop_yes, song_level	,"EXCALIBR","Excalibur"},
		{ loop_yes, song_level	,"CCCOOL",	"CCCool"},
		{ loop_yes, song_level	,"WORK_DAY","Work Day"},
		{ loop_yes, song_level	,"WHERIZIT","Where Iz It?"},
		{ loop_no,  song_bossdie,"BOSSBLOW", "Boss Blow"},
		{ loop_yes, song_bosssee ,"HELLERO", "Hellero"},
		{ loop_yes, song_cinematic1,"EVINRUDE","Evin Rude"},
		{ loop_yes, song_youwin  ,"VICTORY", "Victory!"},
		{ loop_yes, song_dogend  ,"HERE_BOY","Here Boy"}
		};
#endif

static byte * currentsong;
static int MU_Started=false;
static int lastsongnumber=-1;
int storedposition=0;

//****************************************************************************
//
// MU_JukeBoxMenu()
//
//****************************************************************************

void MU_PlayJukeBoxSong
	(
	int which
	)

	{
	if ( ( MusicMode > 0 ) && ( MU_Started == true ) )
		{
		SetMenuHeader( rottsongs[ which ].songname );
		MU_PlaySong( which );
		}
	}


//****************************************************************************
//
// MU_JukeBoxMenu()
//
//****************************************************************************

void MU_JukeBoxRedraw
	(
	void
	)

	{
	if ( ( MusicMode > 0 ) && ( MU_Started == true ) )
		{
		SetMenuHeader( rottsongs[ lastsongnumber ].songname );
		}
	}


//****************************************************************************
//
// MU_JukeBoxMenu()
//
//****************************************************************************

void MU_JukeBoxMenu
	(
	void
	)

	{
	char *SongNames[ MAXSONGS ];
	int	i;

	for( i = 0; i < MAXSONGS; i++ )
		{
		SongNames[ i ] = rottsongs[ i ].songname;
		}

	HandleMultiPageCustomMenu( SongNames, MAXSONGS, lastsongnumber,
		"Jukebox", MU_PlayJukeBoxSong, MU_JukeBoxRedraw, false );

	if ( rottsongs[ lastsongnumber ].loopflag == loop_no )
		{
		MU_StartSong(song_level);
		}
	}

//***************************************************************************
//
// MusicStarted - see if the music is started
//
//***************************************************************************
boolean MusicStarted( void )
{
	return MU_Started;
}

//***************************************************************************
//
// MU_Startup - Initialize music stuff
//
//***************************************************************************

int MU_Startup ( boolean bombonerror )
{
	int status;
	int card;

	if (MU_Started==true)
		{
		MU_StopSong();
		MU_Shutdown();
		}
	if ( ( MusicMode < 0 ) || ( MusicMode >= 11 ) )
		{
		return( 0 );
		}
	card = musicnums[ MusicMode ];
	if (card==-1) // Check if it is off
		return (0);

	if ( ( card == SoundBlaster ) || ( card == Awe32 ) || ( card == WaveBlaster ) )
		{
		if ( SD_Started == false )
			{
			extern fx_blaster_config SBSettings;
			int numvoices;
			int numbits;
			int numchannels;

			FX_SetupSoundBlaster( SBSettings, &numvoices,
				&numbits, &numchannels );
			}
		}

	if (card== UltraSound)
		{
		MU_SetupGUSInitFile();
		}

	status=MUSIC_Init( card, MidiAddress );

	if (status != MUSIC_Ok)
		if (bombonerror)
			{
			DeleteSoundFile ();
			Error( "%s\n", MUSIC_ErrorString( status ) );
			}
		else
			return (status);

	currentsong=0;

	MU_Started=true;

	MU_SetVolume (MUvolume);

	return (0);
}

//***************************************************************************
//
// MU_Shutdown - Shutdown the music system
//
//***************************************************************************

void MU_Shutdown (void)
{
	if (MU_Started==false)
		return;
	MUSIC_Shutdown();
	MU_Started=false;
}
//***************************************************************************
//
// MU_SetupGUSInitFile - initialize GUS stuff
//
//***************************************************************************

void MU_SetupGUSInitFile( void )
{
	char filename[ 128 ];

	GetPathFromEnvironment( filename, ApogeePath, GUSMIDIINIFILE );
//	if (access (filename, F_OK) != 0)
	if (w_chkaccess (filename) != 0)
	{
		int lump;
		lump=W_GetNumForName("gusmidi");
		SaveFile (filename, W_CacheLumpNum(lump,PU_CACHE), W_LumpLength(lump));
	}
}

//***************************************************************************
//
// MU_GetNumForType - returns number of song in rottsongs of specific type
//
//***************************************************************************
int MU_GetNumForType ( int type )
{
	int i;

	for (i=0;i<MAXSONGS;i++)
		{
		if (rottsongs[i].songtype == type)
			return i;
		}
	Error("MU_GetNumForType: could not find song type in list\n");
	return -1;
}


//***************************************************************************
//
// MU_PlaySong - Play a specific song number
//
//***************************************************************************

void MU_PlaySong ( int num )
{
	if (MU_Started==false)
		return;

	if (num<0)
		return;

	if (num>=MAXSONGS)
		Error("Song number out of range\n");

	MU_StopSong();

	lastsongnumber=num;

	currentsong=W_CacheLumpName(rottsongs[num].lumpname,PU_STATIC);
	if (rottsongs[num].loopflag == loop_yes)
		MUSIC_PlaySong(currentsong,MUSIC_LoopSong);
	else
		MUSIC_PlaySong(currentsong,MUSIC_PlayOnce);
	MU_SetVolume (MUvolume);
}

//***************************************************************************
//
// MU_StopSong - Play a specific song number
//
//***************************************************************************

void MU_StopSong ( void )
{
	if (MU_Started==false)
		return;

	MUSIC_StopSong ();
	if (currentsong)
	{
		W_CacheLumpName(rottsongs[lastsongnumber].lumpname,PU_CACHE);
		currentsong=0;
	}
}

//***************************************************************************
//
// MU_GetSongNumber - get current song number
//
//***************************************************************************

int MU_GetSongNumber ( void )
{
	return lastsongnumber;
}


//***************************************************************************
//
// MU_FadeToSong - Fade to a specific song in a certain time
//
//***************************************************************************

void MU_FadeToSong ( int num, int time )
{
	int t;

	if (MU_Started==false)
		return;

	MU_FadeOut(time>>1);

	while (MU_FadeActive())
		{
		t=ticcount;
		while (ticcount==t) {}
		}

	MU_FadeIn (num,time>>1);
}

//***************************************************************************
//
// MU_FadeIn - Fade in
//
//***************************************************************************

void MU_FadeIn ( int num, int time )
{
	if (MU_Started==false)
		return;

	MUSIC_SetVolume(0);
	MU_PlaySong ( num );
	MUSIC_FadeVolume (MUvolume, time);
}

//***************************************************************************
//
// MU_FadeOut - Fade out
//
//***************************************************************************

void MU_FadeOut ( int time )
{
	if (MU_Started==false)
		return;
	if (!MUSIC_SongPlaying())
		{
#if (DEVELOPMENT == 1)
		SoftError("Called FadeOut with no song playing\n");
#endif
		return;
		}
	MUSIC_FadeVolume(0,time);
}


//***************************************************************************
//
// MU_StartSong - Start a context sensitive song
//
//***************************************************************************

void MU_StartSong ( int songtype )
{
	int songnum;

	if (MU_Started==false)
		return;

	MU_StopSong();

	songnum = MU_GetNumForType ( songtype );
	switch (songtype)
		{
		case song_level:
			if (IsChristmas())
				{
				songnum = MU_GetNumForType ( song_christmas );
				}
			else
				{
				songnum += GetSongForLevel ();
				}
			break;
		}
	MU_PlaySong (songnum);
}

//***************************************************************************
//
// MU_StoreSongPostition - Save off Song Position
//
//***************************************************************************

void MU_StoreSongPosition ( void )
{
	if (MU_Started==false)
		return;
	PositionStored=true;
	storedposition=MUSIC_GetPosition();
}

//***************************************************************************
//
// MU_RestoreSongPostition - Save off Song Position
//
//***************************************************************************

void MU_RestoreSongPosition ( void )
{
	if (MU_Started==false)
		return;
	if (PositionStored==false)
		return;
	PositionStored=false;

	MUSIC_SetPosition(storedposition);
}

//***************************************************************************
//
// MU_GetStoredPostition - Get Stored song Position
//
//***************************************************************************

int MU_GetStoredPosition ( void )
{
	if (PositionStored)
		return storedposition;
	else
		return -1;
}

//***************************************************************************
//
// MU_SetStoredPostition - Get Stored song Position
//
//***************************************************************************

void MU_SetStoredPosition ( int position )
{
	if (MU_Started==false)
		return;
	if (position==-1)
		return;
	PositionStored=true;
	storedposition=position;
}



//***************************************************************************
//
// MU_GetSongPostition - Get Song Position
//
//***************************************************************************

int MU_GetSongPosition ( void )	
{
	if (MU_Started==false)
		return 0;
	return MUSIC_GetPosition();
}

//***************************************************************************
//
// MU_SetSongPostition - Set Song Position
//
//***************************************************************************

void MU_SetSongPosition ( int position )
{
	if (MU_Started==false)
		return;
	MUSIC_SetPosition(position);
}

//***************************************************************************
//
// MU_SaveMusic
//
//***************************************************************************

void MU_SaveMusic (byte ** buf, int * size)
{
	int unitsize;
	byte *ptr;
	int vsize;
	int i;

	//
	// Size
	//

	unitsize=0;

	unitsize+=sizeof(i);
	unitsize+=sizeof(i);
	unitsize+=sizeof(i);


	*size = unitsize;
	*buf = (byte *) SafeMalloc (*size);

	ptr = *buf;

	i=MU_GetSongNumber();
	if (rottsongs[i].songtype == song_menu)
		{
		i = MU_GetNumForType ( song_level );
		if (IsChristmas())
			{
			i = MU_GetNumForType ( song_christmas );
			}
		else
			{
			i += GetSongForLevel ();
			}
		vsize=sizeof(i);
		memcpy(ptr,&i,vsize);
		ptr+=vsize;

		i=MU_GetStoredPosition();
		vsize=sizeof(i);
		memcpy(ptr,&i,vsize);
		ptr+=vsize;

		i=-1;
		vsize=sizeof(i);
		memcpy(ptr,&i,vsize);
		ptr+=vsize;
		}
	else
		{
		vsize=sizeof(i);
		memcpy(ptr,&i,vsize);
		ptr+=vsize;

		i=MU_GetSongPosition();
		vsize=sizeof(i);
		memcpy(ptr,&i,vsize);
		ptr+=vsize;

		i=MU_GetStoredPosition();
		vsize=sizeof(i);
		memcpy(ptr,&i,vsize);
		ptr+=vsize;
		}
}


//***************************************************************************
//
// MU_LoadMusic
//
//***************************************************************************

void MU_LoadMusic (byte * buf, int size)
{
	int unitsize;
	byte *ptr;
	int i;
	int songnumber;
	boolean differentsong=false;
	int vsize;

	//
	// Size
	//

	unitsize=0;

	unitsize+=sizeof(i);
	unitsize+=sizeof(i);
	unitsize+=sizeof(i);

	if (size!=unitsize)
		Error("LoadMusic: Different number of parameters\n");

	ptr  = buf;

	vsize=sizeof(songnumber);
	memcpy(&songnumber,ptr,vsize);
	ptr+=vsize;
	if (MU_GetSongNumber () != songnumber)
		{
		MU_PlaySong(songnumber);
		differentsong=true;
		}

	vsize=sizeof(i);
	memcpy(&i,ptr,vsize);
	ptr+=vsize;
	if (differentsong==true)
		{
		MU_SetSongPosition(i);
		}

	vsize=sizeof(i);
	memcpy(&i,ptr,vsize);
	ptr+=vsize;
	MU_SetStoredPosition(i);

	// Check if game was saved with NOSOUND

	if (MU_GetSongNumber () != songnumber)
		{
		MU_StartSong ( song_level );
		}
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA	02111-1307, USA.

*/

#include "rt_def.h"
//#include <malloc.h>
//#include <dos.h>
#include <string.h>
#include "sprites.h"
#include <stdio.h>
#include <stdlib.h>
#include "rt_stat.h"
#include "z_zone.h"
#include "lumpy.h"
#include "rt_util.h"
#include "rt_draw.h"
#include "rt_ted.h"
#include "rt_door.h"
#include "rt_main.h"
#include "w_wad.h"
#include "rt_main.h"
#include "rt_rand.h"
#include "rt_menu.h"
#include "rt_sound.h"
#include "_rt_stat.h"
#include "rt_net.h"
#include "rt_view.h"
#include "isr.h"
//MED
// #include "memcheck.h"


/*
=============================================================================

Global Variables																																																																	GLOBAL VARIABLES

=============================================================================
*/

statobj_t		*firstactivestat,*lastactivestat;
statobj_t		*firstemptystat,*lastemptystat;

wall_t			switches[MAXSWITCHES],*lastswitch;
respawn_t		*firstrespawn,*lastrespawn;
statobj_t	*FIRSTSTAT,*LASTSTAT,*sprites[MAPSIZE][MAPSIZE];
animwall_t	animwalls[MAXANIMWALLS];

dirtype opposite[9] =
	{west,southwest,south,southeast,east,northeast,north,northwest,nodir};


statinfo stats[NUMSTATS] =
{
{0,SPR0_YLIGHT, stat_ylight,FL_LIGHT|FL_SHOOTABLE,0,0,2},
{0,SPR1_RLIGHT, stat_rlight,FL_LIGHT|FL_SHOOTABLE,0,0,2},
{0,SPR2_GLIGHT, stat_glight,FL_LIGHT|FL_SHOOTABLE,0,0,2},
{0,SPR3_BLIGHT, stat_blight,FL_LIGHT|FL_SHOOTABLE,0,0,2},
{0,SPR4_CHAND, stat_chandelier,FL_LIGHT|FL_SHOOTABLE,0,0,2},
{0,SPR5_LAMPOFF, stat_lamp,FL_LIGHT|FL_BLOCK|FL_SHOOTABLE,0,0,2},
{0,SPR73_GKEY1, stat_pedgoldkey,FL_COLORED|FL_BONUS|FL_CHANGES|FL_BLOCK|FL_ACTIVE,2,16,pc_orange},
{0,SPR73_GKEY1,stat_pedsilverkey,FL_COLORED|FL_BONUS|FL_CHANGES|FL_BLOCK|FL_ACTIVE,2,16,pc_gray},
{0,SPR73_GKEY1, stat_pedironkey,FL_COLORED|FL_BONUS|FL_CHANGES|FL_BLOCK|FL_ACTIVE,2,16,pc_olive},
{0,SPR73_GKEY1,stat_pedcrystalkey,FL_COLORED|FL_BONUS|FL_CHANGES|FL_BLOCK|FL_ACTIVE,2,16,pc_red},
{0,SPR6_GIBS1,	stat_gibs1},
{0,SPR7_GIBS2,	stat_gibs2},
{0,SPR8_GIBS3,	stat_gibs3},
{0,SPR9_MONKMEAL, stat_monkmeal,FL_BONUS|FL_RESPAWN},
{0,PORRIDGE1, stat_priestporridge,FL_BONUS|FL_RESPAWN,2,6},
{0,MONKCRYSTAL11,stat_monkcrystal1,FL_BONUS|FL_ACTIVE|FL_RESPAWN,2,6},
{0,MONKCRYSTAL21,stat_monkcrystal2,FL_BONUS|FL_ACTIVE|FL_RESPAWN,2,7},
{0,ONEUP01,stat_oneup,FL_BONUS|FL_ACTIVE|FL_FULLLIGHT,2,8},
{0,THREEUP01,stat_threeup,FL_BONUS|FL_ACTIVE|FL_FULLLIGHT,2,8},
{0,TORCH1,stat_altbrazier1,FL_HEAT|FL_BLOCK|FL_ACTIVE|FL_LIGHT|FL_SHOOTABLE,2,15,2},
{0,SPR_ABRAZIER2,stat_altbrazier2,FL_HEAT|FL_BLOCK|FL_LIGHT|FL_SHOOTABLE,0,0,2},
{0,FBASIN1,stat_healingbasin,FL_BONUS|FL_CHANGES|FL_ACTIVE|FL_BLOCK,2,3},
{20,EBASIN,stat_emptybasin,FL_BLOCK|FL_SHOOTABLE,},
{0,BAT1,stat_bat,FL_BONUS|FL_ACTIVE|FL_RESPAWN|FL_WEAPON,1,16,0,0,10},
{0,KNIFE_STATUE1,stat_knifestatue,FL_BONUS|FL_CHANGES|FL_BLOCK},
{0,SPR_TWOPIST,stat_twopistol,FL_BONUS|FL_RESPAWN|FL_WEAPON,0,0,0,0,5},
{0,SPR_MP40,stat_mp40,FL_BONUS|FL_RESPAWN|FL_WEAPON,0,0,0,0,5},
{0,SPR_BAZOOKA,stat_bazooka,FL_BONUS|FL_RESPAWN|FL_WEAPON,0,0,0,0,10},
{0,SPR_FIREBOMB,stat_firebomb,FL_BONUS|FL_RESPAWN|FL_WEAPON,0,0,0,0,5},
{0,SPR_HEATSEEK,stat_heatseeker,FL_BONUS|FL_RESPAWN|FL_WEAPON,0,0,0,0,7},
{0,SPR_DRUNK,stat_drunkmissile,FL_BONUS|FL_RESPAWN|FL_WEAPON,0,0,0,0,7},
{0,SPR_FIREWALL,stat_firewall,FL_BONUS|FL_RESPAWN|FL_WEAPON,0,0,0,0,5},
{0,SPR_SPLIT,stat_splitmissile,FL_BONUS|FL_RESPAWN|FL_WEAPON,0,0,0,0,7},
{0,SPR_KES,stat_kes,FL_BONUS|FL_RESPAWN|FL_WEAPON,0,0,0,0,7},
{0,LIFEITEMA01,stat_lifeitem1,FL_BONUS|FL_ACTIVE|FL_SHOOTABLE|FL_FULLLIGHT,2,8, 2},
{0,LIFEITEMB01,stat_lifeitem2,FL_BONUS|FL_ACTIVE|FL_SHOOTABLE|FL_FULLLIGHT,2,8, 2},
{0,LIFEITEMD01,stat_lifeitem3,FL_BONUS|FL_ACTIVE|FL_SHOOTABLE|FL_FULLLIGHT,2,8, 2},
{0,LIFEITEMC01,stat_lifeitem4,FL_BONUS|FL_ACTIVE|FL_SHOOTABLE|FL_FULLLIGHT,2,15, 2},
{24,SPR32_EXPLOS,stat_tntcrate,FL_SHOOTABLE|FL_BLOCK|FL_WOODEN,0,0,3,10},
{12,SPR33_CBARREL,stat_bonusbarrel,FL_METALLIC|FL_SHOOTABLE|FL_BLOCK,0,0,3,10},
{0,TORCH1,stat_torch,FL_BLOCK|FL_LIGHT|FL_ACTIVE|FL_HEAT|FL_SHOOTABLE,2,15,2},
{30,FFLAME1,stat_floorfire,FL_HEAT|FL_BLOCK|FL_LIGHT|FL_ACTIVE|FL_SHOOTABLE,2,7,30},
{0,DIP11,stat_dipball1,FL_BONUS|FL_FULLLIGHT},
{0,DIP21,stat_dipball2,FL_BONUS|FL_FULLLIGHT},
{0,DIP31,stat_dipball3,FL_BONUS|FL_FULLLIGHT},
{0,SPR34_TOUCH1,stat_touch1,0|FL_TRANSLUCENT|FL_FADING},
{0,SPR35_TOUCH2,stat_touch2,0|FL_TRANSLUCENT|FL_FADING},
{0,SPR36_TOUCH3,stat_touch3,0|FL_TRANSLUCENT|FL_FADING},
{0,SPR37_TOUCH4,stat_touch4,0|FL_TRANSLUCENT|FL_FADING},
{20,SPR62_ETOUCH1,stat_dariantouch,FL_METALLIC|FL_BANDF|FL_SHOOTABLE|FL_BLOCK,10,3,50},
{0,SCOTHEAD1, stat_scotthead,FL_BONUS|FL_ACTIVE|FL_FULLLIGHT,4,7},

{0,SPR38_GARBAGE1,stat_garb1},
{0,SPR39_GARBAGE2,stat_garb2},
{0,SPR40_GARBAGE3,stat_garb3},

{0,SPR41_SHIT,stat_shit},
{0,SPR42_GRATE,stat_grate},
{0,SPR43_MSHARDS,stat_metalshards},
{20,SPR44_PEDESTAL,stat_emptypedestal,FL_BLOCK|FL_SHOOTABLE|FL_WOODEN,0,0,60},
{20,SPR45_ETABLE,stat_emptytable,FL_BLOCK|FL_SHOOTABLE|FL_WOODEN,0,0,100},
{16,SPR46_STOOL,stat_stool,FL_BLOCK|FL_SHOOTABLE|FL_WOODEN,0,0,25},
{0,SPR_PUSHCOLUMN1,stat_bcolumn,FL_BLOCK|FL_HEIGHTFLIPPABLE},
{0,SPR_PUSHCOLUMN1,stat_gcolumn,FL_BLOCK|FL_HEIGHTFLIPPABLE},
{0,SPR_PUSHCOLUMN1,stat_icolumn,FL_BLOCK|FL_HEIGHTFLIPPABLE},
{20,SPR50_TREE,stat_tree,FL_SHOOTABLE|FL_BLOCK},
{20,SPR51_PLANT,stat_plant,FL_SHOOTABLE|FL_BLOCK},
{20,BLUEVASE,stat_urn,FL_SHOOTABLE|FL_BLOCK},
{0,SPR54_HAY,stat_haystack,FL_SHOOTABLE|FL_BLOCK,0,0,20},
{12,SPR55_IBARREL,stat_ironbarrel,FL_METALLIC|FL_BLOCK|FL_SHOOTABLE,0,0,50},
{0,HGRATE1,stat_heatgrate,FL_LIGHT|FL_ACTIVE,2,4,0,5},
{-10,STNPOLE1,stat_standardpole,FL_SHOOTABLE|FL_BLOCK,0,0,25},
{0,PREPIT,stat_pit,FL_CHANGES},
{0,GODPOWERUP1,stat_godmode,FL_WEAPON|FL_BONUS|FL_ACTIVE|FL_RESPAWN|FL_FULLLIGHT,2,8},
{0,DOGPOWERUP1,stat_dogmode,FL_WEAPON|FL_BONUS|FL_ACTIVE|FL_RESPAWN|FL_FULLLIGHT,2,8},
{0,FLEETFEETPOWERUP1,stat_fleetfeet,FL_BONUS|FL_ACTIVE|FL_RESPAWN|FL_FULLLIGHT,2,8},
{0,ELASTICPOWERUP1, stat_elastic, FL_BONUS|FL_ACTIVE|FL_RESPAWN|FL_FULLLIGHT,2,8},
{0,MUSHROOMPOWERUP1, stat_mushroom, FL_BONUS|FL_ACTIVE|FL_RESPAWN|FL_FULLLIGHT,2,8},
{0,GASMASKPOWERUP, stat_gasmask, FL_BONUS|FL_RESPAWN},
{0,BULLETPROOFPOWERUP, stat_bulletproof, FL_BONUS|FL_RESPAWN},
{0,ASBESTOSPOWERUP, stat_asbesto, FL_BONUS|FL_RESPAWN},
{0,RANDOMPOWERUP1, stat_random, FL_BONUS|FL_ACTIVE|FL_RESPAWN,2,8},
{0,RUBBLE1, stat_rubble, FL_ACTIVE,2,10},
{0,WOODFRAG1, stat_woodfrag, FL_ACTIVE,2,14},
{0,ROBOGRDDIE1, stat_metalfrag, FL_ACTIVE,2,10},
{0,EMPTY_STATUE1,stat_emptystatue,FL_BLOCK|FL_SHOOTABLE,0,0,50},
{16,TOMLARVA1,stat_tomlarva,FL_ACTIVE|FL_SHOOTABLE|FL_BLOCK,2,4,150},
{0,BULLETHOLE,stat_bullethole,FL_TRANSLUCENT},
//MED
//{0,COLLECTOR1,stat_collector,FL_ACTIVE|FL_BONUS,2,8,-1},
{0,DOPE1,stat_collector,FL_ACTIVE|FL_BONUS,2,8,-1},
{0,SPR_MINE1,stat_mine,FL_BONUS|FL_SHOOTABLE|FL_RESPAWN,0,0,10},
{0,MISSMOKE1,stat_missmoke,FL_ACTIVE,6,4},
{0,PLATFORM1,stat_disk,FL_BLOCK|FL_HEIGHTFLIPPABLE},
{-1}
};


dirtype diagonal[9][9] =
{
/* east */	{nodir,nodir,northeast,nodir,nodir,nodir,southeast,nodir,nodir},
			{nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir},
/* north */ {northeast,nodir,nodir,nodir,northwest,nodir,nodir,nodir,nodir},
			{nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir},
/* west */	{nodir,nodir,northwest,nodir,nodir,nodir,southwest,nodir,nodir},
			{nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir},
/* south */ {southeast,nodir,nodir,nodir,southwest,nodir,nodir,nodir,nodir},
			{nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir},
			{nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir}
};

/*
=============================================================================

Local Variables																																																																	GLOBAL VARIABLES

=============================================================================
*/
static awallinfo_t animwallsinfo[MAXANIMWALLS] = {
	{3,4,"FPLACE1\0"}, //lava wall
	{3,6,"ANIMY1\0"}, //anim red
	{3,6,"ANIMR1\0"}, //anim yellow
	{40,4,"ANIMFAC1\0"}, //anim face
	{3,4,"ANIMONE1\0"}, //anim one
	{3,4,"ANIMTWO1\0"}, //anim two
	{3,4,"ANIMTHR1\0"}, //anim three
	{3,4,"ANIMFOR1\0"}, //anim four
	{3,6,"ANIMGW1\0"}, //anim grey water
	{3,6,"ANIMYOU1\0"}, //anim you do not belong
	{3,6,"ANIMBW1\0"}, //anim brown water
	{3,6,"ANIMBP1\0"}, //anim brown piston
	{3,6,"ANIMCHN1\0"}, //anim chain
	{3,6,"ANIMFW1\0"}, //anim firewall
	{3,6,"ANIMLAT1\0"}, //anim little blips
	{3,6,"ANIMST1\0"}, //anim light streams left
	{3,6,"ANIMRP1\0"}};//anim light streams right

int statcount;


void AddToFreeStaticList(statobj_t*stat)
{
	if (!firstemptystat)
	{
		firstemptystat = stat;
	}
	else
	{
		stat->statprev = lastemptystat;
		lastemptystat->statnext = stat;
	}
	lastemptystat = stat;

}


void RemoveFromFreeStaticList(statobj_t*stat)
{
	if (stat == lastemptystat)
	{
		lastemptystat = stat->statprev;
		if(lastemptystat)
			lastemptystat->statnext=NULL;
	}
	else if(stat->statnext)
	{
		stat->statnext->statprev = stat->statprev;
	}

	if (stat == firstemptystat)
	{
		firstemptystat = stat->statnext;
		if(firstemptystat)
			firstemptystat->statprev=NULL;
	}
	else if(stat->statprev)
	{
		stat->statprev->statnext = stat->statnext;
	}

	stat->statprev = NULL;
	stat->statnext = NULL;

}


/*
===============
=
= MakeStatActive
=
===============
*/

void MakeStatActive(statobj_t *x)
{
	if (!firstactivestat)
	{
		firstactivestat	= x;
		lastactivestat = x;
	}
	else
	{
		x->prevactive = lastactivestat;
		lastactivestat->nextactive = x;
		lastactivestat = x;
	}
}


/*
===============
=
= MakeStatInactive
=
===============
*/

void MakeStatInactive(statobj_t*stat)
{
	if (stat == lastactivestat)
	{
		lastactivestat = stat->prevactive;
		if(lastactivestat)
			lastactivestat->nextactive=NULL;
	}
	else if(stat->nextactive)
	{
		stat->nextactive->prevactive = stat->prevactive;
	}

	if (stat == firstactivestat)
	{
		firstactivestat = stat->nextactive;
		if(firstactivestat)
			firstactivestat->prevactive=NULL;
	}
	else if(stat->prevactive)
	{
		stat->prevactive->nextactive = stat->nextactive;
	}

	stat->prevactive = NULL;
	stat->nextactive = NULL;
}

/*
===============
=
= AddStatic
=
===============
*/

void AddStatic(statobj_t *stat)
{
	if (FIRSTSTAT)
//	if (LASTSTAT)
	{
		stat->statprev = LASTSTAT;
		LASTSTAT->statnext = stat;
		LASTSTAT = stat;
	}
	else
	{
		FIRSTSTAT = stat;
		LASTSTAT = stat;
	}
}


void RemoveStatic(statobj_t*stat)
{
	if (stat->flags & FL_ABP) //remove from active list
		MakeStatInactive(stat);

	if (stat == LASTSTAT)			// remove from master list
	{
		LASTSTAT = stat->statprev;
		if (LASTSTAT)
			LASTSTAT->statnext=NULL;
	}
	else if(stat->statnext)
	{
		stat->statnext->statprev = stat->statprev;
	}

	if (stat == FIRSTSTAT)
	{
		FIRSTSTAT = stat->statnext;
		if (FIRSTSTAT)
			FIRSTSTAT->statprev=NULL;
	}
	else if(stat->statprev)
	{
		stat->statprev->statnext = stat->statnext;
	}

	stat->statprev = NULL;
	stat->statnext = NULL;

	if (stat->flags & FL_WEAPON)
		MISCVARS->NUMWEAPONS --;

	if ((stat->flags & FL_RESPAWN) &&
			gamestate.BattleOptions.RespawnItems &&
			(!((stat->flags & FL_WEAPON ) &&
				(gamestate.BattleOptions.WeaponPersistence)
				)
			)
		)
	{
		respawn_t*temp;
	//		if ( !( (stat->flags & FL_WEAPON) &&
	//					(MISCVARS->NUMWEAPONS >= (numplayers+10))
		//			)
		// )
		{
			temp = (respawn_t *)Z_LevelMalloc(
				sizeof(respawn_t), PU_LEVELSTRUCT, NULL);

			memset (temp, 0, sizeof(*temp));
			temp->ticcount = GetRespawnTimeForItem(stat->itemnumber);
			temp->tilex = stat->tilex;
			temp->tiley = stat->tiley;
			temp->itemnumber = stat->itemnumber;
			temp->spawnz = stat->z;
			temp->linked_to = stat->linked_to;
			//SoftError("\nrespawn obj created for stattype %d with z = %d",stat->itemnumber,temp->spawnz);
			AddRespawnStatic(temp);
		}
	}

	//Z_Free(stat);
	AddToFreeStaticList(stat);

	//Add_To_Delete_Array(stat);
	statcount --;
}


void RemoveRespawnStatic(respawn_t*stat)
{
	if (stat == lastrespawn)
	{
		lastrespawn = stat->prev;
		if(lastrespawn)
			lastrespawn->next = NULL;
	}
	else if(stat->next)
	{
		stat->next->prev = stat->prev;
	}

	if (stat == firstrespawn)
	{
		firstrespawn = stat->next;
		if(firstrespawn)
			firstrespawn->prev = NULL;
	}
	else if(stat->prev)
	{
		stat->prev->next = stat->next;
	}

	stat->prev = NULL;
	stat->next = NULL;
	Z_Free(stat);
}


void TurnOffLight(int tilex,int tiley)
{
	int area;
	DoLights(tilex, tiley);
	area = MAPSPOT(tilex, tiley, 0)-AREATILE;
	if((area<0) || (area>=NUMAREAS))
		return;
	LightsInArea[area]--;
}


void ActivateLight(int light)
{
	statobj_t	*tstat;

	// tstat = (statobj_t*)light;
	tstat = T_SwizzleStatObjFromInt(light);

	tstat->shapenum ++;
	tstat->flags |= FL_LIGHTON;
	TurnOnLight(tstat->tilex,tstat->tiley);
}


void DeactivateLight(int light)
{
	statobj_t	*tstat;

	// tstat = (statobj_t*)light;
	tstat = T_SwizzleStatObjFromInt(light);

	tstat->shapenum --;
	tstat->flags &= ~(FL_LIGHTON);
	TurnOffLight(tstat->tilex,tstat->tiley);
}

void TurnOnLight(int i,int j)
{
	int area;

	area = MAPSPOT(i,j,0)-AREATILE;
	if((area<0) || (area>=NUMAREAS))
		return;

	LightsInArea[area]++;

	if (lightsource==0)
		return;

	if ((!(tilemap[i+1][j])) && (!(tilemap[i-1][j])))
	{
		SetLight(i,j,0xcdeffedc);
		SetLight(i+1,j,0x135789ab);
		SetLight(i-1,j,0xba987351);
		SetLight(i,j+1,0xcdeffedc);
		SetLight(i,j-1,0xcdeffedc);
		SetLight(i-1,j-1,0xba987351);
		SetLight(i+1,j+1,0xba987351);
		SetLight(i+1,j-1,0x135789ab);
		SetLight(i-1,j+1,0x135789ab);
	}
	else if ((!(tilemap[i][j+1])) && (!(tilemap[i][j-1])))
	{
		SetLight(i,j,0xcdeffedc);
		SetLight(i+1,j,0xcdeffedc);
		SetLight(i-1,j,0xcdeffedc);
		SetLight(i,j+1,0x135789ab);
		SetLight(i,j-1,0xba987531);
		SetLight(i-1,j-1,0x135789ab);
		SetLight(i+1,j-1,0xba987531);
		SetLight(i+1,j+1,0x135789ab);
		SetLight(i-1,j+1,0xba987531);
	}
						//	|
						//__|
	else if ((tilemap[i][j+1]) && (tilemap[i+1][j]))
	{
		SetLight(i,j,0xcdeffedc);
		SetLight(i+1,j,0xcdeffedc);
		SetLight(i-1,j,0xcdeffedc);
		SetLight(i,j+1,0xcdeffedc);
		SetLight(i,j-1,0xcdeffedc);
		SetLight(i-1,j-1,0xba987351);
		SetLight(i+1,j-1,0xba987351);
		SetLight(i+1,j+1,0xba987351);
		SetLight(i-1,j+1,0x135789ab);
	}
						//|
						//|_
	else if ((tilemap[i][j+1]) && (tilemap[i-1][j]))
	{
		SetLight(i,j,0xcdeffedc);
		SetLight(i+1,j,0xcdeffedc);
		SetLight(i-1,j,0xcdeffedc);
		SetLight(i,j+1,0xcdeffedc);
		SetLight(i,j-1,0xcdeffedc);
		SetLight(i-1,j-1,0x135789ab);
		SetLight(i+1,j-1,0xba987531);
		SetLight(i+1,j+1,0xba987531);
		SetLight(i-1,j+1,0xba987531);
	}
						//_
						// |
	else if ((tilemap[i][j-1]) && (tilemap[i+1][j]))
	{
		SetLight(i,j,0xcdeffedc);
		SetLight(i+1,j,0xcdeffedc);
		SetLight(i-1,j,0xcdeffedc);
		SetLight(i,j+1,0xcdeffedc);
		SetLight(i,j-1,0xcdeffedc);
		SetLight(i-1,j-1,0xba987531);
		SetLight(i+1,j-1,0x135789ab);
		SetLight(i+1,j+1,0x135789ab);
		SetLight(i-1,j+1,0xba987531);
	}
						//__
						//|
	else if ((tilemap[i][j-1]) && (tilemap[i-1][j]))
	{
		SetLight(i,j,0xcdeffedc);
		SetLight(i+1,j,0xcdeffedc);
		SetLight(i-1,j,0xcdeffedc);
		SetLight(i,j+1,0xcdeffedc);
		SetLight(i,j-1,0xcdeffedc);
		SetLight(i-1,j-1,0x135789ab);
		SetLight(i+1,j-1,0x135789ab);
		SetLight(i+1,j+1,0xba987531);
		SetLight(i-1,j+1,0xba987531);
	}
	else if (tilemap[i][j])
	{
		SetLight(i,j,0x58bffb85);
	}
	else
	{
		SetLight(i,j,0xcdeffedc);
		SetLight(i+1,j,0xba987654);
		SetLight(i-1,j,0x456789ab);
		SetLight(i,j+1,0xba987654);
		SetLight(i,j-1,0x456789ab);
		SetLight(i-1,j+1,0x33322211);
		SetLight(i+1,j+1,0x33322211);
		SetLight(i+1,j-1,0x11222333);
		SetLight(i-1,j-1,0x11222333);
	}
}


/*===============
=
= AddRespawnStatic
=
===============
*/

void AddRespawnStatic(respawn_t *stat)
{
	if (firstrespawn)
	{
		stat->prev = lastrespawn;
		lastrespawn->next = stat;
		lastrespawn = stat;
	}
	else
	{
		firstrespawn = stat;
		lastrespawn = stat;
	}
}


/*
===============
=
= InitStaticList
=
===============
*/

void InitStaticList (void)
{
	FIRSTSTAT = NULL;
	LASTSTAT = NULL;
	lastactivestat = NULL;
	firstactivestat = NULL;
	firstrespawn = NULL;
	lastrespawn = NULL;
	lastemptystat = NULL;
	firstemptystat = NULL;

	memset(&BulletHoles[0], 0, sizeof(BulletHoles));
		MISCVARS->BulletHoleNum = 0;

	memset(sprites,0,sizeof(sprites));
	if (loadedgame==false)
	{
		memset(switches,0,sizeof(switches));
		lastswitch = &switches[0];
	}

	statcount = 0;
}


/*
===============
=
= InitAnimatedWallList
=
===============
*/

void InitAnimatedWallList(void)
{
	int i;

	for (i=0;i<MAXANIMWALLS;i++)
		animwalls[i].active=0;
}

/*
===============
=
= SetupAnimatedWall
=
===============
*/

void SetupAnimatedWall(int which)
{
	animwall_t * aw;
	int i, l;
	int texture;

	aw = &animwalls[which];

	aw->active=1;
	aw->ticcount=animwallsinfo[which].tictime;
	aw->count = 1;

	texture=W_GetNumForName(animwallsinfo[which].firstlump);

	aw->basetexture=texture;
	aw->texture=texture;

	if (DoPanicMapping()==true)
	{
		PreCacheLump(aw->basetexture, PU_CACHEWALLS);
	}
	else
	{
		l = aw->basetexture + animwallsinfo[which].numanims;
		for (i=aw->basetexture; i<l; i++)
			PreCacheLump(i,PU_CACHEWALLS);
	}
}


/*
===============
=
= SaveStatics
=
===============
*/

void SaveStatics (byte **buffer, int * size)
{
	statobj_t * temp;
	saved_stat_type dummy;
	byte * tptr;
	int count;

	if (statcount==0)
	{
		*size=0;
		*buffer=SafeMalloc(16);
		return;
	}

	*size = statcount*sizeof(saved_stat_type);
	*buffer = (byte *)SafeMalloc(*size);
	tptr = *buffer;

	for(count=0, temp=FIRSTSTAT; temp; temp=temp->statnext)
	{
		dummy.x = temp->x;
		dummy.y = temp->y;
		dummy.z = temp->z;
		dummy.flags = temp->flags;
		dummy.ticcount = temp->ticcount;
		dummy.hitpoints = temp->hitpoints;
		dummy.shapenum = temp->shapenum;
		dummy.ammo = temp->ammo;
		dummy.count = temp->count;
		dummy.numanims = temp->numanims;
		dummy.itemnumber = temp->itemnumber;
		dummy.areanumber = temp->areanumber;
		temp->whichstat = count;
		dummy.whichstat = count++;
		dummy.linked_to = temp->linked_to;

		memcpy(tptr,&(dummy.x),sizeof(saved_stat_type));
		tptr += sizeof(saved_stat_type);
	}
}

/*
===============
=
= DoLights
=
===============
*/

void DoLights (int tilex, int tiley)
{
	if (lightsource==0)
		return;

	if (TurnOffLight0 (tilex, tiley))
		LightSourceAt(tilex,tiley) = 0;

	if (TurnOffLight1 (tilex, tiley, -1, -1))
		LightSourceAt(tilex-1,tiley-1) = 0;

	if (TurnOffLight2 (tilex, tiley, -1))
		LightSourceAt(tilex,tiley-1) = 0;

	if (TurnOffLight1 (tilex, tiley, 1, -1))
		LightSourceAt(tilex+1,tiley-1) = 0;

	if (TurnOffLight3 (tilex, tiley, 1))
		LightSourceAt(tilex+1,tiley) = 0;

	if (TurnOffLight1 (tilex, tiley, 1, 1))
		LightSourceAt(tilex+1,tiley+1) = 0;

	if (TurnOffLight2 (tilex, tiley, 1))
		LightSourceAt(tilex,tiley+1) = 0;

	if (TurnOffLight1 (tilex, tiley, -1, 1))
		LightSourceAt(tilex-1,tiley+1) = 0;

	if (TurnOffLight3 (tilex, tiley, -1))
		LightSourceAt(tilex-1,tiley) = 0;
}


/*
===============
=
= TurnOffLight0
=
===============
*/

boolean TurnOffLight0 (int tilex, int tiley)
{
	if (	IsLight(tilex-1,tiley	) ||
			IsLight(tilex-1,tiley-1) ||
			IsLight(tilex	,tiley-1) ||
			IsLight(tilex+1,tiley-1) ||
			IsLight(tilex+1,tiley	) ||
			IsLight(tilex+1,tiley+1) ||
			IsLight(tilex	,tiley+1) ||
			IsLight(tilex-1,tiley+1) )
	{
		return (false);
	}
	else
	{
		return (true);
	}
}

/*
===============
=
= TurnOffLight1
=
===============
*/

boolean TurnOffLight1 (int tilex, int tiley, int i, int j)
{
	int tempi = 2*i;
	int tempy = 2*j;

	if (	IsLight(tilex+i		,tiley	) ||
			IsLight(tilex+i		,tiley+j) ||
			IsLight(tilex			,tiley+j) ||
			IsLight(tilex			,tiley+tempy) ||
			IsLight(tilex+i		,tiley+tempy) ||
			IsLight(tilex+tempi,tiley+tempy) ||
			IsLight(tilex+tempi,tiley+j) ||
			IsLight(tilex+tempi,tiley))
		return (false);
	else
		return (true);
}


/*
===============
=
= TurnOffLight2
=
===============
*/

boolean TurnOffLight2 (int tilex, int tiley, int j)
{
	int tempy = 2*j;

	if (	IsLight(tilex-1		,tiley	) ||
			IsLight(tilex-1		,tiley+j) ||
			IsLight(tilex-1		,tiley+tempy) ||
			IsLight(tilex			,tiley+j) ||
			IsLight(tilex			,tiley+tempy) ||
			IsLight(tilex+1		,tiley) ||
			IsLight(tilex+1		,tiley+j) ||
			IsLight(tilex+1		,tiley+tempy))
		return (false);
	else
		return (true);
}


/*
===============
=
= TurnOffLight3
=
===============
*/

boolean TurnOffLight3 (int tilex, int tiley, int i)
{
	int tempx = 2*i;

	if (	IsLight(tilex			,tiley-1) ||
			IsLight(tilex+1		,tiley-1) ||
			IsLight(tilex+tempx,tiley-1) ||
			IsLight(tilex+i		,tiley) ||
			IsLight(tilex+tempx,tiley) ||
			IsLight(tilex			,tiley+1) ||
			IsLight(tilex+i		,tiley+1) ||
			IsLight(tilex+tempx,tiley+1))
		return (false);
	else
		return (true);
}


/*
======================
=
= PreCacheStaticFrames
=
======================
*/

void PreCacheStaticFrames(statobj_t*temp)
{
	int z,start,stop;
	int female=0,black=0;

	PreCacheLump(temp->shapenum+shapestart,PU_CACHESPRITES);
	for (z=0;z<temp->numanims;z++)
		PreCacheLump(temp->shapenum+shapestart+z,PU_CACHESPRITES);

	if (temp->flags & FL_ROTATING)
	{
		for (z=1;z<8;z++)
			PreCacheLump(temp->shapenum+shapestart+z,PU_CACHESPRITES);
	}

	if (temp->flags & FL_WOODEN)
	{
		start = W_GetNumForName("WFRAG1");
		stop = W_GetNumForName("WFRAG14");
		PreCacheGroup(start,stop);
	}

	if (temp->flags & FL_METALLIC)
	{
		PreCacheLump(W_GetNumForName("MSHARDS"),PU_CACHESPRITES);
		start = W_GetNumForName("ROBODIE1");
		stop = W_GetNumForName("ROBODEAD");
		PreCacheGroup(start,stop);
	}

	female = ((locplayerstate->player == 1) || (locplayerstate->player == 3));
	black = (locplayerstate->player == 2);

	if (female)
	{
		start = W_GetNumForName("FPIST11");
		stop = W_GetNumForName("FPIST13");
	}
	else if (black)
	{
		start = W_GetNumForName("BMPIST1");
		stop = W_GetNumForName("BMPIST3");
	}
	else
	{
		start = W_GetNumForName("MPIST11");
		stop = W_GetNumForName("MPIST13");
	}

	PreCacheGroup(start,stop);

	switch (temp->itemnumber)
	{

	case stat_pedgoldkey:
	case stat_pedsilverkey:
	case stat_pedironkey:
	case stat_pedcrystalkey:
		PreCacheLump(W_GetNumForName("PEDESTA"),PU_CACHESPRITES);
		break;

	case stat_bat:
		start = W_GetNumForName("EXBAT1");
		stop = W_GetNumForName("EXBAT7");
		PreCacheGroup(start,stop);
		break;
	case stat_knifestatue:
		start = W_GetNumForName("KNIFE1");
		stop = W_GetNumForName("KNIFE10");
		PreCacheGroup(start,stop);
		break;
	case stat_twopistol:
		if (female)
		{
			start = W_GetNumForName("RFPIST1");
			stop = W_GetNumForName("LFPIST3");
		}
		else if (black)
		{
			start = W_GetNumForName("RBMPIST1");
			stop = W_GetNumForName("LBMPIST3");
		}
		else
		{
			start = W_GetNumForName("RMPIST1");
			stop = W_GetNumForName("LMPIST3");
		}
		PreCacheGroup(start,stop);
		break;
	case stat_mp40:
		start = W_GetNumForName("MP401");
		stop = W_GetNumForName("MP403");
		PreCacheGroup(start,stop);
		break;
	case stat_bazooka:
		start = W_GetNumForName("BAZOOKA1");
		stop = W_GetNumForName("BAZOOKA4");
		PreCacheGroup(start,stop);
		break;
	case stat_firebomb:
		start = W_GetNumForName("FBOMB1");
		stop = W_GetNumForName("FBOMB4");
		PreCacheGroup(start,stop);
		break;
	case stat_heatseeker:
		start = W_GetNumForName("HSEEK1");
		stop = W_GetNumForName("HSEEK4");
		PreCacheGroup(start,stop);
		break;
	case stat_drunkmissile:
		start = W_GetNumForName("DRUNK1");
		stop = W_GetNumForName("DRUNK4");
		PreCacheGroup(start,stop);
		break;
	case stat_firewall:
		start = W_GetNumForName("FIREW1");
		stop = W_GetNumForName("FIREW3");
		PreCacheGroup(start,stop);
		break;
	case stat_splitmissile:
		start = W_GetNumForName("SPLIT1");
		stop = W_GetNumForName("SPLIT4");
		PreCacheGroup(start,stop);
		break;
	case stat_kes:
		start = W_GetNumForName("KES1");
		stop = W_GetNumForName("KES6");
		PreCacheGroup(start,stop);
		break;
	case stat_godmode:
		start = W_GetNumForName("GODHAND1");
		stop = W_GetNumForName("GODHAND8");
		PreCacheGroup(start,stop);
		PreCacheGroup(W_GetNumForName("VAPO1"),
			W_GetNumForName("LITSOUL"));
		PreCacheGroup(W_GetNumForName("GODFIRE1"),
			W_GetNumForName("GODFIRE4"));
		break;
	case stat_dogmode:
		start = W_GetNumForName("DOGNOSE1");
		stop = W_GetNumForName("DOGPAW4");
		PreCacheGroup(start,stop);
		break;
	}
}


/*
===============
=
= LoadStatics
=
===============
*/

void LoadStatics( byte * buffer, int size)
{
	saved_stat_type dummy;
	int stcount,i;
	statobj_t*temp;

	stcount = size/sizeof(saved_stat_type);
	InitStaticList();

	for(i=0;i<stcount;i++)
	{
		temp = (statobj_t*)Z_LevelMalloc(
			sizeof(statobj_t), PU_LEVELSTRUCT, NULL);
		if (!temp)
			Error("LoadStatics: Failed on allocation of static %ld of %ld",i,stcount);
		memset(temp,0,sizeof(*temp));
		memcpy(&(dummy.x),buffer,sizeof(saved_stat_type));
		temp->whichstat = statcount++;
		temp->x = dummy.x;
		temp->y = dummy.y;
		temp->z = dummy.z;
		temp->flags = dummy.flags;
		temp->ticcount = dummy.ticcount;
		temp->hitpoints = dummy.hitpoints;
		temp->shapenum = dummy.shapenum;
		temp->ammo = dummy.ammo;
		temp->count = dummy.count;
		temp->numanims = dummy.numanims;
		temp->itemnumber = dummy.itemnumber;
		temp->areanumber = dummy.areanumber;
		temp->linked_to = dummy.linked_to;

		temp->which = SPRITE;
		temp->tilex = temp->x >> TILESHIFT;
		temp->tiley = temp->y >> TILESHIFT;
		temp->flags &= ~FL_ABP;
		temp->visspot = &spotvis[temp->tilex][temp->tiley];

		if ((temp->itemnumber >= stat_touch1) &&
				(temp->itemnumber <= stat_touch4))
		{
			touchindices[temp->tilex][temp->tiley] = lasttouch + 1;
			lasttouch ++;
			SD_PreCacheSoundGroup(SD_TOUCHPLATESND,SD_BADTOUCHSND);
		}

		AddStatic(temp);
		if (temp->shapenum != -1)
		{
				if (temp->itemnumber == stat_bullethole)
				{
				SetupBulletHoleLink(temp->linked_to,temp);
				}

			else if (temp->flags & FL_DEADBODY)
				{
					if ( actorat[temp->tilex][temp->tiley] == NULL )
							actorat[temp->tilex][temp->tiley] = temp;
				}

			else if (!(temp->flags & FL_NONMARK))
				{
				sprites[temp->tilex][temp->tiley] = temp;
				}

				PreCacheStaticFrames(temp);


			}
		PreCacheStaticSounds(temp->itemnumber);

		buffer += sizeof(saved_stat_type);
	}
}


void Set_NewZ_to_MapValue(
	fixed *newz, int zoffset,
	const char *errorstr, int tilex, int tiley)
{
	int zf,z;

	zoffset&=0xff;
	z=zoffset>>4;
	zf=zoffset&0xf;
	if (z==0xf)
	{
		*newz = nominalheight+64-(zf<<2);
	}
	else
	{
		if (z>levelheight)
			Error ("You specified a height of %lx for the %s at "
				"tilex=%ld tiley=%ld when\n the level is only %ld high\n",
					zoffset,errorstr,tilex,tiley,levelheight);
		else
			*newz = nominalheight-(z<<6)-(zf<<2);
	}

}

/*
===============
=
= SpawnStatic
=
===============
*/

void SpawnStatic (int tilex, int tiley, int mtype, int zoffset)
{
	statobj_t * temp;
	boolean onetimer;
	int area;

#if (SHAREWARE == 1)
	switch(mtype)
	{
	case stat_rlight:
	case stat_glight:
	case stat_ylight:
	case stat_chandelier:
		mtype = stat_blight;
		break;

	case stat_garb1:
	case stat_garb2:
	case stat_garb3:
	case stat_shit:
		mtype = stat_metalshards;
		break;

	case stat_lamp:
		mtype = stat_altbrazier2;
		break;
	}
#endif

	if ( BATTLEMODE )
	{
		if ( !gamestate.BattleOptions.SpawnWeapons )
		{
			if ( stats[ mtype ].flags & FL_WEAPON )
			{
				return;
			}
		}

		if (mtype == stat_pit)
			return;

		// Change lifeitems and extra lives to health
		switch( mtype )
		{
		case stat_lifeitem1 :
		case stat_lifeitem2 :
			mtype = stat_monkcrystal1;
			break;

		case stat_lifeitem3 :
		case stat_lifeitem4 :
		case stat_oneup :
		case stat_threeup :
			mtype = stat_monkcrystal2;
			break;
		}

		switch( mtype )
		{
		case stat_monkmeal :
		case stat_priestporridge :
		case stat_monkcrystal1 :
		case stat_monkcrystal2 :
		case stat_healingbasin :
			if (	( gamestate.Product != ROTT_SHAREWARE ) &&
					( gamestate.BattleOptions.SpawnMines ) &&
					( !IsPlatform( tilex, tiley ) &&
					( ( zoffset & 0xff00 ) != 0xb000 ) ) &&
					( zoffset == -1 ) )
			{
				mtype = stat_mine;
			}
			else if ( !gamestate.BattleOptions.SpawnHealth )
			{
				return;
			}
			break;
		}
	}

	if (!firstemptystat)
	{
		temp = (statobj_t*)Z_LevelMalloc(sizeof(statobj_t),PU_LEVELSTRUCT,NULL);
		//SoftError("\nMalloc-ing actor");
		//if (insetupgame)
		//	SoftError("in setup");
	}

	else
	{
		temp = lastemptystat;
		//SoftError("\nfree actor available");
		RemoveFromFreeStaticList(lastemptystat);
	}

	// Standard pole hack

	if ((zoffset>=14) && (zoffset<=17))
		zoffset=-1;

	if (temp)
	{
		memset(temp,0,sizeof(*temp));
		temp->shapenum = stats[mtype].picnum;
		temp->whichstat = statcount ++;
		temp->tilex = tilex;
		temp->tiley = tiley;
		temp->x = ((long)tilex << TILESHIFT) + 0x8000;
		temp->y = ((long)tiley << TILESHIFT) + 0x8000;
		area = MAPSPOT(tilex,tiley,0)-AREATILE;

		if((area<0) || (area>NUMAREAS))		//BGB: debug
			area=1;

		temp->areanumber = area;
		temp->linked_to = -1;
		if ((temp->areanumber<=0) || (temp->areanumber>NUMAREAS))
			Error ("Sprite at x=%ld y=%ld type=%ld has an illegal areanumber\n",tilex,tiley,mtype);

		if ( mtype == stat_mine )
		{
			temp->z = nominalheight;
		}
		else if (zoffset!=-1)
		{
			if ((zoffset&0xff00)==0xb000)
				Set_NewZ_to_MapValue(&(temp->z),zoffset,"static",tilex,tiley);
			else if (IsPlatform(tilex,tiley))
				temp->z = PlatformHeight(tilex,tiley);
			else if (zoffset==11)
				temp->z=-65;
			else if (zoffset==12)
				temp->z=-66;
			else
				temp->z = nominalheight;
				// Error ("You didn't specify a valid height over the sprite at tilex=%ld tiley=%ld\n",tilex,tiley);
		}
		else if (mtype>stat_chandelier)
			temp->z = nominalheight;

		temp->visspot = &spotvis[tilex][tiley];
		temp->which = SPRITE;
		temp->ticcount = stats[mtype].tictime;
		temp->hitpoints = stats[mtype].hitpoints;
		temp->itemnumber = stats[mtype].type;
		temp->flags = stats[mtype].flags;
		temp->ammo = stats[mtype].ammo;
		temp->numanims = stats[mtype].numanims;

		if(rott_iswolf)
		{
			switch	(stats[mtype].type)
			{
			case stat_bonusbarrel:
				break;

			case stat_healingbasin:
				temp->flags &= ~FL_BLOCK;
				break;
			
			default:
				temp->flags &= ~FL_SHOOTABLE;
				break;
			}
		}

		if (temp->flags & FL_BONUS)
		{
			switch	(stats[mtype].type)
			{
			case stat_lifeitem1:
			case stat_lifeitem2:
			case stat_lifeitem3:
			case stat_lifeitem4:
				gamestate.treasuretotal++;
				break;
			}
		}


		AddStatic(temp);

		onetimer = ((mtype == stat_rubble) || (mtype == stat_woodfrag) ||
								(mtype == stat_metalfrag) || (mtype == stat_missmoke)
							);

		if (DoPanicMapping())
		{
			if (temp->numanims && (!onetimer))
			{
				temp->flags &= ~FL_ACTIVE;
				temp->numanims = 0;
				GameRandomNumber("SpawnStatic",mtype);
			}
		}
		else
		{
			if (temp->numanims)
			{
				if (!onetimer)
					temp->count = (int)(((int)GameRandomNumber(
						"SpawnStatic",mtype) % stats[mtype].numanims) + 1);
				else
					temp->count = 0;
			}
			else if (temp->itemnumber == stat_standardpole)
			{
				if (MAPSPOT(temp->tilex,temp->tiley,2))
					temp->count = 2*(MAPSPOT(temp->tilex,temp->tiley,2)-14);
				else
					temp->count = 0;
			}

			if ((temp->itemnumber == stat_knifestatue) ||
					(temp->itemnumber == stat_emptystatue) ||
					(temp->itemnumber == stat_standardpole))
					temp->flags|=FL_ROTATING;
		}


		if (mtype != stat_missmoke)
			sprites[tilex][tiley] = temp;
		else
			temp->flags |= FL_NONMARK;


//================ check special junk ==================================//

		if (temp->itemnumber == stat_dariantouch)
		{
			_2Dpoint *tdptr;

			tdptr = &(MISCVARS->ETOUCH[MISCVARS->nexttouch]);

			tdptr->x = tilex;
			tdptr->y = tiley;
			sprites[tilex][tiley]->linked_to = MISCVARS->nexttouch;
			MISCVARS->nexttouch ++;
		}
		else if ((temp->itemnumber >= stat_touch1) &&
					(temp->itemnumber <= stat_touch4))
		{
			touchindices[tilex][tiley] = lasttouch + 1;
			SD_PreCacheSoundGroup(SD_TOUCHPLATESND,SD_BADTOUCHSND);
			lasttouch ++;
		}

//=====================================================================//

		PreCacheStaticFrames(temp);
		PreCacheStaticSounds(temp->itemnumber);

		if (temp->flags & FL_WEAPON)
			MISCVARS->NUMWEAPONS ++;
	}
	else
		Error("Z_LevelMalloc failed in SpawnStatic!");

}

/*
===============
=
= SpawnInertStatic
=
===============
*/

void SpawnInertStatic (int x, int y, int z, int mtype)
{
	statobj_t * temp;

	if (!firstemptystat)
	{
		temp = (statobj_t*)Z_LevelMalloc(sizeof(statobj_t),PU_LEVELSTRUCT,NULL);
		//SoftError("\nMalloc-ing actor");
		//if (insetupgame)
		//	SoftError("in setup");
	}
	else
	{
		temp = lastemptystat;
		//SoftError("\nfree actor available");
		RemoveFromFreeStaticList(lastemptystat);
	}

	if (temp)
	{
		memset(temp,0,sizeof(*temp));
		temp->shapenum = stats[mtype].picnum;

		temp->whichstat = statcount ++;
		temp->tilex = x>>16;
		temp->tiley = y>>16;
		temp->x = x;
		temp->y = y;
		temp->areanumber = MAPSPOT(temp->tilex,temp->tiley,0)-AREATILE;
		temp->linked_to = -1;
		if ((temp->areanumber<=0) || (temp->areanumber>NUMAREAS))
		{
			int tilex=temp->tilex;
			int tiley=temp->tiley;

			FindEmptyTile(&tilex,&tiley);
			temp->areanumber = MAPSPOT(tilex,tiley,0)-AREATILE;
		}
		temp->z=z;
		temp->visspot = &spotvis[temp->tilex][temp->tiley];
		temp->which = SPRITE;
		temp->ticcount = stats[mtype].tictime;
		temp->hitpoints = stats[mtype].hitpoints;
		temp->itemnumber = stats[mtype].type;
		temp->flags = (stats[mtype].flags|FL_ABP|FL_NONMARK);
		if (fog)
		{
			temp->shapenum++;
			temp->flags &= ~FL_TRANSLUCENT;
		}

		temp->ammo = stats[mtype].ammo;
		temp->numanims = stats[mtype].numanims;
		AddStatic(temp);
		MakeStatActive(temp);
	}
	else
		Error("Z_LevelMalloc failed in SpawnStatic!");

}

/*
===============
=
= SpawnSolidStatic
=
===============
*/

void SpawnSolidStatic (statobj_t * temp)
{
	if (temp->flags & FL_ACTIVE)
		temp->flags &= ~FL_ACTIVE;
	temp->hitpoints = INITIALFIRECOLOR;
	temp->flags = FL_SOLIDCOLOR|FL_SEEN|FL_ABP;
	if (	(gamestate.BattleOptions.RespawnItems) &&
			(temp->itemnumber == stat_tntcrate)	)
	{
		temp->flags |= FL_RESPAWN;
	}

	temp->ticcount = SOLIDCOLORTICTIME;
}


/*
======================
=
= PreCacheStaticSounds
=
======================
*/


void PreCacheStaticSounds (int itemnumber)
{
	if (stats[itemnumber].flags & FL_SHOOTABLE)
		SD_PreCacheSound(SD_ITEMBLOWSND);

	switch(itemnumber)
	{
	case		stat_pit:
		SD_PreCacheSound(SD_PITTRAPSND);
		break;

	case		stat_bonusbarrel:
		SD_PreCacheSound(SD_BONUSBARRELSND);
		break;

	case		stat_knifestatue:
		SD_PreCacheSound(SD_GETKNIFESND);
		break;
	case		stat_gibs1:
	case		stat_gibs2:
	case		stat_gibs3:
		SD_PreCacheSound (SD_ACTORSQUISHSND);
		break;
	case		stat_pedgoldkey:
	case		stat_pedsilverkey:
	case		stat_pedironkey:
	case		stat_pedcrystalkey:
		SD_PreCacheSound (SD_GETKEYSND);
		break;
	case		stat_monkmeal:
		SD_PreCacheSound (SD_GETHEALTH1SND);
		break;
	case		stat_monkcrystal1:
		SD_PreCacheSound (SD_GETHEALTH2SND);
		break;
	case		stat_monkcrystal2:
		SD_PreCacheSound (SD_GETHEALTH2SND);
		break;
	case		stat_priestporridge:
		SD_PreCacheSound (SD_GETHEALTH1SND);
		SD_PreCacheSound(SD_COOKHEALTHSND);
		break;

	case		stat_healingbasin:
		SD_PreCacheSound (SD_GETHEALTH2SND);
		break;

	case stat_oneup:
		SD_PreCacheSound(SD_GET1UPSND);
		break;
	case stat_threeup:
		SD_PreCacheSound(SD_GET3UPSND);
		break;

	case stat_scotthead:
		SD_PreCacheSound(SD_GETHEADSND);
		break;

	case stat_twopistol:
	case stat_mp40:
	case stat_bazooka:
	case stat_firebomb:
	case stat_heatseeker:
	case stat_drunkmissile:
	case stat_firewall:
	case stat_splitmissile:
	case stat_kes:
		SD_PreCacheSound(SD_GETWEAPONSND);
		break;

	case stat_bat:
		SD_PreCacheSound(SD_GETBATSND);
		break;

	case stat_lifeitem1:
	case stat_lifeitem2:
	case stat_lifeitem3:
	case stat_lifeitem4:
		SD_PreCacheSound(SD_GETBONUSSND);
		break;

	case stat_random:
		SD_PreCacheSound(SD_GETGODSND);
		SD_PreCacheSound(SD_GETDOGSND);
		SD_PreCacheSound(SD_GETELASTSND);
		SD_PreCacheSound(SD_GETSHROOMSSND);
		SD_PreCacheSound(SD_LOSEMODESND);
		break;

	case stat_bulletproof:
		SD_PreCacheSound(SD_GETBVESTSND);
		SD_PreCacheSound(SD_LOSEMODESND);
		break;

	case stat_gasmask:
		SD_PreCacheSound(SD_GETMASKSND);
		SD_PreCacheSound(SD_LOSEMODESND);
		break;

	case stat_asbesto:
		SD_PreCacheSound(SD_GETAVESTSND);
		SD_PreCacheSound(SD_LOSEMODESND);
		break;

	case stat_elastic:
		SD_PreCacheSound(SD_GETELASTSND);
		SD_PreCacheSound(SD_LOSEMODESND);
		break;

	case stat_fleetfeet:
		SD_PreCacheSound(SD_GETFLEETSND);
		SD_PreCacheSound(SD_LOSEMODESND);
		break;

	case stat_godmode:
		SD_PreCacheSound(SD_GETGODSND);
		SD_PreCacheSound(SD_GODMODE1SND);
		break;

	case stat_dogmode:
		SD_PreCacheSound(SD_GETDOGSND);
		break;

	case stat_mushroom:
		SD_PreCacheSound(SD_GETSHROOMSSND);
		SD_PreCacheSound(SD_LOSEMODESND);
		break;

	case stat_dipball1:
	case stat_dipball2:
	case stat_dipball3:
		SD_PreCacheSound(SD_GETBONUSSND);
		break;

	default:
		SD_PreCacheSound(SD_GETBONUSSND);
		break;
	}
}


/*
===============
=
= SaveSwitches
=
===============
*/

void SaveSwitches(byte ** buffer, int * size)
{
	int numswitches,i;
	byte * tptr;

	numswitches = lastswitch-&switches[0];
	if (numswitches==0)
	{
		*size=0;
		*buffer=SafeMalloc(16);
		return;
	}
	*size = numswitches*sizeof(wall_t);

	*buffer = (byte *)SafeMalloc(*size);
	tptr = *buffer;

	for(i=0;i<numswitches;i++)
	{
		memcpy(tptr,&switches[i],sizeof(wall_t));
		tptr += sizeof(wall_t);
	}
}


/*
===============
=
= LoadSwitches
=
===============
*/

void LoadSwitches (byte * buffer, int size)
{
	int numswitches,i,tilex,tiley;

	numswitches = size/sizeof(wall_t);

	for(i=0;i<numswitches;i++)
	{
		memcpy(&switches[i],buffer,sizeof(wall_t));
		tilex = switches[i].tilex;
		tiley = switches[i].tiley;
		actorat[tilex][tiley]=&switches[i];
		if (MAPSPOT(tilex,tiley,0) == 79) // On by default
		{
			if (!(switches[i].flags & FL_ON))
				tilemap[tilex][tiley]--;
		}
		else if (switches[i].flags & FL_W_INVERTED) // Hi masked wall
		{
			maskedwallobj_t * lastmaskobj;

			lastmaskobj=maskobjlist[tilemap[tilex][tiley]&0x3ff];
			if (switches[i].flags & FL_ON)
				lastmaskobj->toptexture++;
		}
		else if (switches[i].flags & FL_ON)
				tilemap[tilex][tiley]++;
		buffer += sizeof(wall_t);
			touchindices[tilex][tiley] = lasttouch + 1;
		lasttouch ++;
	}
	lastswitch=&switches[numswitches];
}


/*
===============
=
= SpawnSwitchThingy
=
===============
*/

void SpawnSwitchThingy(int tilex, int tiley)
{
	lastswitch->flags |= FL_SWITCH;
	lastswitch->which = WALL;
	lastswitch->tilex = tilex;
	lastswitch->tiley = tiley;
	touchindices[tilex][tiley] = lasttouch + 1;
	lasttouch ++;
	actorat[tilex][tiley] = lastswitch;
	lastswitch ++;
}

/*
===============
=
= AnimateWalls
=
===============
*/

void AnimateWalls(void)
{
	int i;
	animwall_t * aw;

	if (DoPanicMapping()==true)
		return;

	for(i=0;i<MAXANIMWALLS;i++)
	{
		aw=&animwalls[i];
		if (aw->active==0)
			continue;
		if (aw->ticcount <= 0)
		{
			if (aw->count < animwallsinfo[i].numanims)
			{
				aw->texture = aw->basetexture + aw->count;
				aw->count++;
			}
			else
			{
				aw->texture = aw->basetexture;
				aw->count = 1;
			}

			while (aw->ticcount<=0)
				aw->ticcount+=animwallsinfo[i].tictime;
		}
		else
			aw->ticcount -= tics;
	}
}


#define M_ResetSprites(x)	\
	{ if ((index == stat_dariantouch) && (!x->count))\
			{x->shapenum = stats[index].picnum;								\
			x->count = 1;																			\
			x->ticcount = stats[index].tictime;					\
			x->flags &= ~FL_BACKWARDS;										\
			x->flags &= ~FL_ACTIVE;												\
			}																								\
	}


void CheckCriticalStatics(void)
{
	respawn_t *rtemp,*ddt;
	int i,stilex,stiley;
	statobj_t*temp,*stat;

	for(rtemp = firstrespawn;rtemp;)
	{
		rtemp->ticcount --;
		ddt = rtemp->next;

		if (rtemp->ticcount <=0)
		{
			int stype;

			stilex = rtemp->tilex;
			stiley = rtemp->tiley;

			// if another weapon is there, nuke it
			if (sprites[stilex][stiley])
			{
				RemoveStatic(sprites[stilex][stiley]);
				sprites[stilex][stiley] = NULL;
			}

			if (rtemp->itemnumber == stat_tntcrate)
			{
//				RemoveStatic((statobj_t*)(rtemp->linked_to));
				RemoveStatic(T_SwizzleStatObjFromInt(rtemp->linked_to));
				stype = stat_tntcrate;
			}
			else
			{
				for(i=0;i<NUMSTATS;i++)
				{
					if (rtemp->itemnumber == stats[i].type)
					{
						stype = i;
						break;
					}
				}
			}

			SpawnStatic(stilex,stiley,stype,-1);
			LASTSTAT->z = rtemp->spawnz;
			LASTSTAT->flags |= FL_ABP;
			MakeStatActive(LASTSTAT);
			SpawnNewObj(stilex,stiley,&s_itemspawn1,inertobj);
			SD_PlaySoundRTP(SD_RESPAWNSND,new->x,new->y);
			new->flags |= FL_ABP;
			MakeActive(new);
			new->z = LASTSTAT->z;
			RemoveRespawnStatic(rtemp);
		}

		rtemp = ddt;
	}

	for (temp = firstactivestat ; temp; )
	{
		stat = temp->nextactive;

		if (temp->flags & FL_SOLIDCOLOR)
		{
			temp->ticcount--;
			if (temp->ticcount<=0)
			{
				temp->hitpoints+=SOLIDCOLORINCREMENT;
				if (temp->hitpoints>MAXFIRECOLOR)
					RemoveStatic(temp);
				else
					temp->ticcount = SOLIDCOLORTICTIME;
			}
		}
		temp = stat;
	}
}


/*
===============
=
= DoSprites
=
===============
*/

void DoSprites(void)
{
	int index,i;
	statobj_t *temp, *tempnext;


#if (0)
		Debug("\n");
#endif

	i=0;
	for(temp = firstactivestat; temp; )
	{
		tempnext = temp->nextactive;

#if (0)
		Debug("\nid: %d, shapenum: %d, numanims: %d",i++,temp->shapenum,temp->numanims);
#endif

		if ((temp->shapenum != NOTHING) && (temp->flags & FL_ACTIVE))
		{
			index = temp->itemnumber;
			temp->ticcount -= tics;
			while (temp->ticcount <= 0)
			{
				if (temp->count < temp->numanims)
				{
					temp->shapenum = stats[index].picnum + temp->count;
					if (index == stat_missmoke)
					{
						RemoveStatic(temp);
						break;
					}

					if (((index == stat_rubble) && (temp->count == 9)) ||
						((index == stat_woodfrag) && (temp->count == 13)) ||
						((index == stat_metalfrag) && (temp->count == 9)))
					{
						temp->flags &= ~FL_ACTIVE;
						break;
					}

					if (temp->flags & FL_BACKWARDS)
					{
						temp->count--;
						M_ResetSprites(temp);
					}
					else
						temp->count ++;
				}
				else if (!(temp->flags & FL_BANDF))
				{
					temp->shapenum = stats[index].picnum;
					temp->count=1;
				}
				else
				{
					temp->flags |= FL_BACKWARDS;
					temp->count --;
				}
				temp->ticcount += stats[index].tictime;
			}
		}

		temp = tempnext;
	}
}

void	SpawnStaticDamage(statobj_t * stat, int angle)
{
	GetNewActor ();
	MakeActive(new);
	NewState(new,&s_gunsmoke1);

	new->obclass = inertobj;
	new->which = ACTOR;
	new->x = (stat->x)-(costable[angle]>>4);
	new->y = (stat->y)+(sintable[angle]>>4);
	new->z = (stat->z)+stats[stat->itemnumber].heightoffset;
	new->drawx = new->x;
	new->drawy = new->y;
	new->tilex = (new->x >> TILESHIFT);
	new->tiley = (new->y >> TILESHIFT);
	new->dir = 0;
	new->speed = 0;
	new->flags = (FL_NEVERMARK|FL_ABP);
	if ((new->x<=0) || (new->y<=0))
		Error("SpawnStaticDamage: bad x,y itemnumber=%ld\n",
			stat->itemnumber);
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "sprites.h"
#include "states.h"
#include "rt_actor.h"
#include "develop.h"
#define SPRINGDELAY 3
//MED
// #include "memcheck.h"

/*
=============================================================================

					  LOW GUARD (includes sneaky)

=============================================================================
*/


extern void T_ReallyDead(objtype*ob);
extern void T_PlayDead(objtype*ob);
extern void T_Xylophone(objtype*ob);
extern void T_BloodFall(objtype*ob);
extern void SetShapeoffset(objtype*ob);
extern void RespawnPlayerobj(objtype*ob);
extern void T_ElevDisk(objtype*ob);
extern void T_Plead(objtype*ob);
extern void T_Blood(objtype*ob);
extern void T_Convert(objtype*ob);
extern void T_SlideDownScreen(objtype*ob);
extern void T_End(objtype*ob);
extern void T_Reset(objtype*ob);
extern void T_CollectorWander(objtype*ob);
extern void T_CollectorFindDoor(objtype*ob);
extern void T_AutoPath(objtype*);
extern void T_AutoRealign(objtype*);
extern void T_AutoShootAlign(objtype*);
extern void T_NME_SpinFire(objtype*);
extern void MissileMovement(objtype*);
extern void T_BatBlast(objtype*);
extern void T_DeadWait(objtype*);
extern void ActorMovement(objtype*);
extern void T_Spring(objtype*);
extern void T_SnakeFinale(objtype*);
extern void T_Special(objtype*);
extern void T_NME_Explode(objtype*);
extern void T_Guts(objtype*);
extern void T_Player(objtype*);
extern void T_ParticleGenerate(objtype*);
extern void T_Particle(objtype*);
extern void T_SpawnSoul(objtype*);
extern void T_NME_WindUp(objtype*);
extern void T_NME_Attack(objtype*);
extern void T_Saucer(objtype*);
extern void T_NMErocket(objtype*);
extern void T_NME_SpinAttack(objtype*);
extern void T_NME_HeadShoot(objtype*);
extern void T_CrushUp(objtype*);
extern void T_CrushDown(objtype*);
extern void T_HeinrichChase(objtype*);
extern void T_KristLeft(objtype*);
extern void T_KristRight(objtype*);
extern void T_KristCheckFire(objtype*);
extern void T_BoulderSpawn(objtype*);
extern void T_BoulderDrop(objtype*);
extern void T_BoulderMove(objtype*);
extern void T_DarkmonkChase(objtype*);
extern void T_DarkSnakeChase(objtype*);
extern void T_DarkSnakeSpawn(objtype*);
extern void A_DmonkAttack(objtype*);
extern void T_GenericMove(objtype*);
extern void T_Count(objtype*);
extern void T_Spears(objtype*);
extern void T_EsauSpears(objtype*);
extern void T_Spring(objtype*);
extern void T_4WayGunStand(objtype*);
extern void A_GunShoot(objtype*);
extern void A_4WayGunShoot(objtype*);
extern void T_Attack(objtype*);
extern void T_SnakePath(objtype*);
extern void T_SnakeFindPath(objtype*);
extern void T_DarkmonkLandAndFire(objtype*ob);
extern void T_DarkmonkCharge(objtype*ob);
extern void T_DarkmonkReact(objtype*ob);
extern void T_BossExplosions(objtype*ob);

statetype s_lowgrdstand	   = {true,SPR_LOWGRD_S1,0,T_Stand,ST_NULL,&s_lowgrdstand};


statetype s_lowgrdpath4    = {true,SPR_LOWGRD_W41,12,T_Path,0,&s_lowgrdpath1};
statetype s_lowgrdpath3    = {true,SPR_LOWGRD_W31,12,T_Path,SF_CLOSE,&s_lowgrdpath4};
statetype s_lowgrdpath2    = {true,SPR_LOWGRD_W21,12,T_Path,0,&s_lowgrdpath3};
statetype s_lowgrdpath1    = {true,SPR_LOWGRD_W11,12,T_Path,SF_CLOSE,&s_lowgrdpath2};

statetype s_lowgrdcollide  = {false,SPR_LOWGRD_PAIN1,0,T_Collide,0,&s_lowgrdcollide};
statetype s_lowgrdcollide2 = {false,SPR_LOWGRD_PAIN2,0,T_Collide,0,&s_lowgrdcollide2};


//statetype s_lowgrduse2     = {true,SPR_LOWGRD_USE21,5,T_Use,0,&s_lowgrdpath1};
//statetype s_lowgrduse1     = {true,SPR_LOWGRD_USE11,5,T_Use,0,&s_lowgrduse2};

statetype s_lowgrdshoot4 	= {false,SPR_LOWGRD_SHOOT4,8,ActorMovement,0,&s_lowgrdchase1};
statetype s_lowgrdshoot3   = {false,SPR_LOWGRD_SHOOT3,5,A_Shoot,0,&s_lowgrdshoot4};
statetype s_lowgrdshoot2   = {false,SPR_LOWGRD_SHOOT2,20,ActorMovement,0,&s_lowgrdshoot3};
statetype s_lowgrdshoot1 	= {false,SPR_LOWGRD_SHOOT1,6,ActorMovement,ST_NULL,&s_lowgrdshoot2};

statetype s_lowgrdchase4   = {true,SPR_LOWGRD_W41,12,T_Chase,0,&s_lowgrdchase1};
statetype s_lowgrdchase3   = {true,SPR_LOWGRD_W31,12,T_Chase,SF_CLOSE,&s_lowgrdchase4};
statetype s_lowgrdchase2   = {true,SPR_LOWGRD_W21,12,T_Chase,0,&s_lowgrdchase3};
statetype s_lowgrdchase1   = {true,SPR_LOWGRD_W11,12,T_Chase,SF_CLOSE,&s_lowgrdchase2};



statetype s_lowgrddead     = {false,SPR_LOWGRD_DEAD,0,T_Collide,ST_NULL,&s_lowgrddead};
statetype s_lowgrddie4     = {false,SPR_LOWGRD_DIE4,8,T_Collide,ST_NULL,&s_lowgrddead};
statetype s_lowgrddie3     = {false,SPR_LOWGRD_DIE3,8,T_Collide,ST_NULL,&s_lowgrddie4};
statetype s_lowgrddie2     = {false,SPR_LOWGRD_DIE2,8,T_Collide,ST_NULL,&s_lowgrddie3};
statetype s_lowgrddie1		= {false,SPR_LOWGRD_DIE1,15,T_Collide,ST_NULL,&s_lowgrddie2};


statetype s_lowgrdcrushed2		= {false,SPR_LOWGRD_DIE3,2,NULL,ST_NULL,&s_lowgrddead};
statetype s_lowgrdcrushed1		= {false,SPR_LOWGRD_DIE1,2,NULL,ST_NULL,&s_lowgrdcrushed2};

/************** Sneaky stuff *******************************************/

statetype s_sneakydown     = {false,SPR_SNEAKY_DEAD,0,T_Stand,ST_NULL,&s_sneakydown};
statetype s_sneakyrise4    = {false,SPR_RISE4,6,ActorMovement,ST_NULL,&s_lowgrdchase1};
statetype s_sneakyrise3    = {false,SPR_RISE3,6,ActorMovement,ST_NULL,&s_sneakyrise4};
statetype s_sneakyrise2    = {false,SPR_RISE2,6,ActorMovement,ST_NULL,&s_sneakyrise3};
statetype s_sneakyrise1    = {false,SPR_RISE1,6,ActorMovement,ST_NULL,&s_sneakyrise2};


/*
=============================================================================

					  HIGH GUARD

=============================================================================
*/



statetype s_highgrdstand	= {true,SPR_HIGHGRD_S1,0,T_Stand,ST_NULL,&s_highgrdstand};


statetype s_highgrdpath4   = {true,SPR_HIGHGRD_W41,12,T_Path,ST_NULL,&s_highgrdpath1};
statetype s_highgrdpath3   = {true,SPR_HIGHGRD_W31,12,T_Path,SF_CLOSE,&s_highgrdpath4};
statetype s_highgrdpath2   = {true,SPR_HIGHGRD_W21,12,T_Path,ST_NULL,&s_highgrdpath3};
statetype s_highgrdpath1   = {true,SPR_HIGHGRD_W11,12,T_Path,SF_CLOSE,&s_highgrdpath2};


//statetype s_highgrdpain1 	= {2,SPR_HIGHGRD_PAIN1,10,T_Collide,ST_NULL,&s_highgrdchase1};
//statetype s_highgrdpain2 	= {2,SPR_HIGHGRD_PAIN2,10,T_Collide,ST_NULL,&s_highgrdchase1};


statetype s_highgrdcollide  = {false,SPR_HIGHGRD_PAIN1,0,T_Collide,ST_NULL,&s_highgrdcollide};
statetype s_highgrdcollide2 = {false,SPR_HIGHGRD_PAIN2,0,T_Collide,ST_NULL,&s_highgrdcollide2};


//statetype s_highgrduse2 	 = {true,SPR_HIGHGRD_USE21,10,T_Use,ST_NULL,&s_highgrdpath1};
//statetype s_highgrduse1 	 = {true,SPR_HIGHGRD_USE11,10,T_Use,ST_NULL,&s_highgrduse2};


statetype s_highgrdshoot4  = {false,SPR_HIGHGRD_SHOOT4,3,A_Repeat,ST_NULL,&s_highgrdshoot3};
statetype s_highgrdshoot3  = {false,SPR_HIGHGRD_SHOOT3,5,A_Shoot,ST_NULL,&s_highgrdshoot4};
statetype s_highgrdshoot2  = {false,SPR_HIGHGRD_SHOOT2,6,ActorMovement,ST_NULL,&s_highgrdshoot3};
statetype s_highgrdshoot1 	= {false,SPR_HIGHGRD_SHOOT1,6,ActorMovement,ST_NULL,&s_highgrdshoot2};


statetype s_highgrdchase4  = {true,SPR_HIGHGRD_W41,12,T_Chase,ST_NULL,&s_highgrdchase1};
statetype s_highgrdchase3 = {true,SPR_HIGHGRD_W31,12,T_Chase,SF_CLOSE,&s_highgrdchase4};
statetype s_highgrdchase2 = {true,SPR_HIGHGRD_W21,12,T_Chase,ST_NULL,&s_highgrdchase3};
statetype s_highgrdchase1 = {true,SPR_HIGHGRD_W11,12,T_Chase,SF_CLOSE,&s_highgrdchase2};


statetype s_highgrddead    = {false,SPR_HIGHGRD_DEAD,0,T_Collide,ST_NULL,&s_highgrddead};
statetype s_highgrddie5    = {false,SPR_HIGHGRD_DIE5,0,T_Collide,ST_NULL,&s_highgrddead};
statetype s_highgrddie4    = {false,SPR_HIGHGRD_DIE4,8,T_Collide,ST_NULL,&s_highgrddie5};
statetype s_highgrddie3    = {false,SPR_HIGHGRD_DIE3,8,T_Collide,ST_NULL,&s_highgrddie4};
statetype s_highgrddie2    = {false,SPR_HIGHGRD_DIE2,8,T_Collide,ST_NULL,&s_highgrddie3};
statetype s_highgrddie1    = {false,SPR_HIGHGRD_DIE1,8,T_Collide,ST_NULL,&s_highgrddie2};

statetype s_highgrdcrushed2		= {false,SPR_HIGHGRD_DIE3,2,NULL,ST_NULL,&s_highgrddead};
statetype s_highgrdcrushed1		= {false,SPR_HIGHGRD_DIE1,2,NULL,ST_NULL,&s_highgrdcrushed2};

/*
===========================================================================

										 STRIKEGUARD

===========================================================================
*/


statetype s_strikestand	= {true,SPR_STRIKE_S1,0,T_Stand,ST_NULL,&s_strikestand};


statetype s_strikepath4    = {true,SPR_STRIKE_W41,12,T_Path,ST_NULL,&s_strikepath1};
statetype s_strikepath3    = {true,SPR_STRIKE_W31,12,T_Path,SF_CLOSE,&s_strikepath4};
statetype s_strikepath2    = {true,SPR_STRIKE_W21,12,T_Path,ST_NULL,&s_strikepath3};
statetype s_strikepath1    = {true,SPR_STRIKE_W11,12,T_Path,SF_CLOSE,&s_strikepath2};

statetype s_strikecollide  = {false,SPR_STRIKE_PAIN1,0,T_Collide,ST_NULL,&s_strikecollide};
statetype s_strikecollide2 = {false,SPR_STRIKE_PAIN2,0,T_Collide,ST_NULL,&s_strikecollide2};

statetype s_strikeshoot4 	= {false,SPR_STRIKE_SHOOT4,6,ActorMovement,ST_NULL,&s_strikechase1};
statetype s_strikeshoot3 	= {false,SPR_STRIKE_SHOOT3,6,ActorMovement,ST_NULL,&s_strikeshoot4};
statetype s_strikeshoot2   = {false,SPR_STRIKE_SHOOT2,5,A_Shoot,ST_NULL,&s_strikeshoot3};
statetype s_strikeshoot1   = {false,SPR_STRIKE_SHOOT1,20,ActorMovement,ST_NULL,&s_strikeshoot2};


//statetype s_strikeuse2      = {true,SPR_STRIKE_USE21,10,T_Use,ST_NULL,&s_strikechase1};
//statetype s_strikeuse1      = {true,SPR_STRIKE_USE11,10,NULL,ST_NULL,&s_strikeuse2};

statetype s_strikewait      = {true,SPR_STRIKE_S1,35,NULL,ST_NULL,&s_strikechase1};

statetype s_strikerollright6    = {false,SPR_STRIKE_LROLL6,8,T_Roll,ST_NULL,&s_strikeshoot1};
statetype s_strikerollright5    = {false,SPR_STRIKE_LROLL5,8,T_Roll,ST_NULL,&s_strikerollright6};
statetype s_strikerollright4    = {false,SPR_STRIKE_LROLL4,7,T_Reset,ST_NULL,&s_strikerollright5};
statetype s_strikerollright3    = {false,SPR_STRIKE_LROLL3,7,T_Roll,ST_NULL,&s_strikerollright4};
statetype s_strikerollright2    = {false,SPR_STRIKE_LROLL2,7,T_Roll,ST_NULL,&s_strikerollright3};
statetype s_strikerollright1    = {false,SPR_STRIKE_LROLL1,5,T_Roll,ST_NULL,&s_strikerollright2};



statetype s_strikerollleft6    = {false,SPR_STRIKE_RROLL6,8,T_Roll,ST_NULL,&s_strikeshoot1};
statetype s_strikerollleft5    = {false,SPR_STRIKE_RROLL5,8,T_Roll,ST_NULL,&s_strikerollleft6};
statetype s_strikerollleft4    = {false,SPR_STRIKE_RROLL4,7,T_Reset,ST_NULL,&s_strikerollleft5};
statetype s_strikerollleft3    = {false,SPR_STRIKE_RROLL3,7,T_Roll,ST_NULL,&s_strikerollleft4};
statetype s_strikerollleft2    = {false,SPR_STRIKE_RROLL2,7,T_Roll,ST_NULL,&s_strikerollleft3};
statetype s_strikerollleft1    = {false,SPR_STRIKE_RROLL1,5,T_Roll,ST_NULL,&s_strikerollleft2};


statetype s_strikechase4   = {true,SPR_STRIKE_W41,12,T_Chase,ST_NULL,&s_strikechase1};
statetype s_strikechase3   = {true,SPR_STRIKE_W31,12,T_Chase,SF_CLOSE,&s_strikechase4};
statetype s_strikechase2   = {true,SPR_STRIKE_W21,12,T_Chase,ST_NULL,&s_strikechase3};
statetype s_strikechase1   = {true,SPR_STRIKE_W11,12,T_Chase,SF_CLOSE,&s_strikechase2};


statetype s_strikedead3    = {false,SPR_STRIKE_DEAD3,0,T_Collide,ST_NULL,&s_strikedead3};
statetype s_strikedead2    = {false,SPR_STRIKE_DEAD2,0,T_Collide,ST_NULL,&s_strikedead3};
statetype s_strikedead     = {false,SPR_STRIKE_DEAD1,7,T_Collide,ST_NULL,&s_strikedead2};
statetype s_strikedie4     = {false,SPR_STRIKE_DIE4,7,T_Collide,ST_NULL,&s_strikedead};
statetype s_strikedie3     = {false,SPR_STRIKE_DIE3,7,T_Collide,ST_NULL,&s_strikedie4};
statetype s_strikedie2     = {false,SPR_STRIKE_DIE2,7,T_Collide,ST_NULL,&s_strikedie3};
statetype s_strikedie1     = {false,SPR_STRIKE_DIE1,7,T_Collide,ST_NULL,&s_strikedie2};


statetype s_strikecrushed2		= {false,SPR_STRIKE_DIE3,2,NULL,ST_NULL,&s_strikedead};
statetype s_strikecrushed1		= {false,SPR_STRIKE_DIE1,2,NULL,ST_NULL,&s_strikecrushed2};

/*
============================================================================

								LIGHTNING GUARD

============================================================================
*/

statetype s_blitzstand	= {true,SPR_BLITZ_S1,0,T_Stand,ST_NULL,&s_blitzstand};

statetype s_blitzpath4 = {true,SPR_BLITZ_W41,12,T_Path,ST_NULL,&s_blitzpath1};
statetype s_blitzpath3 = {true,SPR_BLITZ_W31,12,T_Path,SF_CLOSE,&s_blitzpath4};
statetype s_blitzpath2 = {true,SPR_BLITZ_W21,12,T_Path,ST_NULL,&s_blitzpath3};
statetype s_blitzpath1 = {true,SPR_BLITZ_W11,12,T_Path,SF_CLOSE,&s_blitzpath2};



statetype s_blitzcollide  = {false,SPR_BLITZ_PAIN1,0,T_Collide,ST_NULL,&s_blitzcollide};
statetype s_blitzcollide2 = {false,SPR_BLITZ_PAIN2,0,T_Collide,ST_NULL,&s_blitzcollide2};

statetype s_blitzshoot4 = {false,SPR_BLITZ_SHOOT4,10,ActorMovement,ST_NULL,&s_blitzchase1};
statetype s_blitzshoot3 = {false,SPR_BLITZ_SHOOT3,10,ActorMovement,ST_NULL,&s_blitzshoot4};
statetype s_blitzshoot2 = {false,SPR_BLITZ_SHOOT2,5,A_Shoot,ST_NULL,&s_blitzshoot3};
statetype s_blitzshoot1 = {false,SPR_BLITZ_SHOOT1,10,ActorMovement,ST_NULL,&s_blitzshoot2};

statetype s_blitzrise4 = {false,SPR_BLITZ_RISE4,8,ActorMovement,ST_NULL,&s_blitzchase1};
statetype s_blitzrise3 = {false,SPR_BLITZ_RISE3,8,ActorMovement,ST_NULL,&s_blitzrise4};
statetype s_blitzrise2 = {false,SPR_BLITZ_RISE2,8,ActorMovement,ST_NULL,&s_blitzrise3};
statetype s_blitzrise1 = {false,SPR_BLITZ_RISE1,8,ActorMovement,ST_NULL,&s_blitzrise2};

statetype s_blitzuse    = {true,SPR_BLITZ_USE,10,T_Use,ST_NULL,&s_blitzpath1};


statetype s_blitzsteal2 = {true,SPR_BLITZ_STEAL2,20,A_Steal,ST_NULL,&s_blitzchase1};
statetype s_blitzsteal1 = {true,SPR_BLITZ_STEAL1,20,ActorMovement,ST_NULL,&s_blitzsteal2};

statetype s_blitzchase4    = {true,SPR_BLITZ_W41,12,T_Chase,ST_NULL,&s_blitzchase1};
statetype s_blitzchase3    = {true,SPR_BLITZ_W31,12,T_Chase,SF_CLOSE,&s_blitzchase4};
statetype s_blitzchase2    = {true,SPR_BLITZ_W21,12,T_Chase,ST_NULL,&s_blitzchase3};
statetype s_blitzchase1    = {true,SPR_BLITZ_W11,12,T_Chase,SF_CLOSE,&s_blitzchase2};


statetype s_blitzdead2     = {false,SPR_BLITZ_DEAD2,0,T_Collide,ST_NULL,&s_blitzdead2};
statetype s_blitzdead      = {false,SPR_BLITZ_DEAD1,0,T_Collide,ST_NULL,&s_blitzdead2};
statetype s_blitzdie4      = {false,SPR_BLITZ_DIE4,7,T_Collide,ST_NULL,&s_blitzdead};
statetype s_blitzdie3      = {false,SPR_BLITZ_DIE3,7,T_Collide,ST_NULL,&s_blitzdie4};
statetype s_blitzdie2      = {false,SPR_BLITZ_DIE2,7,T_Collide,ST_NULL,&s_blitzdie3};
statetype s_blitzdie1      = {false,SPR_BLITZ_DIE1,7,T_Collide,ST_NULL,&s_blitzdie2};


statetype s_blitzstruggledead  = {false,SPR_BLITZ_RISE2,0,T_Collide,ST_NULL,&s_blitzstruggledead};
statetype s_blitzstruggledie1  = {false,SPR_BLITZ_RISE2,20,T_ReallyDead,ST_NULL,&s_blitzstruggledead};


statetype s_blitzfakedead  = {false,SPR_BLITZ_DEAD2,0,T_PlayDead,SF_FAKING,&s_blitzfakedead};
statetype s_blitzfakedie3  = {false,SPR_BLITZ_DEAD1,5,ActorMovement,ST_NULL,&s_blitzfakedead};
statetype s_blitzfakedie2  = {false,SPR_BLITZ_DIE4,5,ActorMovement,ST_NULL,&s_blitzfakedie3};
statetype s_blitzfakedie1  = {false,SPR_BLITZ_DIE3,5,ActorMovement,ST_NULL,&s_blitzfakedie2};


statetype s_blitzcrushed2     = {false,SPR_BLITZ_DIE3,2,NULL,ST_NULL,&s_blitzdead};
statetype s_blitzcrushed1		= {false,SPR_BLITZ_DIE1,2,NULL,ST_NULL,&s_blitzcrushed2};

statetype s_blitzplead11    = {false,SPR_BLITZ_PLEAD11,0,T_Collide,ST_NULL,&s_blitzplead11};
statetype s_blitzplead10    = {false,SPR_BLITZ_PLEAD10,6,NULL,ST_NULL,&s_blitzplead11};
statetype s_blitzplead9    = {false,SPR_BLITZ_PLEAD9,6,NULL,ST_NULL,&s_blitzplead10};
statetype s_blitzplead8    = {false,SPR_BLITZ_PLEAD8,6,NULL,ST_NULL,&s_blitzplead9};
statetype s_blitzplead7    = {false,SPR_BLITZ_PLEAD7,6,NULL,ST_NULL,&s_blitzplead8};




statetype s_blitzaplead4    = {false,SPR_BLITZ_PLEAD4,5,T_Plead,SF_DOWN,&s_blitzplead3};
statetype s_blitzaplead5    = {false,SPR_BLITZ_PLEAD5,5,T_Plead,SF_DOWN,&s_blitzaplead4};

statetype s_blitzplead6    = {false,SPR_BLITZ_PLEAD6,5,T_Plead,SF_DOWN,&s_blitzaplead5};
statetype s_blitzplead5    = {false,SPR_BLITZ_PLEAD5,5,T_Plead,SF_DOWN,&s_blitzplead6};
statetype s_blitzplead4    = {false,SPR_BLITZ_PLEAD4,5,T_Plead,SF_DOWN,&s_blitzplead5};
statetype s_blitzplead3    = {false,SPR_BLITZ_PLEAD3,5,T_Plead,SF_DOWN,&s_blitzplead4};
statetype s_blitzplead2    = {false,SPR_BLITZ_PLEAD2,6,ActorMovement,ST_NULL,&s_blitzplead3};
statetype s_blitzplead1    = {false,SPR_BLITZ_PLEAD1,6,ActorMovement,ST_NULL,&s_blitzplead2};



/*
============================================================================

								TRIAD ENFORCERS

============================================================================
*/


statetype s_enforcerstand	= {true,SPR_ENFORCER_S1,0,T_Stand,ST_NULL,&s_enforcerstand};


statetype s_enforcerpath4  = {true,SPR_ENFORCER_W41,12,T_Path,ST_NULL,&s_enforcerpath1};
statetype s_enforcerpath3  = {true,SPR_ENFORCER_W31,12,T_Path,SF_CLOSE,&s_enforcerpath4};
statetype s_enforcerpath2  = {true,SPR_ENFORCER_W21,12,T_Path,ST_NULL,&s_enforcerpath3};
statetype s_enforcerpath1  = {true,SPR_ENFORCER_W11,12,T_Path,SF_CLOSE,&s_enforcerpath2};


statetype s_enforcerchase4    = {true,SPR_ENFORCER_W41,12,T_Chase,ST_NULL,&s_enforcerchase1};
statetype s_enforcerchase3    = {true,SPR_ENFORCER_W31,12,T_Chase,SF_CLOSE,&s_enforcerchase4};
statetype s_enforcerchase2    = {true,SPR_ENFORCER_W21,12,T_Chase,ST_NULL,&s_enforcerchase3};
statetype s_enforcerchase1    = {true,SPR_ENFORCER_W11,12,T_Chase,SF_CLOSE,&s_enforcerchase2};

statetype s_enforcercollide  = {false,SPR_ENFORCER_PAIN1,0,T_Collide,ST_NULL,&s_enforcercollide};
statetype s_enforcercollide2 = {false,SPR_ENFORCER_PAIN2,0,T_Collide,ST_NULL,&s_enforcercollide2};


//statetype s_enforceruse2    = {true,SPR_ENFORCER_USE21,10,T_Use,ST_NULL,&s_enforcerchase1};
//statetype s_enforceruse1    = {true,SPR_ENFORCER_USE11,10,T_Use,ST_NULL,&s_enforceruse2};

statetype s_enforcershoot4 = {false,SPR_ENFORCER_SHOOT4,6,A_Repeat,ST_NULL,&s_enforcershoot3};
statetype s_enforcershoot3 = {false,SPR_ENFORCER_SHOOT3,6,A_Shoot,ST_NULL,&s_enforcershoot4};
statetype s_enforcershoot2 = {false,SPR_ENFORCER_SHOOT2,6,ActorMovement,ST_NULL,&s_enforcershoot3};
statetype s_enforcershoot1 = {false,SPR_ENFORCER_SHOOT1,6,ActorMovement,ST_NULL,&s_enforcershoot2};


statetype s_enforcerthrow8 = {false,SPR_ENFORCER_THROW8,10,ActorMovement,ST_NULL,&s_enforcerchase1};
statetype s_enforcerthrow7 = {false,SPR_ENFORCER_THROW7,10,ActorMovement,ST_NULL,&s_enforcerthrow8};
statetype s_enforcerthrow6 = {false,SPR_ENFORCER_THROW6,10,ActorMovement,ST_NULL,&s_enforcerthrow7};
statetype s_enforcerthrow5 = {false,SPR_ENFORCER_THROW5,10,A_MissileWeapon,ST_NULL,&s_enforcerthrow6};
statetype s_enforcerthrow4 = {false,SPR_ENFORCER_THROW4,10,ActorMovement,ST_NULL,&s_enforcerthrow5};
statetype s_enforcerthrow3 = {false,SPR_ENFORCER_THROW3,10,ActorMovement,ST_NULL,&s_enforcerthrow4};
statetype s_enforcerthrow2 = {false,SPR_ENFORCER_THROW2,10,ActorMovement,ST_NULL,&s_enforcerthrow3};
statetype s_enforcerthrow1 = {false,SPR_ENFORCER_THROW1,10,ActorMovement,ST_NULL,&s_enforcerthrow2};



statetype s_grenade10      = {false,SPR_ENFORCER_GR10,2,T_Projectile,ST_NULL,&s_grenade1};
statetype s_grenade9       = {false,SPR_ENFORCER_GR9,2,T_Projectile,ST_NULL,&s_grenade10};
statetype s_grenade8       = {false,SPR_ENFORCER_GR8,2,T_Projectile,ST_NULL,&s_grenade9};
statetype s_grenade7       = {false,SPR_ENFORCER_GR7,2,T_Projectile,ST_NULL,&s_grenade8};
statetype s_grenade6       = {false,SPR_ENFORCER_GR6,2,T_Projectile,ST_NULL,&s_grenade7};
statetype s_grenade5       = {false,SPR_ENFORCER_GR5,2,T_Projectile,ST_NULL,&s_grenade6};
statetype s_grenade4       = {false,SPR_ENFORCER_GR4,2,T_Projectile,ST_NULL,&s_grenade5};
statetype s_grenade3       = {false,SPR_ENFORCER_GR3,2,T_Projectile,ST_NULL,&s_grenade4};
statetype s_grenade2       = {false,SPR_ENFORCER_GR2,2,T_Projectile,ST_NULL,&s_grenade3};
statetype s_grenade1       = {false,SPR_ENFORCER_GR1,2,T_Projectile,ST_NULL,&s_grenade2};

statetype s_grenade_fall6  = {false,SPR_ENFORCER_FALL6,6,T_Projectile,ST_NULL,&s_grenade_fall6};
statetype s_grenade_fall5  = {false,SPR_ENFORCER_FALL5,6,T_Projectile,ST_NULL,&s_grenade_fall6};
statetype s_grenade_fall4  = {false,SPR_ENFORCER_FALL4,6,T_Projectile,ST_NULL,&s_grenade_fall5};
statetype s_grenade_fall3  = {false,SPR_ENFORCER_FALL3,6,T_Projectile,ST_NULL,&s_grenade_fall4};
statetype s_grenade_fall2  = {false,SPR_ENFORCER_FALL1,6,T_Projectile,ST_NULL,&s_grenade_fall3};
statetype s_grenade_fall1  = {false,SPR_ENFORCER_FALL1,6,T_Projectile,ST_NULL,&s_grenade_fall2};

statetype s_grenadehit3     = {false,SPR_GRENADE_HIT3,5,NULL,ST_NULL,NULL};
statetype s_grenadehit2     = {false,SPR_GRENADE_HIT2,5,NULL,ST_NULL,&s_grenadehit3};
statetype s_grenadehit1     = {false,SPR_GRENADE_HIT1,5,NULL,ST_NULL,&s_grenadehit2};


statetype s_enforcerdead      = {false,SPR_ENFORCER_DEAD,0,T_Collide,ST_NULL,&s_enforcerdead};
statetype s_enforcerdie4      = {false,SPR_ENFORCER_DIE4,7,T_Collide,ST_NULL,&s_enforcerdead};
statetype s_enforcerdie3      = {false,SPR_ENFORCER_DIE3,7,T_Collide,ST_NULL,&s_enforcerdie4};
statetype s_enforcerdie2      = {false,SPR_ENFORCER_DIE2,7,T_Collide,ST_NULL,&s_enforcerdie3};
statetype s_enforcerdie1      = {false,SPR_ENFORCER_DIE1,7,T_Collide,ST_NULL,&s_enforcerdie2};



statetype s_enforcercrushed2		= {false,SPR_ENFORCER_DIE3,2,NULL,ST_NULL,&s_enforcerdead};
statetype s_enforcercrushed1		= {false,SPR_ENFORCER_DIE1,2,NULL,ST_NULL,&s_enforcercrushed2};

/*
============================================================================

								 ROBOT GUARD

============================================================================
*/



statetype s_robogrdstand	= {16,SPR_ROBOGRD_S11,0,T_Stand,ST_NULL,&s_robogrdstand};

statetype s_robogrdpath1 	= {16,SPR_ROBOGRD_S11,20,T_AutoPath,ST_NULL,&s_robogrdpath1};

statetype s_robowait = {16,SPR_ROBOGRD_S11,0,NULL,ST_NULL,&s_robowait};
statetype s_roborealign = {16,SPR_ROBOGRD_S11,0,T_AutoRealign,ST_NULL,&s_roborealign};
statetype s_roboalign = {16,SPR_ROBOGRD_S11,0,T_AutoShootAlign,ST_NULL,&s_roboalign};

statetype s_robogrdshoot1 	= {false,SPR_ROBOGRD_S11,35,A_MissileWeapon,ST_NULL,&s_roborealign};

statetype s_robogrdshuriken4 	= {false,SPR_ROBOGRD_SHURIKEN4,4,T_Projectile,ST_NULL,&s_robogrdshuriken1};
statetype s_robogrdshuriken3 	= {false,SPR_ROBOGRD_SHURIKEN3,4,T_Projectile,ST_NULL,&s_robogrdshuriken4};
statetype s_robogrdshuriken2 	= {false,SPR_ROBOGRD_SHURIKEN2,4,T_Projectile,ST_NULL,&s_robogrdshuriken3};
statetype s_robogrdshuriken1  = {false,SPR_ROBOGRD_SHURIKEN1,4,T_Projectile,ST_NULL,&s_robogrdshuriken2};

statetype s_shurikenhit3    = {false,SPR_SHURIKEN_HIT3,5,NULL,ST_NULL,NULL};
statetype s_shurikenhit2    = {false,SPR_SHURIKEN_HIT2,5,NULL,ST_NULL,&s_shurikenhit3};
statetype s_shurikenhit1    = {false,SPR_SHURIKEN_HIT1,5,NULL,ST_NULL,&s_shurikenhit2};

statetype s_robogrdcollide  = {16,SPR_ROBOGRD_S11,0,T_Collide,ST_NULL,&s_robogrdcollide};
statetype s_robogrdcollide2 = {16,SPR_ROBOGRD_S11,0,T_Collide,ST_NULL,&s_robogrdcollide2};

//statetype s_robogrdchase1 	= {16,SPR_ROBOGRD_S11,10,T_RoboChase,ST_NULL,&s_robogrdchase1};

statetype s_robogrddead		= {false,ROBOGRDDEAD,0,T_Collide,ST_NULL,&s_robogrddead};
statetype s_robogrddie9	   = {false,ROBOGRDDIE9,3,T_Collide,ST_NULL,&s_robogrddead};
statetype s_robogrddie8	   = {false,ROBOGRDDIE8,3,T_Collide,ST_NULL,&s_robogrddie9};
statetype s_robogrddie7	   = {false,ROBOGRDDIE7,3,T_Collide,ST_NULL,&s_robogrddie8};
statetype s_robogrddie6	   = {false,ROBOGRDDIE6,3,T_Collide,ST_NULL,&s_robogrddie7};
statetype s_robogrddie5	   = {false,ROBOGRDDIE5,3,T_Collide,ST_NULL,&s_robogrddie6};
statetype s_robogrddie4	   = {false,ROBOGRDDIE4,3,T_Collide,ST_NULL,&s_robogrddie5};
statetype s_robogrddie3	   = {false,ROBOGRDDIE3,3,T_Collide,ST_NULL,&s_robogrddie4};
statetype s_robogrddie2	   = {false,ROBOGRDDIE2,3,T_Collide,ST_NULL,&s_robogrddie3};
statetype s_robogrddie1	   = {false,ROBOGRDDIE1,3,T_Collide,ST_NULL,&s_robogrddie2};


statetype s_bstar4 = {false,SPR_BSTAR4,1,T_Projectile,ST_NULL,&s_bstar1};
statetype s_bstar3 = {false,SPR_BSTAR3,1,T_Projectile,ST_NULL,&s_bstar4};
statetype s_bstar2 = {false,SPR_BSTAR2,1,T_Projectile,ST_NULL,&s_bstar3};
statetype s_bstar1 = {false,SPR_BSTAR1,1,T_Projectile,ST_NULL,&s_bstar2};



/*
==========================================================================
=
=                             Explosions
=
==========================================================================
*/

statetype s_altexplosion10 = {false,SPR_EXPLOSION19,3,NULL,ST_NULL,NULL};
statetype s_altexplosion9 = {false,SPR_EXPLOSION17,3,NULL,ST_NULL,&s_altexplosion10};
statetype s_altexplosion8 = {false,SPR_EXPLOSION15,3,NULL,ST_NULL,&s_altexplosion9};
statetype s_altexplosion7 = {false,SPR_EXPLOSION13,3,NULL,ST_NULL,&s_altexplosion8};
statetype s_altexplosion6 = {false,SPR_EXPLOSION11,3,NULL,ST_NULL,&s_altexplosion7};
statetype s_altexplosion5 = {false,SPR_EXPLOSION9,3,NULL,ST_NULL,&s_altexplosion6};
statetype s_altexplosion4 = {false,SPR_EXPLOSION7,3,NULL,ST_NULL,&s_altexplosion5};
statetype s_altexplosion3 = {false,SPR_EXPLOSION5,3,NULL,ST_NULL,&s_altexplosion4};
statetype s_altexplosion2 = {false,SPR_EXPLOSION3,3,T_Explosion,ST_NULL,&s_altexplosion3};
statetype s_altexplosion1 = {false,SPR_EXPLOSION1,3,NULL,ST_NULL,&s_altexplosion2};





statetype s_explosion20 = {false,SPR_EXPLOSION20,2,NULL,ST_NULL,NULL};
statetype s_explosion19 = {false,SPR_EXPLOSION19,2,NULL,ST_NULL,&s_explosion20};
statetype s_explosion18 = {false,SPR_EXPLOSION18,2,NULL,ST_NULL,&s_explosion19};
statetype s_explosion17 = {false,SPR_EXPLOSION17,2,NULL,ST_NULL,&s_explosion18};
statetype s_explosion16 = {false,SPR_EXPLOSION16,2,NULL,ST_NULL,&s_explosion17};
statetype s_explosion15 = {false,SPR_EXPLOSION15,2,NULL,ST_NULL,&s_explosion16};
statetype s_explosion14 = {false,SPR_EXPLOSION14,2,NULL,ST_NULL,&s_explosion15};
statetype s_explosion13 = {false,SPR_EXPLOSION13,2,NULL,ST_NULL,&s_explosion14};
statetype s_explosion12 = {false,SPR_EXPLOSION12,2,NULL,ST_NULL,&s_explosion13};
statetype s_explosion11 = {false,SPR_EXPLOSION11,2,NULL,ST_NULL,&s_explosion12};
statetype s_explosion10 = {false,SPR_EXPLOSION10,2,NULL,ST_NULL,&s_explosion11};
statetype s_explosion9 = {false,SPR_EXPLOSION9,2,NULL,ST_NULL,&s_explosion10};
statetype s_explosion8 = {false,SPR_EXPLOSION8,2,NULL,ST_NULL,&s_explosion9};
statetype s_explosion7 = {false,SPR_EXPLOSION7,2,NULL,ST_NULL,&s_explosion8};
statetype s_explosion6 = {false,SPR_EXPLOSION6,2,NULL,ST_NULL,&s_explosion7};
statetype s_explosion5 = {false,SPR_EXPLOSION5,2,NULL,ST_NULL,&s_explosion6};
statetype s_explosion4 = {false,SPR_EXPLOSION4,2,NULL,ST_NULL,&s_explosion5};
statetype s_explosion3 = {false,SPR_EXPLOSION3,2,T_Explosion,ST_NULL,&s_explosion4};
statetype s_explosion2 = {false,SPR_EXPLOSION2,2,NULL,ST_NULL,&s_explosion3};
statetype s_explosion1 = {false,SPR_EXPLOSION1,2,NULL,ST_NULL,&s_explosion2};



statetype s_grexplosion20 = {false,SPR_GROUNDEXPL20,2,T_Special,ST_NULL,NULL};
statetype s_grexplosion19 = {false,SPR_GROUNDEXPL19,2,NULL,ST_NULL,&s_grexplosion20};
statetype s_grexplosion18 = {false,SPR_GROUNDEXPL18,2,NULL,ST_NULL,&s_grexplosion19};
statetype s_grexplosion17 = {false,SPR_GROUNDEXPL17,2,NULL,ST_NULL,&s_grexplosion18};
statetype s_grexplosion16 = {false,SPR_GROUNDEXPL16,2,NULL,ST_NULL,&s_grexplosion17};
statetype s_grexplosion15 = {false,SPR_GROUNDEXPL15,2,NULL,ST_NULL,&s_grexplosion16};
statetype s_grexplosion14 = {false,SPR_GROUNDEXPL14,2,NULL,ST_NULL,&s_grexplosion15};
statetype s_grexplosion13 = {false,SPR_GROUNDEXPL13,2,NULL,ST_NULL,&s_grexplosion14};
statetype s_grexplosion12 = {false,SPR_GROUNDEXPL12,2,NULL,ST_NULL,&s_grexplosion13};
statetype s_grexplosion11 = {false,SPR_GROUNDEXPL11,2,NULL,ST_NULL,&s_grexplosion12};
statetype s_grexplosion10 = {false,SPR_GROUNDEXPL10,2,NULL,ST_NULL,&s_grexplosion11};
statetype s_grexplosion9 = {false,SPR_GROUNDEXPL9,2,NULL,ST_NULL,&s_grexplosion10};
statetype s_grexplosion8 = {false,SPR_GROUNDEXPL8,2,NULL,ST_NULL,&s_grexplosion9};
statetype s_grexplosion7 = {false,SPR_GROUNDEXPL7,2,NULL,ST_NULL,&s_grexplosion8};
statetype s_grexplosion6 = {false,SPR_GROUNDEXPL6,2,NULL,ST_NULL,&s_grexplosion7};
statetype s_grexplosion5 = {false,SPR_GROUNDEXPL5,2,NULL,ST_NULL,&s_grexplosion6};
statetype s_grexplosion4 = {false,SPR_GROUNDEXPL4,2,NULL,ST_NULL,&s_grexplosion5};
statetype s_grexplosion3 = {false,SPR_GROUNDEXPL3,2,T_Explosion,ST_NULL,&s_grexplosion4};
statetype s_grexplosion2 = {false,SPR_GROUNDEXPL2,2,NULL,ST_NULL,&s_grexplosion3};
statetype s_grexplosion1 = {false,SPR_GROUNDEXPL1,2,NULL,ST_NULL,&s_grexplosion2};



statetype s_staticexplosion25 = {false,SPR_STATICEXPL25,2,NULL,ST_NULL,NULL};
statetype s_staticexplosion24 = {false,SPR_STATICEXPL24,2,NULL,ST_NULL,&s_staticexplosion25};
statetype s_staticexplosion23 = {false,SPR_STATICEXPL23,2,NULL,ST_NULL,&s_staticexplosion24};
statetype s_staticexplosion22 = {false,SPR_STATICEXPL22,2,NULL,ST_NULL,&s_staticexplosion23};
statetype s_staticexplosion21 = {false,SPR_STATICEXPL21,2,NULL,ST_NULL,&s_staticexplosion22};
statetype s_staticexplosion20 = {false,SPR_STATICEXPL20,2,NULL,ST_NULL,&s_staticexplosion21};
statetype s_staticexplosion19 = {false,SPR_STATICEXPL19,2,NULL,ST_NULL,&s_staticexplosion20};
statetype s_staticexplosion18 = {false,SPR_STATICEXPL18,2,NULL,ST_NULL,&s_staticexplosion19};
statetype s_staticexplosion17 = {false,SPR_STATICEXPL17,2,NULL,ST_NULL,&s_staticexplosion18};
statetype s_staticexplosion16 = {false,SPR_STATICEXPL16,2,NULL,ST_NULL,&s_staticexplosion17};
statetype s_staticexplosion15 = {false,SPR_STATICEXPL15,2,NULL,ST_NULL,&s_staticexplosion16};
statetype s_staticexplosion14 = {false,SPR_STATICEXPL14,2,NULL,ST_NULL,&s_staticexplosion15};
statetype s_staticexplosion13 = {false,SPR_STATICEXPL13,2,NULL,ST_NULL,&s_staticexplosion14};
statetype s_staticexplosion12 = {false,SPR_STATICEXPL12,2,NULL,ST_NULL,&s_staticexplosion13};
statetype s_staticexplosion11 = {false,SPR_STATICEXPL11,2,NULL,ST_NULL,&s_staticexplosion12};
statetype s_staticexplosion10 = {false,SPR_STATICEXPL10,2,NULL,ST_NULL,&s_staticexplosion11};
statetype s_staticexplosion9 = {false,SPR_STATICEXPL9,2,NULL,ST_NULL,&s_staticexplosion10};
statetype s_staticexplosion8 = {false,SPR_STATICEXPL8,2,NULL,ST_NULL,&s_staticexplosion9};
statetype s_staticexplosion7 = {false,SPR_STATICEXPL7,2,NULL,ST_NULL,&s_staticexplosion8};
statetype s_staticexplosion6 = {false,SPR_STATICEXPL6,2,NULL,ST_NULL,&s_staticexplosion7};
statetype s_staticexplosion5 = {false,SPR_STATICEXPL5,2,NULL,ST_NULL,&s_staticexplosion6};
statetype s_staticexplosion4 = {false,SPR_STATICEXPL4,2,NULL,ST_NULL,&s_staticexplosion5};
statetype s_staticexplosion3 = {false,SPR_STATICEXPL3,2,T_Explosion,ST_NULL,&s_staticexplosion4};
statetype s_staticexplosion2 = {false,SPR_STATICEXPL2,2,NULL,ST_NULL,&s_staticexplosion3};
statetype s_staticexplosion1 = {false,SPR_STATICEXPL1,2,NULL,ST_NULL,&s_staticexplosion2};



statetype s_upblade16 = {false,UBLADE8,1,T_Path,ST_NULL,&s_upblade1};
statetype s_upblade15 = {false,UBLADE7,2,T_Path,ST_NULL,&s_upblade16};
statetype s_upblade14 = {false,UBLADE6,1,T_Path,ST_NULL,&s_upblade15};
statetype s_upblade13 = {false,UBLADE5,2,T_Path,ST_NULL,&s_upblade14};
statetype s_upblade12 = {false,UBLADE4,1,T_Path,ST_NULL,&s_upblade13};
statetype s_upblade11 = {false,UBLADE3,2,T_Path,ST_NULL,&s_upblade12};
statetype s_upblade10 = {false,UBLADE2,1,T_Path,ST_NULL,&s_upblade11};
statetype s_upblade9 = {false,UBLADE9,2,T_Path,ST_NULL,&s_upblade10};
statetype s_upblade8 = {false,UBLADE8,1,T_Path,ST_NULL,&s_upblade9};
statetype s_upblade7 = {false,UBLADE7,2,T_Path,ST_NULL,&s_upblade8};
statetype s_upblade6 = {false,UBLADE6,1,T_Path,ST_NULL,&s_upblade7};
statetype s_upblade5 = {false,UBLADE5,2,T_Path,ST_NULL,&s_upblade6};
statetype s_upblade4 = {false,UBLADE4,1,T_Path,ST_NULL,&s_upblade5};
statetype s_upblade3 = {false,UBLADE3,2,T_Path,ST_NULL,&s_upblade4};
statetype s_upblade2 = {false,UBLADE2,1,T_Path,ST_NULL,&s_upblade3};
statetype s_upblade1 = {false,UBLADE1,2,T_Path,SF_SOUND,&s_upblade2};


statetype s_firejetup23 = {false,FIREJETUP23,3,T_Path,SF_CRUSH,&s_firejetup1};
statetype s_firejetup22 = {false,FIREJETUP22,3,T_Path,SF_CRUSH,&s_firejetup23};
statetype s_firejetup21 = {false,FIREJETUP21,3,T_Path,ST_NULL,&s_firejetup22};
statetype s_firejetup20 = {false,FIREJETUP20,3,T_Path,ST_NULL,&s_firejetup21};
statetype s_firejetup19 = {false,FIREJETUP19,3,T_Path,ST_NULL,&s_firejetup20};
statetype s_firejetup18 = {false,FIREJETUP18,3,T_Path,ST_NULL,&s_firejetup19};
statetype s_firejetup17 = {false,FIREJETUP17,3,T_Path,ST_NULL,&s_firejetup18};
statetype s_firejetup16 = {false,FIREJETUP16,3,T_Path,SF_CRUSH,&s_firejetup17};
statetype s_firejetup15 = {false,FIREJETUP15,3,T_Path,SF_CRUSH,&s_firejetup16};
statetype s_firejetup14 = {false,FIREJETUP14,3,T_Path,SF_CRUSH,&s_firejetup15};
statetype s_firejetup13 = {false,FIREJETUP13,3,T_Path,ST_NULL,&s_firejetup14};
statetype s_firejetup12 = {false,FIREJETUP12,3,T_Path,ST_NULL,&s_firejetup13};
statetype s_firejetup11 = {false,FIREJETUP11,3,T_Path,ST_NULL,&s_firejetup12};
statetype s_firejetup10 = {false,FIREJETUP10,3,T_Path,ST_NULL,&s_firejetup11};
statetype s_firejetup9 = {false,FIREJETUP9,3,T_Path,ST_NULL,&s_firejetup10};
statetype s_firejetup8 = {false,FIREJETUP8,3,T_Path,SF_CRUSH,&s_firejetup9};
statetype s_firejetup7 = {false,FIREJETUP7,3,T_Path,SF_CRUSH,&s_firejetup8};
statetype s_firejetup6 = {false,FIREJETUP6,3,T_Path,SF_CRUSH,&s_firejetup7};
statetype s_firejetup5 = {false,FIREJETUP5,3,T_Path,ST_NULL,&s_firejetup6};
statetype s_firejetup4 = {false,FIREJETUP4,3,T_Path,ST_NULL,&s_firejetup5};
statetype s_firejetup3 = {false,FIREJETUP3,3,T_Path,ST_NULL,&s_firejetup4};
statetype s_firejetup2 = {false,FIREJETUP2,3,T_Path,ST_NULL,&s_firejetup3};
statetype s_firejetup1 = {false,FIREJETUP1,70,T_Path,SF_SOUND,&s_firejetup2};



statetype s_columndownup6 = {false,CRUSHDOWN7,5,NULL,ST_NULL,&s_columndowndown1};
statetype s_columndownup5 = {false,CRUSHDOWN6,5,NULL,ST_NULL,&s_columndownup6};
statetype s_columndownup4 = {false,CRUSHDOWN5,5,NULL,SF_BLOCK,&s_columndownup5};
statetype s_columndownup3 = {false,CRUSHDOWN4,5,NULL,SF_BLOCK,&s_columndownup4};
statetype s_columndownup2 = {false,CRUSHDOWN3,5,NULL,SF_BLOCK,&s_columndownup3};
statetype s_columndownup1 = {false,CRUSHDOWN2,5,NULL,SF_BLOCK,&s_columndownup2};


statetype s_columndowndown8 = {false,CRUSHDOWN1,5,T_CrushDown,SF_CRUSH|SF_DOWN|SF_BLOCK,&s_columndownup1};
statetype s_columndowndown7 = {false,CRUSHDOWN2,5,T_CrushDown,SF_CRUSH|SF_DOWN|SF_BLOCK,&s_columndowndown8};
statetype s_columndowndown6 = {false,CRUSHDOWN3,5,T_CrushDown,SF_DOWN|SF_BLOCK,&s_columndowndown7};
statetype s_columndowndown5 = {false,CRUSHDOWN4,5,T_CrushDown,SF_DOWN|SF_BLOCK,&s_columndowndown6};
statetype s_columndowndown4 = {false,CRUSHDOWN5,5,T_CrushDown,SF_DOWN,&s_columndowndown5};
statetype s_columndowndown3 = {false,CRUSHDOWN6,5,T_CrushDown,SF_DOWN,&s_columndowndown4};
statetype s_columndowndown2 = {false,CRUSHDOWN7,5,T_CrushDown,SF_DOWN,&s_columndowndown3};
statetype s_columndowndown1 = {false,CRUSHDOWN8,30,T_CrushDown,SF_DOWN|SF_SOUND,&s_columndowndown2};


statetype s_spearup16 = {false,SPEARUP16,2,T_Spears,SF_CRUSH,&s_spearup1};
statetype s_spearup15 = {false,SPEARUP15,2,T_Spears,SF_CRUSH,&s_spearup16};
statetype s_spearup14 = {false,SPEARUP14,2,T_Spears,SF_CRUSH,&s_spearup15};
statetype s_spearup13 = {false,SPEARUP13,2,T_Spears,SF_CRUSH,&s_spearup14};
statetype s_spearup12 = {false,SPEARUP12,2,T_Spears,SF_CRUSH,&s_spearup13};
statetype s_spearup11 = {false,SPEARUP11,2,T_Spears,SF_CRUSH,&s_spearup12};
statetype s_spearup10 = {false,SPEARUP10,2,T_Spears,SF_CRUSH,&s_spearup11};
statetype s_spearup9 = {false,SPEARUP9,2,T_Spears,SF_DOWN,&s_spearup10};

statetype s_spearup8 = {false,SPEARUP8,35,T_Spears,SF_DOWN|SF_SOUND,&s_spearup9};
statetype s_spearup7 = {false,SPEARUP7,2,T_Spears,SF_DOWN,&s_spearup8};
statetype s_spearup6 = {false,SPEARUP6,2,T_Spears,SF_CRUSH,&s_spearup7};
statetype s_spearup5 = {false,SPEARUP5,2,T_Spears,SF_CRUSH,&s_spearup6};
statetype s_spearup4 = {false,SPEARUP4,2,T_Spears,SF_CRUSH,&s_spearup5};
statetype s_spearup3 = {false,SPEARUP3,2,T_Spears,SF_CRUSH,&s_spearup4};
statetype s_spearup2 = {false,SPEARUP2,2,T_Spears,SF_CRUSH,&s_spearup3};
statetype s_spearup1 = {false,SPEARUP1,2,T_Spears,SF_CRUSH,&s_spearup2};


statetype s_dust = {false,NOTHING,0,NULL,0,&s_dust};



statetype s_gas2 = {false,SPR42_GRATE,5,T_Count,0,&s_gas2};
statetype s_gas1 = {false,SPR42_GRATE,0,NULL,0,&s_gas1};


//================== player stuff =======================================/

statetype s_p_bazooka1 = {16,SPR_BJMISS11,3,T_Projectile,ST_NULL,&s_p_bazooka1};

statetype s_p_grenade = {16,SPR_BJMISS11,3,T_Projectile,ST_NULL,&s_p_grenade};

/*
statetype s_p_misssmoke4 = {false,MISSSMOKE4,7,NULL,ST_NULL,NULL};
statetype s_p_misssmoke3 = {false,MISSSMOKE3,7,NULL,ST_NULL,&s_p_misssmoke4};
statetype s_p_misssmoke2 = {false,MISSSMOKE2,7,NULL,ST_NULL,&s_p_misssmoke3};
statetype s_p_misssmoke1 = {false,MISSSMOKE1,3,NULL,ST_NULL,&s_p_misssmoke2};
*/


statetype s_basemarker8 = {false,FLASH8,3,NULL,ST_NULL,&s_basemarker1};
statetype s_basemarker7 = {false,FLASH7,3,NULL,ST_NULL,&s_basemarker8};
statetype s_basemarker6 = {false,FLASH6,3,NULL,ST_NULL,&s_basemarker7};
statetype s_basemarker5 = {false,FLASH5,3,NULL,ST_NULL,&s_basemarker6};
statetype s_basemarker4 = {false,FLASH4,3,NULL,ST_NULL,&s_basemarker5};
statetype s_basemarker3 = {false,FLASH3,3,NULL,ST_NULL,&s_basemarker4};
statetype s_basemarker2 = {false,FLASH2,3,NULL,ST_NULL,&s_basemarker3};
statetype s_basemarker1 = {false,FLASH1,3,NULL,ST_NULL,&s_basemarker2};



statetype s_flash8 = {false,FLASH8,3,NULL,ST_NULL,NULL};
statetype s_flash7 = {false,FLASH7,3,NULL,ST_NULL,&s_flash8};
statetype s_flash6 = {false,FLASH6,3,NULL,ST_NULL,&s_flash7};
statetype s_flash5 = {false,FLASH5,3,NULL,ST_NULL,&s_flash6};
statetype s_flash4 = {false,FLASH4,3,NULL,ST_NULL,&s_flash5};
statetype s_flash3 = {false,FLASH3,3,NULL,ST_NULL,&s_flash4};
statetype s_flash2 = {false,FLASH2,3,NULL,ST_NULL,&s_flash3};
statetype s_flash1 = {false,FLASH1,3,NULL,ST_NULL,&s_flash2};

statetype s_gunsmoke8 = {false,GUNSMOKE8,3,NULL,ST_NULL,NULL};
statetype s_gunsmoke7 = {false,GUNSMOKE7,3,NULL,ST_NULL,&s_gunsmoke8};
statetype s_gunsmoke6 = {false,GUNSMOKE6,3,NULL,ST_NULL,&s_gunsmoke7};
statetype s_gunsmoke5 = {false,GUNSMOKE5,3,NULL,ST_NULL,&s_gunsmoke6};
statetype s_gunsmoke4 = {false,GUNSMOKE4,3,NULL,ST_NULL,&s_gunsmoke5};
statetype s_gunsmoke3 = {false,GUNSMOKE3,3,NULL,ST_NULL,&s_gunsmoke4};
statetype s_gunsmoke2 = {false,GUNSMOKE2,3,NULL,ST_NULL,&s_gunsmoke3};
statetype s_gunsmoke1 = {false,GUNSMOKE1,2,NULL,ST_NULL,&s_gunsmoke2};

statetype s_bloodspurt8 = {false,BLOODSPURT8,7,NULL,ST_NULL,NULL};
statetype s_bloodspurt7 = {false,BLOODSPURT7,7,NULL,ST_NULL,&s_bloodspurt8};
statetype s_bloodspurt6 = {false,BLOODSPURT6,7,NULL,ST_NULL,&s_bloodspurt7};
statetype s_bloodspurt5 = {false,BLOODSPURT5,7,NULL,ST_NULL,&s_bloodspurt6};
statetype s_bloodspurt4 = {false,BLOODSPURT4,7,NULL,ST_NULL,&s_bloodspurt5};
statetype s_bloodspurt3 = {false,BLOODSPURT3,7,NULL,ST_NULL,&s_bloodspurt4};
statetype s_bloodspurt2 = {false,BLOODSPURT2,7,NULL,ST_NULL,&s_bloodspurt3};
statetype s_bloodspurt1 = {false,BLOODSPURT1,5,NULL,ST_NULL,&s_bloodspurt2};

statetype s_hitmetalwall4 = {false,HITMETALWALL4,7,NULL,ST_NULL,NULL};
statetype s_hitmetalwall3 = {false,HITMETALWALL3,7,NULL,ST_NULL,&s_hitmetalwall4};
statetype s_hitmetalwall2 = {false,HITMETALWALL2,7,NULL,ST_NULL,&s_hitmetalwall3};
statetype s_hitmetalwall1 = {false,HITMETALWALL1,5,NULL,ST_NULL,&s_hitmetalwall2};

statetype s_hitmetalactor4 = {false,HITMETALACTOR4,7,NULL,ST_NULL,NULL};
statetype s_hitmetalactor3 = {false,HITMETALACTOR3,7,NULL,ST_NULL,&s_hitmetalactor4};
statetype s_hitmetalactor2 = {false,HITMETALACTOR2,7,NULL,ST_NULL,&s_hitmetalactor3};
statetype s_hitmetalactor1 = {false,HITMETALACTOR1,5,NULL,ST_NULL,&s_hitmetalactor2};



statetype s_fireunit15 = {false,FIREW15,3,T_Firethink,ST_NULL,&s_fireunit1};
statetype s_fireunit14 = {false,FIREW14,3,T_Firethink,ST_NULL,&s_fireunit15};
statetype s_fireunit13 = {false,FIREW13,3,T_Firethink,ST_NULL,&s_fireunit14};
statetype s_fireunit12 = {false,FIREW12,3,T_Firethink,ST_NULL,&s_fireunit13};
statetype s_fireunit11 = {false,FIREW11,3,T_Firethink,ST_NULL,&s_fireunit12};
statetype s_fireunit10 = {false,FIREW10,3,T_Firethink,ST_NULL,&s_fireunit11};
statetype s_fireunit9 = {false,FIREW9,3,T_Firethink,ST_NULL,&s_fireunit10};
statetype s_fireunit8 = {false,FIREW8,3,T_Firethink,ST_NULL,&s_fireunit9};
statetype s_fireunit7 = {false,FIREW7,3,T_Firethink,ST_NULL,&s_fireunit8};
statetype s_fireunit6 = {false,FIREW6,3,T_Firethink,ST_NULL,&s_fireunit7};
statetype s_fireunit5 = {false,FIREW5,3,T_Firethink,ST_NULL,&s_fireunit6};
statetype s_fireunit4 = {false,FIREW4,3,T_Firethink,ST_NULL,&s_fireunit5};
statetype s_fireunit3 = {false,FIREW3,3,T_Firethink,ST_NULL,&s_fireunit4};
statetype s_fireunit2 = {false,FIREW2,3,T_Firethink,ST_NULL,&s_fireunit3};
statetype s_fireunit1 = {false,FIREW1,3,T_Firethink,ST_NULL,&s_fireunit2};



statetype s_skeleton48 = {false,SKELETON48,0,T_Convert,ST_NULL,&s_skeleton48};
statetype s_skeleton47 = {false,SKELETON47,2,NULL,ST_NULL,&s_skeleton48};
statetype s_skeleton46 = {false,SKELETON46,2,NULL,ST_NULL,&s_skeleton47};
statetype s_skeleton45 = {false,SKELETON45,2,NULL,ST_NULL,&s_skeleton46};
statetype s_skeleton44 = {false,SKELETON44,2,NULL,ST_NULL,&s_skeleton45};
statetype s_skeleton43 = {false,SKELETON43,2,NULL,ST_NULL,&s_skeleton44};
statetype s_skeleton42 = {false,SKELETON42,2,NULL,ST_NULL,&s_skeleton43};
statetype s_skeleton41 = {false,SKELETON41,2,T_Xylophone,ST_NULL,&s_skeleton42};
statetype s_skeleton40 = {false,SKELETON40,2,NULL,ST_NULL,&s_skeleton41};
statetype s_skeleton39 = {false,SKELETON39,2,NULL,ST_NULL,&s_skeleton40};
statetype s_skeleton38 = {false,SKELETON38,2,NULL,ST_NULL,&s_skeleton39};
statetype s_skeleton37 = {false,SKELETON37,2,NULL,ST_NULL,&s_skeleton38};
statetype s_skeleton36 = {false,SKELETON36,2,NULL,ST_NULL,&s_skeleton37};
statetype s_skeleton35 = {false,SKELETON35,2,NULL,ST_NULL,&s_skeleton36};
statetype s_skeleton34 = {false,SKELETON34,2,NULL,ST_NULL,&s_skeleton35};
statetype s_skeleton33 = {false,SKELETON33,2,NULL,ST_NULL,&s_skeleton34};
statetype s_skeleton32 = {false,SKELETON32,2,NULL,ST_NULL,&s_skeleton33};
statetype s_skeleton31 = {false,SKELETON31,2,NULL,ST_NULL,&s_skeleton32};
statetype s_skeleton30 = {false,SKELETON30,2,NULL,ST_NULL,&s_skeleton31};
statetype s_skeleton29 = {false,SKELETON29,2,NULL,ST_NULL,&s_skeleton30};
statetype s_skeleton28 = {false,SKELETON28,2,NULL,ST_NULL,&s_skeleton29};
statetype s_skeleton27 = {false,SKELETON27,2,NULL,ST_NULL,&s_skeleton28};
statetype s_skeleton26 = {false,SKELETON26,2,NULL,ST_NULL,&s_skeleton27};
statetype s_skeleton25 = {false,SKELETON25,2,NULL,ST_NULL,&s_skeleton26};
statetype s_skeleton24 = {false,SKELETON24,2,NULL,ST_NULL,&s_skeleton25};
statetype s_skeleton23 = {false,SKELETON23,2,NULL,ST_NULL,&s_skeleton24};
statetype s_skeleton22 = {false,SKELETON22,2,NULL,ST_NULL,&s_skeleton23};
statetype s_skeleton21 = {false,SKELETON21,2,NULL,ST_NULL,&s_skeleton22};
statetype s_skeleton20 = {false,SKELETON20,2,NULL,ST_NULL,&s_skeleton21};
statetype s_skeleton19 = {false,SKELETON19,2,NULL,ST_NULL,&s_skeleton20};
statetype s_skeleton18 = {false,SKELETON18,2,NULL,ST_NULL,&s_skeleton19};
statetype s_skeleton17 = {false,SKELETON17,2,NULL,ST_NULL,&s_skeleton18};
statetype s_skeleton16 = {false,SKELETON16,2,NULL,ST_NULL,&s_skeleton17};
statetype s_skeleton15 = {false,SKELETON15,2,NULL,ST_NULL,&s_skeleton16};
statetype s_skeleton14 = {false,SKELETON14,2,NULL,ST_NULL,&s_skeleton15};
statetype s_skeleton13 = {false,SKELETON13,2,NULL,ST_NULL,&s_skeleton14};
statetype s_skeleton12 = {false,SKELETON12,2,NULL,ST_NULL,&s_skeleton13};
statetype s_skeleton11 = {false,SKELETON11,2,NULL,ST_NULL,&s_skeleton12};
statetype s_skeleton10 = {false,SKELETON10,2,NULL,ST_NULL,&s_skeleton11};
statetype s_skeleton9 = {false,SKELETON9,2,NULL,ST_NULL,&s_skeleton10};
statetype s_skeleton8 = {false,SKELETON8,2,NULL,ST_NULL,&s_skeleton9};
statetype s_skeleton7 = {false,SKELETON7,2,NULL,ST_NULL,&s_skeleton8};
statetype s_skeleton6 = {false,SKELETON6,2,NULL,ST_NULL,&s_skeleton7};
statetype s_skeleton5 = {false,SKELETON5,2,NULL,ST_NULL,&s_skeleton6};
statetype s_skeleton4 = {false,SKELETON4,2,NULL,ST_NULL,&s_skeleton5};
statetype s_skeleton3 = {false,SKELETON3,2,NULL,ST_NULL,&s_skeleton4};
statetype s_skeleton2 = {false,SKELETON2,2,NULL,ST_NULL,&s_skeleton3};
statetype s_skeleton1 = {false,SKELETON1,2,NULL,ST_NULL,&s_skeleton2};



statetype s_spring9 = {false,SPRING9,4,T_Spring,SF_DOWN,&s_spring1};
statetype s_spring8 = {false,SPRING8,4,NULL,ST_NULL,&s_spring9};
statetype s_spring7 = {false,SPRING7,4,NULL,ST_NULL,&s_spring8};
statetype s_spring6 = {false,SPRING6,4,NULL,ST_NULL,&s_spring7};
statetype s_spring5 = {false,SPRING5,4,NULL,ST_NULL,&s_spring6};
statetype s_spring4 = {false,SPRING4,15,NULL,SF_UP,&s_spring5};
statetype s_spring3 = {false,SPRING3,1,NULL,SF_UP,&s_spring4};
statetype s_spring2 = {false,SPRING2,1,NULL,SF_UP,&s_spring3};
statetype s_spring1 = {false,SPRING1,0,NULL,SF_UP,&s_spring1};


statetype s_autospring9 = {false,SPRING9,4,NULL,ST_NULL,&s_autospring1};
statetype s_autospring8 = {false,SPRING8,4,NULL,ST_NULL,&s_autospring9};
statetype s_autospring7 = {false,SPRING7,4,NULL,ST_NULL,&s_autospring8};
statetype s_autospring6 = {false,SPRING6,4,NULL,ST_NULL,&s_autospring7};
statetype s_autospring5 = {false,SPRING5,4,NULL,ST_NULL,&s_autospring6};
statetype s_autospring4 = {false,SPRING4,15,NULL,SF_UP,&s_autospring5};
statetype s_autospring3 = {false,SPRING3,1,T_Spring,SF_UP,&s_autospring4};
statetype s_autospring2 = {false,SPRING2,1,T_Spring,SF_UP,&s_autospring3};
statetype s_autospring1 = {false,SPRING1,70*SPRINGDELAY,NULL,ST_NULL,&s_autospring2};

//====================== remote player ==============================//

statetype s_itemspawn8 = {false,ITEMSPAWN8,6,NULL,ST_NULL,NULL};
statetype s_itemspawn7 = {false,ITEMSPAWN7,6,NULL,ST_NULL,&s_itemspawn8};
statetype s_itemspawn6 = {false,ITEMSPAWN6,6,NULL,ST_NULL,&s_itemspawn7};
statetype s_itemspawn5 = {false,ITEMSPAWN5,6,NULL,ST_NULL,&s_itemspawn6};
statetype s_itemspawn4 = {false,ITEMSPAWN4,6,NULL,ST_NULL,&s_itemspawn5};
statetype s_itemspawn3 = {false,ITEMSPAWN3,6,NULL,ST_NULL,&s_itemspawn4};
statetype s_itemspawn2 = {false,ITEMSPAWN2,6,NULL,ST_NULL,&s_itemspawn3};
statetype s_itemspawn1 = {false,ITEMSPAWN1,6,NULL,ST_NULL,&s_itemspawn2};


statetype s_player = {true,CASSATT_S1,0,T_Player,ST_NULL,&s_player};

statetype s_pgunattack2 = {true,CASSATT_SHOOT11,0,T_Attack,ST_NULL,&s_pgunattack2};
statetype s_pgunattack1 = {true,CASSATT_SHOOT21,5,T_Attack,ST_NULL,&s_pgunattack2};

statetype s_pmissattack2 = {true,CASSATTM_SHOOT11,0,T_Attack,ST_NULL,&s_pmissattack2};
statetype s_pmissattack1 = {true,CASSATTM_SHOOT21,5,T_Attack,ST_NULL,&s_pmissattack2};

statetype s_pbatblast = {true,CASSATT_SHOOT21,0,T_BatBlast,ST_NULL,&s_pbatblast};




statetype s_remotemove4 = {true,CASSATT_W41,5,T_Player,SF_DOWN,&s_remotemove1};
statetype s_remotemove3 = {true,CASSATT_W31,5,T_Player,SF_DOWN,&s_remotemove4};
statetype s_remotemove2 = {true,CASSATT_W21,5,T_Player,SF_DOWN,&s_remotemove3};
statetype s_remotemove1 = {true,CASSATT_W11,5,T_Player,SF_DOWN,&s_remotemove2};

statetype s_remoteinelev = {true,CASSATT_S1,700,T_Player,ST_NULL,&s_remoteinelev};

statetype s_remotedead = {false,CASSATT_VDEAD,0,T_Player,ST_NULL,&s_remotedead};



statetype s_remotedie6 = {false,CASSATT_VDIE6,3,T_Player,ST_NULL,&s_remotedead};
statetype s_remotedie5 = {false,CASSATT_VDIE5,3,T_Player,ST_NULL,&s_remotedie6};
statetype s_remotedie4 = {false,CASSATT_VDIE4,3,T_Player,ST_NULL,&s_remotedie5};
statetype s_remotedie3 = {false,CASSATT_VDIE3,3,T_Player,ST_NULL,&s_remotedie4};
statetype s_remotedie2 = {false,CASSATT_VDIE2,3,T_Player,ST_NULL,&s_remotedie3};
statetype s_remotedie1 = {false,CASSATT_VDIE1,3,T_Player,ST_NULL,&s_remotedie2};


statetype s_voidwait = {false,NOTHING,0,T_DeadWait,ST_NULL,&s_voidwait};
statetype s_ashwait = {false,SKELETON48,0,T_DeadWait,ST_NULL,&s_ashwait};
statetype s_deadwait = {false,CASSATT_VDEAD,0,T_DeadWait,ST_NULL,&s_deadwait};
statetype s_gutwait = {false,GUTS12,0,T_DeadWait,ST_NULL,&s_gutwait};
statetype s_remoteguts12 = {false,GUTS12,0,T_Player,ST_NULL,&s_remoteguts12};
statetype s_remoteguts11 = {false,GUTS11,3,T_Player,ST_NULL,&s_remoteguts12};
statetype s_remoteguts10 = {false,GUTS10,3,T_Player,ST_NULL,&s_remoteguts11};
statetype s_remoteguts9 = {false,GUTS9,3,T_Player,ST_NULL,&s_remoteguts10};
statetype s_remoteguts8 = {false,GUTS8,3,T_Player,ST_NULL,&s_remoteguts9};
statetype s_remoteguts7 = {false,GUTS7,3,T_Player,ST_NULL,&s_remoteguts8};
statetype s_remoteguts6 = {false,GUTS6,3,T_Player,ST_NULL,&s_remoteguts7};
statetype s_remoteguts5 = {false,GUTS5,3,T_Player,ST_NULL,&s_remoteguts6};
statetype s_remoteguts4 = {false,GUTS4,3,T_Player,ST_NULL,&s_remoteguts5};
statetype s_remoteguts3 = {false,GUTS3,3,T_Player,ST_NULL,&s_remoteguts4};
statetype s_remoteguts2 = {false,GUTS2,3,T_Player,ST_NULL,&s_remoteguts3};
statetype s_remoteguts1 = {false,GUTS1,3,T_Player,ST_NULL,&s_remoteguts2};

//========================================================================//

statetype s_godfire4 = {false,GODFIRE4,3,T_Projectile,ST_NULL,&s_godfire1};
statetype s_godfire3 = {false,GODFIRE3,3,T_Projectile,ST_NULL,&s_godfire4};
statetype s_godfire2 = {false,GODFIRE2,3,T_Projectile,ST_NULL,&s_godfire3};
statetype s_godfire1 = {false,GODFIRE1,3,T_Projectile,ST_NULL,&s_godfire2};




statetype s_guts12 = {false,GUTS12,0,T_Collide,SF_GUTS,&s_guts12};
statetype s_guts11 = {false,GUTS11,3,T_Collide,SF_GUTS,&s_guts12};
statetype s_guts10 = {false,GUTS10,3,T_Collide,SF_GUTS,&s_guts11};
statetype s_guts9 = {false,GUTS9,3,T_Collide,SF_GUTS,&s_guts10};
statetype s_guts8 = {false,GUTS8,3,T_Collide,SF_GUTS,&s_guts9};
statetype s_guts7 = {false,GUTS7,3,T_Collide,SF_GUTS,&s_guts8};
statetype s_guts6 = {false,GUTS6,3,T_Collide,SF_GUTS,&s_guts7};
statetype s_guts5 = {false,GUTS5,3,T_Collide,SF_GUTS,&s_guts6};
statetype s_guts4 = {false,GUTS4,3,T_Collide,SF_GUTS,&s_guts5};
statetype s_guts3 = {false,GUTS3,3,T_Collide,SF_GUTS,&s_guts4};
statetype s_guts2 = {false,GUTS2,3,T_Collide,SF_GUTS,&s_guts3};
statetype s_guts1 = {false,GUTS1,3,T_Collide,SF_GUTS,&s_guts2};

//MED
/*
statetype s_collectorwander8 = {false,COLLECTOR15,0,T_CollectorWander,ST_NULL,&s_collectorwander1};
statetype s_collectorwander7 = {false,COLLECTOR13,1,T_CollectorWander,ST_NULL,&s_collectorwander8};
statetype s_collectorwander6 = {false,COLLECTOR11,0,T_CollectorWander,ST_NULL,&s_collectorwander7};
statetype s_collectorwander5 = {false,COLLECTOR9,1,T_CollectorWander,ST_NULL,&s_collectorwander6};
statetype s_collectorwander4 = {false,COLLECTOR7,0,T_CollectorWander,ST_NULL,&s_collectorwander5};
statetype s_collectorwander3 = {false,COLLECTOR5,1,T_CollectorWander,ST_NULL,&s_collectorwander4};
statetype s_collectorwander2 = {false,COLLECTOR3,0,T_CollectorWander,ST_NULL,&s_collectorwander3};
statetype s_collectorwander1 = {false,COLLECTOR1,1,T_CollectorWander,ST_NULL,&s_collectorwander2};
*/

statetype s_collectorwander8 = {false,DOPE8,2,T_CollectorWander,ST_NULL,&s_collectorwander1};
statetype s_collectorwander7 = {false,DOPE7,2,T_CollectorWander,ST_NULL,&s_collectorwander8};
statetype s_collectorwander6 = {false,DOPE6,2,T_CollectorWander,ST_NULL,&s_collectorwander7};
statetype s_collectorwander5 = {false,DOPE5,2,T_CollectorWander,ST_NULL,&s_collectorwander6};
statetype s_collectorwander4 = {false,DOPE4,2,T_CollectorWander,ST_NULL,&s_collectorwander5};
statetype s_collectorwander3 = {false,DOPE3,2,T_CollectorWander,ST_NULL,&s_collectorwander4};
statetype s_collectorwander2 = {false,DOPE2,2,T_CollectorWander,ST_NULL,&s_collectorwander3};
statetype s_collectorwander1 = {false,DOPE1,2,T_CollectorWander,ST_NULL,&s_collectorwander2};


//MED
/*
statetype s_collectorfdoor8 = {false,COLLECTOR15,0,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor1};
statetype s_collectorfdoor7 = {false,COLLECTOR13,1,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor8};
statetype s_collectorfdoor6 = {false,COLLECTOR11,0,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor7};
statetype s_collectorfdoor5 = {false,COLLECTOR9,1,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor6};
statetype s_collectorfdoor4 = {false,COLLECTOR7,0,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor5};
statetype s_collectorfdoor3 = {false,COLLECTOR5,1,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor4};
statetype s_collectorfdoor2 = {false,COLLECTOR3,0,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor3};
statetype s_collectorfdoor1 = {false,COLLECTOR1,1,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor2};
*/

statetype s_collectorfdoor8 = {false,DOPE8,2,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor1};
statetype s_collectorfdoor7 = {false,DOPE7,2,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor8};
statetype s_collectorfdoor6 = {false,DOPE6,2,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor7};
statetype s_collectorfdoor5 = {false,DOPE5,2,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor6};
statetype s_collectorfdoor4 = {false,DOPE4,2,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor5};
statetype s_collectorfdoor3 = {false,DOPE3,2,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor4};
statetype s_collectorfdoor2 = {false,DOPE2,2,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor3};
statetype s_collectorfdoor1 = {false,DOPE1,2,T_CollectorFindDoor,ST_NULL,&s_collectorfdoor2};


statetype s_timekeeper = {false,NOTHING,140,T_End,ST_NULL,NULL};

statetype s_wind = {false,-1,10,T_Wind,ST_NULL,&s_wind};


statetype s_deadblood8 = {false,NOTHING,0,T_Blood,ST_NULL,&s_deadblood8};
statetype s_deadblood7 = {false,DEADBLOOD7,5,NULL,ST_NULL,&s_deadblood8};
statetype s_deadblood6 = {false,DEADBLOOD6,5,NULL,ST_NULL,&s_deadblood7};
statetype s_deadblood5 = {false,DEADBLOOD5,5,NULL,ST_NULL,&s_deadblood6};
statetype s_deadblood4 = {false,DEADBLOOD4,5,NULL,ST_NULL,&s_deadblood5};
statetype s_deadblood3 = {false,DEADBLOOD3,5,NULL,ST_NULL,&s_deadblood4};
statetype s_deadblood2 = {false,DEADBLOOD2,5,NULL,ST_NULL,&s_deadblood3};
statetype s_deadblood1 = {false,DEADBLOOD1,5,NULL,ST_NULL,&s_deadblood2};

/*
statetype s_rain7 = {false,RAINDROP6,0,NULL,ST_NULL,NULL};
statetype s_rain6 = {false,RAINDROP5,3,NULL,ST_NULL,&s_rain7};
statetype s_rain5 = {false,RAINDROP4,0,NULL,ST_NULL,&s_rain6};
statetype s_rain4 = {false,RAINDROP3,3,NULL,ST_NULL,&s_rain5};
statetype s_rain3 = {false,RAINDROP2,0,NULL,ST_NULL,&s_rain4};
statetype s_rain2 = {false,RAINDROP1,0,T_RainFall,ST_NULL,&s_rain2};
statetype s_rain1 = {false,NOTHING,50,T_RainSpawn,ST_NULL,&s_rain1};

statetype s_rainmaster = {false,NOTHING,0,T_RainMaster,ST_NULL,&s_rainmaster};
*/

statetype s_pathdisk = {false,PLATFORM1,0,T_Path,ST_NULL,&s_pathdisk};
statetype s_elevdisk = {false,PLATFORM1,0,T_ElevDisk,ST_NULL,&s_elevdisk};

statetype s_diskmaster = {false,NOTHING,0,T_ElevDisk,ST_NULL,&s_diskmaster};



statetype s_blooddrip4 = {false,WALLGIB4,3,T_BloodFall,ST_NULL,&s_blooddrip1};
statetype s_blooddrip3 = {false,WALLGIB3,3,T_BloodFall,ST_NULL,&s_blooddrip4};
statetype s_blooddrip2 = {false,WALLGIB2,3,T_BloodFall,ST_NULL,&s_blooddrip3};
statetype s_blooddrip1 = {false,WALLGIB1,3,T_BloodFall,ST_NULL,&s_blooddrip2};



//==================== Push column =====================================//


statetype s_pushcolumn1 = {false,SPR_PUSHCOLUMN1,6,T_MoveColumn,ST_NULL,&s_pushcolumn1};
statetype s_pushcolumn2 = {false,SPR_PUSHCOLUMN1,6,T_MoveColumn,ST_NULL,&s_pushcolumn2};
statetype s_pushcolumn3 = {false,SPR_PUSHCOLUMN1,6,T_MoveColumn,ST_NULL,&s_pushcolumn3};


//=================== Wall Fire =======================================/

statetype s_wallfireball = {false,NOTHING,50,A_Wallfire,ST_NULL,&s_wallfireball};

statetype s_crossfire2 = {true,SPR_CROSSFIRE31,6,T_Projectile,ST_NULL,&s_crossfire1};
statetype s_crossfire1 = {true,SPR_CROSSFIRE11,6,T_Projectile,ST_NULL,&s_crossfire2};

statetype s_crossdone5 = {false,SPR_CREXP5,6,NULL,ST_NULL,NULL};
statetype s_crossdone4 = {false,SPR_CREXP4,6,NULL,ST_NULL,&s_crossdone5};
statetype s_crossdone3 = {false,SPR_CREXP3,6,NULL,ST_NULL,&s_crossdone4};
statetype s_crossdone2 = {false,SPR_CREXP2,6,NULL,ST_NULL,&s_crossdone3};
statetype s_crossdone1 = {false,SPR_CREXP1,6,NULL,ST_NULL,&s_crossdone2};



//=============== gib/related states ===========================================//


statetype s_bossdeath = {false,NOTHING,140,T_BossDied,ST_NULL,NULL};

statetype s_megaremove     = {false,NOTHING,0,NULL,ST_NULL,NULL};
statetype s_megaexplosions = {false,NOTHING,0,T_BossExplosions,ST_NULL,&s_megaexplosions};
statetype s_superparticles = {false,NOTHING,0,T_ParticleGenerate,ST_NULL,&s_superparticles};


statetype s_gibsdone8 = {false,PARTICLE12,2,NULL,ST_NULL,NULL};
statetype s_gibsdone7 = {false,PARTICLE11,2,NULL,ST_NULL,&s_gibsdone8};
//MED
statetype s_gibsdone6 = {false,PARTICLE10,2,NULL,ST_NULL,&s_gibsdone7};
statetype s_gibsdone5 = {false,PARTICLE09,2,NULL,ST_NULL,&s_gibsdone6};
statetype s_gibsdone4 = {false,PARTICLE08,2,NULL,ST_NULL,&s_gibsdone5};
statetype s_gibsdone3 = {false,PARTICLE07,2,NULL,ST_NULL,&s_gibsdone4};
statetype s_gibsdone2 = {false,PARTICLE06,2,NULL,ST_NULL,&s_gibsdone3};
statetype s_gibsdone1 = {false,PARTICLE05,2,NULL,ST_NULL,&s_gibsdone2};

statetype s_gibs4 = {false,PARTICLE04,2,T_Particle,ST_NULL,&s_gibs1};
statetype s_gibs3 = {false,PARTICLE03,2,T_Particle,ST_NULL,&s_gibs4};
statetype s_gibs2 = {false,PARTICLE02,2,T_Particle,ST_NULL,&s_gibs3};
statetype s_gibs1 = {false,PARTICLE01,2,T_Particle,ST_NULL,&s_gibs2};



//statetype s_head = {false,DEADHEAD,4200,NULL,ST_NULL,&s_gibsdone2};

statetype s_eye3 = {false,NOTHING,7,T_SlideDownScreen,SF_EYE3,&s_eye1};
statetype s_eye2 = {false,NOTHING,7,T_SlideDownScreen,SF_EYE2,&s_eye3};
statetype s_eye1 = {false,NOTHING,7,T_SlideDownScreen,SF_EYE1,&s_eye2};

statetype s_littlesoul = {false,LITTLESOUL,0,MissileMovement,ST_NULL,&s_littlesoul};
statetype s_bigsoul = {false,BIGSOUL,0,MissileMovement,ST_NULL,&s_bigsoul};


statetype s_vaporized8 = {false,VAPORIZED8,0,T_Convert,ST_NULL,NULL};
statetype s_vaporized7 = {false,VAPORIZED7,3,NULL,ST_NULL,&s_vaporized8};
statetype s_vaporized6 = {false,VAPORIZED6,3,NULL,ST_NULL,&s_vaporized7};
statetype s_vaporized5 = {false,VAPORIZED5,3,NULL,ST_NULL,&s_vaporized6};
statetype s_vaporized4 = {false,VAPORIZED4,3,NULL,ST_NULL,&s_vaporized5};
statetype s_vaporized3 = {false,VAPORIZED3,3,NULL,ST_NULL,&s_vaporized4};
statetype s_vaporized2 = {false,VAPORIZED2,3,NULL,ST_NULL,&s_vaporized3};
statetype s_vaporized1 = {false,VAPORIZED1,3,NULL,ST_NULL,&s_vaporized2};

statetype s_respawn8 = {false,VAPORIZED1,0,SetShapeoffset,ST_NULL,&s_player};
statetype s_respawn7 = {false,VAPORIZED2,3,NULL,ST_NULL,&s_respawn8};
statetype s_respawn6 = {false,VAPORIZED3,3,NULL,ST_NULL,&s_respawn7};
statetype s_respawn5 = {false,VAPORIZED4,3,NULL,ST_NULL,&s_respawn6};
statetype s_respawn4 = {false,VAPORIZED5,3,NULL,ST_NULL,&s_respawn5};
statetype s_respawn3 = {false,VAPORIZED6,3,NULL,ST_NULL,&s_respawn4};
statetype s_respawn2 = {false,VAPORIZED7,3,NULL,ST_NULL,&s_respawn3};
statetype s_respawn1 = {false,VAPORIZED8,3,NULL,ST_NULL,&s_respawn2};



#if (SHAREWARE == 0)


//========================= NON-SHAREWARE STATES ============================


statetype s_scottwander7 = {false,SCOTHEAD7,4,T_CollectorWander,ST_NULL,&s_scottwander1};
statetype s_scottwander6 = {false,SCOTHEAD6,4,T_CollectorWander,ST_NULL,&s_scottwander7};
statetype s_scottwander5 = {false,SCOTHEAD5,4,T_CollectorWander,ST_NULL,&s_scottwander6};
statetype s_scottwander4 = {false,SCOTHEAD4,4,T_CollectorWander,ST_NULL,&s_scottwander5};
statetype s_scottwander3 = {false,SCOTHEAD3,4,T_CollectorWander,ST_NULL,&s_scottwander4};
statetype s_scottwander2 = {false,SCOTHEAD2,4,T_CollectorWander,ST_NULL,&s_scottwander3};
statetype s_scottwander1 = {false,SCOTHEAD1,4,T_CollectorWander,ST_NULL,&s_scottwander2};

statetype s_scottwanderdoor7 = {false,SCOTHEAD7,4,T_CollectorWander,ST_NULL,&s_scottwanderdoor1};
statetype s_scottwanderdoor6 = {false,SCOTHEAD6,4,T_CollectorWander,ST_NULL,&s_scottwanderdoor7};
statetype s_scottwanderdoor5 = {false,SCOTHEAD5,4,T_CollectorWander,ST_NULL,&s_scottwanderdoor6};
statetype s_scottwanderdoor4 = {false,SCOTHEAD4,4,T_CollectorWander,ST_NULL,&s_scottwanderdoor5};
statetype s_scottwanderdoor3 = {false,SCOTHEAD3,4,T_CollectorWander,ST_NULL,&s_scottwanderdoor4};
statetype s_scottwanderdoor2 = {false,SCOTHEAD2,4,T_CollectorWander,ST_NULL,&s_scottwanderdoor3};
statetype s_scottwanderdoor1 = {false,SCOTHEAD1,4,T_CollectorWander,ST_NULL,&s_scottwanderdoor2};



/*
===========================================================================

							 OVERPATROLS (op)
																			,
===========================================================================
*/

statetype s_opstand	   = {true,SPR_OP_S1,0,T_Stand,ST_NULL,&s_opstand};

statetype s_oppath4 	   = {true,SPR_OP_W41,10,T_Path,ST_NULL,&s_oppath1};
statetype s_oppath3 	   = {true,SPR_OP_W31,10,T_Path,SF_CLOSE,&s_oppath4};
statetype s_oppath2	   = {true,SPR_OP_W21,10,T_Path,ST_NULL,&s_oppath3};
statetype s_oppath1 	   = {true,SPR_OP_W11,10,T_Path,SF_CLOSE,&s_oppath2};


statetype s_opcollide  = {false,SPR_OP_PAIN1,0,T_Collide,ST_NULL,&s_opcollide};
statetype s_opcollide2 = {false,SPR_OP_PAIN2,0,T_Collide,ST_NULL,&s_opcollide2};


//statetype s_opuse2 	   = {true,SPR_OP_USE21,10,T_Use,ST_NULL,&s_oppath1};
//statetype s_opuse1 	   = {true,SPR_OP_USE11,10,T_Use,ST_NULL,&s_opuse2};


statetype s_opshoot4 	= {false,SPR_OP_SHOOT4,10,ActorMovement,ST_NULL,&s_opchase1};
statetype s_opshoot3 	= {false,SPR_OP_SHOOT3,10,ActorMovement,ST_NULL,&s_opshoot4};
statetype s_opshoot2 	= {false,SPR_OP_SHOOT2,20,A_Shoot,ST_NULL,&s_opshoot3};
statetype s_opshoot1 	= {false,SPR_OP_SHOOT1,6,ActorMovement,ST_NULL,&s_opshoot2};



statetype s_opbolo5     = {false,SPR_OP_BOLOSHOOT5,6,ActorMovement,ST_NULL,&s_opchase1};
statetype s_opbolo4     = {false,SPR_OP_BOLOSHOOT4,6,ActorMovement,ST_NULL,&s_opbolo5};
statetype s_opbolo3     = {false,SPR_OP_BOLOSHOOT3,20,A_MissileWeapon,ST_NULL,&s_opbolo4};
statetype s_opbolo2     = {false,SPR_OP_BOLOSHOOT2,6,ActorMovement,ST_NULL,&s_opbolo3};
statetype s_opbolo1     = {false,SPR_OP_BOLOSHOOT1,6,ActorMovement,ST_NULL,&s_opbolo2};


statetype s_bolocast4   = {false,SPR_BOLO4,6,T_Projectile,ST_NULL,&s_bolocast4};
statetype s_bolocast3   = {false,SPR_BOLO3,6,T_Projectile,ST_NULL,&s_bolocast4};
statetype s_bolocast2   = {false,SPR_BOLO2,6,T_Projectile,ST_NULL,&s_bolocast3};
statetype s_bolocast1   = {false,SPR_BOLO1,6,T_Projectile,ST_NULL,&s_bolocast2};


statetype s_opchase4	   = {true,SPR_OP_W41,6,T_Chase,ST_NULL,&s_opchase1};
statetype s_opchase3	   = {true,SPR_OP_W31,6,T_Chase,SF_CLOSE,&s_opchase4};
statetype s_opchase2	   = {true,SPR_OP_W21,6,T_Chase,ST_NULL,&s_opchase3};
statetype s_opchase1	   = {true,SPR_OP_W11,6,T_Chase,SF_CLOSE,&s_opchase2};


statetype s_opdead		= {false,SPR_OP_ALTDEAD,0,T_Collide,ST_NULL,&s_opdead};
statetype s_opdie5		= {false,SPR_OP_ALTDIE5,5,T_Collide,ST_NULL,&s_opdead};
statetype s_opdie4		= {false,SPR_OP_ALTDIE4,5,T_Collide,ST_NULL,&s_opdie5};
statetype s_opdie3		= {false,SPR_OP_ALTDIE3,5,T_Collide,ST_NULL,&s_opdie4};
statetype s_opdie2		= {false,SPR_OP_ALTDIE2,5,T_Collide,ST_NULL,&s_opdie3};
statetype s_opdie1		= {false,SPR_OP_ALTDIE1,5,T_Collide,ST_NULL,&s_opdie2};


statetype s_opcrushed2		= {false,SPR_OP_DIE3,2,NULL,ST_NULL,&s_opdead};
statetype s_opcrushed1		= {false,SPR_OP_DIE1,2,NULL,ST_NULL,&s_opcrushed2};



/*
============================================================================

								DEATH MONKS

============================================================================
*/


statetype s_dmonkstand	= {true,SPR_MONK_S1,0,T_Stand,ST_NULL,&s_dmonkstand};

statetype s_dmonkpath4	= {true,SPR_MONK_W41,10,T_Path,ST_NULL,&s_dmonkpath1};
statetype s_dmonkpath3  = {true,SPR_MONK_W31,10,T_Path,SF_CLOSE,&s_dmonkpath4};
statetype s_dmonkpath2	= {true,SPR_MONK_W21,10,T_Path,ST_NULL,&s_dmonkpath3};
statetype s_dmonkpath1  = {true,SPR_MONK_W11,10,T_Path,SF_CLOSE,&s_dmonkpath2};


statetype s_dmonkcollide  = {false,SPR_MONK_PAIN1,0,T_Collide,ST_NULL,&s_dmonkcollide};
statetype s_dmonkcollide2 = {false,SPR_MONK_PAIN2,0,T_Collide,ST_NULL,&s_dmonkcollide2};


statetype s_dmonkshoot6 = {false,SPR_MONK_DRAIN6,20,ActorMovement,ST_NULL,&s_dmonkchase1};
statetype s_dmonkshoot5 = {false,SPR_MONK_DRAIN5,20,ActorMovement,ST_NULL,&s_dmonkshoot6};
statetype s_dmonkshoot4 = {false,SPR_MONK_DRAIN4,20,ActorMovement,ST_NULL,&s_dmonkshoot3};
statetype s_dmonkshoot3 = {false,SPR_MONK_DRAIN3,20,A_Drain,ST_NULL,&s_dmonkshoot4};
statetype s_dmonkshoot2 = {false,SPR_MONK_DRAIN2,20,ActorMovement,ST_NULL,&s_dmonkshoot3};
statetype s_dmonkshoot1 = {false,SPR_MONK_DRAIN1,20,A_Drain,ST_NULL,&s_dmonkshoot2};

statetype s_dmonkchase4	   = {true,SPR_MONK_W41,6,T_Chase,ST_NULL,&s_dmonkchase1};
statetype s_dmonkchase3 	= {true,SPR_MONK_W31,6,T_Chase,SF_CLOSE,&s_dmonkchase4};
statetype s_dmonkchase2	   = {true,SPR_MONK_W21,6,T_Chase,ST_NULL,&s_dmonkchase3};
statetype s_dmonkchase1 	= {true,SPR_MONK_W11,6,T_Chase,SF_CLOSE,&s_dmonkchase2};

statetype s_dmonkdead		= {false,SPR_MONK_DEAD,0,T_Collide,ST_NULL,&s_dmonkdead};
statetype s_dmonkdie4		= {false,SPR_MONK_DIE4,5,T_Collide,ST_NULL,&s_dmonkdead};
statetype s_dmonkdie3		= {false,SPR_MONK_DIE3,5,T_Collide,ST_NULL,&s_dmonkdie4};
statetype s_dmonkdie2		= {false,SPR_MONK_DIE2,5,T_Collide,ST_NULL,&s_dmonkdie3};
statetype s_dmonkdie1		= {false,SPR_MONK_DIE1,5,T_Collide,ST_NULL,&s_dmonkdie2};


statetype s_dmonkcrushed2		= {false,SPR_MONK_DIE3,2,NULL,ST_NULL,&s_dmonkdead};
statetype s_dmonkcrushed1		= {false,SPR_MONK_DIE1,2,NULL,ST_NULL,&s_dmonkcrushed2};

/*
============================================================================

								DEATH FIRE MONKS

============================================================================
*/

statetype s_firemonkstand	= {true,SPR_FIREMONK_S1,0,T_Stand,ST_NULL,&s_firemonkstand};

statetype s_firemonkpath4	= {true,SPR_FIREMONK_W41,10,T_Path,ST_NULL,&s_firemonkpath1};
statetype s_firemonkpath3  = {true,SPR_FIREMONK_W31,10,T_Path,SF_CLOSE,&s_firemonkpath4};
statetype s_firemonkpath2	= {true,SPR_FIREMONK_W21,10,T_Path,ST_NULL,&s_firemonkpath3};
statetype s_firemonkpath1  = {true,SPR_FIREMONK_W11,10,T_Path,SF_CLOSE,&s_firemonkpath2};


statetype s_firemonkcollide  = {false,SPR_FIREMONK_PAIN1,0,T_Collide,ST_NULL,&s_firemonkcollide};
statetype s_firemonkcollide2 = {false,SPR_FIREMONK_PAIN2,0,T_Collide,ST_NULL,&s_firemonkcollide2};

statetype s_firemonkcast7 = {false,SPR_FIREMONK_CAST7,6,ActorMovement,ST_NULL,&s_firemonkchase1};
statetype s_firemonkcast6 = {false,SPR_FIREMONK_CAST6,40,A_MissileWeapon,ST_NULL,&s_firemonkcast7};
statetype s_firemonkcast5 = {false,SPR_FIREMONK_CAST5,6,ActorMovement,ST_NULL,&s_firemonkcast6};
statetype s_firemonkcast4 = {false,SPR_FIREMONK_CAST4,6,ActorMovement,ST_NULL,&s_firemonkcast5};
statetype s_firemonkcast3 = {false,SPR_FIREMONK_CAST3,6,ActorMovement,ST_NULL,&s_firemonkcast4};
statetype s_firemonkcast2 = {false,SPR_FIREMONK_CAST2,6,ActorMovement,ST_NULL,&s_firemonkcast3};
statetype s_firemonkcast1 = {false,SPR_FIREMONK_CAST1,6,ActorMovement,ST_NULL,&s_firemonkcast2};

statetype s_monkfire4 = {false,MONKFIRE4,3,T_Projectile,ST_NULL,&s_monkfire1};
statetype s_monkfire3 = {false,MONKFIRE3,3,T_Projectile,ST_NULL,&s_monkfire4};
statetype s_monkfire2 = {false,MONKFIRE2,3,T_Projectile,ST_NULL,&s_monkfire3};
statetype s_monkfire1 = {false,MONKFIRE1,3,T_Projectile,ST_NULL,&s_monkfire2};


statetype s_fireballhit3 = {false,SPR_FIREBALL_HIT3,5,NULL,ST_NULL,NULL};
statetype s_fireballhit2 = {false,SPR_FIREBALL_HIT2,5,NULL,ST_NULL,&s_fireballhit3};
statetype s_fireballhit1 = {false,SPR_FIREBALL_HIT1,5,NULL,ST_NULL,&s_fireballhit2};

statetype s_firemonkchase4 	= {true,SPR_FIREMONK_W41,6,T_Chase,ST_NULL,&s_firemonkchase1};
statetype s_firemonkchase3 	= {true,SPR_FIREMONK_W31,6,T_Chase,SF_CLOSE,&s_firemonkchase4};
statetype s_firemonkchase2	   = {true,SPR_FIREMONK_W21,6,T_Chase,ST_NULL,&s_firemonkchase3};
statetype s_firemonkchase1 	= {true,SPR_FIREMONK_W11,6,T_Chase,SF_CLOSE,&s_firemonkchase2};


statetype s_firemonkdead7		= {false,SPR_FIREMONK_DEAD7,0,T_Collide,ST_NULL,&s_firemonkdead7};
statetype s_firemonkdead6	   = {false,SPR_FIREMONK_DEAD6,5,T_Collide,ST_NULL,&s_firemonkdead7};
statetype s_firemonkdead5	   = {false,SPR_FIREMONK_DEAD5,5,T_Collide,ST_NULL,&s_firemonkdead6};
statetype s_firemonkdead4	   = {false,SPR_FIREMONK_DEAD4,5,T_Collide,ST_NULL,&s_firemonkdead5};
statetype s_firemonkdead3	   = {false,SPR_FIREMONK_DEAD3,5,T_Collide,ST_NULL,&s_firemonkdead4};
statetype s_firemonkdead2	   = {false,SPR_FIREMONK_DEAD2,5,T_Collide,ST_NULL,&s_firemonkdead3};
statetype s_firemonkdead		= {false,SPR_FIREMONK_DEAD1,5,T_Collide,ST_NULL,&s_firemonkdead2};
statetype s_firemonkdie4		= {false,SPR_FIREMONK_DIE3,5,T_Collide,ST_NULL,&s_firemonkdead};
statetype s_firemonkdie3		= {false,SPR_FIREMONK_DIE3,5,T_Collide,ST_NULL,&s_firemonkdie4};
statetype s_firemonkdie2		= {false,SPR_FIREMONK_DIE2,5,T_Collide,ST_NULL,&s_firemonkdie3};
statetype s_firemonkdie1		= {false,SPR_FIREMONK_DIE1,5,T_Collide,ST_NULL,&s_firemonkdie2};


statetype s_firemonkcrushed2		= {false,SPR_FIREMONK_DIE3,2,NULL,ST_NULL,&s_firemonkdead};
statetype s_firemonkcrushed1		= {false,SPR_FIREMONK_DIE1,2,NULL,ST_NULL,&s_firemonkcrushed2};

/*===========================================================================

								  INSANE WALL DUDE

============================================================================*/


statetype s_wallstand = {16,BCRAFT01,0,T_Stand,ST_NULL,&s_wallstand};

statetype s_wallpath = {16,BCRAFT01,20,T_AutoPath,ST_NULL,&s_wallpath};

statetype s_wallshoot = {16,BCRAFT01,15,A_MissileWeapon,ST_NULL,&s_wallshoot};

statetype s_wallalign = {16,BCRAFT01,0,T_AutoShootAlign,ST_NULL,&s_wallalign};
statetype s_wallwait = {16,BCRAFT01,0,NULL,ST_NULL,&s_wallwait};
statetype s_wallrestore = {16,BCRAFT01,0,T_AutoRealign,ST_NULL,&s_wallrestore};



statetype s_wallcollide  = {16,BCRAFT01,0,T_Collide,ST_NULL,&s_wallcollide};


/*
===========================================================================

									  ESAU GUDERIAN

===========================================================================
*/




statetype s_darianstand = {true,SPR_DARIAN_S1,0,T_Stand,ST_NULL,&s_darianstand};

statetype s_darianchase4	= {true,SPR_DARIAN_W41,8,T_EsauChase,ST_NULL,&s_darianchase1};
statetype s_darianchase3	= {true,SPR_DARIAN_W31,8,T_EsauChase,SF_CLOSE,&s_darianchase4};
statetype s_darianchase2	= {true,SPR_DARIAN_W21,8,T_EsauChase,ST_NULL,&s_darianchase3};
statetype s_darianchase1	= {true,SPR_DARIAN_W11,8,T_EsauChase,SF_CLOSE,&s_darianchase2};


statetype s_darianrise8 = {false,SPR_DARIAN_SINK1,3,NULL,ST_NULL,&s_darianwait};
statetype s_darianrise7 = {false,SPR_DARIAN_SINK2,3,NULL,ST_NULL,&s_darianrise8};
statetype s_darianrise6 = {false,SPR_DARIAN_SINK3,3,NULL,ST_NULL,&s_darianrise7};
statetype s_darianrise5 = {false,SPR_DARIAN_SINK4,3,NULL,ST_NULL,&s_darianrise6};
statetype s_darianrise4 = {false,SPR_DARIAN_SINK5,3,NULL,ST_NULL,&s_darianrise5};
statetype s_darianrise3 = {false,SPR_DARIAN_SINK6,3,NULL,ST_NULL,&s_darianrise4};
statetype s_darianrise2 = {false,SPR_DARIAN_SINK7,3,NULL,ST_NULL,&s_darianrise3};
statetype s_darianrise1 = {false,SPR_DARIAN_SINK8,3,NULL,ST_NULL,&s_darianrise2};


statetype s_dariansink9 = {false,NOTHING,110,T_EsauRise,ST_NULL,&s_darianrise1};
statetype s_dariansink8 = {false,SPR_DARIAN_SINK8,3,NULL,ST_NULL,&s_dariansink9};
statetype s_dariansink7 = {false,SPR_DARIAN_SINK7,3,NULL,ST_NULL,&s_dariansink8};
statetype s_dariansink6 = {false,SPR_DARIAN_SINK6,3,NULL,ST_NULL,&s_dariansink7};
statetype s_dariansink5 = {false,SPR_DARIAN_SINK5,3,NULL,ST_NULL,&s_dariansink6};
statetype s_dariansink4 = {false,SPR_DARIAN_SINK4,3,NULL,ST_NULL,&s_dariansink5};
statetype s_dariansink3 = {false,SPR_DARIAN_SINK3,3,NULL,ST_NULL,&s_dariansink4};
statetype s_dariansink2 = {false,SPR_DARIAN_SINK2,3,NULL,ST_NULL,&s_dariansink3};
statetype s_dariansink1 = {false,SPR_DARIAN_SINK1,3,NULL,ST_NULL,&s_dariansink2};


statetype s_dariancollide  = {false,SPR_DARIAN_PAIN1,0,T_Collide,ST_NULL,&s_dariancollide};
statetype s_dariancollide2 = {false,SPR_DARIAN_PAIN2,0,T_Collide,ST_NULL,&s_dariancollide2};


statetype s_darianshoot4  = {false,SPR_DARIAN_SHOOT4,10,NULL,ST_NULL,&s_darianchase1};
statetype s_darianshoot3  = {false,SPR_DARIAN_SHOOT3,10,NULL,ST_NULL,&s_darianshoot4};
statetype s_darianshoot2  = {false,SPR_DARIAN_SHOOT2,20,A_MissileWeapon,ST_NULL,&s_darianshoot3};
statetype s_darianshoot1  = {false,SPR_DARIAN_SHOOT1,10,NULL,ST_NULL,&s_darianshoot2};

statetype s_dariandefend3  = {false,SPR_DARIAN_SHOOT3,10,NULL,ST_NULL,&s_darianwait};
statetype s_dariandefend2  = {false,SPR_DARIAN_SHOOT2,20,A_MissileWeapon,ST_NULL,&s_dariandefend3};
statetype s_dariandefend1  = {false,SPR_DARIAN_SHOOT1,10,NULL,ST_NULL,&s_dariandefend2};


statetype s_darianuse4  = {true,SPR_DARIAN_USE11,10,NULL,ST_NULL,&s_darianspears};
statetype s_darianuse3  = {true,SPR_DARIAN_USE21,10,T_Use,ST_NULL,&s_darianuse4};
statetype s_darianuse2  = {true,SPR_DARIAN_USE11,30,NULL,ST_NULL,&s_darianuse3};
statetype s_darianuse1  = {true,SPR_DARIAN_S1,40,NULL,ST_NULL,&s_darianuse2};

statetype s_darianwait = {false,SPR_DARIAN_SHOOT1,0,T_EsauWait,ST_NULL,&s_darianwait};

statetype s_darianspears  = {true,SPR_DARIAN_S1,280,NULL,ST_NULL,&s_darianchase1};


statetype s_dspear16 = {false,SPEARDOWN7,2,T_Spears,SF_DOWN,NULL};
statetype s_dspear15 = {false,SPEARDOWN6,2,T_Spears,SF_CRUSH,&s_dspear16};
statetype s_dspear14 = {false,SPEARDOWN5,2,T_Spears,SF_CRUSH,&s_dspear15};
statetype s_dspear13 = {false,SPEARDOWN4,2,T_Spears,SF_CRUSH,&s_dspear14};
statetype s_dspear12 = {false,SPEARDOWN3,2,T_Spears,SF_CRUSH,&s_dspear13};
statetype s_dspear11 = {false,SPEARDOWN2,2,T_Spears,SF_CRUSH,&s_dspear12};
statetype s_dspear10 = {false,SPEARDOWN1,2,T_Spears,SF_CRUSH,&s_dspear11};
statetype s_dspear9 = {false,SPEARDOWN16,2,T_Spears,SF_CRUSH,&s_dspear10};
statetype s_dspear8 = {false,SPEARDOWN15,2,T_Spears,SF_CRUSH,&s_dspear9};
statetype s_dspear7 = {false,SPEARDOWN14,2,T_Spears,SF_CRUSH,&s_dspear8};
statetype s_dspear6 = {false,SPEARDOWN13,2,T_Spears,SF_CRUSH,&s_dspear7};
statetype s_dspear5 = {false,SPEARDOWN12,2,T_Spears,SF_CRUSH,&s_dspear6};
statetype s_dspear4 = {false,SPEARDOWN11,2,T_Spears,SF_CRUSH,&s_dspear5};
statetype s_dspear3 = {false,SPEARDOWN10,2,T_Spears,SF_CRUSH,&s_dspear4};
statetype s_dspear2 = {false,SPEARDOWN9,2,T_Spears,SF_DOWN,&s_dspear3};
statetype s_dspear1 = {false,SPEARDOWN8,2,T_Spears,SF_DOWN,&s_dspear2};


statetype s_dariandead2 	= {false,SPR_DARIAN_DEAD,0,T_BossDied,ST_NULL,&s_dariandead2};
statetype s_dariandead1 	= {false,SPR_DARIAN_DEAD,140,NULL,ST_NULL,&s_dariandead2};
statetype s_dariandead 	= {false,SPR_DARIAN_DEAD,0,NULL,ST_NULL,&s_dariandead1};

statetype s_dariandie10 = {false,SPR_DARIAN_DIE10,5,NULL,ST_NULL,&s_dariandead};
statetype s_dariandie9 	= {false,SPR_DARIAN_DIE9,5,NULL,ST_NULL,&s_dariandie10};
statetype s_dariandie8 	= {false,SPR_DARIAN_DIE8,5,NULL,ST_NULL,&s_dariandie9};
statetype s_dariandie7 	= {false,SPR_DARIAN_DIE7,5,NULL,ST_NULL,&s_dariandie8};
statetype s_dariandie6 	= {false,SPR_DARIAN_DIE6,5,T_Guts,ST_NULL,&s_dariandie7};
statetype s_dariandie5 	= {false,SPR_DARIAN_DIE5,5,NULL,ST_NULL,&s_dariandie6};
statetype s_dariandie4 	= {false,SPR_DARIAN_DIE4,5,NULL,ST_NULL,&s_dariandie5};
statetype s_dariandie3 	= {false,SPR_DARIAN_DIE3,5,NULL,ST_NULL,&s_dariandie4};
statetype s_dariandie2 	= {false,SPR_DARIAN_DIE2,5,NULL,ST_NULL,&s_dariandie3};
statetype s_dariandie1 	= {false,SPR_DARIAN_DIE1,70,T_Collide,ST_NULL,&s_dariandie2};



/*
===========================================================================

									HEINRICH KRIST

===========================================================================
*/


statetype s_heinrichstand	= {true,SPR_KRIST_S1,0,T_Stand,ST_NULL,&s_heinrichstand};

statetype s_heinrichchase 	= {true,SPR_KRIST_FOR1,10,T_HeinrichChase,ST_NULL,&s_heinrichchase};


statetype s_kristleft = {true,SPR_KRIST_LEFT1,10,T_KristLeft,ST_NULL,&s_kristleft};

statetype s_kristright = {true,SPR_KRIST_RIGHT1,10,T_KristRight,ST_NULL,&s_kristright};

statetype s_heinrichshoot11  = {false,SPR_KRIST_SHOOT11,8,NULL,ST_NULL,&s_heinrichchase};
statetype s_heinrichshoot10  = {false,SPR_KRIST_SHOOT10,8,NULL,ST_NULL,&s_heinrichshoot11};
statetype s_heinrichshoot9  = {false,SPR_KRIST_SHOOT9,8,A_HeinrichShoot,ST_NULL,&s_heinrichshoot10};
statetype s_heinrichshoot8  = {false,SPR_KRIST_SHOOT8,8,NULL,ST_NULL,&s_heinrichshoot9};
statetype s_heinrichshoot7  = {false,SPR_KRIST_SHOOT7,8,T_KristCheckFire,ST_NULL,&s_heinrichshoot8};
statetype s_heinrichshoot6  = {false,SPR_KRIST_SHOOT6,8,NULL,ST_NULL,&s_heinrichshoot7};
statetype s_heinrichshoot5  = {false,SPR_KRIST_SHOOT5,8,NULL,ST_NULL,&s_heinrichshoot6};
statetype s_heinrichshoot4  = {false,SPR_KRIST_SHOOT4,8,A_HeinrichShoot,ST_NULL,&s_heinrichshoot5};
statetype s_heinrichshoot3  = {false,SPR_KRIST_SHOOT3,8,NULL,ST_NULL,&s_heinrichshoot4};
statetype s_heinrichshoot2  = {false,SPR_KRIST_SHOOT2,8,NULL,ST_NULL,&s_heinrichshoot3};
statetype s_heinrichshoot1  = {false,SPR_KRIST_SHOOT1,8,T_KristCheckFire,ST_NULL,&s_heinrichshoot2};

statetype s_missile1       = {16,SPR_BJMISS11,6,T_Projectile,ST_NULL,&s_missile1};


statetype s_missilehit3    = {false,SPR_MISSILEHIT3,6,NULL,ST_NULL,NULL};
statetype s_missilehit2    = {false,SPR_MISSILEHIT2,6,NULL,ST_NULL,&s_missilehit3};
statetype s_missilehit1    = {false,SPR_MISSILEHIT1,6,NULL,ST_NULL,&s_missilehit2};

statetype s_mine4          = {false,SPR_MINE4,3,T_Projectile,ST_NULL,&s_mine1};
statetype s_mine3          = {false,SPR_MINE3,3,T_Projectile,ST_NULL,&s_mine4};
statetype s_mine2          = {false,SPR_MINE2,3,T_Projectile,ST_NULL,&s_mine3};
statetype s_mine1          = {false,SPR_MINE1,3,T_Projectile,ST_NULL,&s_mine2};

statetype s_heinrichdefend = {true,SPR_KRIST_MINERIGHT1,35,T_Heinrich_Defend,ST_NULL,&s_heinrichdefend};


statetype s_heinrichooc    = {true,SPR_KRIST_DEAD1,0,T_Heinrich_Out_of_Control,ST_NULL,&s_heinrichooc};

statetype s_heinrichdead 	= {false,SPR_KRIST_DEAD1,35,T_Collide,ST_NULL,&s_heinrichooc};

statetype s_heinrichdie2 	= {false,SPR_KRIST_DIE2,35,T_Collide,ST_NULL,&s_heinrichdead};
statetype s_heinrichdie1 	= {false,SPR_KRIST_DIE1,35,T_Collide,ST_NULL,&s_heinrichdie2};

statetype s_heindead2 = {false,-1,0,T_BossDied,ST_NULL,NULL};
statetype s_heindead1 = {false, -1, 140,NULL,ST_NULL,&s_heindead2};
statetype s_heinexp13 = {false,SPR_EXPLOSION13,2,NULL,ST_NULL,&s_heindead1};
statetype s_heinexp12 = {false,SPR_EXPLOSION12,2,NULL,ST_NULL,&s_heinexp13};
statetype s_heinexp11 = {false,SPR_EXPLOSION11,2,NULL,ST_NULL,&s_heinexp12};
statetype s_heinexp10 = {false,SPR_EXPLOSION10,2,NULL,ST_NULL,&s_heinexp11};
statetype s_heinexp9 = {false,SPR_EXPLOSION9,2,NULL,ST_NULL,&s_heinexp10};
statetype s_heinexp8 = {false,SPR_EXPLOSION8,2,NULL,ST_NULL,&s_heinexp9};
statetype s_heinexp7 = {false,SPR_EXPLOSION7,2,NULL,ST_NULL,&s_heinexp8};
statetype s_heinexp6 = {false,SPR_EXPLOSION6,2,NULL,ST_NULL,&s_heinexp7};
statetype s_heinexp5 = {false,SPR_EXPLOSION5,2,NULL,ST_NULL,&s_heinexp6};
statetype s_heinexp4 = {false,SPR_EXPLOSION4,2,NULL,ST_NULL,&s_heinexp5};
statetype s_heinexp3 = {false,SPR_EXPLOSION3,2,T_Explosion,ST_NULL,&s_heinexp4};
statetype s_heinexp2 = {false,SPR_EXPLOSION2,2,NULL,ST_NULL,&s_heinexp3};
statetype s_heinexp1 = {false,SPR_EXPLOSION1,0,NULL,ST_NULL,&s_heinexp2};


/*
===========================================================================

								  DARK MONK (TOM)

===========================================================================
*/


statetype s_darkmonkstand	= {true,TOMS1,0,T_Stand,ST_NULL,&s_darkmonkstand};

statetype s_darkmonkland	= {true,TOMFLY11,6,NULL,ST_NULL,&s_darkmonkstand};


statetype s_darkmonkchase2	= {true,TOMFLY21,10,T_DarkmonkChase,ST_NULL,&s_darkmonkchase2};
statetype s_darkmonkchase1	= {true,TOMFLY11,3,T_DarkmonkChase,ST_NULL,&s_darkmonkchase2};

statetype s_dmlandandfire = {true,TOMFLY11,0,T_DarkmonkLandAndFire,ST_NULL,&s_dmlandandfire};

statetype s_darkmonkcover3	= {false,TAWAKEN1,1,NULL,ST_NULL,&s_darkmonkawaken1};
statetype s_darkmonkcover2	= {false,TAWAKEN2,1,NULL,ST_NULL,&s_darkmonkcover3};
statetype s_darkmonkcover1	= {false,TAWAKEN3,1,NULL,ST_NULL,&s_darkmonkcover2};


statetype s_darkmonkawaken5	= {false,TAWAKEN5,3,NULL,ST_NULL,&s_darkmonkchase1};
statetype s_darkmonkawaken4	= {false,TAWAKEN4,3,NULL,ST_NULL,&s_darkmonkawaken5};
statetype s_darkmonkawaken3	= {false,TAWAKEN3,3,NULL,ST_NULL,&s_darkmonkawaken4};
statetype s_darkmonkawaken2	= {false,TAWAKEN2,3,NULL,ST_NULL,&s_darkmonkawaken3};
statetype s_darkmonkawaken1 	= {false,TAWAKEN1,3,NULL,ST_NULL,&s_darkmonkawaken2};


statetype s_darkmonklightning11	= {false,TOMLG11,3,NULL,ST_NULL,&s_darkmonkchase1};
statetype s_darkmonklightning10	= {false,TOMLG10,3,NULL,ST_NULL,&s_darkmonklightning11};
statetype s_darkmonklightning9	= {false,TOMLG9,70,A_DmonkAttack,ST_NULL,&s_darkmonklightning10};
statetype s_darkmonklightning8	= {false,TOMLG8,3,NULL,ST_NULL,&s_darkmonklightning9};
statetype s_darkmonklightning7 	= {false,TOMLG7,3,NULL,ST_NULL,&s_darkmonklightning8};
statetype s_darkmonklightning6	= {false,TOMLG6,3,NULL,ST_NULL,&s_darkmonklightning7};
statetype s_darkmonklightning5	= {false,TOMLG5,3,NULL,ST_NULL,&s_darkmonklightning6};
statetype s_darkmonklightning4	= {false,TOMLG4,3,NULL,ST_NULL,&s_darkmonklightning5};
statetype s_darkmonklightning3	= {false,TOMLG3,3,NULL,ST_NULL,&s_darkmonklightning4};
statetype s_darkmonklightning2 	= {false,TOMLG2,3,NULL,ST_NULL,&s_darkmonklightning3};
statetype s_darkmonklightning1 	= {false,TOMLG1,3,NULL,ST_NULL,&s_darkmonklightning2};

statetype s_darkmonkfspark6	= {false,TOMFS6,3,NULL,ST_NULL,&s_darkmonkchase1};
statetype s_darkmonkfspark5	= {false,TOMFS5,70,A_DmonkAttack,ST_NULL,&s_darkmonkfspark6};
statetype s_darkmonkfspark4	= {false,TOMFS4,3,NULL,ST_NULL,&s_darkmonkfspark5};
statetype s_darkmonkfspark3	= {false,TOMFS3,3,NULL,ST_NULL,&s_darkmonkfspark4};
statetype s_darkmonkfspark2 	= {false,TOMFS2,3,NULL,ST_NULL,&s_darkmonkfspark3};
statetype s_darkmonkfspark1 	= {false,TOMFS1,3,NULL,ST_NULL,&s_darkmonkfspark2};


statetype s_darkmonkbreathe8	= {false,TOMBR8,3,NULL,ST_NULL,&s_darkmonkchase1};
statetype s_darkmonkbreathe7 	= {false,TOMBR7,3,NULL,ST_NULL,&s_darkmonkbreathe8};
statetype s_darkmonkbreathe6	= {false,TOMBR6,70,A_DmonkAttack,ST_NULL,&s_darkmonkbreathe7};
statetype s_darkmonkbreathe5	= {false,TOMBR5,3,NULL,ST_NULL,&s_darkmonkbreathe6};
statetype s_darkmonkbreathe4	= {false,TOMBR4,3,NULL,ST_NULL,&s_darkmonkbreathe5};
statetype s_darkmonkbreathe3	= {false,TOMBR3,3,NULL,ST_NULL,&s_darkmonkbreathe4};
statetype s_darkmonkbreathe2 	= {false,TOMBR2,3,NULL,ST_NULL,&s_darkmonkbreathe3};
statetype s_darkmonkbreathe1 	= {false,TOMBR1,70,NULL,ST_NULL,&s_darkmonkbreathe2};

statetype s_darkmonksummon3	= {false,TOMBR1,3,NULL,ST_NULL,&s_darkmonkchase1};
statetype s_darkmonksummon2 	= {false,TOMBR3,3,NULL,ST_NULL,&s_darkmonksummon3};
statetype s_darkmonksummon1 	= {false,TOMBR2,3,NULL,ST_NULL,&s_darkmonksummon2};

statetype s_snakepath = {true,TOMHEAD1,0,T_SnakePath,ST_NULL,&s_snakepath};
statetype s_snakefindpath = {true,TOMHEAD1,0,T_SnakeFindPath,ST_NULL,&s_snakefindpath};

statetype s_darkmonkhead	= {true,TOMHEAD1,0,T_DarkSnakeChase,ST_NULL,&s_darkmonkhead};
statetype s_darkmonksnakelink	= {true,TOMHEAD1,0,T_GenericMove,ST_NULL,&s_darkmonksnakelink};


statetype s_darkmonkhspawn = {false,NOTHING,78,T_DarkSnakeSpawn,ST_NULL,NULL};
statetype s_darkmonkfastspawn = {false,NOTHING,35,T_DarkSnakeSpawn,ST_NULL,NULL};

statetype s_darkmonkheaddead	= {false,THDIE2,0,NULL,ST_NULL,&s_darkmonkheaddead};
statetype s_darkmonkheaddie1	= {false,THDIE1,1400,T_SnakeFinale,ST_NULL,&s_snakefireworks1};

statetype s_snakefireworks2 = {false,THDIE2,10,T_SnakeFinale,ST_NULL,&s_snakefireworks1};
statetype s_snakefireworks1 = {false,THDIE1,10,T_SnakeFinale,ST_NULL,&s_snakefireworks2};

statetype s_darkmonkhball9	= {false,THBALL9,5,NULL,ST_NULL,&s_darkmonkchase1};
statetype s_darkmonkhball8	= {false,THBALL8,5,NULL,ST_NULL,&s_darkmonkhball9};
statetype s_darkmonkhball7 = {false,THBALL7,5,A_DmonkAttack,ST_NULL,&s_darkmonkhball8};
statetype s_darkmonkhball6	= {false,THBALL6,5,NULL,ST_NULL,&s_darkmonkhball7};
statetype s_darkmonkhball5	= {false,THBALL5,5,NULL,ST_NULL,&s_darkmonkhball6};
statetype s_darkmonkhball4	= {false,THBALL4,5,NULL,ST_NULL,&s_darkmonkhball5};
statetype s_darkmonkhball3	= {false,THBALL3,5,NULL,ST_NULL,&s_darkmonkhball4};
statetype s_darkmonkhball2 = {false,THBALL2,5,NULL,ST_NULL,&s_darkmonkhball3};
statetype s_darkmonkhball1 = {false,THBALL1,70,NULL,ST_NULL,&s_darkmonkhball2};

statetype s_darkmonkabsorb9	= {false,THBALL9,3,NULL,ST_NULL,&s_darkmonksphere1};
statetype s_darkmonkabsorb8	= {false,THBALL8,3,NULL,ST_NULL,&s_darkmonkabsorb9};
statetype s_darkmonkabsorb7 = {false,THBALL7,3,NULL,ST_NULL,&s_darkmonkabsorb8};
statetype s_darkmonkabsorb6	= {false,THBALL6,3,NULL,ST_NULL,&s_darkmonkabsorb7};
statetype s_darkmonkabsorb5	= {false,THBALL5,3,NULL,ST_NULL,&s_darkmonkabsorb6};
statetype s_darkmonkabsorb4	= {false,THBALL4,3,NULL,ST_NULL,&s_darkmonkabsorb5};
statetype s_darkmonkabsorb3	= {false,THBALL3,3,NULL,ST_NULL,&s_darkmonkabsorb4};
statetype s_darkmonkabsorb2 = {false,THBALL2,3,NULL,ST_NULL,&s_darkmonkabsorb3};
statetype s_darkmonkabsorb1 = {false,THBALL1,3,NULL,ST_NULL,&s_darkmonkabsorb2};


statetype s_darkmonksphere10 = {false,TSPHERE10,4,NULL,ST_NULL,&s_darkmonkchase1};
statetype s_darkmonksphere9 = {false,TSPHERE9,4,NULL,ST_NULL,&s_darkmonksphere10};
statetype s_darkmonksphere8 = {false,TSPHERE8,4,A_DmonkAttack,ST_NULL,&s_darkmonksphere9};
statetype s_darkmonksphere7 = {false,TSPHERE7,4,NULL,ST_NULL,&s_darkmonksphere8};
statetype s_darkmonksphere6 = {false,TSPHERE6,4,NULL,ST_NULL,&s_darkmonksphere7};
statetype s_darkmonksphere5 = {false,TSPHERE5,4,NULL,ST_NULL,&s_darkmonksphere6};
statetype s_darkmonksphere4 = {false,TSPHERE4,4,NULL,ST_NULL,&s_darkmonksphere5};
statetype s_darkmonksphere3 = {false,TSPHERE3,4,NULL,ST_NULL,&s_darkmonksphere4};
statetype s_darkmonksphere2 = {false,TSPHERE2,4,NULL,ST_NULL,&s_darkmonksphere3};
statetype s_darkmonksphere1 = {false,TSPHERE1,4,NULL,ST_NULL,&s_darkmonksphere2};

statetype s_dmgreenthing10 = {false,TSPHERE10,4,NULL,ST_NULL,&s_darkmonkchase1};
statetype s_dmgreenthing9 = {false,TSPHERE9,4,NULL,ST_NULL,&s_dmgreenthing10};
statetype s_dmgreenthing8 = {false,TSPHERE8,4,A_DmonkAttack,ST_NULL,&s_dmgreenthing9};
statetype s_dmgreenthing7 = {false,TSPHERE7,4,NULL,ST_NULL,&s_dmgreenthing8};
statetype s_dmgreenthing6 = {false,TSPHERE6,4,NULL,ST_NULL,&s_dmgreenthing7};
statetype s_dmgreenthing5 = {false,TSPHERE5,4,NULL,ST_NULL,&s_dmgreenthing6};
statetype s_dmgreenthing4 = {false,TSPHERE4,4,NULL,ST_NULL,&s_dmgreenthing5};
statetype s_dmgreenthing3 = {false,TSPHERE3,4,NULL,ST_NULL,&s_dmgreenthing4};
statetype s_dmgreenthing2 = {false,TSPHERE2,4,NULL,ST_NULL,&s_dmgreenthing3};
statetype s_dmgreenthing1 = {false,TSPHERE1,4,NULL,ST_NULL,&s_dmgreenthing2};


statetype s_energysphere4 = {false,TOMSPHERE4,4,T_Projectile,ST_NULL,&s_energysphere1};
statetype s_energysphere3 = {false,TOMSPHERE3,4,T_Projectile,ST_NULL,&s_energysphere4};
statetype s_energysphere2 = {false,TOMSPHERE2,4,T_Projectile,ST_NULL,&s_energysphere3};
statetype s_energysphere1 = {false,TOMSPHERE1,4,T_Projectile,ST_NULL,&s_energysphere2};


statetype s_lightning = {true,TOMLIGHTNING1,0,T_Projectile,ST_NULL,&s_lightning};


statetype s_handball2 = {false,TOMHANDBALL2,3,T_Projectile,ST_NULL,&s_handball1};
statetype s_handball1 = {false,TOMHANDBALL1,3,T_Projectile,ST_NULL,&s_handball2};

statetype s_faceball2 = {false,TOMFACEBALL2,3,T_Projectile,ST_NULL,&s_faceball1};
statetype s_faceball1 = {false,TOMFACEBALL1,3,T_Projectile,ST_NULL,&s_faceball2};

statetype s_floorspark4 = {false,TOMFLOORSPARK4,3,T_Projectile,ST_NULL,&s_floorspark1};
statetype s_floorspark3 = {false,TOMFLOORSPARK3,3,T_Projectile,ST_NULL,&s_floorspark4};
statetype s_floorspark2 = {false,TOMFLOORSPARK2,3,T_Projectile,ST_NULL,&s_floorspark3};
statetype s_floorspark1 = {false,TOMFLOORSPARK1,3,T_Projectile,ST_NULL,&s_floorspark2};



statetype s_darkmonkreact = {true,TOMFLY11,0,T_DarkmonkReact,ST_NULL,&s_darkmonkreact};

statetype s_darkmonkbball9	= {false,TBBALL9,4,NULL,ST_NULL,&s_darkmonkchase1};
statetype s_darkmonkbball8	= {false,TBBALL8,4,NULL,ST_NULL,&s_darkmonkbball9};
statetype s_darkmonkbball7 = {false,TBBALL7,4,A_DmonkAttack,ST_NULL,&s_darkmonkbball8};
statetype s_darkmonkbball6	= {false,TBBALL6,4,NULL,ST_NULL,&s_darkmonkbball7};
statetype s_darkmonkbball5	= {false,TBBALL5,4,NULL,ST_NULL,&s_darkmonkbball6};
statetype s_darkmonkbball4	= {false,TBBALL4,4,NULL,ST_NULL,&s_darkmonkbball5};
statetype s_darkmonkbball3	= {false,TBBALL3,4,NULL,ST_NULL,&s_darkmonkbball4};
statetype s_darkmonkbball2 = {false,TBBALL2,4,NULL,ST_NULL,&s_darkmonkbball3};
statetype s_darkmonkbball1 = {false,TBBALL1,70,NULL,ST_NULL,&s_darkmonkbball2};


statetype s_darkmonkcharge10 = {false,TSCAREB3,140,T_DarkmonkCharge,ST_NULL,&s_darkmonkchase1};
statetype s_darkmonkcharge9	= {false,TAWAKEN5,3,NULL,ST_NULL,&s_darkmonkcharge10};
statetype s_darkmonkcharge8	= {false,TAWAKEN4,3,NULL,ST_NULL,&s_darkmonkcharge9};
statetype s_darkmonkcharge7	= {false,TAWAKEN3,3,NULL,ST_NULL,&s_darkmonkcharge8};
statetype s_darkmonkcharge6 	= {false,TAWAKEN2,3,NULL,ST_NULL,&s_darkmonkcharge7};
statetype s_darkmonkcharge5	= {false,TAWAKEN1,3,NULL,ST_NULL,&s_darkmonkcharge6};
statetype s_darkmonkcharge4	= {false,TAWAKEN2,3,NULL,ST_NULL,&s_darkmonkcharge5};
statetype s_darkmonkcharge3	= {false,TAWAKEN3,3,NULL,ST_NULL,&s_darkmonkcharge4};
statetype s_darkmonkcharge2	= {false,TAWAKEN4,3,NULL,ST_NULL,&s_darkmonkcharge3};
statetype s_darkmonkcharge1 	= {false,TAWAKEN5,3,NULL,ST_NULL,&s_darkmonkcharge2};


statetype s_darkmonkscare5	= {false,TSCAREB5,3,NULL,ST_NULL,&s_darkmonkcharge1};
statetype s_darkmonkscare4	= {false,TSCAREB4,3,NULL,ST_NULL,&s_darkmonkscare5};
statetype s_darkmonkscare3	= {false,TSCAREB3,3,NULL,ST_NULL,&s_darkmonkscare4};
statetype s_darkmonkscare2 = {false,TSCAREB2,3,NULL,ST_NULL,&s_darkmonkscare3};
statetype s_darkmonkscare1 = {false,TSCAREB1,3,NULL,ST_NULL,&s_darkmonkscare2};

statetype s_darkmonkdead = {false,TOMDIE8,0,T_Collide,ST_NULL,&s_darkmonkdead};
statetype s_darkmonkdie7 = {false,TOMDIE7,3,T_Collide,ST_NULL,&s_darkmonkdead};
statetype s_darkmonkdie6 = {false,TOMDIE6,3,T_Collide,ST_NULL,&s_darkmonkdie7};
statetype s_darkmonkdie5 = {false,TOMDIE5,3,T_Collide,ST_NULL,&s_darkmonkdie6};
statetype s_darkmonkdie4 = {false,TOMDIE4,3,T_Collide,ST_NULL,&s_darkmonkdie5};
statetype s_darkmonkdie3 = {false,TOMDIE3,3,T_Collide,ST_NULL,&s_darkmonkdie4};
statetype s_darkmonkdie2 = {false,TOMDIE2,3,T_Collide,ST_NULL,&s_darkmonkdie3};
statetype s_darkmonkdie1 = {false,TOMDIE1,3,T_Collide,ST_NULL,&s_darkmonkdie2};



statetype s_darkmonkredhead = {true,TOMRH1,50,T_DarkSnakeChase,ST_NULL,&s_darkmonkhead};
statetype s_darkmonkredlink = {true,TOMRH1,50,T_GenericMove,ST_NULL,&s_darkmonksnakelink};

statetype s_redheadhit = {false,THDIE1,35,T_DarkSnakeChase,ST_NULL,&s_darkmonkhead};
statetype s_redlinkhit = {false,THDIE1,35,T_GenericMove,ST_NULL,&s_darkmonksnakelink};


statetype s_spithit4 = {false,SPITHIT4,3,NULL,ST_NULL,NULL};
statetype s_spithit3 = {false,SPITHIT3,3,NULL,ST_NULL,&s_spithit4};
statetype s_spithit2 = {false,SPITHIT2,3,NULL,ST_NULL,&s_spithit3};
statetype s_spithit1 = {false,SPITHIT1,3,NULL,ST_NULL,&s_spithit2};

statetype s_spit4 = {false,TOMSPIT4,3,T_Projectile,ST_NULL,&s_spit1};
statetype s_spit3 = {false,TOMSPIT3,3,T_Projectile,ST_NULL,&s_spit4};
statetype s_spit2 = {false,TOMSPIT2,3,T_Projectile,ST_NULL,&s_spit3};
statetype s_spit1 = {false,TOMSPIT1,3,T_Projectile,ST_NULL,&s_spit2};

statetype s_snakefire2 = {true,TOMHEAD1,1,T_DarkSnakeChase,SF_DOWN|SF_UP,&s_darkmonkhead};
statetype s_snakefire1 = {false,TPREPARE,30,T_DarkSnakeChase,SF_DOWN,&s_snakefire2};

statetype s_dexplosion22 = {false,-1,0,T_BossDied,ST_NULL,NULL};
statetype s_dexplosion21 = {false, -1, 240,NULL,ST_NULL,&s_dexplosion22};
statetype s_dexplosion20 = {false,SPR_EXPLOSION20,2,NULL,ST_NULL,&s_dexplosion21};
statetype s_dexplosion19 = {false,SPR_EXPLOSION19,2,NULL,ST_NULL,&s_dexplosion20};
statetype s_dexplosion18 = {false,SPR_EXPLOSION18,2,NULL,ST_NULL,&s_dexplosion19};
statetype s_dexplosion17 = {false,SPR_EXPLOSION17,2,NULL,ST_NULL,&s_dexplosion18};
statetype s_dexplosion16 = {false,SPR_EXPLOSION16,2,NULL,ST_NULL,&s_dexplosion17};
statetype s_dexplosion15 = {false,SPR_EXPLOSION15,2,NULL,ST_NULL,&s_dexplosion16};
statetype s_dexplosion14 = {false,SPR_EXPLOSION14,2,NULL,ST_NULL,&s_dexplosion15};
statetype s_dexplosion13 = {false,SPR_EXPLOSION13,2,NULL,ST_NULL,&s_dexplosion14};
statetype s_dexplosion12 = {false,SPR_EXPLOSION12,2,NULL,ST_NULL,&s_dexplosion13};
statetype s_dexplosion11 = {false,SPR_EXPLOSION11,2,NULL,ST_NULL,&s_dexplosion12};
statetype s_dexplosion10 = {false,SPR_EXPLOSION10,2,NULL,ST_NULL,&s_dexplosion11};
statetype s_dexplosion9 = {false,SPR_EXPLOSION9,2,NULL,ST_NULL,&s_dexplosion10};
statetype s_dexplosion8 = {false,SPR_EXPLOSION8,2,NULL,ST_NULL,&s_dexplosion9};
statetype s_dexplosion7 = {false,SPR_EXPLOSION7,2,NULL,ST_NULL,&s_dexplosion8};
statetype s_dexplosion6 = {false,SPR_EXPLOSION6,2,NULL,ST_NULL,&s_dexplosion7};
statetype s_dexplosion5 = {false,SPR_EXPLOSION5,2,NULL,ST_NULL,&s_dexplosion6};
statetype s_dexplosion4 = {false,SPR_EXPLOSION4,2,NULL,ST_NULL,&s_dexplosion5};
statetype s_dexplosion3 = {false,SPR_EXPLOSION3,2,T_Explosion,ST_NULL,&s_dexplosion4};
statetype s_dexplosion2 = {false,SPR_EXPLOSION2,2,NULL,ST_NULL,&s_dexplosion3};
statetype s_dexplosion1 = {false,SPR_EXPLOSION1,2,NULL,ST_NULL,&s_dexplosion2};


/*
===========================================================================

									OROBOT

===========================================================================
*/

statetype s_NMEdeathbuildup = {16,NMEBODY1_01,210,T_NME_Explode,ST_NULL,NULL};
statetype s_NMEheadexplosion = {16,NMEHEAD1_01,140,T_Special,ST_NULL,&s_grexplosion1};

statetype s_NMEstand = {16,NMEBODY1_01,0,T_Stand,ST_NULL,&s_NMEstand};
statetype s_NMEhead1 = {16,NMEHEAD1_01,0,NULL,ST_NULL,&s_NMEhead1};
statetype s_NMEhead2 = {16,NMEHEAD2_01,0,NULL,ST_NULL,&s_NMEhead2};
statetype s_NMEchase = {16,NMEBODY1_01,20,T_OrobotChase,ST_NULL,&s_NMEchase};
statetype s_NMEwheels1 = {16,NMEWHEEL1_01,0,NULL,ST_NULL,&s_NMEwheels1};
statetype s_NMEwheels2 = {16,NMEWHEEL2_01,0,NULL,ST_NULL,&s_NMEwheels2};
statetype s_NMEwheels3 = {16,NMEWHEEL3_01,0,NULL,ST_NULL,&s_NMEwheels3};
statetype s_NMEwheels4 = {16,NMEWHEEL4_01,0,NULL,ST_NULL,&s_NMEwheels4};
statetype s_NMEwheels5 = {16,NMEWHEEL5_01,0,NULL,ST_NULL,&s_NMEwheels5};

statetype s_shootinghead = {16,NMEHEAD1_01,140,T_NME_HeadShoot,ST_NULL,&s_shootinghead};

statetype s_NMEspinattack = {16,NMEBODY1_01,70,T_NME_SpinAttack,ST_NULL,&s_NMEchase};
statetype s_NMEwheelspin = {16,NMEWHEEL1_01,70,NULL,ST_NULL,&s_NMEwheels2};

statetype s_NMEminiball4 = {false,NMEMINIBALL_04,4,T_Projectile,ST_NULL,&s_NMEminiball1};
statetype s_NMEminiball3 = {false,NMEMINIBALL_03,4,T_Projectile,ST_NULL,&s_NMEminiball4};
statetype s_NMEminiball2 = {false,NMEMINIBALL_02,4,T_Projectile,ST_NULL,&s_NMEminiball3};
statetype s_NMEminiball1 = {false,NMEMINIBALL_01,4,T_Projectile,ST_NULL,&s_NMEminiball2};

statetype s_NMEsaucer4 = {false,NMESAUCER_04,6,T_Saucer,ST_NULL,&s_NMEsaucer1};
statetype s_NMEsaucer3 = {false,NMESAUCER_03,6,T_Saucer,ST_NULL,&s_NMEsaucer4};
statetype s_NMEsaucer2 = {false,NMESAUCER_02,6,T_Saucer,ST_NULL,&s_NMEsaucer3};
statetype s_NMEsaucer1 = {false,NMESAUCER_01,6,T_Saucer,SF_SOUND,&s_NMEsaucer2};

statetype s_NMEdie = {16,NMEBODY1_01,0,T_Collide,ST_NULL,&s_NMEdie};


statetype s_NMEspinfire = {16,NMEBODY1_01,0,T_NME_SpinFire,ST_NULL,&s_NMEspinfire};
statetype s_NMEattack = {16,NMEBODY1_01,0,T_NME_Attack,ST_NULL,&s_NMEattack};
statetype s_NMEhead1rl = {16,NMEROCKET_01,0,NULL,ST_NULL,&s_NMEhead1rl};
statetype s_NMEhead2rl = {16,NMEROCKET2_01,0,NULL,ST_NULL,&s_NMEhead2rl};

statetype s_NMEwindup = {16,NMEBODY1_01,0,T_NME_WindUp,ST_NULL,&s_NMEwindup};

statetype s_NMEwheels120 = {16,NMEWHEEL1_01,0,NULL,ST_NULL,&s_NMEwheels120};

statetype s_NMEwrotleft3 = {16,NMEWHEEL4_01,10,NULL,ST_NULL,&s_NMEwrotleft3};
statetype s_NMEwrotleft2 = {16,NMEWHEEL3_01,10,NULL,ST_NULL,&s_NMEwrotleft3};
statetype s_NMEwrotleft1 = {16,NMEWHEEL2_01,10,NULL,ST_NULL,&s_NMEwrotleft2};

statetype s_NMEwrotright3 = {16,NMEWHEEL4_01,10,NULL,ST_NULL,&s_NMEwrotleft3};
statetype s_NMEwrotright2 = {16,NMEWHEEL5_01,10,NULL,ST_NULL,&s_NMEwrotleft3};
statetype s_NMEwrotright1 = {16,NMEWHEEL2_01,10,NULL,ST_NULL,&s_NMEwrotleft2};

statetype  s_oshuriken4 = {false,SPR_OSHUR4,1,T_Projectile,ST_NULL,&s_oshuriken1};
statetype  s_oshuriken3 = {false,SPR_OSHUR3,1,T_Projectile,ST_NULL,&s_oshuriken4};
statetype  s_oshuriken2 = {false,SPR_OSHUR2,1,T_Projectile,ST_NULL,&s_oshuriken3};
statetype  s_oshuriken1 = {false,SPR_OSHUR1,1,T_Projectile,ST_NULL,&s_oshuriken2};

statetype  s_oshurikenhit3 = {false,SPR_OSHURHIT3,3,NULL,ST_NULL,NULL};
statetype  s_oshurikenhit2 = {false,SPR_OSHURHIT2,3,NULL,ST_NULL,&s_oshurikenhit3};
statetype  s_oshurikenhit1 = {false,SPR_OSHURHIT1,3,NULL,ST_NULL,&s_oshurikenhit2};

statetype s_speardown16 = {false,SPEARDOWN16,2,T_Spears,SF_CRUSH,&s_speardown1};
statetype s_speardown15 = {false,SPEARDOWN15,2,T_Spears,SF_CRUSH,&s_speardown16};
statetype s_speardown14 = {false,SPEARDOWN14,2,T_Spears,SF_CRUSH,&s_speardown15};
statetype s_speardown13 = {false,SPEARDOWN13,2,T_Spears,SF_CRUSH,&s_speardown14};
statetype s_speardown12 = {false,SPEARDOWN12,2,T_Spears,SF_CRUSH,&s_speardown13};
statetype s_speardown11 = {false,SPEARDOWN11,2,T_Spears,SF_CRUSH,&s_speardown12};
statetype s_speardown10 = {false,SPEARDOWN10,2,T_Spears,SF_CRUSH,&s_speardown11};
statetype s_speardown9 = {false,SPEARDOWN9,2,T_Spears,SF_DOWN,&s_speardown10};

statetype s_speardown8 = {false,SPEARDOWN8,35,T_Spears,SF_DOWN|SF_SOUND,&s_speardown9};
statetype s_speardown7 = {false,SPEARDOWN7,2,T_Spears,SF_DOWN,&s_speardown8};
statetype s_speardown6 = {false,SPEARDOWN6,2,T_Spears,SF_CRUSH,&s_speardown7};
statetype s_speardown5 = {false,SPEARDOWN5,2,T_Spears,SF_CRUSH,&s_speardown6};
statetype s_speardown4 = {false,SPEARDOWN4,2,T_Spears,SF_CRUSH,&s_speardown5};
statetype s_speardown3 = {false,SPEARDOWN3,2,T_Spears,SF_CRUSH,&s_speardown4};
statetype s_speardown2 = {false,SPEARDOWN2,2,T_Spears,SF_CRUSH,&s_speardown3};
statetype s_speardown1 = {false,SPEARDOWN1,2,T_Spears,SF_CRUSH,&s_speardown2};



statetype s_downblade16 = {false,DBLADE8,1,T_Path,ST_NULL,&s_downblade1};
statetype s_downblade15 = {false,DBLADE7,2,T_Path,ST_NULL,&s_downblade16};
statetype s_downblade14 = {false,DBLADE6,1,T_Path,ST_NULL,&s_downblade15};
statetype s_downblade13 = {false,DBLADE5,2,T_Path,ST_NULL,&s_downblade14};
statetype s_downblade12 = {false,DBLADE4,1,T_Path,ST_NULL,&s_downblade13};
statetype s_downblade11 = {false,DBLADE3,2,T_Path,ST_NULL,&s_downblade12};
statetype s_downblade10 = {false,DBLADE2,1,T_Path,ST_NULL,&s_downblade11};
statetype s_downblade9 = {false,DBLADE9,2,T_Path,ST_NULL,&s_downblade10};
statetype s_downblade8 = {false,DBLADE8,1,T_Path,ST_NULL,&s_downblade9};
statetype s_downblade7 = {false,DBLADE7,2,T_Path,ST_NULL,&s_downblade8};
statetype s_downblade6 = {false,DBLADE6,1,T_Path,ST_NULL,&s_downblade7};
statetype s_downblade5 = {false,DBLADE5,2,T_Path,ST_NULL,&s_downblade6};
statetype s_downblade4 = {false,DBLADE4,1,T_Path,ST_NULL,&s_downblade5};
statetype s_downblade3 = {false,DBLADE3,2,T_Path,ST_NULL,&s_downblade4};
statetype s_downblade2 = {false,DBLADE2,1,T_Path,ST_NULL,&s_downblade3};
statetype s_downblade1 = {false,DBLADE1,2,T_Path,SF_SOUND,&s_downblade2};


statetype s_firejetdown23 = {false,FIREJETDOWN23,3,T_Path,SF_CRUSH,&s_firejetdown1};
statetype s_firejetdown22 = {false,FIREJETDOWN22,3,T_Path,SF_CRUSH,&s_firejetdown23};
statetype s_firejetdown21 = {false,FIREJETDOWN21,3,T_Path,ST_NULL,&s_firejetdown22};
statetype s_firejetdown20 = {false,FIREJETDOWN20,3,T_Path,ST_NULL,&s_firejetdown21};
statetype s_firejetdown19 = {false,FIREJETDOWN19,3,T_Path,ST_NULL,&s_firejetdown20};
statetype s_firejetdown18 = {false,FIREJETDOWN18,3,T_Path,ST_NULL,&s_firejetdown19};
statetype s_firejetdown17 = {false,FIREJETDOWN17,3,T_Path,ST_NULL,&s_firejetdown18};
statetype s_firejetdown16 = {false,FIREJETDOWN16,3,T_Path,SF_CRUSH,&s_firejetdown17};
statetype s_firejetdown15 = {false,FIREJETDOWN15,3,T_Path,SF_CRUSH,&s_firejetdown16};
statetype s_firejetdown14 = {false,FIREJETDOWN14,3,T_Path,SF_CRUSH,&s_firejetdown15};
statetype s_firejetdown13 = {false,FIREJETDOWN13,3,T_Path,ST_NULL,&s_firejetdown14};
statetype s_firejetdown12 = {false,FIREJETDOWN12,3,T_Path,ST_NULL,&s_firejetdown13};
statetype s_firejetdown11 = {false,FIREJETDOWN11,3,T_Path,ST_NULL,&s_firejetdown12};
statetype s_firejetdown10 = {false,FIREJETDOWN10,3,T_Path,ST_NULL,&s_firejetdown11};
statetype s_firejetdown9 = {false,FIREJETDOWN9,3,T_Path,ST_NULL,&s_firejetdown10};
statetype s_firejetdown8 = {false,FIREJETDOWN8,3,T_Path,SF_CRUSH,&s_firejetdown9};
statetype s_firejetdown7 = {false,FIREJETDOWN7,3,T_Path,SF_CRUSH,&s_firejetdown8};
statetype s_firejetdown6 = {false,FIREJETDOWN6,3,T_Path,SF_CRUSH,&s_firejetdown7};
statetype s_firejetdown5 = {false,FIREJETDOWN5,3,T_Path,ST_NULL,&s_firejetdown6};
statetype s_firejetdown4 = {false,FIREJETDOWN4,3,T_Path,ST_NULL,&s_firejetdown5};
statetype s_firejetdown3 = {false,FIREJETDOWN3,3,T_Path,ST_NULL,&s_firejetdown4};
statetype s_firejetdown2 = {false,FIREJETDOWN2,3,T_Path,ST_NULL,&s_firejetdown3};
statetype s_firejetdown1 = {false,FIREJETDOWN1,70,T_Path,SF_SOUND,&s_firejetdown2};



statetype s_columnupdown6 = {false,CRUSHUP7,5,T_CrushUp,SF_DOWN,&s_columnupup1};
statetype s_columnupdown5 = {false,CRUSHUP6,2,T_CrushUp,SF_DOWN,&s_columnupdown6};
statetype s_columnupdown4 = {false,CRUSHUP5,5,T_CrushUp,SF_DOWN|SF_BLOCK,&s_columnupdown5};
statetype s_columnupdown3 = {false,CRUSHUP4,5,T_CrushUp,SF_DOWN|SF_BLOCK,&s_columnupdown4};
statetype s_columnupdown2 = {false,CRUSHUP3,5,T_CrushUp,SF_DOWN|SF_BLOCK,&s_columnupdown3};
statetype s_columnupdown1 = {false,CRUSHUP2,2,T_CrushUp,SF_DOWN|SF_BLOCK,&s_columnupdown2};


statetype s_columnupup8 = {false,CRUSHUP1,5,T_CrushUp,SF_CRUSH|SF_BLOCK,&s_columnupdown1};
statetype s_columnupup7 = {false,CRUSHUP2,2,T_CrushUp,SF_CRUSH|SF_UP|SF_BLOCK,&s_columnupup8};
statetype s_columnupup6 = {false,CRUSHUP3,5,T_CrushUp,SF_UP|SF_BLOCK,&s_columnupup7};
statetype s_columnupup5 = {false,CRUSHUP4,5,T_CrushUp,SF_UP|SF_BLOCK,&s_columnupup6};
statetype s_columnupup4 = {false,CRUSHUP5,5,T_CrushUp,SF_UP,&s_columnupup5};
statetype s_columnupup3 = {false,CRUSHUP6,2,T_CrushUp,SF_UP,&s_columnupup4};
statetype s_columnupup2 = {false,CRUSHUP7,5,T_CrushUp,SF_UP,&s_columnupup3};
statetype s_columnupup1 = {false,CRUSHUP8,30,T_CrushUp,SF_SOUND,&s_columnupup2};



statetype s_spinupblade16 = {false,SPINUBLADE_16,2,T_Path,SF_DOWN,&s_spinupblade1};
statetype s_spinupblade15 = {false,SPINUBLADE_15,2,T_Path,ST_NULL,&s_spinupblade16};
statetype s_spinupblade14 = {false,SPINUBLADE_14,2,T_Path,ST_NULL,&s_spinupblade15};
statetype s_spinupblade13 = {false,SPINUBLADE_13,2,T_Path,ST_NULL,&s_spinupblade14};
statetype s_spinupblade12 = {false,SPINUBLADE_12,2,T_Path,ST_NULL,&s_spinupblade13};
statetype s_spinupblade11 = {false,SPINUBLADE_11,2,T_Path,ST_NULL,&s_spinupblade12};
statetype s_spinupblade10 = {false,SPINUBLADE_10,2,T_Path,ST_NULL,&s_spinupblade11};
statetype s_spinupblade9 = {false,SPINUBLADE_09,2,T_Path,ST_NULL,&s_spinupblade10};

statetype s_spinupblade8 = {false,SPINUBLADE_08,2,T_Path,ST_NULL,&s_spinupblade9};
statetype s_spinupblade7 = {false,SPINUBLADE_07,2,T_Path,ST_NULL,&s_spinupblade8};
statetype s_spinupblade6 = {false,SPINUBLADE_06,2,T_Path,ST_NULL,&s_spinupblade7};
statetype s_spinupblade5 = {false,SPINUBLADE_05,2,T_Path,ST_NULL,&s_spinupblade6};
statetype s_spinupblade4 = {false,SPINUBLADE_04,2,T_Path,ST_NULL,&s_spinupblade5};
statetype s_spinupblade3 = {false,SPINUBLADE_03,2,T_Path,ST_NULL,&s_spinupblade4};
statetype s_spinupblade2 = {false,SPINUBLADE_02,2,T_Path,ST_NULL,&s_spinupblade3};
statetype s_spinupblade1 = {false,SPINUBLADE_01,35,T_Path,SF_UP|SF_SOUND,&s_spinupblade2};


statetype s_spindownblade16 = {false,SPINDBLADE_16,2,T_Path,SF_DOWN,&s_spindownblade1};
statetype s_spindownblade15 = {false,SPINDBLADE_15,2,T_Path,ST_NULL,&s_spindownblade16};
statetype s_spindownblade14 = {false,SPINDBLADE_14,2,T_Path,ST_NULL,&s_spindownblade15};
statetype s_spindownblade13 = {false,SPINDBLADE_13,2,T_Path,ST_NULL,&s_spindownblade14};
statetype s_spindownblade12 = {false,SPINDBLADE_12,2,T_Path,ST_NULL,&s_spindownblade13};
statetype s_spindownblade11 = {false,SPINDBLADE_11,2,T_Path,ST_NULL,&s_spindownblade12};
statetype s_spindownblade10 = {false,SPINDBLADE_10,2,T_Path,ST_NULL,&s_spindownblade11};
statetype s_spindownblade9 = {false,SPINDBLADE_09,2,T_Path,ST_NULL,&s_spindownblade10};

statetype s_spindownblade8 = {false,SPINDBLADE_08,2,T_Path,ST_NULL,&s_spindownblade9};
statetype s_spindownblade7 = {false,SPINDBLADE_07,2,T_Path,ST_NULL,&s_spindownblade8};
statetype s_spindownblade6 = {false,SPINDBLADE_06,2,T_Path,ST_NULL,&s_spindownblade7};
statetype s_spindownblade5 = {false,SPINDBLADE_05,2,T_Path,ST_NULL,&s_spindownblade6};
statetype s_spindownblade4 = {false,SPINDBLADE_04,2,T_Path,ST_NULL,&s_spindownblade5};
statetype s_spindownblade3 = {false,SPINDBLADE_03,2,T_Path,ST_NULL,&s_spindownblade4};
statetype s_spindownblade2 = {false,SPINDBLADE_02,2,T_Path,ST_NULL,&s_spindownblade3};
statetype s_spindownblade1 = {false,SPINDBLADE_01,35,T_Path,SF_UP|SF_SOUND,&s_spindownblade2};


statetype s_bouldersink9 = {false,BSINK9,2,NULL,0,NULL};
statetype s_bouldersink8 = {false,BSINK8,2,NULL,0,&s_bouldersink9};
statetype s_bouldersink7 = {false,BSINK7,2,NULL,0,&s_bouldersink8};
statetype s_bouldersink6 = {false,BSINK6,2,NULL,0,&s_bouldersink7};
statetype s_bouldersink5 = {false,BSINK5,2,NULL,0,&s_bouldersink6};
statetype s_bouldersink4 = {false,BSINK4,2,NULL,0,&s_bouldersink5};
statetype s_bouldersink3 = {false,BSINK3,2,NULL,0,&s_bouldersink4};
statetype s_bouldersink2 = {false,BSINK2,2,NULL,0,&s_bouldersink3};
statetype s_bouldersink1 = {false,BSINK1,2,NULL,0,&s_bouldersink2};


statetype s_boulderroll8 = {false,BOULDER41,3,T_BoulderMove,0,&s_boulderroll1};
statetype s_boulderroll7 = {false,BOULDER31,3,T_BoulderMove,0,&s_boulderroll8};
statetype s_boulderroll6 = {false,BOULDER21,3,T_BoulderMove,0,&s_boulderroll7};
statetype s_boulderroll5 = {false,BOULDER11,3,T_BoulderMove,0,&s_boulderroll6};
statetype s_boulderroll4 = {false,BOULDER41,3,T_BoulderMove,0,&s_boulderroll5};
statetype s_boulderroll3 = {false,BOULDER31,3,T_BoulderMove,0,&s_boulderroll4};
statetype s_boulderroll2 = {false,BOULDER21,3,T_BoulderMove,0,&s_boulderroll3};
statetype s_boulderroll1 = {false,BOULDER11,3,T_BoulderMove,SF_SOUND,&s_boulderroll2};




statetype s_boulderdrop12 = {false,BOULDER11,0,T_BoulderDrop,0,&s_boulderdrop12};
statetype s_boulderdrop11 = {false,BDROP11,1,T_BoulderDrop,0,&s_boulderdrop12};
statetype s_boulderdrop10 = {false,BDROP10,1,T_BoulderDrop,0,&s_boulderdrop11};
statetype s_boulderdrop9 = {false,BDROP9,2,T_BoulderDrop,0,&s_boulderdrop10};
statetype s_boulderdrop8 = {false,BDROP8,1,T_BoulderDrop,0,&s_boulderdrop9};
statetype s_boulderdrop7 = {false,BDROP7,1,T_BoulderDrop,0,&s_boulderdrop8};
statetype s_boulderdrop6 = {false,BDROP6,2,T_BoulderDrop,0,&s_boulderdrop7};
statetype s_boulderdrop5 = {false,BDROP5,3,T_BoulderDrop,0,&s_boulderdrop6};
statetype s_boulderdrop4 = {false,BDROP4,4,T_BoulderDrop,0,&s_boulderdrop5};
statetype s_boulderdrop3 = {false,BDROP3,5,T_BoulderDrop,SF_SOUND,&s_boulderdrop4};
statetype s_boulderdrop2 = {false,BDROP2,6,NULL,0,&s_boulderdrop3};
statetype s_boulderdrop1 = {false,BDROP1,6,NULL,0,&s_boulderdrop2};

statetype s_boulderspawn = {false,NOTHING,70,T_BoulderSpawn,0,&s_boulderspawn};



/*==========================================================================

									GUN STUFF

============================================================================*/

statetype s_gunfire2 = {true,GUNRISE51,5,A_GunShoot,ST_NULL,&s_gunfire1};
statetype s_gunfire1 = {true,GUNFIRE1,5,A_GunShoot,ST_NULL,&s_gunfire2};

statetype s_gunstand = {true,GUNRISE11,0,T_GunStand,ST_NULL,&s_gunstand};

statetype s_gunraise4 = {true,GUNRISE51,2,NULL,ST_NULL,&s_gunfire1};
statetype s_gunraise3 = {true,GUNRISE41,2,NULL,ST_NULL,&s_gunraise4};
statetype s_gunraise2 = {true,GUNRISE31,2,NULL,ST_NULL,&s_gunraise3};
statetype s_gunraise1 = {true,GUNRISE21,2,NULL,ST_NULL,&s_gunraise2};

statetype s_gunlower3 = {true,GUNRISE21,2,NULL,ST_NULL,&s_gunstand};
statetype s_gunlower2 = {true,GUNRISE31,2,NULL,ST_NULL,&s_gunlower3};
statetype s_gunlower1 = {true,GUNRISE41,2,NULL,ST_NULL,&s_gunlower2};


statetype s_gundead = {false,GUNDEAD2,0,T_Collide,ST_NULL,&s_gundead};
statetype s_gundie1 = {false,GUNDEAD1,5,NULL,ST_NULL,&s_gundead};



//======================================================================//

statetype s_4waygunfire1 = {true,FOURWAYFIRE01,5,A_4WayGunShoot,ST_NULL,&s_4waygunfire2};
statetype s_4waygunfire2 = {true,FOURWAY01,5,NULL,ST_NULL,&s_4waygunfire1};

statetype s_4waygun = {true,FOURWAY01,0,T_4WayGunStand,ST_NULL,&s_4waygun};




statetype s_kessphere8 = {false,KESSPHERE8,2,T_Projectile,ST_NULL,&s_kessphere1};
statetype s_kessphere7 = {false,KESSPHERE7,2,T_Projectile,ST_NULL,&s_kessphere8};
statetype s_kessphere6 = {false,KESSPHERE6,2,T_Projectile,ST_NULL,&s_kessphere7};
statetype s_kessphere5 = {false,KESSPHERE5,2,T_Projectile,ST_NULL,&s_kessphere6};
statetype s_kessphere4 = {false,KESSPHERE4,2,T_Projectile,ST_NULL,&s_kessphere5};
statetype s_kessphere3 = {false,KESSPHERE3,2,T_Projectile,ST_NULL,&s_kessphere4};
statetype s_kessphere2 = {false,KESSPHERE2,2,T_Projectile,ST_NULL,&s_kessphere3};
statetype s_kessphere1 = {false,KESSPHERE1,2,T_Projectile,ST_NULL,&s_kessphere2};


statetype s_slop4 = {false,TOMSPIT4,3,T_Particle,ST_NULL,&s_slop1};
statetype s_slop3 = {false,TOMSPIT3,3,T_Particle,ST_NULL,&s_slop4};
statetype s_slop2 = {false,TOMSPIT2,3,T_Particle,ST_NULL,&s_slop3};
statetype s_slop1 = {false,TOMSPIT1,3,T_Particle,ST_NULL,&s_slop2};


statetype s_batblast4 = {false,BATBLAST4,3,T_Projectile,SF_BAT,&s_batblast1};
statetype s_batblast3 = {false,BATBLAST3,3,T_Projectile,SF_BAT,&s_batblast4};
statetype s_batblast2 = {false,BATBLAST2,3,T_Projectile,SF_BAT,&s_batblast3};
statetype s_batblast1 = {false,BATBLAST1,3,T_Projectile,SF_BAT,&s_batblast2};


statetype s_serialdog4 = {true,SERIALDOG_W41,5,T_Player,SF_DOGSTATE,&s_serialdog};
statetype s_serialdog3 = {true,SERIALDOG_W31,5,T_Player,SF_DOGSTATE,&s_serialdog4};
statetype s_serialdog2 = {true,SERIALDOG_W21,5,T_Player,SF_DOGSTATE,&s_serialdog3};
statetype s_serialdog = {true,SERIALDOG_W11,5,T_Player,SF_DOGSTATE,&s_serialdog2};
statetype s_serialdogattack = {true,SERIALDOG_ATTACK1,0,T_Attack,SF_DOGSTATE,&s_serialdogattack };


#endif


#include "rt_table.h"
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
//******************************************************************************
//
// RT_STR.C
//	 Contains the menu stuff!
//
//******************************************************************************

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

#include <string.h>
#include <ctype.h>
#include "rt_def.h"
#include "rt_menu.h"
#include "rt_util.h"
#include "rt_vid.h"
#include "rt_build.h"
#include "lumpy.h"
#include "rt_str.h"
#include "_rt_str.h"
#include "isr.h"
#include "rt_in.h"
#include "rt_menu.h"
#include "rt_view.h"
#include "w_wad.h"
#include "z_zone.h"
#include "modexlib.h"
#include "rt_main.h"
#include "rt_msg.h"
#include "rt_playr.h"
#include "rt_sound.h"
//MED
// #include "memcheck.h"


//******************************************************************************
//
// GLOBALS
//
//******************************************************************************

short  ASCIINames[] = {			 // Unshifted ASCII for scan codes
//		 0	1	2	3	4	5	6	7	8	9	A	B	C	D	E	F
		  0  ,27 ,'1','2','3','4','5','6','7','8','9','0','-','=',8  ,9  ,		  // 0
		  'q','w','e','r','t','y','u','i','o','p','[',']',13 ,0  ,'a','s',		  // 1
		  'd','f','g','h','j','k','l',';',39 ,'`',0  ,92 ,'z','x','c','v',		  // 2
		  'b','n','m',',','.','/',0  ,'*',0  ,' ',0  ,0  ,0  ,0  ,0  ,0  ,		  // 3
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,'7','8','9','-','4','5','6','+','1',		  // 4
		  '2','3','0',127,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,		  // 5
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,		  // 6
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0			  // 7
};

short		ShiftNames[] = {			  // Shifted ASCII for scan codes
//		 0	1	2	3	4	5	6	7	8	9	A	B	C	D	E	F
		  0  ,27 ,'!','@','#','$','%','^','&','*','(',')','_','+',8  ,9  ,		  // 0
		  'Q','W','E','R','T','Y','U','I','O','P','{','}',13 ,0  ,'A','S',		  // 1
		  'D','F','G','H','J','K','L',':',34 ,'~',0  ,'|','Z','X','C','V',		  // 2
		  'B','N','M','<','>','?',0  ,'*',0  ,' ',0  ,0  ,0  ,0  ,0  ,0  ,		  // 3
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,'7','8','9','-','4','5','6','+','1',		  // 4
		  '2','3','0',127,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,		  // 5
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,		  // 6
		  0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0			  // 7
};

int fontcolor;

//******************************************************************************
//
// LOCALS
//
//******************************************************************************

static int BKw;
static int BKh;

//******************************************************************************
//
// VW_DrawClippedString ()
//
// Draws a string at x, y to bufferofs
//
//******************************************************************************

#if 1
void VW_DrawNonClippedChar (int x, int y, char ch)
{
	int	width,height,ht;
	byte	*source;
	byte	*ct, *oct;
//	int	ch;
	int	oy, x1, pix;

	ht = CurrentFont->height;
	width = CurrentFont->width[ch];

	oy=y;

	VGAWRITEMAP(x&3);
	oct=VGA_GetAsPtr(bufferofs+ylookup[y]+(x>>2));

	source = ((byte *)CurrentFont)+CurrentFont->charofs[ch];
	while (width--)
	{
		ct=oct;
		height = ht;

		while (height>=4)
		{
			pix=source[0];
			if(pix>0)	ct[0*384]=pix;
			pix=source[1];
			if(pix>0)	ct[1*384]=pix;
			pix=source[2];
			if(pix>0)	ct[2*384]=pix;
			pix=source[3];
			if(pix>0)	ct[3*384]=pix;

			source+=4;
			ct+=4*384;
			height-=4;
		}

		while (height--)
		{
			pix=*source++;
			if(pix>0)
				*ct=pix;
			ct+=384;
		}
		oct++;
	}
}

void VW_DrawClippedChar (int x, int y, char ch)
{
	int	width,height,ht;
	byte  *source;
//	int	ch;
	int	oy;


	ht = CurrentFont->height;
	width = CurrentFont->width[ch];

#if 1
	if ((x>=0) && ((x+width)<MAXSCREENWIDTH))
	{
		if ((y>=0) && ((y+ht)<MAXSCREENHEIGHT))
		{
			VW_DrawNonClippedChar(x, y, ch);
			return;
		}
	}
#endif

	oy=y;

	source = ((byte *)CurrentFont)+CurrentFont->charofs[ch];
	while (width--)
	{
		if ((x>=0) && (x<MAXSCREENWIDTH))
		{
			y=oy;
			VGAWRITEMAP(x&3);
			height = ht;
			while (height--)
			{
				if ((y>=0) && (y<MAXSCREENHEIGHT))
				{
					if (*source>0)
//							*((byte *)(bufferofs+ylookup[y]+(x>>2))) = *source;
						VGAWRITE(bufferofs+ylookup[y]+(x>>2), *source);
				}
				source++;
				y++;
			}
		}
		x++;
	}
}

void VW_DrawClippedString (int x, int y, char *string)
{
	int	width,height,ht;
	byte  *source;
	int	ch;
	int	oy;

	ht = CurrentFont->height;

	oy=y;

//	while ((ch = *string++)!=0)
	while (*string!=0)
	{
		ch = *string++;
		ch -= 31;
		if(ch<0)
			continue;

		width = CurrentFont->width[ch];
		VW_DrawClippedChar(x, y, ch);
		x += width;
	}
}
#endif

#if 0
void VW_DrawClippedString (int x, int y, char *string)
{
	int	width,height,ht;
	byte  *source;
	int	ch;
	int	oy;

	ht = CurrentFont->height;

	oy=y;

	while ((ch = *string++)!=0)
	{
		ch -= 31;
		width = CurrentFont->width[ch];
		source = ((byte *)CurrentFont)+CurrentFont->charofs[ch];
		while (width--)
		{
			if ((x>=0) && (x<MAXSCREENWIDTH))
			{
				y=oy;
				VGAWRITEMAP(x&3);
				height = ht;
				while (height--)
				{
					if ((y>=0) && (y<MAXSCREENHEIGHT))
					{
						if (*source>0)
//							*((byte *)(bufferofs+ylookup[y]+(x>>2))) = *source;
							VGAWRITE(bufferofs+ylookup[y]+(x>>2), *source);
					}
					source++;
					y++;
				}
			}
			x++;
		}
	}
}
#endif

//******************************************************************************
//
// US_ClippedPrint() - Prints a string in bufferofs. Newlines are supported.
//
//******************************************************************************

void US_ClippedPrint (int x, int y, char *s)
{
	char  c,
			*se;
	int	startx;

	startx=x;
	while (*s)
	{
		se = s;
		while ((c = *se) && (c != '\n'))
			se++;
		*se = '\0';

		VW_DrawClippedString ( x, y, s);

		s = se;
		if (c)
		{
			*se = c;
			s++;
			y += CurrentFont->height;
		}
	}
}


//******************************************************************************
//
// VW_DrawPropString ()
//
// Draws a string at px, py to bufferofs
//
//******************************************************************************

void VW_DrawPropString (char *string)
{
	byte  pix;
	int	width,step,height,ht;
	byte  *source;
	unsigned dest, origdest;
	int	ch,mask;

	ht = CurrentFont->height;
//	dest = origdest = (byte *)(bufferofs+ylookup[py]+(px>>2));
	dest = origdest = (bufferofs+ylookup[py]+(px>>2));

	mask = 1<<(px&3);

	while ((ch = *string++)!=0)
	{
		ch -= 31;
		width = step = CurrentFont->width[ch];
		source = ((byte *)CurrentFont)+CurrentFont->charofs[ch];
		while (width--)
		{
			VGAMAPMASK(mask);

			height = ht;
			while (height--)
			{
				pix = *source;
				if (pix)
//					*dest = pix;
					VGAWRITE(dest, pix);

				source++;
				dest += linewidth;
			}

			px++;
			mask <<= 1;
			if (mask == 16)
			{
				mask = 1;
				origdest++;
			}
			dest = origdest;
		}
	}
	bufferheight = ht;
	bufferwidth = ((dest+1)-origdest)*4;
}



//******************************************************************************
//
// VWB_DrawPropString ()
//
// Calls VW_DrawPropString then updates the mark block.
//
//******************************************************************************

void VWB_DrawPropString  (char *string)
{
	int x;
	x = px;
	VW_DrawPropString (string);
	VW_MarkUpdateBlock (x, py, px-1, py+bufferheight-1);
}



//******************************************************************************
//
// VW_DrawIPropString ()
//
// Draws a string at px, py to bufferofs
//
//******************************************************************************

void VW_DrawIPropString (char *string)
{
	byte  pix;
	int	width,step,height,ht;
	byte  *source;
	unsigned dest, origdest;
	int	ch,mask;

	ht = CurrentFont->height;
//	dest = origdest = (byte *)(bufferofs+ylookup[py]+(px>>2));
	dest = origdest = (bufferofs+ylookup[py]+(px>>2));

	mask = 1<<(px&3);

	while ((ch = *string++)!=0)
	{
		ch -= 31;
		width = step = CurrentFont->width[ch];
		source = ((byte *)CurrentFont)+CurrentFont->charofs[ch];
		while (width--)
		{
			VGAMAPMASK(mask);

			height = ht;
			while (height--)
			{
				pix = *source;
				if (pix)
//					*dest = pix;
					VGAWRITE(dest, pix);

				source++;
				dest += linewidth;
			}

			px++;
			mask <<= 1;
			if (mask == 16)
			{
				mask = 1;
				origdest++;
			}
			dest = origdest;
		}
	}
	bufferheight = ht;
	bufferwidth = ((dest+1)-origdest)*4;
}



//******************************************************************************
//
// VWB_DrawIPropString ()
//
// Calls VW_DrawIPropString then updates the mark block.
//
//******************************************************************************

void VWB_DrawIPropString  (char *string)
{
	int x;
	x = px;
	VW_DrawIPropString (string);
	VW_MarkUpdateBlock (x, py, px-1, py+bufferheight-1);
}



//******************************************************************************
//
// VWL_MeasureString ()
//
//******************************************************************************

void VWL_MeasureString (char *s, int *width, int *height, font_t *font)
{
	*height = font->height;

	for (*width = 0; *s; s++)
		*width += font->width[(*((byte *)s))-31];	// proportional width
}

//******************************************************************************
//
// VWL_MeasureIntensityString ()
//
//******************************************************************************

void VWL_MeasureIntensityString (char *s, int *width, int *height, cfont_t *font)
{
	*height = font->height;

	for (*width = 0; *s; s++)
		*width += font->width[(*((byte *)s))-31];	// proportional width
}

//******************************************************************************
//
// VW_MeasureIntensityPropString ()
//
//******************************************************************************

void VW_MeasureIntensityPropString (char *string, int *width, int *height)
{
	VWL_MeasureIntensityString (string, width, height, IFont);
}

//******************************************************************************
//
// VW_MeasurePropString ()
//
//******************************************************************************

void VW_MeasurePropString (char *string, int *width, int *height)
{
	VWL_MeasureString (string, width, height, CurrentFont);
}


//******************************************************************************
//
// US_MeasureStr ()
//
//******************************************************************************

void US_MeasureStr (int *width, int *height, char * s, ...)
{
	char  c,
			*se,
			*ss;
	int	w,h;
	va_list strptr;
	char buf[300];

	*width  = 0;
	*height = 0;

	memset (&buf[0], 0, sizeof (buf));
	va_start (strptr, s);
	vsprintf (&buf[0], s, strptr);
	va_end (strptr);

	ss = &buf[0];

	while (*ss)
	{
		se = ss;
		while ((c = *se) && (c != '\n'))
			se++;
		*se = '\0';

		VWL_MeasureString (ss, &w, &h, CurrentFont);

		*height += h;

		if (w > *width)
			*width = w;

		ss = se;
		if (c)
		{
			*se = c;
			ss++;
		}
	}
}


//******************************************************************************
//
// US_SetPrintRoutines() - Sets the routines used to measure and print
//	 from within the User Mgr. Primarily provided to allow switching
//	 between masked and non-masked fonts
//
//******************************************************************************

void US_SetPrintRoutines (void (*measure)(char *, int *, int *, font_t *),
								  void (*print)(char *))
{
	USL_MeasureString = measure;
	USL_DrawString	 = print;
}


//******************************************************************************
//
// US_Print() - Prints a string in the current window. Newlines are
//	 supported.
//
//******************************************************************************

void US_Print (char *s)
{
	char  c,
			*se;
	int	w,h;

	while (*s)
	{
		se = s;
		while ((c = *se) && (c != '\n'))
			se++;
		*se = '\0';

		USL_MeasureString (s, &w, &h, CurrentFont);
		px = PrintX;
		py = PrintY;
		USL_DrawString (s);

		s = se;
		if (c)
		{
			*se = c;
			s++;

			PrintX = WindowX;
			PrintY += h;
		}
		else
			PrintX += w;
	}
}

//******************************************************************************
//
// US_BufPrint() - Prints a string in bufferofs. Newlines are supported.
//
//******************************************************************************

void US_BufPrint (char *s)
{
	char  c,
			*se;
	int	startx;

	startx=PrintX;
	while (*s)
	{
		se = s;
		while ((c = *se) && (c != '\n'))
			se++;
		*se = '\0';

		px = PrintX;
		py = PrintY;
		USL_DrawString (s);

		PrintY = py;
		PrintX = px;

		s = se;
		if (c)
		{
			*se = c;
			s++;
			PrintY += CurrentFont->height;
			PrintX = startx;
		}
	}
}


//******************************************************************************
//
// US_PrintUnsigned () - Prints an unsigned long int
//
//******************************************************************************

void US_PrintUnsigned (unsigned long int n)
{
	char  buffer[32];

	US_Print (ultoa (n, buffer, 10));
}

//******************************************************************************
//
// US_PrintSigned() - Prints a signed long
//
//******************************************************************************

void US_PrintSigned (long int n)
{
	char  buffer[32];

	US_Print (ltoa (n, buffer, 10));
}

//******************************************************************************
//
// USL_PrintInCenter() - Prints a string in the center of the given rect
//
//******************************************************************************

void USL_PrintInCenter (char *s, Rect r)
{
	int	w,h, rw,rh;

	USL_MeasureString (s,&w,&h, CurrentFont);
	rw = r.lr.x - r.ul.x;
	rh = r.lr.y - r.ul.y;

	px = r.ul.x + ((rw - w) / 2);
	py = r.ul.y + ((rh - h) / 2);
	USL_DrawString (s);
}

//******************************************************************************
//
// US_PrintCentered() - Prints a string centered in the current window.
//
//******************************************************************************

void US_PrintCentered (char *s)
{
	Rect  r;

	r.ul.x = WindowX;
	r.ul.y = WindowY;
	r.lr.x = r.ul.x + WindowW;
	r.lr.y = r.ul.y + WindowH;

	USL_PrintInCenter (s, r);
}

//******************************************************************************
//
// US_CPrintLine() - Prints a string centered on the current line and
//	 advances to the next line. Newlines are not supported.
//
//******************************************************************************

void US_CPrintLine (char *s)
{
	int w, h;

	USL_MeasureString (s, &w, &h, CurrentFont);

	if (w > WindowW)
		Error("US_CPrintLine() - String exceeds width");

	px = WindowX + ((WindowW - w) / 2);
	py = PrintY;
	USL_DrawString (s);
	PrintY += h;
}

//******************************************************************************
//
// US_CPrint() - Prints a string in the current window. Newlines are
//	 supported.
//
//******************************************************************************

void US_CPrint (char *s)
{
	char  c,
			*se;

	while (*s)
	{
		se = s;
		while ((c = *se) && (c != '\n'))
			se++;
		*se = '\0';

		US_CPrintLine (s);

		s = se;
		if (c)
		{
			*se = c;
			s++;
		}
	}
}


//
//
// Text Input routines
//
//
//


//******************************************************************************
//
// USL_XORICursor() - XORs the I-bar text cursor. Used by  US_LineInput()
//
//******************************************************************************

static void USL_XORICursor (int x, int y, char *s, int cursor, int color)
{
	static	boolean  status;	  // VGA doesn't XOR...
	char	  buf[MaxString];

	int		w,h;
	int		oldx = px;
	int		oldy = py;

	strcpy (buf,s);
	buf[cursor] = '\0';
	USL_MeasureString (buf, &w, &h, CurrentFont);


	if (status^=1)
	{
		px = x + w;
		py = y;
		if (color)
			USL_DrawString ("\x80");
		else
			DrawMenuBufPropString (px, py, "\x80");
	}
	else
	{
		if (color)
		{
			VWB_Bar (px, py, BKw, BKh, color);
			USL_DrawString (s);
		}
		else
		{
			EraseMenuBufRegion (px, py, BKw, BKh);
//			EraseMenuBufRegion (px, py+1, BKw, BKh-2);
			DrawMenuBufPropString (px, py, s);
		}
	}
	px = oldx;
	py = oldy;
}






//******************************************************************************
//
// US_LineInput() - Gets a line of user input at (x,y), the string defaults
//	 to whatever is pointed at by def. Input is restricted to maxchars
//	 chars or maxwidth pixels wide. If the user hits escape (and escok is
//	 true), nothing is copied into buf, and false is returned. If the
//	 user hits return, the current string is copied into buf, and true is
//	 returned
//
///******************************************************************************

extern byte * IN_GetScanName (ScanCode scan);

boolean US_LineInput (int x, int y, char *buf, char *def, boolean escok,
							 int maxchars, int maxwidth, int color)
{
	boolean  redraw,
				cursorvis,
				cursormoved,
				done,
				result;
	char	  s[MaxString],
				olds[MaxString];
	int		i,
				cursor,
				w,h,
				len;

	int		lasttime;


	int		lastkey;
	int		cursorwidth;

	cursorwidth = CurrentFont->width[80-31];

	memset (s, 0, MaxString);
	memset (olds, 0, MaxString);
	IN_ClearKeyboardQueue ();

	BKw = maxwidth;
	BKh = CurrentFont->height;


	if (def)
		strcpy (s, def);
	else
		*s = '\0';

	*olds = '\0';

	cursor		= strlen (s);
	cursormoved = redraw = true;
	cursorvis	= done	= false;

	lasttime  = ticcount;


	lastkey = getASCII ();

	while (!done)
	{
//		if (GameEscaped==true)
//			PauseLoop ();

		if (cursorvis)
			USL_XORICursor (x, y, s, cursor, color);

		LastScan = IN_InputUpdateKeyboard ();
		if (Keyboard[sc_LShift] || Keyboard[sc_RShift])
			lastkey = ShiftNames[LastScan];
		else
			lastkey = ASCIINames[LastScan];


		switch (LastScan)
		{
		case sc_LeftArrow:

			if (cursor)
				{
				cursor--;
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				}
			lastkey = key_None;
			Keyboard[sc_LeftArrow] = 0;
			break;

		case sc_RightArrow:

			if (s[cursor])
				{
				cursor++;
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				}
			lastkey = key_None;
			Keyboard[sc_RightArrow] = 0;
			break;

		case sc_Home:

			if ( cursor )
				{
				cursor = 0;
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				}
			Keyboard[sc_Home] = 0;
			lastkey = key_None;
			break;

		case sc_End:

			if ( cursor != strlen (s) )
				{
				cursor = strlen (s);
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				}
			lastkey = key_None;
			Keyboard[sc_End] = 0;
			break;


		case sc_Return:
			strcpy (buf,s);
			done = true;
			result = true;
			lastkey = key_None;
			MN_PlayMenuSnd (SD_SELECTSND);
			break;

		case sc_Escape:
			if (escok)
			{
				done = true;
				result = false;
				MN_PlayMenuSnd (SD_ESCPRESSEDSND);
			}
			lastkey = key_None;
			break;

		case sc_BackSpace:

			if (cursor)
				{
				strcpy (s + cursor - 1,s + cursor);
				cursor--;
				redraw = true;
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				}
			lastkey = key_None;
			Keyboard[sc_BackSpace] = 0;
			IN_ClearKeyboardQueue ();
			break;

		case sc_Delete:

			if (s[cursor])
			{
				strcpy (s + cursor,s + cursor + 1);
				redraw = true;
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
			}
			lastkey = key_None;
			Keyboard[sc_Delete] = 0;
			IN_ClearKeyboardQueue ();
			break;

		case 0x4c:  // Keypad 5
		case sc_UpArrow:
		case sc_DownArrow:
		case sc_PgUp:
		case sc_PgDn:
		case sc_Insert:
			lastkey = key_None;
			break;
		}

//		if (GameEscaped==true)
//			PauseLoop ();

		if (lastkey)
		{
			len = strlen (s);
			USL_MeasureString (s, &w, &h, CurrentFont);

			if
			(
				isprint(lastkey)
			&& (len < MaxString - 1)
			&& ((!maxchars) || (len < maxchars))
			&& ((!maxwidth) || ((w+2) < (maxwidth-cursorwidth-2)))
			)
			{
				int ls;
				int rs;

				for (i = len + 1;i > cursor;i--)
					s[i] = s[i - 1];
				s[cursor++] = lastkey;
				redraw = true;

				ls = Keyboard[sc_LShift];
				rs = Keyboard[sc_RShift];
				memset ((void *)(Keyboard), 0, 127*sizeof(int));		 // Clear printable keys
				Keyboard[sc_LShift] = ls;
				Keyboard[sc_RShift] = rs;

				MN_PlayMenuSnd (SD_MOVECURSORSND);
			}
		}

//		if (GameEscaped==true)
//			PauseLoop ();

		if (redraw)
		{
			if (color)
				VWB_Bar (x, y, BKw, BKh, color);
			else
				EraseMenuBufRegion (x, y, BKw, BKh);

			strcpy (olds, s);

			px = x;
			py = y;
			if (color)
				USL_DrawString (s);
			else
				DrawMenuBufPropString (px, py, s);
			px = x;
			py = y;

			redraw = false;
		}

		if (cursormoved)
		{
			cursorvis = false;
			lasttime = ticcount - VBLCOUNTER;

			cursormoved = false;
		}
		if (ticcount - lasttime > VBLCOUNTER / 2)
		{
			lasttime = ticcount;

			cursorvis ^= true;
		}
		if (cursorvis)
			USL_XORICursor (x, y, s, cursor, color);

//		if (GameEscaped==true)
//			PauseLoop ();

		if (color)
			VW_UpdateScreen ();
		else
			RefreshMenuBuf (0);
	}

	if (cursorvis)
		USL_XORICursor (x, y, s, cursor, color);

	if (!result)
	{
		px = x;
		py = y;
		if (color)
			USL_DrawString (olds);
		else
			DrawMenuBufPropString (px, py, olds);
	}

//	if (GameEscaped==true)
//		PauseLoop ();

	if (color)
		VW_UpdateScreen ();
	else
		RefreshMenuBuf (0);

	IN_ClearKeyboardQueue ();
	return (result);
}


//******************************************************************************
//
// US_lineinput() - Gets a line of user input at (x,y), the string defaults
//	 to whatever is pointed at by def. Input is restricted to maxchars
//	 chars or maxwidth pixels wide. If the user hits escape (and escok is
//	 true), nothing is copied into buf, and false is returned. If the
//	 user hits return, the current string is copied into buf, and true is
//	 returned - PASSWORD INPUT
//
///******************************************************************************

boolean US_lineinput (int x, int y, char *buf, char *def, boolean escok,
							 int maxchars, int maxwidth, int color)
{
	boolean  redraw,
				cursorvis,
				cursormoved,
				done,
				result;
	char	  s[MaxString],
				xx[MaxString],
				olds[MaxString];
	int		i,
				cursor,
				w,h,
				len;

	int		lasttime;


	int		lastkey;
	int		cursorwidth;

	cursorwidth = CurrentFont->width[80-31];

	memset (s, 0, MaxString);
	memset (xx, 0, MaxString);
	memset (olds, 0, MaxString);
	IN_ClearKeyboardQueue ();

	BKw = maxwidth;
	BKh = CurrentFont->height;


	if (def)
		strcpy (s, def);
	else
		*s = '\0';

	*olds = '\0';

	cursor		= strlen (s);
	cursormoved = redraw = true;
	cursorvis	= done	= false;

	lasttime  = ticcount;


	lastkey = getASCII ();

	while (!done)
	{
//		if (GameEscaped == true)
//			PauseLoop ();

		if (cursorvis)
			USL_XORICursor (x, y, xx, cursor, color);

		LastScan = IN_InputUpdateKeyboard ();
		if (Keyboard[sc_LShift] || Keyboard[sc_RShift])
			lastkey = ShiftNames[LastScan];
		else
			lastkey = ASCIINames[LastScan];


		switch (LastScan)
		{
		case sc_LeftArrow:

			if (cursor)
				{
				cursor--;
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				}
			lastkey = key_None;
			Keyboard[sc_LeftArrow] = 0;
			break;

		case sc_RightArrow:

			if (s[cursor])
				{
				cursor++;
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				}
			lastkey = key_None;
			Keyboard[sc_RightArrow] = 0;
			break;

		case sc_Home:

			if ( cursor != 0 )
				{
				cursor = 0;
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				}
			Keyboard[sc_Home] = 0;
			lastkey = key_None;
			break;

		case sc_End:

			if ( cursor != strlen( s ) )
				{
				cursor = strlen (s);
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				}
			lastkey = key_None;
			Keyboard[sc_End] = 0;
			break;

		case sc_Return:
			strcpy (buf,s);
			done = true;
			result = true;
			lastkey = key_None;
			MN_PlayMenuSnd (SD_SELECTSND);
			break;

		case sc_Escape:
			if (escok)
			{
				done = true;
				result = false;
				MN_PlayMenuSnd (SD_ESCPRESSEDSND);
			}
			lastkey = key_None;
			break;

		case sc_BackSpace:

			if (cursor)
				{
				strcpy (s + cursor - 1,s + cursor);
				strcpy (xx + cursor - 1,xx + cursor);
				cursor--;
				redraw = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				cursormoved = true;
				}
			lastkey = key_None;
			Keyboard[sc_BackSpace] = 0;
			IN_ClearKeyboardQueue ();
			break;

		case sc_Delete:

			if (s[cursor])
				{
				strcpy (s + cursor,s + cursor + 1);
				strcpy (xx + cursor,xx + cursor + 1);
				redraw = true;
				cursormoved = true;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
				}
			lastkey = key_None;
			Keyboard[sc_Delete] = 0;
			IN_ClearKeyboardQueue ();
			break;

		case 0x4c:  // Keypad 5
		case sc_UpArrow:
		case sc_DownArrow:
		case sc_PgUp:
		case sc_PgDn:
		case sc_Insert:
			lastkey = key_None;
			break;
		}

//		if (GameEscaped==true)
//			PauseLoop ();

		if (lastkey)
		{
			len = strlen (s);
			USL_MeasureString (xx, &w, &h, CurrentFont);

			if
			(
				isprint(lastkey)
			&& (len < MaxString - 1)
			&& ((!maxchars) || (len < maxchars))
			&& ((!maxwidth) || ((w+2) < (maxwidth-cursorwidth-2)))
			)
			{
				int ls;
				int rs;

				for (i = len + 1;i > cursor;i--)
					s[i] = s[i - 1];
				s[cursor]	= lastkey;
				xx[cursor++] = '*';
				redraw = true;

				ls = Keyboard[sc_LShift];
				rs = Keyboard[sc_RShift];
				memset ((void *)(Keyboard), 0, 127*sizeof(int));		 // Clear printable keys
				Keyboard[sc_LShift] = ls;
				Keyboard[sc_RShift] = rs;
				MN_PlayMenuSnd (SD_MOVECURSORSND);
			}
		}

//		if (GameEscaped==true)
//			PauseLoop ();

		if (redraw)
		{
			if (color)
				VWB_Bar (x, y, BKw, BKh, color);
			else
				EraseMenuBufRegion (x, y, BKw, BKh);

			strcpy (olds, s);

			px = x;
			py = y;
			if (color)
				USL_DrawString (xx);
			else
				DrawMenuBufPropString (px, py, xx);
			px = x;
			py = y;

			redraw = false;
		}

		if (cursormoved)
		{
			cursorvis = false;
			lasttime = ticcount - VBLCOUNTER;

			cursormoved = false;
		}
		if (ticcount - lasttime > VBLCOUNTER / 2)
		{
			lasttime = ticcount;

			cursorvis ^= true;
		}
		if (cursorvis)
			USL_XORICursor (x, y, xx, cursor, color);

		if (color)
			VW_UpdateScreen ();
		else
			RefreshMenuBuf (0);
	}

	if (cursorvis)
		USL_XORICursor (x, y, xx, cursor, color);

	if (!result)
	{
		px = x;
		py = y;
		if (color)
			USL_DrawString (xx);
		else
			DrawMenuBufPropString (px, py, xx);
	}

//	if (GameEscaped==true)
//		PauseLoop ();

	if (color)
		VW_UpdateScreen ();
	else
		RefreshMenuBuf (0);

	IN_ClearKeyboardQueue ();
	return (result);
}



//******************************************************************************
//******************************************************************************
//
// WINDOWING ROUTINES
//
//******************************************************************************
//******************************************************************************


//******************************************************************************
//
// US_ClearWindow() - Clears the current window to white and homes the
//	 cursor
//
//******************************************************************************

void US_ClearWindow (void)
{
	VWB_Bar (WindowX, WindowY, WindowW, WindowH, 13);
	PrintX = WindowX;
	PrintY = WindowY;
}




//******************************************************************************
//
// US_DrawWindow() - Draws a frame and sets the current window parms
//
//******************************************************************************

void US_DrawWindow (int x, int y, int w, int h)
{
	int  i,
		  sx,
		  sy,
		  sw,
		  sh;
	byte * shape;

	pic_t *Win1;
	pic_t *Win2;
	pic_t *Win3;
	pic_t *Win4;
	pic_t *Win5;
	pic_t *Win6;
	pic_t *Win7;
	pic_t *Win8;
	pic_t *Win9;

	// Cache in windowing shapes
	shape = W_CacheLumpNum (W_GetNumForName ("window1"), PU_CACHE);
	Win1 = (pic_t *) shape;
	shape = W_CacheLumpNum (W_GetNumForName ("window2"), PU_CACHE);
	Win2 = (pic_t *) shape;
	shape = W_CacheLumpNum (W_GetNumForName ("window3"), PU_CACHE);
	Win3 = (pic_t *) shape;
	shape = W_CacheLumpNum (W_GetNumForName ("window4"), PU_CACHE);
	Win4 = (pic_t *) shape;
	shape = W_CacheLumpNum (W_GetNumForName ("window5"), PU_CACHE);
	Win5 = (pic_t *) shape;
	shape = W_CacheLumpNum (W_GetNumForName ("window6"), PU_CACHE);
	Win6 = (pic_t *) shape;
	shape = W_CacheLumpNum (W_GetNumForName ("window7"), PU_CACHE);
	Win7 = (pic_t *) shape;
	shape = W_CacheLumpNum (W_GetNumForName ("window8"), PU_CACHE);
	Win8 = (pic_t *) shape;
	shape = W_CacheLumpNum (W_GetNumForName ("window9"), PU_CACHE);
	Win9 = (pic_t *) shape;

	WindowX = x * 8;
	WindowY = y * 8;
	WindowW = w * 8;
	WindowH = h * 8;

	PrintX = WindowX;
	PrintY = WindowY;

	sx = (x - 1) * 8;
	sy = (y - 1) * 8;
	sw = (w + 1) * 8;
	sh = (h + 1) * 8;

	US_ClearWindow ();


	VWB_DrawPic (sx, sy, Win1);

	VWB_DrawPic (sx, sy + sh, Win7);

	for (i = sx + 8;i <= sx + sw - 8; i += 8)
	{
		VWB_DrawPic (i, sy, Win2);
		VWB_DrawPic (i, sy + sh, Win8);
	}

	VWB_DrawPic (i, sy, Win3);
	VWB_DrawPic (i, sy + sh, Win9);

	for (i = sy + 8;i <= sy + sh - 8; i += 8)
	{
		VWB_DrawPic (sx, i, Win4);
		VWB_DrawPic (sx + sw, i, Win6);
	}
}



//******************************************************************************
//
// US_CenterWindow() - Generates a window of a given width & height in the
//	 middle of the screen
//
//******************************************************************************

void US_CenterWindow (int w, int h)
{
	US_DrawWindow (((MaxX / 8) - w) / 2,((MaxY / 8) - h) / 2, w, h);
}



//==============================================================================
//
// Intensity Font stuff
//
// TEXT FORMATTING COMMANDS - (Use EGA colors ONLY!)
// -------------------------------------------------
// /<hex digit> - Change the following word to <hex digit> color
// `				- Highlights the following word with lighter color of fontcolor
// /N<hex digit> - Change the fontcolor to a certain color
//
//==============================================================================

//******************************************************************************
//
// GetIntensityColor ()
//
//******************************************************************************

byte GetIntensityColor (byte pix)
{
	if ((fontcolor<0) || (fontcolor>255))
		Error("Intensity Color out of range\n");
	return ((byte) intensitytable[(pix<<8)+fontcolor]);
}


//******************************************************************************
//
// DrawIntensityChar ()
//
// Draws an intensity character at px, py
//
//******************************************************************************

void DrawIntensityChar( char ch )
{
	byte  pix;
	int	width;
	int	height;
	int	ht;
	byte  *source;
	unsigned	dest;
	unsigned	origdest;
	int	mask;

	if(ch<' ')
		return;

	ht = IFont->height;

//	origdest = ( byte * )( bufferofs + ylookup[ py ] + ( px >> 2 ) );
	origdest = ( bufferofs + ylookup[ py ] + ( px >> 2 ) );
	dest = origdest;

	ch -= 31;
	width = IFont->width[ ch ];
	source = ( ( byte * )IFont ) + IFont->charofs[ ch ];

	mask = 1 << ( px & 3 );

	while( width-- )
	{
		VGAMAPMASK( mask );

		height = ht;
		while( height-- )
		{
			pix = *source;
			if ( pix != 0xFE )
			{
//				*dest = GetIntensityColor( pix );
				VGAWRITE(dest, GetIntensityColor( pix ));
			}

			source++;
			dest += linewidth;
		}

		px++;
		mask <<= 1;
		if ( mask == 16 )
		{
			mask = 1;
			origdest++;
		}
		dest = origdest;
	}
}


//******************************************************************************
//
// GetColor ()
//
//******************************************************************************

int GetColor (int num)
{
	int returnval;

	if ((num >= '0') && (num <= '9'))
		returnval = egacolor[num - '0'];
	else
		if ((num >= 'A') && (num <= 'F'))
			returnval = egacolor[((num - 'A') + 10)];

	return (returnval);
}

//******************************************************************************
//
// DrawIString ()
//
//******************************************************************************

static int oldfontcolor = 0;
static boolean highlight = false;

void DrawIString (
	unsigned short int x, unsigned short int y,
	char *string, int flags)
{
	char ch;
	char temp;

	px = x;
	py = y;

	while ((ch = *string++) != 0)
	{
		if ( !PERMANENT_MSG( flags ) )
		{
			// Highlighting is done only for 1 word - if we get a "space"
			//  and highlight is on ...., reset variables.
			//
			if ((ch == ' ') && (highlight == true))
			{
				highlight = false;
				fontcolor = oldfontcolor;
				DrawIntensityChar (ch);
			}
			else
				// '\\' is color change to a specific EGA color (ie. egacolor)
				//
				if (ch == '\\')
				{
					temp = *string++;
					temp = toupper (temp);

					// Force fontcolor to a specific color
					if (temp == 'N')
					{
						temp			= *string++;
						fontcolor	 = GetColor (temp);
						oldfontcolor = fontcolor;
					}

					// Restore fontcolor to a previous color
					else if (temp == 'O')
					{
						fontcolor	 = oldfontcolor;
					}
					else
					{
						oldfontcolor = fontcolor;			  // save off old font color
						highlight	 = true;					 // set highlight
						fontcolor	 = GetColor (temp);
					}
				}
				else
					// '`' is highlight the current fontcolor
					//
					if (ch == '`')
					{
						oldfontcolor = fontcolor;		  // save off old font color
						highlight	 = true;				 // set highlight
						if (fontcolor < 8)					// only highlight the
							fontcolor	 = fontcolor-10;  //  lower colors
					}
					else
						DrawIntensityChar (ch);
		}
		else
			DrawIntensityChar (ch);
	}

	if (highlight == true)
	{
		highlight = false;
		fontcolor = oldfontcolor;
	}
}


//******************************************************************************
//
// DrawIntensityString ()
//
//******************************************************************************

void DrawIntensityString (
	unsigned short int x, unsigned short int y,
	char *string, int color)
{
	char ch;

	px = x;
	py = y;

	fontcolor=color;

	while ((ch = *string++) != 0)
	{
		DrawIntensityChar (ch);
	}
}


#if 0
static unsigned short disp_offset = 160 * 24;

void DrawText
	(
	int x,
	int y,
	int ch,
	int foreground,
	int background
	)

{
	char *vid;

	vid  = ( char * )( 0xb0000 );
	vid += y * 160;
	vid += x * 2;

	if ( ch != NONE )
		{
		*vid = ch;
		}
	vid++;
	*vid = ( ( background & 0x0f ) << 4 ) | ( foreground & 0x0f );
}

void TextBox
	(
	int  x1,
	int  y1,
	int  x2,
	int  y2,
	int ch,
	int  foreground,
	int  background
	)

{
	int x;
	int y;

	for( x = x1; x <= x2; x++ )
	{
		for( y = y1; y <= y2; y++ )
		{
			DrawText( x, y, ch, foreground, background );
		}
	}
}

void TextFrame
	(
	int x1,
	int y1,
	int x2,
	int y2,
	int type,
	int foreground,
	int background
	)
{
	int x;
	int y;

	if ( type == 0 )
	{
		for( x = x1 + 1; x < x2; x++ )
		{
			DrawText( x, y1, type, foreground, background );
			DrawText( x, y2, type, foreground, background );
		}
		for( y = y1 + 1; y < y2; y++ )
		{
			DrawText( x1, y, type, foreground, background );
			DrawText( x2, y, type, foreground, background );
		}
	}
	if ( type == SINGLE_FRAME )
	{
		DrawText( x1, y1, '', foreground, background );
		DrawText( x2, y1, '', foreground, background );
		DrawText( x1, y2, '', foreground, background );
		DrawText( x2, y2, '', foreground, background );
		for( x = x1 + 1; x < x2; x++ )
		{
			DrawText( x, y1, '', foreground, background );
			DrawText( x, y2, '', foreground, background );
		}
		for( y = y1 + 1; y < y2; y++ )
		{
			DrawText( x1, y, '', foreground, background );
			DrawText( x2, y, '', foreground, background );
		}
	}
	if ( type == DOUBLE_FRAME )
	{
		DrawText( x1, y1, '', foreground, background );
		DrawText( x2, y1, '', foreground, background );
		DrawText( x1, y2, '', foreground, background );
		DrawText( x2, y2, '', foreground, background );
		for( x = x1 + 1; x < x2; x++ )
		{
			DrawText( x, y1, '', foreground, background );
			DrawText( x, y2, '', foreground, background );
		}
		for( y = y1 + 1; y < y2; y++ )
		{
			DrawText( x1, y, '', foreground, background );
			DrawText( x2, y, '', foreground, background );
		}
	}
}

void mysetxy
	(
	int x,
	int y
	)
{
	disp_offset = ( x * 2 ) + ( y * 160 );
}

void myputch
	(
	char ch
	)
{
	int j;
	char *disp_start = (char *)( 0xb0000 );

	if ( disp_offset >= 160 * 24 )
	{
		for ( j = 160; j < 160 * 24; j += 2 )
		{
			*( disp_start + j - 160 ) = *( disp_start + j );
		}

		disp_offset = 160 * 23;

		for ( j = disp_offset; j < ( 160 * 24 ); j += 2 )
		{
			*( disp_start + j ) = ' ';
		}
	}

	if ( ch >= 32 )
	{
		*( disp_start + disp_offset ) = ch;
		disp_offset = disp_offset + 2;
	}

	if ( ch == '\r' )
	{
		disp_offset = disp_offset / 160;
		disp_offset = disp_offset * 160;
	}

	if ( ch == '\n' )
	{
		disp_offset = disp_offset + 160;
		if ( disp_offset < 160 * 24 )
		{
			for ( j = disp_offset; j < ( ( ( disp_offset / 160 ) + 1 ) *
				160 ); j += 2 )
			{
				*( disp_start + j ) = ' ';
			}
		}
	}
}

int printstring
	(
	char *string
	)
{
	int count;
	char *ptr;

	ptr = string;
	count = 0;

	while ( *ptr )
	{
		myputch( *ptr );
		count++;
		ptr++;
	}

	return( count );
}


int printnum
	(
	int number
	)
{
	char string[ 100 ];
	int  count;

	itoa( number, string, 10 );
	count = printstring( string );

	return( count );
}

int printunsigned
	(
	unsigned long number,
	int radix
	)
{
	char string[ 100 ];
	int  count;

	ultoa( number, string, radix );
	count = printstring( string );

	return( count );
}

int myprintf
	(
	char *fmt,
	...
	)

{
	va_list argptr;
	int	  count;
	char	 *ptr;
	if (MONOPRESENT==false)
	{
		Debug(fmt);
		return 0;
	}
	va_start( argptr, fmt );
	ptr = fmt;
	count = 0;

	while( *ptr != 0 )
	{
		if ( *ptr == '%' )
		{
			ptr++;
			switch( *ptr )
			{
				case 0 :
					return( EOF );
					break;
				case 'l' :
					count += printnum( va_arg( argptr, int ) );
					ptr++;
					break;
				case 'd' :
					count += printnum( va_arg( argptr, int ) );
					break;
				case 's' :
					count += printstring( va_arg( argptr, char * ) );
					break;
				case 'u' :
					count += printunsigned( va_arg( argptr, int ), 10 );
					break;
				case 'x' :
				case 'X' :
					count += printunsigned( va_arg( argptr, int ), 16 );
					break;
			}
			ptr++;
		}
		else
		{
			myputch( *ptr );
			count++;
			ptr++;
		}
	}

	va_end( argptr );

	return( count );
}
#endif
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
	// make sure word alignment is OFF!

#include "rt_def.h"
#include "rt_sound.h"
// #include <io.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
// #include <conio.h>
// #include <dos.h>
#include "states.h"
#include "watcom.h"
#include "rt_ted.h"
#include "_rt_ted.h"
#include "w_wad.h"
#include "z_zone.h"
#include "rt_util.h"
#include "lumpy.h"
#include "rt_vid.h"
#include "rt_actor.h"
#include "rt_stat.h"
#include "rt_menu.h"
#include "rt_draw.h"
#include "rt_com.h"
#include "rt_main.h"
#include "rt_door.h"
#include "rt_playr.h"
#include "rt_view.h"
#include "rt_str.h"
#include "isr.h"
#include "rt_floor.h"
#include "rt_game.h"
#include "rt_rand.h"
#include "rt_cfg.h"
#include "develop.h"
#include "modexlib.h"
#include "engine.h"
#include "rt_debug.h"
#include "rt_scale.h"
#include "rt_net.h"
//MED
// #include "memcheck.h"




//========================================
// GLOBAL VARIABLES
//========================================



teamtype TEAM[MAXPLAYERS];
int numareatiles[NUMAREAS+1];
int shapestart,shapestop;
_2dvec SPAWNLOC[MAXSPAWNLOCATIONS],FIRST,SECOND;
int NUMSPAWNLOCATIONS,numteams=0;
wall_t	walls[MAXWALLTILES];
str_clock Clocks[MAXCLOCKS];
int numclocks;
int LightsInArea[NUMAREAS+1];

int maxheight;
int nominalheight;
int elevatorstart;
int gunsstart;
int fog;
int lightsource;
int SNAKELEVEL;
int whichpath;

word *mapplanes[3];
int  mapwidth;
int  mapheight;
int  lastlevelloaded=-1;

boolean insetupgame;
boolean ISRTL = false;

unsigned MapSpecials = 0;

char LevelName[80];


int rott_wallcache[256];
int rott_wallstrt;
int rott_wallstop;

int rott_shapecache[4096];
int rott_shapestrt;
int rott_shapestop;

boolean rott_iswolf = false;

//========================================
// LOCAL VARIABLES
//========================================

static cachetype * cachelist;
static word cacheindex;
static boolean CachingStarted=false;
static char * ROTTMAPS = STANDARDGAMELEVELS;
static char * BATTMAPS = STANDARDBATTLELEVELS;

static char NormalWeaponTiles[ 10 ] =
	{
	46, 48, 49, 50, 51, 52, 53, 54, 55, 56
	};
static char SharewareWeaponTiles[ 7 ] =
	{
	48, 49, 50, 51, 52, 53, 54
	};

static char CacheStrings[MAXSILLYSTRINGS][80]=
{
	{"Ready yourself\nfor destruction!\0\0"},
	{"Here comes the enemy!\0\0"},
	{"Hope you wrote\nyour will!\0\0"},
	{"Did you bring your\nextra bullets?\0\0"},
	{"Try not to bleed\non the rug.\0\0"},
	{"Let's see...bandages,\ntape, splints,...\0\0"},
	{"Couldn't we just\ntalk this over?\0\0"},
	{"Cache as cache can...\0\0"},
	{"You are smart.\nMake us strong.\0\0"},
	{"Bleh!\0\0"},
	{"I am as far\nabove you...\0\0"},
	{"Just keep thinkin':\nBut it's loadin' COOL\nstuff...\0\0"},
	{"Guess which line\nwill win!\0\0"},
	{"Oh, no. Not again.\0\0"},
	{"Wait! I'm not ready!\nToo late.\0\0"},
	{"Hope this doesn't\ncrash.\0\0"},
	{"Have a sandwich.\0\0"},
	{"Smoke 'em if\nya got 'em...and\nif ya like cancer.\0\0"},
	{"Ummmmm...\0\0"},
	{"Bang! Bang! Bang!\nFreeze!\0\0"},
	{"You have the right\nto...DIE.\0\0"},
	{"Insert funny phrase\nhere.\0\0"},
	{"Blood, bullets,\nnicely decorated\nhallways.\0\0"},
	{"You are to be killed,\nnot hurt.\0\0"},
	{"It's time for you to\ngo down the stairs!\0\0"},
	{"This game, like,\nrules and stuff.\0\0"},
	{"We get money for this!\nHa ha ha ha!\0\0"},
	{"Let's not start any\nreligious wars...\0\0"},
	{"I don't wanna start\nno ting...\0\0"},
	{"Ah, another sacrifice!\0\0"},
	{"If you were dead,\nyou'd be the\nsame thing.\0\0"},
	{"This Game isn't\nhuman; it can't\nbe reasoned with!\0\0"}
};

void SetupGameLevel (void);
void ScanInfoPlane(void);


#include "rt_wolf.c"


//========================================

/*
======================
=
= SortPreCache
= Sort the Precache for cachelevel precedence using a HEAPSORT
=
======================
*/
#define SGN(x)			((x>0) ? (1) : ((x==0) ? (0) : (-1)))

/*--------------------------------------------------------------------------*/
int CompareTags(s1p,s2p) cachetype *s1p,*s2p;
{
// Sort according to lump
	if (DoPanicMapping()==true)
		return SGN(s1p->cachelevel-s2p->cachelevel);
// Sort according to cachelevel
	else
		return SGN(s1p->lump-s2p->lump);
}

void SwitchCacheEntries(s1p,s2p) cachetype *s1p,*s2p;
{
	cachetype temp;

	temp=*s1p;
	*s1p=*s2p;
	*s2p=temp;
}



void SortPreCache( void )
{
	hsort((char *)cachelist,cacheindex,sizeof(cachetype),&CompareTags,&SwitchCacheEntries);
}

//========================================


/*
======================
=
= SetupPreCache
= Setup the cache for pre-cacheing
=
======================
*/
void SetupPreCache( void )
{

	CachingStarted=true;
	cacheindex=0;
	cachelist=(cachetype *)SafeMalloc(MAXPRECACHE*(sizeof(cachetype)));
	DrawPreCache();
}


/*
======================
=
= ShutdownPreCache
= Setup the cache for pre-cacheing
=
======================
*/
void ShutdownPreCache( void )
{

	CachingStarted=false;
	SafeFree((byte *)cachelist);
}


/*
======================
=
= PreCacheLump
= precache the lump and check to see if it is already tagged
=
======================
*/
void PreCacheLump( int lump, int level )
{
	int i;

	if (CachingStarted==false)
		return;
	if (!W_LumpLength(lump))
		{
#if (PRECACHETEST == 1)
		SoftError("Tried to precache a label, lump = %ld tag=%ld maskednum=%ld\n",lump, level, maskednum);
#endif
		return;
		}
	for (i=1;i<cacheindex;i++)
		if (cachelist[i].lump==lump)
			return;
	cachelist[cacheindex].lump=lump;
	cachelist[cacheindex++].cachelevel=level;
	if (cacheindex==MAXPRECACHE)
		Error("MaxPreCache reached\n");
}



/*
======================
=
= PreCacheGroup
= precache the lump and check to see if it is already tagged
=
======================
*/
void PreCacheGroup( int start, int end )
{
	int i;
	int j;
	int k;
	int found;

	if (CachingStarted==false)
		return;
	k=cacheindex;
	for (j=start;j<=end;j++)
		{
		if (!W_LumpLength(j))
			{
#if (PRECACHETEST == 1)
			SoftError("Tried to precache a label, lump = %ld\n",j);
#endif
			continue;
			}
		found=0;
		for (i=1;i<k;i++)
			if (cachelist[i].lump==j)
				{
				found=1;
				break;
				}
		if (found==0)
			{
			cachelist[cacheindex].lump=j;
			cachelist[cacheindex++].cachelevel=PU_CACHEACTORS;

			if (cacheindex==MAXPRECACHE)
				Error("MaxPreCache reached\n");
			}
		}

}


/*
======================
=
= PreCachePlayers
= precache the lump and check to see if it is already tagged
=
======================
*/
void PreCachePlayers(void )
{
	int start;
	int end;
	int i;
	playertype*pstate;

	for(i=0;i<numplayers;i++)
	{if (i!=consoleplayer) // don't cache consoleplayer
		{pstate = &PLAYERSTATE[i];
		start=W_GetNumForName("CASSHO11")+(pstate->player*REMOTEOFFSET);
		end  =W_GetNumForName("CASWDEAD")+(pstate->player*REMOTEOFFSET);
		PreCacheGroup(start,end);
		}
	}
}




void PreCachePlayerSound(void)
	{
	switch (locplayerstate->player)
		{
		case 0:
			SD_PreCacheSound(SD_PLAYERTCSND);

			break;
		case 1:
			SD_PreCacheSound(SD_PLAYERTBSND);

			break;
		case 2:
			SD_PreCacheSound(SD_PLAYERDWSND);

			break;
		case 3:
			SD_PreCacheSound(SD_PLAYERLNSND);

			break;
		case 4:
			SD_PreCacheSound(SD_PLAYERIPFSND);
			break;
		}
	}


#define IS_ALTERNATE_ACTOR(ob)											\
		((ob->shapeoffset - deathshapeoffset[ob->obclass]) > 0)\

/*
======================
=
= PreCacheActor
= precache the lump and check to see if it is already tagged
=
======================
*/
void PreCacheActor( int actor, int which )
{
	int start;
	int end;

	switch (actor)
		{
		case lowguardobj:
			if (IS_ALTERNATE_ACTOR(new))
				{
				start = SD_LOWGUARD2SEESND;
				end = SD_LOWGUARD2SEE3SND;
				SD_PreCacheSoundGroup(start,end);

				start = SD_LOWGUARD2DIESND;
				end = SD_LOWGUARD2DIESND;
				SD_PreCacheSoundGroup(start,end);

				start = SD_LOWGUARDFIRESND;
				end = SD_SNEAKYSPRINGFSND;
				SD_PreCacheSoundGroup(start,end);

				start=W_GetNumForName("MARSHOO1");
				end  =W_GetNumForName("MNGRISE4");
				//end  =W_GetNumForName("MARUSE28");
				}

			else
				{start = SD_LOWGUARD1SEESND;
				end = SD_LOWGUARD1SEE3SND;
				SD_PreCacheSoundGroup(start,end);

				start = SD_LOWGUARD1DIESND;
				end = SD_LOWGUARD1DIESND;
				SD_PreCacheSoundGroup(start,end);

				start = SD_LOWGUARDFIRESND;
				end = SD_SNEAKYSPRINGFSND;
				SD_PreCacheSoundGroup(start,end);

				start=W_GetNumForName("LWGSHOO1");
				end = W_GetNumForName("SNGRISE4");
				//end  =W_GetNumForName("LOWUSE28");
				}

			break;
		case highguardobj:

			start = SD_HIGHGUARD1SEESND;
			end = SD_HIGHGUARDDIESND;
			SD_PreCacheSoundGroup(start,end);

			if (IS_ALTERNATE_ACTOR(new))
				{
				start=W_GetNumForName("HIGSHOO1");
				end  =W_GetNumForName("HIGWDEAD");
				//end  =W_GetNumForName("HIHUSE28");
				}
			else
				{
				start=W_GetNumForName("HG2SHOO1");
				end  =W_GetNumForName("HG2WDEAD");
				//end  =W_GetNumForName("H2HUSE28");
				}
			break;

		case overpatrolobj:

			start=W_GetNumForName("OBBOLO1");
			end  =W_GetNumForName("OBBOLO4");
			PreCacheGroup(start,end);
			start=W_GetNumForName("NET1");
			end  =W_GetNumForName("NET4");
			PreCacheGroup(start,end);

			start = SD_OVERP1SEESND;
			end = SD_OVERPDIESND;
			SD_PreCacheSoundGroup(start,end);
			SD_PreCacheSoundGroup(SD_NETWIGGLESND,SD_NETFALLSND);

			if (IS_ALTERNATE_ACTOR(new))
				{
				start=W_GetNumForName("PATSHOO1");
				end  =W_GetNumForName("PATDEAD");

				//end  =W_GetNumForName("OBPUSE28");
				}

			else
				{
				start=W_GetNumForName("OBPSHOO1");
				end  =W_GetNumForName("OBPDEAD");

				//end  =W_GetNumForName("PATUSE28");
				}

			break;
		case strikeguardobj:


			start = SD_STRIKE1SEESND;
			end = SD_STRIKEDIESND;
			SD_PreCacheSoundGroup(start,end);

			if (IS_ALTERNATE_ACTOR(new))
				{
				start=W_GetNumForName("XYGSHOO1");
				end  =W_GetNumForName("XYLROLL6");
				//end  =W_GetNumForName("XYUSE28");
				}

			else
				{
				start=W_GetNumForName("ANGSHOO1");
				end  =W_GetNumForName("ANLROLL6");
				//end  =W_GetNumForName("ANUSE28");
				}

			break;

		case blitzguardobj:

			start = SD_BLITZ1SEESND;
			end = SD_BLITZDIESND;
			SD_PreCacheSoundGroup(start,end);

			if (IS_ALTERNATE_ACTOR(new))
				{
				start=W_GetNumForName("WIGSHOO1");
				end  =W_GetNumForName("WIHUSE28");
				}

			else
				{
				start=W_GetNumForName("LIGSHOO1");
				end  =W_GetNumForName("LIPEAD11");
				}

			break;

		case triadenforcerobj:

			start = SD_ENFORCERSEESND;
			end = SD_ENFORCERDIESND;
			SD_PreCacheSoundGroup(start,end);

			start=W_GetNumForName("TEGREN1");
			end  =W_GetNumForName("TGRENF6");
			PreCacheGroup(start,end);
			start=W_GetNumForName("TRISHOO1");
			end  =W_GetNumForName("TRIWDEAD");
			//end  =W_GetNumForName("TRIUSE28");
			break;
		case deathmonkobj:


			start = SD_MONKSEESND;
			end = SD_MONKDIESND;
			SD_PreCacheSoundGroup(start,end);

			start=W_GetNumForName("MONKDR1");
			end  =W_GetNumForName("MONDEAD");
			//end  =W_GetNumForName("MONUSE28");
			break;


		case dfiremonkobj:

			start = SD_FIREMONKSEESND;
			end = SD_FIREMONKDIESND;
			SD_PreCacheSoundGroup(start,end);

			start = W_GetNumForName("MONFIRE1");
			end = W_GetNumForName("MONFIRE4");
			PreCacheGroup(start,end);


			if (IS_ALTERNATE_ACTOR(new))
				{
				start=W_GetNumForName("MRKKSH1");
				end  =W_GetNumForName("MRKDEAD7");
				}

			else
				{
				start=W_GetNumForName("ALLKSH1");
				end  =W_GetNumForName("ALLDEAD7");
				}

			break;

		case roboguardobj:

			start = SD_ROBOTSEESND;
			end = SD_ROBOTDIESND;
			SD_PreCacheSoundGroup(start,end);
			start=W_GetNumForName("ROBOGRD1");
			end  =W_GetNumForName("ROBGRD16");
			break;

		case b_darianobj:

			PreCachePlayerSound();

			start = SD_DARIANSEESND;
			end = SD_DARIANSAY3;
			SD_PreCacheSoundGroup(start,end);


			start=W_GetNumForName("DARSHOO1");
			end  =W_GetNumForName("DARUSE28");
			break;


		case b_heinrichobj:

			PreCachePlayerSound();

			start = SD_KRISTSEESND;
			end = SD_KRISTSAY3;
			SD_PreCacheSoundGroup(start,end);

			start=W_GetNumForName("MINE1");
			end  =W_GetNumForName("MINE4");
			PreCacheGroup(start,end);
			start=W_GetNumForName("HSIT1");
			end  =W_GetNumForName("HDOPE8");
			break;

		case b_darkmonkobj:

			start = SD_DARKMONKSEESND;
			end = SD_DARKMONKSAY3;
			SD_PreCacheSoundGroup(start,end);

			start=W_GetNumForName("LIGNING1");
			end  =W_GetNumForName("FSPARK4");
			PreCacheGroup(start,end);
			start=W_GetNumForName("TOMS1");
			end  =W_GetNumForName("TOHRH8");
			break;

		case b_darksnakeobj:

			PreCachePlayerSound();

			start = SD_SNAKESEESND;
			end = SD_SNAKESAY3;
			SD_PreCacheSoundGroup(start,end);

			start=W_GetNumForName("TOMRH1");
			end  =W_GetNumForName("TOHRH8");
		case b_robobossobj:

			PreCachePlayerSound();

			start = SD_NMESEESND;
			end = SD_NMESEESND;
			SD_PreCacheSoundGroup(start,end);

			start=W_GetNumForName("RHEAD101");
			end  =W_GetNumForName("NMESAUC4");
			break;
		case patrolgunobj:

			start = SD_EMPLACEMENTSEESND;
			end = SD_BIGEMPLACEFIRESND;
			SD_PreCacheSoundGroup(start,end);


			start=W_GetNumForName("GUNEMP1");
			end  =W_GetNumForName("GUNEMPF8");
			PreCacheGroup(start,end);
			start=W_GetNumForName("GRISE11");
			end  =W_GetNumForName("GDEAD2");
			break;

		case wallopobj:
			start=W_GetNumForName("BSTAR1");
			end  =W_GetNumForName("BSTAR4");
			PreCacheGroup(start,end);
			start=W_GetNumForName("BCRAFT1");
			end  =W_GetNumForName("BCRAFT16");
			break;

		case wallfireobj:

			SD_PreCacheSound(SD_FIRECHUTESND);
			SD_PreCacheSound(SD_FIREBALLSND);
			SD_PreCacheSound(SD_FIREBALLHITSND);

			start = W_GetNumForName("CRFIRE11");
			end = W_GetNumForName("CREXP5");

		case pillarobj:

			start=W_GetNumForName("PUSHCOL1");
			end  =W_GetNumForName("PSHCOL1A");
			//end  =W_GetNumForName("PUSHCOL3");
			break;

		case firejetobj:

			SD_PreCacheSound(SD_FIREJETSND);

			if (which)
				{
				start=W_GetNumForName("FJUP0");
				end  =W_GetNumForName("FJUP22");
				}
	#if (SHAREWARE == 0)
			else
				{
				start=W_GetNumForName("FJDOWN0");
				end  =W_GetNumForName("FJDOWN22");
				}
	#endif

			break;

		case bladeobj:

			SD_PreCacheSound(SD_BLADESPINSND);


	#if (SHAREWARE == 0)


			if (which&2)
				{
				if (which&1)
					{
					start=W_GetNumForName("SPSTUP1");
					end  =W_GetNumForName("SPSTUP16");
					}
				else
					{
					start=W_GetNumForName("SPSTDN1");
					end  =W_GetNumForName("SPSTDN16");
					}
				}
			else
				{
				if (which&1)
					{
					start=W_GetNumForName("UBLADE1");
					end  =W_GetNumForName("UBLADE9");
					}
				else
					{
					start=W_GetNumForName("DBLADE1");
					end  =W_GetNumForName("DBLADE9");
					}
				}
	#else
			start=W_GetNumForName("UBLADE1");
			end  =W_GetNumForName("UBLADE9");
	#endif

			break;
		case crushcolobj:

			SD_PreCacheSound(SD_CYLINDERMOVESND);
			if (which)
				{
				start=W_GetNumForName("CRDOWN1");
				end  =W_GetNumForName("CRDOWN8");
				}
	#if (SHAREWARE == 0)
			else
				{
				start=W_GetNumForName("CRUP1");
				end  =W_GetNumForName("CRUP8");
				}
	#endif
			break;

		case boulderobj:
			start=W_GetNumForName("BOL11");
			end  =W_GetNumForName("BSINK9");
			SD_PreCacheSound(SD_BOULDERHITSND);
			SD_PreCacheSound(SD_BOULDERROLLSND);
			SD_PreCacheSound(SD_BOULDERFALLSND);

			break;

		case spearobj:
			SD_PreCacheSound(SD_SPEARSTABSND);

			if (which)
				{
				start=W_GetNumForName("SPEARUP1");
				end  =W_GetNumForName("SPERUP16");
				}
#if (SHAREWARE == 0)
			else
				{
				start=W_GetNumForName("SPEARDN1");
				end  =W_GetNumForName("SPERDN16");
				}
#endif

			break;

		case gasgrateobj:

			start = SD_GASSTARTSND;
			end = SD_GASMASKSND;
			SD_PreCacheSoundGroup(start,end);
			if ((locplayerstate->player == 1) || (locplayerstate->player == 3))
			SD_PreCacheSound(SD_PLAYERCOUGHFSND);
			else
			SD_PreCacheSound(SD_PLAYERCOUGHMSND);
			start=-1;
			end=-1;
			break;

		case springobj:

			SD_PreCacheSound(SD_SPRINGBOARDSND);

			start=W_GetNumForName("SPRING1");
			end  =W_GetNumForName("SPRING9");
			break;
		default:
			return;
			break;
		}
	if ((start>=0) && (end>=0))
		PreCacheGroup(start,end);
}



/*
======================
=
= MiscPreCache
= precache the lump and check to see if it is already tagged
=
======================
*/
void MiscPreCache( void )
{
	int start;
	int end;

	//essential sounds

	SD_PreCacheSoundGroup(SD_HITWALLSND,SD_PLAYERDWHURTSND);
	SD_PreCacheSoundGroup(SD_RICOCHET1SND,SD_RICOCHET3SND);
	SD_PreCacheSound(SD_ATKPISTOLSND);
	SD_PreCacheSoundGroup(SD_PLAYERBURNEDSND,SD_PLAYERLANDSND);
	SD_PreCacheSoundGroup(SD_EXPLODEFLOORSND,SD_EXPLODESND);

	if (lightning==true)
		SD_PreCacheSound(SD_LIGHTNINGSND);

	SD_PreCacheSound(SD_BODYLANDSND);
	SD_PreCacheSound(SD_GIBSPLASHSND);
	SD_PreCacheSound(SD_ACTORLANDSND);
	SD_PreCacheSound(SD_ACTORSQUISHSND);


	// cache in bullet hole graphics
	start=W_GetNumForName("BULLETHO");
	end=W_GetNumForName("ALTBHO");
	PreCacheGroup(start,end);


	// cache in explosions

	if (DoPanicMapping()==true)
		{
		start=W_GetNumForName("EXPLOS1");
		end  =W_GetNumForName("EXPLOS20");
		PreCacheGroup(start,end);
		}
	else
		{
		start=W_GetNumForName("EXPLOS1");
		end  =W_GetNumForName("GREXP25");
		PreCacheGroup(start,end);
		}

	// cache in misc player sprites
	start=W_GetNumForName("BLOODS1");
	end  =W_GetNumForName("PLATFRM5");
	PreCacheGroup(start,end);

	// cache in missile smoke
	start=W_GetNumForName("MISSMO11");
	end  =W_GetNumForName("MISSMO14");
	PreCacheGroup(start,end);

#if (DEVELOPMENT == 1)
	// cache in all weapon sounds
	SD_PreCacheSoundGroup(SD_ATKPISTOLSND,SD_LOSEMODESND);

	// cache in misc player weapons
#if (SHAREWARE == 0)
	start=W_GetNumForName("KNIFE1");
	end  =W_GetNumForName("DOGPAW4");
	PreCacheGroup(start,end);
	// cache in kinetic sphere
	start=W_GetNumForName("KSPHERE1");
	end  =W_GetNumForName("KSPHERE4");
	PreCacheGroup(start,end);

#else
	start=W_GetNumForName("MPIST11");
	end  =W_GetNumForName("GODHAND8");
	PreCacheGroup(start,end);
#endif


	// cache in god mode stuff

	PreCacheGroup(W_GetNumForName("VAPO1"),
					W_GetNumForName("LITSOUL"));

	PreCacheGroup(W_GetNumForName("GODFIRE1"),
					W_GetNumForName("GODFIRE4"));


#endif
	// cache in player's gun

	// cache in rubble
	start=W_GetNumForName("RUBBLE1");
	end  =W_GetNumForName("RUBBLE10");
	PreCacheGroup(start,end);

	// cache in guts
	start=W_GetNumForName("GUTS1");
	end  =W_GetNumForName("GUTS12");
	PreCacheGroup(start,end);

	// cache in player missile
	start=W_GetNumForName("BJMISS1");
	end  =W_GetNumForName("BJMISS16");
	PreCacheGroup(start,end);

	if (gamestate.violence >= vl_high)
		{											// cache in all gibs
		if (DoPanicMapping()==true)
			{
			start = W_GetNumForName("ORGAN1");
			end = W_GetNumForName("ORGAN12");
			}
		else
			{
			start = W_GetNumForName("PART1");
			end = W_GetNumForName("GEYE3");
			}
		PreCacheGroup(start,end);
		}
}


/*
========================
=
= IsChristmas
=
========================
*/

boolean IsChristmas(void)
	{
#if 0

	struct dosdate_t date;

	_dos_getdate(&date);

	if (((date.day == 24) || (date.day == 25)) &&		//Christmas
		(date.month == 12)
		)
		return true;
#endif

	return false;

	}


/*
========================
=
= CheckHolidays
=
========================
*/

void CheckHolidays(void)
	{
#if 0
	struct dosdate_t date;

	_dos_getdate(&date);


	if (IsChristmas())
		DrawNormalSprite(0,0,W_GetNumForName("santahat"));

	else if ((date.month == 5) && (date.day == 5))	// Cinco de Mayo
		DrawNormalSprite(0,0,W_GetNumForName("sombrero"));

	else if ((date.month == 7) && (date.day == 4))	// 4th of July
		DrawNormalSprite(0,0,W_GetNumForName("amflag"));

	else if ((date.month == 10) && (date.day == 31))	// Halloween
		DrawNormalSprite(0,0,W_GetNumForName("witchhat"));

	else if ((date.month == 4) && (date.dayofweek == 0))	//Easter
		{
		int i;

		for(i=15;i<=21;i++)
			{
			if (date.day == i)
				DrawNormalSprite(0,0,W_GetNumForName("esterhat"));
			}
		}
#endif

	}


/*
======================
=
= DrawPreCache
=
======================
*/
extern boolean dopefish;
void DrawPreCache( void )
{
	if (loadedgame==false)
		{
		char temp[80];
		int width, height, num;
		char buf[30];

		if ( BATTLEMODE )
			{
			VL_DrawPostPic (W_GetNumForName("trilogo"));
			VWB_TBar ( 30, 23, 260, 82 );
			ShowBattleOptions( false, 56, 26 );

			DrawPlayers ();
			}
		else
			{
			pic_t * pic;
			pic=(pic_t *)W_CacheLumpName("mmbk",PU_CACHE);
			VWB_DrawPic (0, 0, pic);

			CheckHolidays();
			}

		DrawNormalSprite (PRECACHEBARX, PRECACHEBARY, W_GetNumForName ("cachebar"));

		CurrentFont=smallfont;

		PrintY = PRECACHEESTRINGY;
		PrintX = PRECACHEESTRINGX;

		memset (&buf[0], 0, sizeof (buf));

		if ( !BATTLEMODE )
		{
			memcpy (&buf[0], "EPISODE ", 8);
			itoa (gamestate.episode,&buf[8],10);
		}
		else
			memcpy (&buf[0], "COMM-BAT", 8);

		US_MeasureStr (&width, &height, &buf[0]);
		VWB_TBar (PrintX-2, PrintY-2, width+4, height+4);
		US_BufPrint (&buf[0]);


		PrintY = PRECACHEASTRINGY;

		memset (&buf[0], 0, sizeof (buf));
		memcpy (&buf[0], "AREA ", 5);

		if ( !BATTLEMODE )
			{
			itoa( GetLevel( gamestate.episode, gamestate.mapon ),
				&buf[ 5 ], 10 );
			}
		else
			{
			itoa( gamestate.mapon + 1, &buf[ 5 ], 10 );
			}
		US_MeasureStr (&width, &height, &buf[0]);
		PrintX = (300-width);
		VWB_TBar (PrintX-2, PrintY-2, width+4, height+4);
		US_BufPrint (&buf[0]);


		PrintY = PRECACHESTRINGY;

		num = (RandomNumber ("PreCacheString", 0)) % MAXSILLYSTRINGS;

		if ((dopefish==true) || (tedlevel == true))
			strcpy (temp, &(CacheStrings[num][0]));
		else
			strcpy (temp, &(LevelName[0]));

		US_MeasureStr (&width, &height, &temp[0]);

		PrintX = (320-width) >> 1;
		PrintY = PRECACHESTRINGY;
		VWB_TBar (PrintX-2, PrintY-2, width+4, height+4);

		US_BufPrint (&temp[0]);

		VW_UpdateScreen();

		MenuFadeIn ();
		}
}

#define CACHETICDELAY (6)
/*
======================
=
= PreCache
= precache all the lumps for the level
=
======================
*/
void PreCache( void )
{
	int i;
	int total;
	byte * dummy;
	int maxheapsize;
	int newheap;

	int currentmem;
	int currentcache;
	int lastmem=0;
	int lastcache=0;
	int ticdelay;
	unsigned tempbuf;

	if (CachingStarted==false)
		{
		if (loadedgame==false)
			{
			ClearGraphicsScreen();
			MenuFadeIn ();
			}
		return;
		}

	MiscPreCache();

	SortPreCache();

	if (loadedgame==false)
		{
		maxheapsize=Z_HeapSize();
		total=0;

		tempbuf=bufferofs;
		bufferofs=displayofs;
		ticdelay=CACHETICDELAY;
		for (i=1;i<cacheindex;i++)
			{
//			dummy=W_CacheLumpNum(cachelist[i].lump,cachelist[i].cachelevel);
			dummy=W_CacheWallLumpNum(cachelist[i].lump,cachelist[i].cachelevel);
			total+=W_LumpLength(cachelist[i].lump);
			newheap=Z_UsedHeap();
			currentmem=(newheap*MAXLEDS)/maxheapsize;
			while (lastmem<=currentmem)
				{
				DrawNormalSprite (PRECACHEBARX+PRECACHELED1X+(lastmem<<2),
										PRECACHEBARY+PRECACHELED1Y,
										W_GetNumForName ("led1"));
				lastmem++;
				}
			currentcache=(i*MAXLEDS)/(cacheindex+1);
			while (lastcache<=currentcache)
				{
				DrawNormalSprite (PRECACHEBARX+PRECACHELED2X+(lastcache<<2),
										PRECACHEBARY+PRECACHELED2Y,
										W_GetNumForName ("led2"));
				lastcache++;
				ticdelay--;
				if (ticdelay==0)
					{
					extern boolean dopefish;

					if ( dopefish==true )
						{
						SD_PlayPitchedSound ( SD_DOPEFISHSND, 255, 0 );
						}
					ticdelay=CACHETICDELAY;
					}
				}
			}
		bufferofs=tempbuf;
		ShutdownPreCache ();

		if ( BATTLEMODE )
			{
			int width,height;
			char buf[30];

			CurrentFont = smallfont;
			strcpy( buf, "Press Any Key" );
			US_MeasureStr (&width, &height, &buf[ 0 ] );
			PrintX = (320-width) / 2;
			PrintY = 162;
			VWB_TBar (PrintX-2, PrintY-2, width+4, height+4);
			US_BufPrint (&buf[0]);
			VW_UpdateScreen();

			IN_StartAck();
			while (!IN_CheckAck ())
				;
			}

#if (DEVELOPMENT == 1)
		tempbuf=bufferofs;
		bufferofs=displayofs;
		CurrentFont = smallfont;
		US_CenterWindow(30,6);
		PrintY+=6;
		US_Print("Max  Heap Size:");
		US_PrintUnsigned(maxheapsize);
		US_Print("\n");
		US_Print("Used Heap Size:");
		US_PrintUnsigned(newheap);
		US_Print("\n");
		US_Print("Percentage Used:");
		US_PrintUnsigned(newheap*100/maxheapsize);
		US_Print("\n");
		US_Print("TotalPrecached:");
		US_PrintUnsigned(total);
		bufferofs=tempbuf;
		I_Delay (40);
#endif
#if (PRECACHETEST == 1)
		SoftError("Max  Heap Size: %ld\n",maxheapsize);
		SoftError("Used Heap Size: %ld\n",newheap);
		SoftError("TotalPrecached: %ld\n",total);
#endif
		}
	else
		{
		for (i=1;i<cacheindex;i++)
			{
//			dummy=W_CacheLumpNum(cachelist[i].lump,cachelist[i].cachelevel);
			dummy=W_CacheWallLumpNum(cachelist[i].lump,cachelist[i].cachelevel);
			DoLoadGameAction ();
			}
		ShutdownPreCache ();
		}
	if (CheckParm("LEVELSIZE")!=0)
		{
		OpenMapDebug();

		MapDebug("Map Number %ld\n",gamestate.mapon);
		MapDebug("sizeoflevel=%ld\n",Z_UsedLevelHeap());
		}
#if (PRECACHETEST == 1)
	SoftError("<<<<<<<<<<<<<<<<<<<<<<<Precaching done\n");
#endif
}



/*
======================
=
= CA_RLEWexpand
= length is EXPANDED length
=
======================
*/

void CA_RLEWexpand (word *source, word *dest,long length, unsigned rlewtag)
{
	word  value,count,i;
	word			*end;

	end = dest + length;
	//
	// expand it
	//
	do
	{
		value = IntelShort(*source++);
		if (value != rlewtag)
		{
			//
			// uncompressed
			//
			*dest++=value;
		}
		else
		{
			//
			// compressed string
			//
			count = IntelShort(*source++);
			value = IntelShort(*source++);
			for (i=1;i<=count;i++)
					*dest++ = value;
		}
	} while (dest<end);
}

/*
Tweaked RLE Scheme. Does not use a tag.
00..7F: 0000..007F
80..BF: 0080..3FFF
C0 WORD: Escaped Word
C1..DF: Repeat last value 1..31 times.
E2..FF BYTE: LZ copy (2..31 elements), with BYTE offset.
 */

void CA_BTRLE1Wexpand (byte *source, word *dest,
	long length)
{
	word	value,count;
	byte	*cs;
	word	*ct, *end;
	int		i, j, k, d;

	cs=source;
	ct = dest;
	end = dest + length;
	
	while(ct<end)
	{
		i=*cs++;
		if(i<0x80)
		{
			value=i;
			*ct++=value;
			continue;
		}
		if(i<0xC0)
		{
			value=((i&0x3F)<<8)|(*cs++);
			*ct++=value;
			continue;
		}
		if(i==0xC0)
		{
			j = cs[0] | (cs[1]<<8);
			cs+=2;
			if(j>=0x4000)
			{
				value=j;
				*ct++=value;
				continue;
			}
			if(j<4096)
			{
				while(j--)
					*ct++=value;
				continue;
			}
		}
		if(i<0xE0)
		{
			j=i-0xC0;
			while(j--)
				*ct++=value;
			continue;
		}
		if((i>=0xE2) && (i<=0xFF))
		{
			d=*cs++;
			j=i-0xE0;
			while(j--)
				*ct++=*(ct-d);
			continue;
		}
	}
}

/*
======================
=
= CheckRTLVersion
=
======================
*/

void CheckRTLVersion
	(
	char *filename
	)

	{
	int  filehandle;
	char RTLSignature[ 4 ];
//	unsigned long RTLVersion;
	unsigned int RTLVersion;

	filehandle = SafeOpenRead( filename );

	//
	// Load RTL signature
	//
	SafeRead( filehandle, RTLSignature, sizeof( RTLSignature ) );

	if ( ( strcmp( RTLSignature, COMMBAT_SIGNATURE ) != 0 ) &&
		( strcmp( RTLSignature, NORMAL_SIGNATURE ) != 0 ) )
		{
		Error( "The file '%s' is not a valid level file.", filename );
		}

	//
	// Check the version number
	//
	SafeRead( filehandle, &RTLVersion, sizeof( RTLVersion ) );
	if ( RTLVersion > RTL_VERSION )
		{
		Error(
			"The file '%s' is a version %d.%d %s file.\n"
			"The highest this version of ROTT can load is %d.%d.", filename,
			RTLVersion >> 8, RTLVersion & 0xff, RTLSignature,
			RTL_VERSION >> 8, RTL_VERSION & 0xff );
		}

	w_close( filehandle );
	}


/*
======================
=
= ReadROTTMap
=
======================
*/

void ReadROTTMap
	(
	char *filename,
	int mapnum
	)

	{
	RTLMAP RTLMap;
	int	filehandle;
	long	pos;
	long	compressed;
	long	expanded;
	int	plane;
	byte  *buffer;

	CheckRTLVersion( filename );
	filehandle = SafeOpenRead( filename );

	//
	// Load map header
	//
	w_lseek( filehandle, RTL_HEADER_OFFSET + mapnum * sizeof( RTLMap ),
		SEEK_SET );
	SafeRead( filehandle, &RTLMap, sizeof( RTLMap ) );

	if ( !RTLMap.used )
	{
		Error( "ReadROTTMap: Tried to load a non existent map!" );
	}

#if ( SHAREWARE == 1 )
	if ( RTLMap.RLEWtag == REGISTERED_TAG )
	{
		Error( "Can't use maps from the registered game "
			"in shareware version." );
	}

	if ( RTLMap.RLEWtag != SHAREWARE_TAG )
	{
		Error( "Can't use modified maps in shareware version." );
	}
#endif

	mapwidth  = 128;
	mapheight = 128;

	// Get special map flags
	MapSpecials = RTLMap.MapSpecials;

	//
	// load the planes in
	//
	expanded = mapwidth * mapheight * 2;

	for( plane = 0; plane <= 2; plane++ )
	{
		pos		= RTLMap.planestart[ plane ];
		compressed = RTLMap.planelength[ plane ];
		buffer	= SafeMalloc( compressed );
		w_lseek( filehandle, pos, SEEK_SET );
		SafeRead( filehandle, buffer, compressed );

		mapplanes[ plane ] = Z_Malloc( expanded, PU_LEVEL, &mapplanes[ plane ] );

		//
		// unRLEW, skipping expanded length
		//
		if(RTLMap.RLEWtag==BT1RLEW_TAG)
		{
			CA_BTRLE1Wexpand( buffer,
				(word *)mapplanes[plane],
				expanded >> 1);
		}else
		{
#if ( SHAREWARE == 1 )
			CA_RLEWexpand( ( word * )buffer, ( word * )mapplanes[ plane ],
				expanded >> 1, SHAREWARE_TAG );
#else
			CA_RLEWexpand( ( word * )buffer, ( word * )mapplanes[ plane ],
				expanded >> 1, RTLMap.RLEWtag );
#endif
		}

		SafeFree( buffer );
	}
	w_close(filehandle);

	//
	// get map name
	//
	strcpy( LevelName, RTLMap.Name );
}

/*
BGB: Try reading the map from the WAD.
This will use the same basic format as the map in the RTL file.
*/
int ReadWadLumpMap( int mapnum )
{
	char tb[64];
	RTLMAP	RTLMap;
	long	pos;
	long	compressed;
	long	expanded;
	int		lump, sz;
	int		plane;
	byte	*map;
	byte	*buffer;

	sprintf(tb, "MAP%02d", mapnum+1);
	lump=W_CheckNumForName(tb);
	
	if(lump<0)
		return(-1);
	
	sz=W_LumpLength(lump);
	if(sz<=sizeof(RTLMap))
		return(-1);

	map=W_CacheLumpNum(lump, PU_CACHE);
	if(!map)
		return(-1);

	memcpy(&RTLMap, map, sizeof( RTLMap ) );

	mapwidth  = 128;
	mapheight = 128;

	// Get special map flags
	MapSpecials = RTLMap.MapSpecials;

	//
	// load the planes in
	//
	expanded = mapwidth * mapheight * 2;

	for( plane = 0; plane <= 2; plane++ )
	{
		pos		= RTLMap.planestart[ plane ];
		compressed = RTLMap.planelength[ plane ];
		buffer	= SafeMalloc( compressed );
//		w_lseek( filehandle, pos, SEEK_SET );
//		SafeRead( filehandle, buffer, compressed );
		memcpy(buffer, map+pos, compressed);

		mapplanes[ plane ] = Z_Malloc(
			expanded, PU_LEVEL, &mapplanes[ plane ] );

		//
		// unRLEW, skipping expanded length
		//

		if(RTLMap.RLEWtag==BT1RLEW_TAG)
		{
			CA_BTRLE1Wexpand( buffer,
				(word *)mapplanes[plane],
				expanded >> 1);
		}else
		{
			CA_RLEWexpand( ( word * )buffer,
				( word * )mapplanes[ plane ],
				expanded >> 1, RTLMap.RLEWtag );
		}

		SafeFree( buffer );
	}

	//
	// get map name
	//
	strcpy( LevelName, RTLMap.Name );
	
	return(1);
}


/*
======================
=
= GetNextMap
=
======================
*/
int GetNextMap ( int tilex, int tiley )
	{
	word next;
	word icon;
	boolean done;

	next = MAPSPOT( tilex, tiley, 2 );
	icon = MAPSPOT( tilex, tiley, 1 );
	done=false;
	if ( ( ( icon != EXITTILE ) && ( icon != SECRETEXITTILE ) ) ||
		( ( ( next&0xff00 ) != 0xe200 ) && ( ( next&0xff00 ) != 0xe400 ) ) )
		{
		int i,j;

		for ( j = 0; j < mapheight; j++ )
			{
			for ( i = 0; i < mapwidth; i++ )
				{
				icon = MAPSPOT( i, j, 1 );
				next = MAPSPOT( i, j, 2 );
				if ( ( ( icon == EXITTILE ) || ( icon == SECRETEXITTILE ) ) &&
					( ( ( next&0xff00 ) == 0xe200 ) ||
					( ( next&0xff00 ) == 0xe400 ) ) )
					{
					done=true;
					break;
					}
				}

			if ( done == true )
				{
				break;
				}
			}

		if ( !done )
			{
			Error( "GetNextMap : No exit tile on map %d.", gamestate.mapon );
			}
		}
	if ( ( ( next & 0xff00 ) != 0xe200 ) &&
		( ( next & 0xff00 ) != 0xe400 ) )
		{
		// Should this be DEVELOPMENT only?
		Error( "GetNextMap : Illegal destination map %xh at exit "
			"tile on map %d.", next, gamestate.mapon );
		}

	if ( next == 0xe2ff )
		{
		return -1;
		}

	return ( next & 0xff );
	}

/*
======================
=
= GetMapFileInfo
=
======================
*/
void GetMapFileInfo
	(
	mapfileinfo_t *mapinfo,
	char *filename
	)

	{
	RTLMAP RTLMap[ 100 ];
	int	filehandle;
	int	i;
	int	nummaps;

	CheckRTLVersion( filename );

	filehandle = SafeOpenRead( filename );

	//
	// Load map header
	//
	w_lseek( filehandle, RTL_HEADER_OFFSET, SEEK_SET );
	SafeRead( filehandle, &RTLMap, sizeof( RTLMap ) );
	w_close( filehandle );

	nummaps = 0;
	for( i = 0; i < 100; i++ )
		{
		if ( !RTLMap[ i ].used )
			{
			continue;
			}

		mapinfo->maps[ nummaps ].number = i;

		strcpy( mapinfo->maps[ nummaps ].mapname, RTLMap[ i ].Name );

		nummaps++;
		}

	mapinfo->nummaps = nummaps;
	}

/*
======================
=
= GetMapFileName
=
======================
*/
void GetMapFileName ( char * filename )
{
	if ( ( BATTLEMODE ) && (BattleLevels.avail == true) )
		{
		strcpy(filename,BattleLevels.file);
		}
	else if (GameLevels.avail == true)
		{
		strcpy(filename,GameLevels.file);
		}
	else if ( BATTLEMODE )
		{
		strcpy(filename,BATTMAPS);
		}
	else
		{
		strcpy(filename,ROTTMAPS);
		}
}

/*
======================
=
= SetBattleMapFileName
=
======================
*/
void SetBattleMapFileName ( char * filename )
{
	BattleLevels.avail = true;
	memset (&(BattleLevels.file[0]), 0, sizeof (BattleLevels.file));
	strcpy (&(BattleLevels.file[0]), filename);
}

/*
======================
=
= GetMapCRC
=
======================
*/
word GetMapCRC
	(
	int num
	)

	{
	int  filehandle;
	char filename[ 80 ];
	RTLMAP RTLMap;

	GetMapFileName( &filename[ 0 ] );
	CheckRTLVersion( filename );
	filehandle = SafeOpenRead( filename );

	//
	// Load map header
	//
	w_lseek( filehandle,
		RTL_HEADER_OFFSET + num * sizeof( RTLMap ),
		SEEK_SET );
	SafeRead( filehandle, &RTLMap, sizeof( RTLMap ) );

	w_close( filehandle );

	return( RTLMap.CRC );
	}


/*
======================
=
= GetAlternateMapInfo
=
======================
*/

void GetAlternateMapInfo (mapfileinfo_t * mapinfo, AlternateInformation *info)
{
	if (UL_ChangeDirectory (info->path) == false)
		Error ("ERROR : Can't change to alternate directory %s!\n");

	GetMapFileInfo (mapinfo, info->file);

	UL_ChangeDirectory (&CWD[0]);
}

/*
======================
=
= GetMapInfo
=
======================
*/
void GetMapInfo
	(
	mapfileinfo_t *mapinfo
	)

	{
	if ( ( BATTLEMODE ) && ( BattleLevels.avail == true ) )
		{
		GetAlternateMapInfo( mapinfo, &BattleLevels );
		}
	else if ( GameLevels.avail == true )
		{
		GetAlternateMapInfo( mapinfo, &GameLevels );
		}
	else if ( BATTLEMODE )
		{
		GetMapFileInfo( mapinfo, BATTMAPS );
		}
	else
		{
		GetMapFileInfo( mapinfo, ROTTMAPS );
		}
	}

/*
======================
=
= LoadTedMap
=
======================
*/
void LoadTedMap
	(
	const char *extension,
	int mapnum
	)

	{
	long	pos;
	long	compressed;
	long	expanded;
	int	plane;
	int	i;
	int	maphandle;
	byte	*buffer;
	maptype mapheader;
	char	name[ 200 ];
	mapfiletype *tinf;

	//
	// load maphead.ext (offsets and tileinfo for map file)
	//
	strcpy( name, "maphead." );
	strcat( name, extension );
	LoadFile( name, ( void * )&tinf );

	// fix structure alignment
	tinf = ( void * )( ( word * )tinf - 1 );

	for( i = 0 ; i < 100 ; i++ )
		{
		tinf->headeroffsets[ i ] = IntelLong( tinf->headeroffsets[ i ] );
		}

	//
	// open the data file
	//
	strcpy( name, "maptemp." );
	strcat( name, extension );
	maphandle = SafeOpenRead( name );

	//
	// load map header
	//
	pos = tinf->headeroffsets[ mapnum ];

	// $FFFFFFFF start is a sparse map
	if ( pos < 0 )
		{
		Error( "LoadTedMap : Tried to load a non existent map!" );
		}

	w_lseek( maphandle, pos, SEEK_SET );
	SafeRead( maphandle, &mapheader, sizeof( maptype ) );

	for( i = 0 ; i < 3; i++ )
		{
		mapheader.planestart[ i ]  = IntelLong( mapheader.planestart[ i ] );
		mapheader.planelength[ i ] = IntelShort( mapheader.planelength[ i ] );
		}

	mapheader.width  = IntelShort( mapheader.width );
	mapheader.height = IntelShort( mapheader.height );

	mapwidth  = mapheader.width;
	mapheight = mapheader.height;

	// Set special map flags
	MapSpecials = 0;

	//
	// load the planes in
	//
	expanded = mapheader.width * mapheader.height * 2;

	for( plane = 0; plane <= 2; plane++ )
		{
		pos = mapheader.planestart[ plane ];
		w_lseek( maphandle, pos, SEEK_SET );

		compressed = mapheader.planelength[ plane ];
		buffer = SafeMalloc( compressed );
		SafeRead( maphandle, buffer, compressed );

		mapplanes[ plane ] = Z_Malloc( expanded, PU_LEVEL, &mapplanes[ plane ] );

		//
		// unRLEW, skipping expanded length
		//
		CA_RLEWexpand( ( word * )( buffer + 2 ), ( word * )mapplanes[ plane ],
			expanded >> 1, 0xabcd );

		SafeFree( buffer );
		}

	// fix structure alignment
	tinf = ( void * )( ( word * )tinf + 1 );

	SafeFree( tinf );

	w_close( maphandle );

//	if ( close( maphandle ) )
//		{
//		Error( "Error closing Ted file Error #%ld", errno );
//		}
	}


/*
======================
=
= LoadAlternateMap
=
======================
*/

void LoadAlternateMap (AlternateInformation *info, int mapnum)
{
	if (UL_ChangeDirectory (info->path) == false)
		Error ("ERROR : Can't change to alternate directory %s!\n",info->path);

	ReadROTTMap (info->file, mapnum);

	UL_ChangeDirectory (&CWD[0]);
}

/*
======================
=
= LoadROTTMap
=
======================
*/
void LoadROTTMap
	(
	int mapnum
	)
{
	char *altrtl;
	int i, j, k;
	
	altrtl=NULL;
	i=CheckParm("rtl");		//BGB
	if(i>0)
	{
		altrtl=_argv[i+1];
	}
	
	if(!altrtl)
	{
		i=ReadWadLumpMap(mapnum);
		if(i>0)
			return;
	}

	if ( tedlevel == true )
	{
		LoadTedMap( "rot", mapnum );
	}
	else if ( ( BATTLEMODE ) && ( BattleLevels.avail == true ) )
	{
		LoadAlternateMap( &BattleLevels, mapnum );
	}
	else if ( GameLevels.avail == true )
	{
		LoadAlternateMap( &GameLevels, mapnum );
	}
	else if ( BATTLEMODE )
	{
		ReadROTTMap( BATTMAPS, mapnum );
	}
	else
	{
		if(altrtl)
			ReadROTTMap( altrtl, mapnum );
		else
			ReadROTTMap( ROTTMAPS, mapnum );
	}
}


void CountAreaTiles(void)
{int i,j,areanumber;
	word*map,tile;

	memset(numareatiles,0,sizeof(numareatiles));
	map  = mapplanes[0];

	for(i=0;i<MAPSIZE;i++)
	for(j=0;j<MAPSIZE;j++)
		{tile = *map++;

		areanumber = tile - AREATILE;
		if ((areanumber >= 0) && (areanumber <= NUMAREAS))
			numareatiles[areanumber] ++;
		}

}



#define InitWall(lump,index,newx,newy)			\
	{											\
	PreCacheLump(lump,PU_CACHEWALLS);			\
	if (W_LumpLength(lump) == 0)				\
		Error("%s being used in shareware at %ld %ld",	\
		W_GetNameForNum(lump),newx,newy);		\
	actorat[newx][newy]= &walls[index];			\
	tempwall = (wall_t*)actorat[newx][newy];	\
	tempwall->which = WALL;						\
	tempwall->tile = index;						\
	tempwall->lump = lump;						\
	}											\


/*
==================
=
= SetupWalls
=
==================
*/
void SetupWalls( void )
{
	int	i,j,lump,index;
	word	*map,tile;
	wall_t * tempwall;


	for (i=0;i<MAXWALLTILES;i++)
		memset(&walls[i],0,sizeof(wall_t));

	map = mapplanes[0];
	for (j=0;j<mapheight;j++)
	{
		for(i=0;i<mapwidth;i++)
		{
			if ((i>=0) && (i<=3) && (j==0))
			{
				map++;
				continue;
			}
			if ((loadedgame == false) && (MAPSPOT(i,j,2) == 0xeeee))
			{
				_2Dpoint *tdptr;

				tdptr = &(MISCVARS->EPOP[MISCVARS->nextpop]);
				tdptr->x = i;
				tdptr->y = j;
				MISCVARS->nextpop ++;
				MISCVARS->popsleft ++;
			}
			tile= *map++;

			if ((tile > 89) ||
				((tile > 32) && (tile < 36)) ||
				(tile == 44) ||
				(tile == 45) ||
				(tile == 0)
				)
			{
				tilemap[i][j] = 0;
				continue;
			}

			if (tile <= 32)
			{
				index = tile;
#if 0
				if (tile==12)
				{
					if (MAPSPOT(i,j,2)==0)
						MAPSPOT(i,j,2)=21;
				}
#endif
			}
			else
				index = tile-3;

			if ((tile > 75) && (tile <= 79))
			{
				lump = tilemap[i][j] = GetLumpForTile(tile);
				PreCacheLump(lump,PU_CACHEWALLS);
				PreCacheLump(elevatorstart+5,PU_CACHEWALLS);
				PreCacheLump(elevatorstart+6,PU_CACHEWALLS);
				PreCacheLump(elevatorstart+7,PU_CACHEWALLS);
				tilemap[i][j]|=0x2000;
				if (MAPSPOT(i,j,2)==0)
					MAPSPOT(i,j,2)=21;
			}
			else if ((tile >= 47) && (tile <= 48))
			{
				lump = tilemap[i][j] = GetLumpForTile(tile);
				InitWall(lump,index,i,j);
				tilemap[i][j]|=0x2000;
				if (MAPSPOT(i,j,2)==0)
					MAPSPOT(i,j,2)=21;
			}
			else
			{
				lump = tilemap[i][j] = GetLumpForTile(tile);
				InitWall(lump,index,i,j);
				if (MAPSPOT(i,j,2))
					tilemap[i][j]|=0x2000;
			}
		}
	}
}


/*
===============
=
= GetNearestAreaNumber
=
===============
*/
word GetNearestAreaNumber ( int tilex, int tiley )
{
	int up,dn,lt,rt;
	int tile;

	tile=MAPSPOT(tilex,tiley,0)-AREATILE;

	if ((tile<=NUMAREAS) && (tile>0))
		return (tile+AREATILE);

	up=MAPSPOT(tilex,tiley-1,0)-AREATILE;
	dn=MAPSPOT(tilex,tiley+1,0)-AREATILE;
	lt=MAPSPOT(tilex-1,tiley,0)-AREATILE;
	rt=MAPSPOT(tilex+1,tiley,0)-AREATILE;

	up = ((up>0) && (up<=NUMAREAS));
	dn = ((dn>0) && (dn<=NUMAREAS));
	lt = ((lt>0) && (lt<=NUMAREAS));
	rt = ((rt>0) && (rt<=NUMAREAS));

	if (rt)
		return (MAPSPOT(tilex+1,tiley,0) + AREATILE);
	else if (lt)
		return (MAPSPOT(tilex-1,tiley,0) + AREATILE);
	else if (up)
		return (MAPSPOT(tilex,tiley-1,0) + AREATILE);
	else if (dn)
		return (MAPSPOT(tilex,tiley+1,0) + AREATILE);
//	else
//		Error("GetNearestAreaNumber: Couldn't fix up area at x=%ld y=%ld\n",tilex,tiley);
	return (NUMAREAS+AREATILE-1);
}

/*
===============
=
= SetupWindows
=
===============
*/
void SetupWindows ( void )
{
	int i,j;
	boolean skythere;

	skythere = SkyExists();

	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			if ((i>=0) && (i<=3) && (j==0))
				continue;
			if (IsWindow(i,j))
				{
				actorat[i][j]=0;
				if (skythere==true)
					{
					tilemap[i][j]|=0x2000;
					}
				else
					{
					MAPSPOT(i,j,2)=0;
					}
				MAPSPOT(i,j,0)=(word)(GetNearestAreaNumber(i,j));
				}
			}
		}

}


/*
==================
=
= GetWallIndex
=
==================
*/

int GetWallIndex( int texture )
{
//	int wallstart;
//	int exitstart;
	int i, j, k;

#if 1
	if (texture&0x1000)
	{
		texture&=~0x1000;
		if (texture==0)
			return 41;
		else if (texture==1)
			return 90;
		else if (texture==2)
			return 91;
		else if (texture==3)
			return 42;
		else if (texture==4)
			return 92;
		else if (texture==5)
			return 93;
		else if (texture==6)
			return 94;
		else if (texture==7)
			return 95;
		else if (texture==8)
			return 96;
		else if (texture==9)
			return 97;
		else if (texture==10)
			return 98;
		else if (texture==11)
			return 99;
		else if (texture==12)
			return 100;
		else if (texture==13)
			return 101;
		else if (texture==14)
			return 102;
		else if (texture==15)
			return 103;
		else if (texture==16)
			return 104;
	}
	else
	{
		for(i=0; i<MAXWALLTILES; i++)
		{
			if(walls[i].lump==texture)
				return(i);
		}
		return 0x8000;
	}
#endif


#if 0
//	wallstart=W_GetNumForName("WALLSTRT");
//	exitstart=W_GetNumForName("EXITSTRT");
//	elevatorstart = W_GetNumForName("ELEVSTRT");

	if (texture&0x1000)
		{
		texture&=~0x1000;
		if (texture==0)
			return 41;
		else if (texture==1)
			return 90;
		else if (texture==2)
			return 91;
		else if (texture==3)
			return 42;
		else if (texture==4)
			return 92;
		else if (texture==5)
			return 93;
		else if (texture==6)
			return 94;
		else if (texture==7)
			return 95;
		else if (texture==8)
			return 96;
		else if (texture==9)
			return 97;
		else if (texture==10)
			return 98;
		else if (texture==11)
			return 99;
		else if (texture==12)
			return 100;
		else if (texture==13)
			return 101;
		else if (texture==14)
			return 102;
		else if (texture==15)
			return 103;
		else if (texture==16)
			return 104;
		}
	else if (texture > elevatorstart)
		return (texture - elevatorstart + 68);
//	else if (texture > specialstart)
//		return (texture - specialstart + 41);
	else if (texture > exitstart)
		return (texture - exitstart + 43);
	else
	{
		if(rott_iswolf)
			return (texture - wallstart);

		if (texture>wallstart+63)
			return (texture - (wallstart + 63) + 76 );
		else if (texture>wallstart+40)
			return (texture - (wallstart + 40) + 45 );
		else
			return (texture - wallstart);
	}
	return 0x8000;
#endif
}

/*
==================
=
= SetupAnimatedWalls
=
==================
*/
void SetupAnimatedWalls( void )
{
	int	i,j;
	word	*map,tile;
	wall_t * tempwall;

	InitAnimatedWallList();
	map = mapplanes[0];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			if ((i>=0) && (i<=3) && (j==0))
				{
				map++;
				continue;
				}
			tile= *map++;
			if (tile == 44)
				{
				actorat[i][j]= &walls[tile-3];
				tempwall = (wall_t*)actorat[i][j];
				tempwall->which = WALL;
				tempwall->tile = tile-3;
				tempwall->flags = FL_W_DAMAGE;
				SetupAnimatedWall(0);
				tilemap[i][j]=0;
				tilemap[i][j]|=0x1000;
				}
			else if (tile == 45)
				{
				actorat[i][j]= &walls[tile-3];
				tempwall = (wall_t*)actorat[i][j];
				tempwall->which = WALL;
				tempwall->tile = tile-3;
				SetupAnimatedWall(3);
				tilemap[i][j]=3;
				tilemap[i][j]|=0x1000;
				}
			else if ((tile >= 106) && (tile <= 107))
				{
				actorat[i][j]= &walls[tile-16];
				tempwall = (wall_t*)actorat[i][j];
				tempwall->which = WALL;
				tempwall->tile = tile-16;
				SetupAnimatedWall(tile-105);
				tilemap[i][j]=tile-105;
				tilemap[i][j]|=0x1000;
				}
			else if ((tile >= 224) && (tile <= 233))
				{
				actorat[i][j]= &walls[tile-224+92];
				tempwall = (wall_t*)actorat[i][j];
				tempwall->which = WALL;
				tempwall->tile = tile-224+94;
				if (tile==233)
					tempwall->flags = FL_W_DAMAGE;
				SetupAnimatedWall(tile-224+4);
				tilemap[i][j]=tile-224+4;
				tilemap[i][j]|=0x1000;
				}
			else if ((tile >= 242) && (tile <= 244))
				{
				actorat[i][j]= &walls[tile-242+102];
				tempwall = (wall_t*)actorat[i][j];
				tempwall->which = WALL;
				tempwall->tile = tile-242+102;
				SetupAnimatedWall(tile-242+14);
				tilemap[i][j]=tile-242+14;
				tilemap[i][j]|=0x1000;
				}
			}
		}
}


/*
==================
=
= SetupSwitches
=
==================
*/

void SetupSwitches( void )
{
	int	i,j;
	word	*map,tile;

	map = mapplanes[0];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			if ((i>=0) && (i<=3) && (j==0))
				{
				map++;
				continue;
				}
			tile= *map++;
			if ((tile >= 76) && (tile <= 79))
				{
				if (tile == 79)
					lastswitch->flags |= FL_ON;
				SpawnSwitchThingy(i,j);
				}
			else if ((tile == 157) || (tile == 175)) // hi masked switches
				{
				lastswitch->flags |= FL_W_INVERTED;
				lastswitch->flags |= FL_REVERSIBLE;
				if (tile==175)
					lastswitch->flags |= FL_ON;
				SpawnSwitchThingy(i,j);
				}
			}
		}
}



void RespawnPlayerobj(objtype *ob)
{
	int rand,numchecked=0;
	int oldsetupgame,nx,ny,ndir;
	playertype *pstate;

	M_LINKSTATE(ob,pstate);

	if (gamestate.battlemode != battle_CaptureTheTriad)
	{
		rand = (GameRandomNumber("playerobj respawn",0) % NUMSPAWNLOCATIONS);

		while(numchecked < NUMSPAWNLOCATIONS)
			{
			if (!actorat[SPAWNLOC[rand].x][SPAWNLOC[rand].y])
				{RevivePlayerobj(SPAWNLOC[rand].x,SPAWNLOC[rand].y,SPAWNLOC[rand].dir,ob);
				return;
				}
			numchecked ++;
			rand = (rand + 1) % NUMSPAWNLOCATIONS;
			}
#if (DEVELOPMENT == 1)
		SoftError("\nno spawn locations available, using FindEmptyTile");
#endif
		nx = SPAWNLOC[rand].x;
		ny = SPAWNLOC[rand].y;
		ndir = SPAWNLOC[rand].dir;
	}
	else
	{
		nx = TEAM[pstate->team].tilex;
		ny = TEAM[pstate->team].tiley;
		ndir = TEAM[pstate->team].dir;
	}

	oldsetupgame = insetupgame;
	insetupgame = true;
	FindEmptyTile(&nx,&ny);
	insetupgame = oldsetupgame;
	RevivePlayerobj(nx,ny,ndir,ob);


}

#define SetupSpecificFlagTeamAt(whichteam, spawnlocindex) \
{int newx,newy;														\
																			\
	newx = SPAWNLOC[spawnlocindex].x;								\
	newy = SPAWNLOC[spawnlocindex].y;								\
	TEAM[whichteam].tilex = newx;									\
	TEAM[whichteam].tiley = newy;									\
	TEAM[whichteam].dir = SPAWNLOC[spawnlocindex].x;			\
	SpawnStatic(newx,newy,stat_collector,9);						\
	SpawnNewObj(newx,newy,&s_basemarker1,inertobj);			\
	LASTACTOR->z = LASTSTAT->z;										\
	LASTSTAT->flags |= FL_COLORED;									\
	LASTSTAT->hitpoints = whichteam;								\
	locspawned[spawnlocindex]=1;									\
	for(j=0;j<numplayers;j++)										\
	{if (PLAYERSTATE[j].uniformcolor !=						\
			TEAM[whichteam].uniformcolor)						\
		continue;													\
																			\
	ntilex = newx;													\
	ntiley = newy;													\
	FindEmptyTile(&ntilex,&ntiley);							\
	SpawnPlayerobj(ntilex,ntiley,dir,j);					\
	}																	\
}																			\


/*
=============
=
= AssignTeams called from SetGameDescription in rt_net.c
=
=============
*/

void AssignTeams(void)
{int i,color;
	int teamforcolor[MAXPLAYERCOLORS];

	numteams = 0;
	if (!gamestate.teamplay)
	return;

	memset(teamforcolor,-1,sizeof(teamforcolor));
	memset(TEAM,0,sizeof(TEAM));

	for(i=0;i<numplayers;i++)
	{color = PLAYERSTATE[i].uniformcolor;
	if (teamforcolor[color] == -1)
		{TEAM[numteams].uniformcolor = color;

			TEAM[numteams].nummembers ++;
			teamforcolor[color] = numteams;
			numteams++;
			if ((gamestate.battlemode == battle_CaptureTheTriad) &&
				(numteams > 2))
			Error("players selected more colors(%d) than Capture the Triad allows",numteams);
		}
	else
		TEAM[teamforcolor[color]].nummembers ++;

	PLAYERSTATE[i].team = teamforcolor[color];

	}

}



/*
=============
=
= SetupTeams
=
=============
*/


void SetupTeams(void)
{

	int i,j,rand,sx,sy,ntilex,ntiley,dir,
		maxdist,currdist,spawnindex,cnt;
	int locspawned[MAXSPAWNLOCATIONS] = {0};

	if (gamestate.battlemode == battle_CaptureTheTriad)
	{
		rand = (GameRandomNumber("net player spawn",0) % NUMSPAWNLOCATIONS);

			for(i=0;i<NUMSPAWNLOCATIONS;i++)
			{
				sx = SPAWNLOC[rand].x;
				sy = SPAWNLOC[rand].y;
				dir = SPAWNLOC[rand].dir;

				if (CheckTile(sx,sy) && (!IsPlatform(sx,sy)) &&
					(Number_of_Empty_Tiles_In_Area_Around(sx,sy) > TEAM[0].nummembers)
					)
					{SetupSpecificFlagTeamAt(0,rand);
					break;
					}

				rand = (rand + 1)%NUMSPAWNLOCATIONS;
				}

			if (i == NUMSPAWNLOCATIONS)
				Error("No spawn location available for team 0, capture the flag");

			maxdist = 0x80000000;
			for(i=0;i<NUMSPAWNLOCATIONS;i++)
			{
				if (locspawned[i])
					continue;

				sx = SPAWNLOC[i].x;
				sy = SPAWNLOC[i].y;
				dir = SPAWNLOC[i].dir;

				if ((Number_of_Empty_Tiles_In_Area_Around(sx,sy) < TEAM[1].nummembers)
					|| (!CheckTile(sx,sy) || IsPlatform(sx,sy))
					)
					continue;

				currdist = FindDistance(sx-TEAM[0].tilex,sy-TEAM[0].tiley);
				if (currdist > maxdist)
				{
					maxdist = currdist;
					spawnindex = i;
				}
			}

			SetupSpecificFlagTeamAt(1,spawnindex);
		}
	else
	{
		int badcount = 0,teamindex;

		if (numteams > NUMSPAWNLOCATIONS)
			Error("More teams than spawn locations !");
		//cnt =0;
		//for(rand = 0;rand < NUMSPAWNLOCATIONS;rand++)
		for(cnt=0;cnt<numteams;)
			{
			rand = (GameRandomNumber("team spawn",0) % NUMSPAWNLOCATIONS);

			if (locspawned[rand])
				continue;


			sx = SPAWNLOC[rand].x;
			sy = SPAWNLOC[rand].y;
			dir = SPAWNLOC[rand].dir;

			if (Number_of_Empty_Tiles_In_Area_Around(sx,sy) < TEAM[cnt].nummembers)
				{
				badcount ++;
				if (badcount == (NUMSPAWNLOCATIONS - cnt))
					Error("\n%s team cannot spawn in this level",colorname[TEAM[cnt].uniformcolor]);
				continue;
				}

			badcount = 0;
			//Debug("\n\nSpawn Location %d",rand);
			//Debug("\n-----------------");
			TEAM[cnt].tilex = sx;
			TEAM[cnt].tiley = sy;
			TEAM[cnt].dir = dir;
			locspawned[rand]=1;
			cnt++;

			}

		for(j=0;j<numplayers;j++)
			{
			teamindex = PLAYERSTATE[j].team;

			sx = TEAM[teamindex].tilex;
			sy = TEAM[teamindex].tiley;
			dir = TEAM[teamindex].dir;

			FindEmptyTile(&sx,&sy);

			//Debug("\n x: %3d, y: %3d",sx,sy);
			SpawnPlayerobj(sx,sy,dir,j);
			}


	}




//numplayers = 1;
//Error("Okay");
#if ((DEVELOPMENT == 1))
#if (TEAMTEST == 1)

	Debug("Team Spawn Location\n");
	Debug("-------------------\n");
	for(i=0;i<numteams;i++)
	Debug("%d	%3d,%3d\n",i,TEAM[i].tilex,TEAM[i].tiley);


	Debug("Player				Team			Location\n");
	Debug("------				----			--------\n");
	for(i=0;i<numplayers;i++)
	Debug("  %d				%d				%3d,%3d\n",i,PLAYERSTATE[i].team,PLAYER[i]->tilex,PLAYER[i]->tiley);

//  Error("done");
#endif
#endif

}


/*
==================
=
= SetupPlayers
=
==================
*/

void SetupPlayers( void )
{
	int	i,j;
	word	*map,tile;

	//START in icon plane = 10

	map = mapplanes[1];
	for(j=0;j<mapheight;j++)
		for(i=0;i<mapwidth;i++)
			{
			tile = *map++;

			if(rott_iswolf)
			{
				tile=RemapObjTile_Wolf(i, j, tile);
				if(tile<=0)
					continue;
			}

			switch (tile)
				{
				case 19:
				case 20:
				case 21:
				case 22:
					FIRST.x = i;
					FIRST.y = j;
					FIRST.dir = tile-19;
					SPAWNLOC[NUMSPAWNLOCATIONS].x  = i;
					SPAWNLOC[NUMSPAWNLOCATIONS].y  = j;
					SPAWNLOC[NUMSPAWNLOCATIONS].dir  = tile-19;
					if (NUMSPAWNLOCATIONS<MAXSPAWNLOCATIONS)
						NUMSPAWNLOCATIONS ++;
					break;

				case 274:
				case 275:
				case 276:
				case 277:
					SPAWNLOC[NUMSPAWNLOCATIONS].x  = i;
					SPAWNLOC[NUMSPAWNLOCATIONS].y  = j;
					SPAWNLOC[NUMSPAWNLOCATIONS].dir  = tile-274;
					if (NUMSPAWNLOCATIONS<MAXSPAWNLOCATIONS)
						NUMSPAWNLOCATIONS ++;
					break;
				}

			}

	if ( NUMSPAWNLOCATIONS <= 0 )
		{
		Error( "No spawn locations found on map." );
		}

	/*modemgame=true;
	gamestate.teamplay = true;
	PLAYERSTATE[0].uniformcolor = 2;
	PLAYERSTATE[1].uniformcolor = 2;
	numplayers = 2;
	AssignTeams();*/

	if (!BATTLEMODE)
		{
		if (tedlevel)
			{
			if ((tedx==0) || (tedy == 0))
				SpawnPlayerobj (FIRST.x, FIRST.y, FIRST.dir,0);
			else
				SpawnPlayerobj(tedx,tedy,FIRST.dir,0);
			}
		else
			SpawnPlayerobj(FIRST.x,FIRST.y,FIRST.dir,0);
		}

	else if (gamestate.teamplay == true)
	SetupTeams();

	else
		{
		int rand,cnt,locspawned[MAXSPAWNLOCATIONS]={0};
		int locsleft;

		locsleft=NUMSPAWNLOCATIONS;
		for(cnt=0;cnt<numplayers;)
			{rand = (GameRandomNumber("net player spawn",0) % NUMSPAWNLOCATIONS);
			if (locsleft==0)
				{
				int x,y;

				x=SPAWNLOC[rand].x;
				y=SPAWNLOC[rand].y;
				FindEmptyTile(&x,&y);
				SpawnPlayerobj(x,y,SPAWNLOC[rand].dir,cnt);
				cnt++;
				}
			else if (!locspawned[rand])
				{SpawnPlayerobj(SPAWNLOC[rand].x,SPAWNLOC[rand].y,SPAWNLOC[rand].dir,cnt);
				locspawned[rand]=1;
				locsleft--;
				cnt++;
				}
			}
		}

	if (gamestate.battlemode == battle_Tag)
	{int i;
		playertype *pstate;

		BATTLE_It = GameRandomNumber("tag choose",0) % numplayers;

		PLAYER[BATTLE_It]->flags |= FL_DESIGNATED;
		for(i=0;i<numplayers;i++)
		{M_LINKSTATE(PLAYER[i],pstate);

			if (i == BATTLE_It)
			{pstate->missileweapon = pstate->oldweapon = pstate->new_weapon =
				pstate->oldmissileweapon = pstate->weapon = wp_godhand;
				pstate->bulletweapon = -1;
			}
			else
			{pstate->missileweapon = pstate->oldweapon = pstate->new_weapon =
				pstate->oldmissileweapon = pstate->bulletweapon = pstate->weapon = -1;
			}
		}
	}

	PreCachePlayers();
}



/*
==================
=
= SetupMaskedWalls
=
==================
*/

void SetupMaskedWalls( void )
{
	int	i,j;
	word	*map,tile;

	map = mapplanes[0];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			tile = *map++;
			if ((tile >= 158) && (tile <= 160)) // Multi glassed walls
				{
				SpawnMaskedWall(i,j,mw_multi1+(tile-158),MW_MULTI|MW_BLOCKING|MW_BLOCKINGCHANGES|MW_SHOOTABLE);
				}
			else if ((tile >= 176) && (tile <= 178)) // Multi shot out glassed walls
				{
				SpawnMaskedWall(i,j,mw_multi1+(tile-176),MW_BOTTOMPASSABLE);
				}
			else if ((tile >= 162) && (tile <= 171))
				{
				switch (tile)
					{
					case 162:
						SpawnMaskedWall(i,j,mw_normal1,MW_SHOOTABLE|MW_BLOCKING);
						break;
					case 163:
						SpawnMaskedWall(i,j,mw_normal1,MW_BLOCKING);
						break;
					case 164:
						SpawnMaskedWall(i,j,mw_normal2,MW_SHOOTABLE|MW_BLOCKING);
						break;
					case 165:
						SpawnMaskedWall(i,j,mw_normal2,MW_BLOCKING);
						break;
					case 166:
						SpawnMaskedWall(i,j,mw_normal3,MW_SHOOTABLE|MW_BLOCKING);
						break;
					case 167:
						SpawnMaskedWall(i,j,mw_normal3,MW_BLOCKING);
						break;
					case 168:
						SpawnMaskedWall(i,j,mw_singlepane,MW_SHOOTABLE|MW_BLOCKINGCHANGES|MW_BLOCKING);
						break;
					case 169:
						SpawnMaskedWall(i,j,mw_singlepane,MW_BOTTOMPASSABLE);
						break;
					case 170:
						SpawnMaskedWall(i,j,mw_dogwall,MW_NONDOGBLOCKING|MW_WEAPONBLOCKING);
						break;
					case 171:
						SpawnMaskedWall(i,j,mw_peephole,MW_WEAPONBLOCKING|MW_BLOCKING);
						break;
					}
				}
			else if (tile == 172)
				SpawnMaskedWall(i,j,mw_exitarch,MW_BOTTOMPASSABLE);
			else if (tile == 173)
				SpawnMaskedWall(i,j,mw_secretexitarch,MW_BOTTOMPASSABLE);
			else if (tile == 174) // entry gate
				SpawnMaskedWall(i,j,mw_entrygate,MW_BLOCKING);
			else if (tile == 157) // hi switch off
				SpawnMaskedWall(i,j,mw_hiswitchoff,MW_BLOCKING);
			else if (tile == 175) // hi switch on
				SpawnMaskedWall(i,j,mw_hiswitchon,MW_BLOCKING|MW_SWITCHON);
			else if (tile == 179) // railing;
				SpawnMaskedWall(i,j,mw_railing,MW_ABOVEPASSABLE|MW_MIDDLEPASSABLE);
//			else if (tile == 161) // pillar
//				SpawnMaskedWall(i,j,mw_pillar,MW_BLOCKING);
			}
		}
	for (j=0;j<mapheight;j++)
		for(i=0;i<mapwidth;i++)
			{
			if (IsPlatform(i,j)) // tall platform in icon plane
				{
				if ((MAPSPOT(i,j,0)-AREATILE>=0) || (MAPSPOT(i,j,0)==21))
					// check to see we are not on a wall
					{
					int which;

					which=MAPSPOT(i,j,2)-4;
					switch (which)
						{
						case 0:
							SpawnMaskedWall(i,j,mw_platform1,MW_BOTTOMPASSABLE|MW_MIDDLEPASSABLE);
							break;
						case 1:
							SpawnMaskedWall(i,j,mw_platform2,MW_ABOVEPASSABLE|MW_MIDDLEPASSABLE);
							break;
						case 2:
							SpawnMaskedWall(i,j,mw_platform3,MW_MIDDLEPASSABLE);
							break;
						case 3:
							SpawnMaskedWall(i,j,mw_platform4,MW_BOTTOMPASSABLE);
							break;
						case 4:
							SpawnMaskedWall(i,j,mw_platform5,MW_BOTTOMPASSABLE|MW_ABOVEPASSABLE);
							break;
						case 5:
							SpawnMaskedWall(i,j,mw_platform6,MW_ABOVEPASSABLE);
							break;
						case -3:
							SpawnMaskedWall(i,j,mw_platform7,MW_ABOVEPASSABLE);
							break;
						default:
							Error ("Illegal Maskedwall platform value at x=%ld y=%ld\n",i,j);
							break;
						}
#if 0
					if (IsPlatform(i+1,j))
						{
						if ( (IsPlatform(i,j+1)) || (IsPlatform(i,j-1)) )
							SpawnStatic(i,j,83,MAPSPOT(i,j,2));
						}
					else if (IsPlatform(i-1,j))
						{
						if ( (IsPlatform(i,j+1)) || (IsPlatform(i,j-1)) )
							SpawnStatic(i,j,83,MAPSPOT(i,j,2));
						}
#endif
					}
				else
					Error("You have what appears to be a platform ontop\n a wall at x=%ld y=%ld\n",i,j);
				}
			}
}

/*
int GetAreaNumber ( int tilex, int tiley, int dir );
void RemoveDangerWalls
	(
	void
	)

	{
	int	i;
	int	j;
	word *map;
	word  tile;

	map = mapplanes[ 1 ];

	for( j = 0; j < mapheight; j++ )
		{
		for( i = 0; i < mapwidth; i++ )
			{
			tile = *map++;
			switch( tile )
				{
				case 256:
				case 257:
				case 258:
				case 259:
					if ( MAPSPOT( i, j, 2 ) == 0 )
						{
						MAPSPOT( i, j, 0 ) = ( word )( GetAreaNumber( i, j,
							( tile - 256 ) << 1 ) + AREATILE );
						MAPSPOT( i, j, 1 ) = 0;
						}
					break;

				case 300:
				case 318:
				case 336:
				case 354:
					if ( MAPSPOT( i, j, 2 ) == 0 )
						{
						MAPSPOT( i, j, 0 ) = ( word )( GetAreaNumber( i, j,
							( ( tile - 300 ) / 9 ) + AREATILE ) );
						MAPSPOT( i, j, 1 ) = 0;
						}
					break;
				}
			}
		}
	}
*/


/*
==================
=
= SetupPushWalls
=
==================
*/

void SetupPushWalls( void )
{
	int	i,j;
	word	*map,tile;
	int	temp;

	map = mapplanes[1];
	for(j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			tile = *map++;

			if(rott_iswolf)
			{
				tile=RemapObjTile_Wolf(i, j, tile);
				if(tile<=0)
					continue;
			}

			switch(tile)
				{
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
					if (tilemap[i][j] && ActorIsWall(i,j))
						{
						temp=tilemap[i][j]&0x1fff;
						tilemap[i][j] = pwallnum;
						if (MAPSPOT(i,j,2))
							SpawnPushWall(i,j,1,temp,tile-72,0);
						else
							SpawnPushWall(i,j,0,temp,tile-72,0);
						}
					break;

				case 80: //OldPushWall
					if (tilemap[i][j])
						{
						temp=tilemap[i][j]&0x1fff;
						tilemap[i][j] = pwallnum;
						if (MAPSPOT(i,j,2))
							Error("You cannot link a pushwall which has no direction associated\n with it at x=%ld y=%ld\n",i,j);
						else
							SpawnPushWall(i,j,0,temp,nodir,0);
						}
					break;

				case 256:
				case 257:
				case 258:
				case 259:
					if(rott_iswolf)
						break;
				
					if (tilemap[i][j])
						{
						temp=tilemap[i][j]&0x1fff;
						tilemap[i][j] = pwallnum;
						if (MAPSPOT(i,j,2))
							SpawnPushWall(i,j,0,temp,(tile-256)<<1,2);
						else
							SpawnPushWall(i,j,0,temp,(tile-256)<<1,4);
						}
					else
						Error("You have to place a turbomovewall icon on a wall at x=%d y=%d",i,j);
					break;

				case 300:
				case 318:
				case 336:
				case 354:
					if(rott_iswolf)
						break;

					if (tilemap[i][j])
						{
						temp=tilemap[i][j]&0x1fff;
						tilemap[i][j] = pwallnum;
						if (MAPSPOT(i,j,2))
							SpawnPushWall(i,j,0,temp,(tile-300)/9,1);
						else
								SpawnPushWall(i,j,0,temp,(tile-300)/9,3);
						}
					else
						Error("You have to place a movewall icon on a wall at x=%d y=%d",i,j);
					break;
				}
			}
		}
}


/*
==================
=
= GetPushWallNumber
=
==================
*/

int GetPushWallNumber( int tx, int ty )
{
	int i;

	for (i=0;i<pwallnum;i++)
		if ( (pwallobjlist[i]->tilex==tx) && (pwallobjlist[i]->tiley==ty))
			return i;
	Error ("Could not find a push wall at x=%ld y=%ld\n",tx,ty);
	return -1;
}


/*
==================
=
= SetupPushWallLinks
=
==================
*/
void SetupPushWallLinks( void )
{
	int	i,j;
	word	*map,tile;
	word  touchx,touchy;

	map = mapplanes[1];
	for(j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			tile = *map++;

			if(rott_iswolf)
			{
				tile=RemapObjTile_Wolf(i, j, tile);
				if(tile<=0)
					continue;
			}

			switch(tile)
				{
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
					if (ActorIsPushWall(i,j))
						{
						if (MAPSPOT(i,j,2))
							{
							touchx = (word) ((MAPSPOT(i,j,2) >> 8) & 0xff);
							touchy = (word) ((MAPSPOT(i,j,2) >> 0) & 0xff);
							if (touchindices[touchx][touchy])
								{
								if (MAPSPOT(i,j+1,2)!=0)
									{
#if (DEVELOPMENT == 1)
									SoftError("MAPWARNING:You left a delay for a linked push wall under the pushwall\n at x=%ld y=%ld\n",i,j);
#endif
									}
								Link_To_Touchplate(touchx,touchy,
									ActivatePushWall,NULL,
									GetPushWallNumber(i,j),0);
								}
							else
								Error("tried to link a pushwall at x=%ld y=%ld to a non-existent touchplate\n",i,j);
							}
						}
					break;

				case 80:
					if (ActorIsPushWall(i,j))
						{
						if (MAPSPOT(i,j,2))
							{
							Error("You shouldn't be linking a nondirectional-push wall at x=%ld y=%ld\n",i,j);
							}
						}
					break;
				case 256:
				case 257:
				case 258:
				case 259:
					if (ActorIsPushWall(i,j))
						{
						if (MAPSPOT(i,j,2))
							{
							touchx = (word) ((MAPSPOT(i,j,2) >> 8) & 0xff);
							touchy = (word) ((MAPSPOT(i,j,2) >> 0) & 0xff);
							if (touchindices[touchx][touchy])
								{
								if (MAPSPOT(i,j+1,2)!=0)
									{
#if (DEVELOPMENT == 1)
									SoftError("MAPWARNING:You left a delay for a linked push wall under the pushwall\n at x=%ld y=%ld\n",i,j);
#endif
									}
								Link_To_Touchplate(touchx,touchy,
									ActivateMoveWall,NULL,
									GetPushWallNumber(i,j),0);
								}
							else
								Error("tried to link a turbomovewall at x=%ld y=%ld to a non-existent touchplate\n",i,j);
							}
						}
					break;

				case 300:
				case 318:
				case 336:
				case 354:
					if (ActorIsPushWall(i,j))
						{
						if (MAPSPOT(i,j,2))
							{
							touchx = (word) ((MAPSPOT(i,j,2) >> 8) & 0xff);
							touchy = (word) ((MAPSPOT(i,j,2) >> 0) & 0xff);
							if (touchindices[touchx][touchy])
								{
								if (MAPSPOT(i,j+1,2)!=0)
									{
#if (DEVELOPMENT == 1)
									SoftError("MAPWARNING:You left a delay for a linked push wall under the pushwall\n at x=%ld y=%ld\n",i,j);
#endif
									}
								Link_To_Touchplate(touchx,touchy,
									ActivateMoveWall,NULL,
									GetPushWallNumber(i,j),0);
								}
							else
								Error("tried to link a movewall at x=%ld y=%ld to a non-existent touchplate\n",i,j);
							}
						}
					break;
				}
			}
		}
}

/*
=================
=
= SetupElevators
=
=================
*/

void SetupElevators (void)
{
	int j, i,x,y,starti;
	word *map;
	word tile;
	elevator_t *elev;
	doorobj_t* dptr;

	if(rott_iswolf)
		return;

	map = mapplanes[1];
	map += 4 ;

	for (j = 0; j < mapheight; j++)
	{
		if (j == 0)
			starti = 4;
		else
			starti = 0;

		for (i = starti; i < mapwidth; i++)
		{
			tile = *map++;

			if ((tile > 89) && (tile < 98))
			{
				elev = &ELEVATOR[tile-90];
				if (!elev->sx)
				{
					elev->sx = i;
					elev->sy = j;
					elev->doortoopen = -1;
					elev->doorclosing = -1;
					elev->nextaction = -1;
					_numelevators ++;
				}
				else
				{
					elev->dx = i;
					elev->dy = j;
				}
			}
		}
	}

	if (_numelevators && (!ELEVATOR[0].sx))
		Error("Elevators must start at 1, dumb ass.");

	for(i=0;i<_numelevators;i++)
	{
		elev = &ELEVATOR[i];
		x = elev->sx;
		y = elev->sy;
		for(j=0;j<doornum;j++)
		{
			dptr = doorobjlist[j];
			if (((dptr->tilex == (x+1)) && (dptr->tiley == y)) ||
				((dptr->tilex == (x-1)) && (dptr->tiley == y)) ||
				((dptr->tilex == x) && (dptr->tiley == (y+1))) ||
				((dptr->tilex == x) && (dptr->tiley == (y-1))))
			{
				elev->door1 = j;
				dptr->eindex = i;
				if ((dptr->tilex == (x+1)) && (dptr->tiley == y))
				{
					elev->esx = x-1;
					elev->esy = y;
				}
				else if ((dptr->tilex == (x-1)) && (dptr->tiley == y))
				{
					elev->esx = x+1;
					elev->esy = y;
				}
				else if ((dptr->tilex == x) && (dptr->tiley == (y+1)))
				{
					elev->esx = x;
					elev->esy = y-1;
				}
				else if ((dptr->tilex == x) && (dptr->tiley == (y-1)))
				{
					elev->esx = x;
					elev->esy = y+1;
				}
				break;
			}
		}

		x = elev->dx;
		y = elev->dy;
		for(j=0;j<doornum;j++)
		{
			dptr = doorobjlist[j];
			if (((dptr->tilex == (x+1)) && (dptr->tiley == y)) ||
				((dptr->tilex == (x-1)) && (dptr->tiley == y)) ||
				((dptr->tilex == x) && (dptr->tiley == (y+1))) ||
				((dptr->tilex == x) && (dptr->tiley == (y-1))))
			{
				elev->door2 = j;
				dptr->eindex = i;
				dptr->flags |= DF_ELEVLOCKED;
				if ((dptr->tilex == (x+1)) && (dptr->tiley == y))
				{
					elev->edx = x-1;
					elev->edy = y;
				}
				else if ((dptr->tilex == (x-1)) && (dptr->tiley == y))
				{
					elev->edx = x+1;
					elev->edy = y;
				}
				else if ((dptr->tilex == x) && (dptr->tiley == (y+1)))
				{
					elev->edx = x;
					elev->edy = y-1;
				}
				else if ((dptr->tilex == x) && (dptr->tiley == (y-1)))
				{
					elev->edx = x;
					elev->edy = y+1;
				}
				break;
			}

		}
	}
	#if ((DEVELOPMENT == 1))
	#if ((ELEVATORTEST == 1))
	for(i=0;i<_numelevators;i++)
		Debug("\nelevator %d door1 %2d, door2 %2d",i,ELEVATOR[i].door1,ELEVATOR[i].door2);
	#endif
	#endif
}


/*
=================
=
= SetupDoors
=
=================
*/

void SetupDoors (void)
{
	int j, i;
	word *map;
	word tile;
	byte locked;

	map = mapplanes[0];

	for (j = 0; j < mapheight; j++)
		for (i = 0; i < mapwidth; i++)
		{
			tile = *map++;
			
			if(rott_iswolf)
			{

				if( (tile >= 0x5A) && (tile <= 0x5F) )
				{
					tilemap[i][j] = doornum;

					locked=0;
//					if (MAPSPOT (i, j, 2))
//						locked = 5;

					if((tile == 0x5C) || (tile == 0x5D))
						locked = 1;
					if((tile == 0x5E) || (tile == 0x5F))
						locked = 2;

//					SpawnDoor (i, j, locked, tile-90);
					SpawnDoor (i, j, locked, 4);

					continue;
				}
				
				if((tile == 0x64) || (tile == 0x65))
				{
					tilemap[i][j] = doornum;

					locked=0;
//					if (MAPSPOT (i, j, 2))
//						locked = 5;

//					SpawnDoor (i, j, locked, tile-90);
					SpawnDoor (i, j, locked, 6);

					continue;
				}
			}
			

			if ((tile >= 33) && (tile <= 35))
			{
				tilemap[i][j] = doornum;

				locked=0;
				if (MAPSPOT (i, j, 2))
					locked = 5;

				SpawnDoor (i, j, locked, (tile-33)+15);
			}

			else if ((tile > 89) && (tile < 94))
			{
				tilemap[i][j] = doornum;

				locked = 0;
				if (MAPSPOT (i, j, 2))
					locked = 5;

				SpawnDoor (i, j, locked, tile-90);
			}

			else if ((tile > 93) && (tile < 98))
			{
				Error("locked door %d being used at %d,%d",tile,i,j);
			}


			else if ((tile > 97) && (tile < 105))
			{
				tilemap[i][j] = doornum;

				locked = 0;
				if (MAPSPOT (i, j, 2))
					locked = 5;

				SpawnDoor (i, j, locked, tile-90);
			}
			else if ((tile >= 154) && (tile <= 156))
			{
				tilemap[i][j] = doornum;

				locked=0;
				if (MAPSPOT (i, j, 2))
					locked = 5;

				SpawnDoor (i, j, locked, (tile-154)+18);
			}
		}
}

/*
==================
=
= GetDoorNumber
=
==================
*/

int GetDoorNumber( int tx, int ty )
{
	int i;

	for (i=0;i<doornum;i++)
		if ( (doorobjlist[i]->tilex==tx) && (doorobjlist[i]->tiley==ty))
			return i;
	Error ("Could not find a door at x=%ld y=%ld\n",tx,ty);
	return -1;
}

/*
=================
=
= SetupDoorLinks
=
=================
*/

void SetupDoorLinks (void)
{
	int  j,
		i,
		k;
	word *map;
	int  clocklinked;
	int  clockx,clocky;
	int  doornumber;
	word touchx,
		tile,
		touchy;

	map = mapplanes[0];

	for (j = 0; j < mapheight; j++)
		for (i = 0; i < mapwidth; i++)
		{
			tile = *map++;

			if (MAPSPOT (i, j, 2))
			{
				if (IsDoor(i,j)==1)
				{
					clocklinked = 0;

					doornumber=GetDoorNumber(i,j);

					for (k = 0; k < numclocks; k++)
					{
						clockx = Clocks[k].points_to_tilex;
						clocky = Clocks[k].points_to_tiley;

						if ((clockx == i) && (clocky == j))
						{
							clocklinked = 1;
							ClockLink (LinkedOpenDoor, LinkedCloseDoor, doornumber, k);
							doorobjlist[doornumber]->lock	= 5;
							doorobjlist[doornumber]->flags |= DF_TIMED;
						}
					}

					if (!clocklinked)
					{
						touchx = (word) ((MAPSPOT (i, j, 2) >> 8) & 0xff);
						touchy = (word) ((MAPSPOT (i, j, 2) >> 0) & 0xff);

						if (touchindices[touchx][touchy])
						{
							if (MAPSPOT (i, j, 1) == 192)
								Link_To_Touchplate (touchx, touchy, 
									LinkedCloseDoor,
									LinkedCloseDoor, doornumber, 0);
							else
								Link_To_Touchplate (touchx, touchy, 
									LinkedOpenDoor,
									LinkedOpenDoor, doornumber, 0);
						}
						else
							Error ("tried to link a door at x=%ld y=%ld to a non-existent touchplate",i,j);
					}
				}
			}
		}
}


/*
=================
=
= FindTimeTile
=
=================
*/
void FindTimeTile ( int * x, int * y )
{
	int xx,yy;

	xx=*x;
	yy=*y;

	if (!(tilemap[xx+1][yy]) && MAPSPOT(xx+1,yy,2))
	{
	*x=xx+1;
	return;
	}
	if (!(tilemap[xx-1][yy]) && MAPSPOT(xx-1,yy,2))
	{
	*x=xx-1;
	return;
	}
	if (!(tilemap[xx][yy+1]) && MAPSPOT(xx,yy+1,2))
	{
	*y=yy+1;
	return;
	}
	if (!(tilemap[xx][yy-1]) && MAPSPOT(xx,yy-1,2))
	{
	*y=yy-1;
	return;
	}
	Error ("Could not find an end time for a clock linked item\nat x=%ld y=%ld\n",*x,*y);
}



/*
=================
=
= SetupClocks
=
=================
*/

void SetupClocks (void)
{
	int  i,
		j,
		minutes,
		seconds,
		starti;
	word *map,
		tile,
		mapx,
		mapy;
	int  endtimex,
		endtimey;

//	if(rott_iswolf)
//		return;

	map  = mapplanes[1];
	map += 4 ;

	for (j = 0; j < mapheight; j++)
	{
		if (j == 0)
			starti = 4;
		else
			starti = 0;

		for (i = starti; i < mapwidth; i++)
		{
			tile = *map++;

			if(rott_iswolf)
			{
				tile=RemapObjTile_Wolf(i, j, tile);
				if(tile<=0)
					continue;
			}


			if (tile == 121)
			{
				mapx = (word) ((MAPSPOT (i, j, 2) >> 8) & 0xff);
				mapy = (word) ((MAPSPOT (i, j, 2) >> 0) & 0xff);

				minutes = (int) ((MAPSPOT (mapx, mapy, 2) >> 8) & 0xff);
				seconds = (int) ((MAPSPOT (mapx, mapy, 2) >> 0) & 0xff);

				if (seconds > 0x59)
					Error ("seconds of clock time must be below 0x5a (60 secs) ");

				seconds = 10 * (seconds/16) + (seconds % 16);
				minutes = 60 * (10*(minutes/16) + (minutes % 16));

				// total seconds
				Clocks[numclocks].time1 = VBLCOUNTER*(seconds + minutes);

				endtimex=mapx;
				endtimey=mapy;

				FindTimeTile (&endtimex, &endtimey);

				minutes = (int) ((MAPSPOT (endtimex, endtimey, 2) >> 8) & 0xff);
				seconds = (int) ((MAPSPOT (endtimex, endtimey, 2) >> 0) & 0xff);

				if (seconds > 0x59)
						Error("seconds of clock time must be below 0x5a (60 secs)");

				seconds = 10 * (seconds/16) + (seconds % 16);
				minutes = 60 * (10*(minutes/16) + (minutes % 16));

				// total seconds
				Clocks[numclocks].time2 = VBLCOUNTER * (seconds + minutes);
				Clocks[numclocks].points_to_tilex = mapx;
				Clocks[numclocks].points_to_tiley = mapy;
				Clocks[numclocks].linkindex		= lasttouch;

				numclocks ++;

				// clocks treated as virtual touchplates
				lasttouch ++;
			}
		}
	}
}



/*
=================
=
= LinkElevatorDiskGroups
=
=================
*/

void LinkElevatorDiskGroups(void)
	{
	objtype *diskfinder1,*temp,*master;
	int maxplatformheight[30]={-1};
	int num_distinct_max_heights=0;
	int i;
	boolean newdiskheight;


	#define M_ISELEVDISK(actor) \
	((actor->obclass == diskobj) && (actor->state == &s_elevdisk))



	for(diskfinder1 = FIRSTACTOR;diskfinder1;diskfinder1 = diskfinder1->next)
		{
		if (!M_ISELEVDISK(diskfinder1))
			continue;

		newdiskheight = true;
		for(i=0;i<num_distinct_max_heights;i++)
			{
			if (maxplatformheight[i] == diskfinder1->temp2)
				{
				newdiskheight = false;
				break;
				}
			}

		if (newdiskheight == true)
			maxplatformheight[num_distinct_max_heights++] = diskfinder1->temp2;

		}


	for(i=0;i<num_distinct_max_heights;i++)
		{

		SpawnDisk(64,64,0,true);
		master = new;
		master->temp2 = maxplatformheight[i];

		for(temp = FIRSTACTOR;temp;temp = temp->next)
			{
			if (temp == master)
				continue;

			if (!M_ISELEVDISK(temp))
				continue;

			if (temp->temp2 != maxplatformheight[i])
				continue;

			temp->target = master;
			SetTilePosition(master,temp->tilex,temp->tiley);
			master->areanumber=AREANUMBER(master->tilex,master->tiley);

			}
		master->flags |= FL_ABP;
		MakeActive(master);
		}


	}


/*
=================
=
= LinkActor
=
=================
*/


void LinkActor (objtype *ob,int tilex,int tiley,
					void (*action)(int),void (*swapaction)(int)
					)
	{
	word  touchx,touchy;
	int	clockx,clocky;
	int	clocklinked,k;
	wall_t * tswitch;


	clocklinked = 0;
	for(k=0;k<numclocks;k++)
		{
		clockx = Clocks[k].points_to_tilex;
		clocky = Clocks[k].points_to_tiley;
		if ((clockx == tilex) && (clocky == tiley))
			{
			clocklinked = 1;
			ClockLink(EnableObject,DisableObject,(nlint)ob,k);
			}
		}

	if (!clocklinked)
		{
		touchx = (word) ((MAPSPOT(tilex,tiley,2) >> 8) & 0xff);
		touchy = (word) ((MAPSPOT(tilex,tiley,2) >> 0) & 0xff);
		if ((MISCVARS->TOMLOC.x == touchx) && (MISCVARS->TOMLOC.y == touchy))
			{
			objtype *tom = (objtype*)actorat[touchx][touchy];
			tom->whatever = ob;
			}

		else if (touchindices[touchx][touchy])
			{
			tswitch = (wall_t*) actorat[touchx][touchy];

			if (tswitch && (ob->obclass == wallfireobj))
				{
				tswitch->flags |= FL_REVERSIBLE;
				if (tswitch->flags & FL_ON)
					ob->flags |= FL_ACTIVE;
				}


			if (tswitch && (tswitch->flags & FL_ON))
//				Link_To_Touchplate(touchx,touchy,swapaction,action,(nlint)ob,0);
				Link_To_Touchplate(touchx,touchy,swapaction,action,
					T_SwizzleObjtypeToInt(ob),0);
			else
//				Link_To_Touchplate(touchx,touchy,action,swapaction,(nlint)ob,0);
				Link_To_Touchplate(touchx,touchy,action,swapaction,
					T_SwizzleObjtypeToInt(ob),0);
			if (ob->obclass == gasgrateobj)
				{
				ob->temp1 = touchx;
				ob->temp2 = touchy;
				}
			}
		else
			Error("tried to link an object at x=%ld y=%ld to a non-existent touchplate supposedly at x=%ld y=%ld",tilex,tiley,touchx,touchy);
		}

	if (tilemap[tilex][tiley])
		(MAPSPOT(tilex,tiley,2))=21;
	}




/*
======================
=
= SetupInanimateActors
=
======================
*/


void SetupInanimateActors (void)
	{
	int	i,j,linked;
	word	*map,tile;
	void (*action)(int),(*swapaction)(int);


	map = mapplanes[1];


	// non-linked, harmless inanimate actors
	for(j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			tile = *map++;

			if(rott_iswolf)
			{
				tile=RemapObjTile_Wolf(i, j, tile);
				if(tile<=0)
					continue;
			}

			switch(tile)
				{

				case 193:
					SpawnSpring(i,j);
					break;

#if 0
				case 460:
//					if ( gamestate.Product != ROTT_SHAREWARE )
						{
						SpawnNewObj(i,j,&s_wind,inertobj);
						}
					break;
#endif

				case 462:
				case 463:
				case 464:
				case 465:
				case 466:

					SpawnDisk(i,j,tile-462,false);
					break;

				case 285:
				case 286:
				case 287:
					SpawnPushColumn(i,j,tile-285,nodir,0);
					break;
				}
			}
		}


	// linked, harmless actors
	map = mapplanes[1];
	for(j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			tile = *map++;
			action = EnableObject;
			swapaction = DisableObject;
			linked = (MAPSPOT(i,j,2) && (!IsPlatform(i,j)));

			if(rott_iswolf)
			{
				tile=RemapObjTile_Wolf(i, j, tile);
				if(tile<=0)
					continue;
			}

			switch(tile)
				{

				case 140:
				case 141:
				case 142:
				case 143:

					if ((!BATTLEMODE) || (gamestate.BattleOptions.SpawnDangers))
						{
						PreCacheActor(wallfireobj,0);
						SpawnWallfire(i,j,tile-140);
						if (!linked)
							{
							new->flags |= FL_ACTIVE;
							if (tilemap[i][j])
								MAPSPOT(i,j,2) = 21;
							}
						else
							LinkActor(new,i,j,action,swapaction);
						}
					else if (tilemap[i][j])
						MAPSPOT(i,j,2) = 21;

					break;

				case 303:
				case 304:
				case 305:
					SpawnPushColumn(i,j,tile-303,east,linked);
					swapaction = NULL;
					if (linked)
						LinkActor(new,i,j,action,swapaction);

					break;

				case 321:
				case 322:
				case 323:
					SpawnPushColumn(i,j,tile-321,north,linked);
					swapaction = NULL;
					if (linked)
						LinkActor(new,i,j,action,swapaction);

					break;

				case 339:
				case 340:
				case 341:
					SpawnPushColumn(i,j,tile-339,west,linked);
					swapaction = NULL;
					if (linked)
						LinkActor(new,i,j,action,swapaction);

					break;

				case 357:
				case 358:
				case 359:
					SpawnPushColumn(i,j,tile-357,south,linked);
					swapaction = NULL;
					if (linked)
						LinkActor(new,i,j,action,swapaction);

					break;

				}

			}
		}

	//harmful actors

	if ((!BATTLEMODE) || (gamestate.BattleOptions.SpawnDangers))
		{
		map = mapplanes[1];
		for(j=0;j<mapheight;j++)
			{
			for(i=0;i<mapwidth;i++)
				{
				tile = *map++;
				action = EnableObject;
				swapaction = DisableObject;
				linked = (MAPSPOT(i,j,2) && (!IsPlatform(i,j)));

				if(rott_iswolf)
				{
					tile=RemapObjTile_Wolf(i, j, tile);
					if(tile<=0)
						continue;
				}

				switch(tile)
					{
					case 89:
						SpawnFourWayGun(i,j);
						break;


					case 156:
					case 157:
						SpawnBlade(i,j,nodir,0,tile-156);
						if (linked)
							LinkActor(new,i,j,action,swapaction);

						break;

					case 174:
					case 175:
						SpawnBlade(i,j,nodir,1,tile-174);
						if (linked)
							LinkActor(new,i,j,action,swapaction);

						break;



					case 412:
						SpawnSpear(i,j,0);
						break;

					case 430:
						SpawnSpear(i,j,1);
						break;

					case 413:
						SpawnCrushingColumn(i,j,1); //down
						break;

					case 431:
						SpawnCrushingColumn(i,j,0); // up
						break;


					case 192:
						if (!tilemap[i][j])
							{
							SpawnNewObj(i,j,&s_gas1,gasgrateobj);
							PreCacheActor(gasgrateobj,0);
							new->flags |= FL_ABP;
							MakeActive(new);
							swapaction = NULL;
							if (linked)
								LinkActor(new,i,j,action,swapaction);

							}
						break;


					case 301:
					case 302:
						SpawnBlade(i,j,east,tile-301,0);
						if (!linked)
							new->flags |= FL_ACTIVE;
						else
							LinkActor(new,i,j,action,swapaction);

						break;

					case 319:
					case 320:
						SpawnBlade(i,j,north,tile-319,0);
						if (!linked)
							new->flags |= FL_ACTIVE;
						else
							LinkActor(new,i,j,action,swapaction);

						break;

					case 337:
					case 338:
						SpawnBlade(i,j,west,tile-337,0);
						if (!linked)
							new->flags |= FL_ACTIVE;
						else
							LinkActor(new,i,j,action,swapaction);

						break;

					case 355:
					case 356:
						SpawnBlade(i,j,south,tile-355,0);
						if (!linked)
							new->flags |= FL_ACTIVE;
						else
							LinkActor(new,i,j,action,swapaction);

						break;

					case 372:
						SpawnFirejet(i,j,nodir,0);
						break;

					case 373:
					case 374:
					case 375:
					case 376:
						SpawnFirejet(i,j,tile-373,0);
						break;

					case 390:
						SpawnFirejet(i,j,nodir,1);
						break;

					case 391:
					case 392:
					case 393:
					case 394:
						SpawnFirejet(i,j,tile-391,1);
						break;

					case 278:
					case 279:
					case 280:
					case 281:
						SpawnBoulder(i,j,tile-278);
						if (!linked)
							new->flags |= FL_ACTIVE;
						else
							LinkActor(new,i,j,action,swapaction);

						break;

					}


				}
			}
		}

	LinkElevatorDiskGroups();

	}


/*
===================
=
= FixTiles
=
===================
*/

void FixTiles(void)
{
	word *map,tile;
	int i,j;

	map = mapplanes[1];
	for(j=0;j<mapheight;j++)
	{
		for(i=0;i<mapwidth;i++)
		{
			tile = *map++;

			if(rott_iswolf)
			{
				tile=RemapObjTile_Wolf(i, j, tile);
				if(tile<=0)
					continue;
			}

			switch(tile)
			{
				case 140:
				case 141:
				case 142:
				case 143:
				case 192:
				case 278:
				case 279:
				case 280:
				case 281:
					if (tilemap[i][j])
						(MAPSPOT(i,j,2))=21;
					break;
			}
		}
	}
}


void Illuminate(void)
{
	statobj_t*temp;

	if (lightsource==0)
	return;
	for(temp=FIRSTSTAT;temp;temp=temp->statnext)
	if (temp->flags & FL_LIGHTON)
	TurnOnLight(temp->tilex,temp->tiley);
}


/*
=================
=
= SetupLights
=
=================
*/

void SetupLights(void)
{
	int i,j,touchx,touchy;
	wall_t *tswitch;
	word *map,tile;
	int starti;

// Initialize Lights in Area

	memset(LightsInArea,0,sizeof(LightsInArea));

	map = mapplanes[1];
	map+=5;

	for (j=0;j<mapheight;j++)
		{
		if (j==0)
			starti=5;
		else
			starti=0;
		for(i=starti;i<mapwidth;i++)
			{
			tile= *map++;

			if(rott_iswolf)
			{
//				SetupLights_Wolf(i, j, tile);
//				continue;
				tile=RemapObjTile_Wolf(i, j, tile);
				if(tile<=0)
					continue;
			}


			switch (tile)
				{

				// Add light sourcing to these objects

				case 23:
				case 24:
				case 25:
				case 26:
				case 27:
				case 42:
				case 63:
				case 64:
					sprites[i][j]->flags |= FL_LIGHTON;
					break;

				case 28:
				case 43:
					if (MAPSPOT(i,j,2))
					{
						touchx = (word) ((MAPSPOT(i,j,2) >> 8) & 0xff);
						touchy = (word) ((MAPSPOT(i,j,2) >> 0) & 0xff);
						tswitch = (wall_t*) actorat[touchx][touchy];

						if (tswitch && (tswitch->which == WALL))
							{tswitch->flags |= FL_REVERSIBLE;
							if (!(tswitch->flags & FL_ON))
								{sprites[i][j]->shapenum --;
								if (touchindices[touchx][touchy])
									{
										Link_To_Touchplate(touchx,touchy,
											ActivateLight,DeactivateLight,
											T_SwizzleStatObjToInt(sprites[i][j]),0);
									sprites[i][j]->linked_to = touchindices[touchx][touchy]-1;
									}
								else
									Error("tried to link a light at x=%ld y=%ld to a non-existent touchplate",i,j);
								}
							else
							{
								if (touchindices[touchx][touchy])
								{
									Link_To_Touchplate(touchx,touchy,
										DeactivateLight,ActivateLight,
										T_SwizzleStatObjToInt(sprites[i][j]),0);
									sprites[i][j]->linked_to = touchindices[touchx][touchy]-1;
								}
								else
									Error("tried to link a light at x=%ld y=%ld to a non-existent touchplate",i,j);
								sprites[i][j]->flags |= FL_LIGHTON;
							}
						}
					else
						{if (touchindices[touchx][touchy])
							{Link_To_Touchplate(touchx,touchy,
								DeactivateLight,ActivateLight,
								T_SwizzleStatObjToInt(sprites[i][j]),0);
							sprites[i][j]->linked_to = touchindices[touchx][touchy]-1;
							}
						else
							Error("tried to link a light at x=%ld y=%ld to a non-existent touchplate",i,j);
						sprites[i][j]->flags |= FL_LIGHTON;
						}

					}
				else
					sprites[i][j]->flags |= FL_LIGHTON;

				break;
				}
			}
		}
}

/*
==================
=
= PrintMapStats
=
==================
*/
void PrintMapStats (void)
{
	int size;
	int total;

	if (MAPSTATS==false)
		return;

	OpenMapDebug();

	total=0;
	MapDebug("MAP STATS Map Number %ld\n",gamestate.mapon);
	MapDebug("=======================\n");
	size=pwallnum*sizeof(pwallobj_t);
	total+=size;
	MapDebug("Number of PushWalls	: %4ld size = %6ld\n",pwallnum,size);
	size=maskednum*sizeof(maskedwallobj_t);
	total+=size;
	MapDebug("Number of MaskedWalls : %4ld size = %6ld\n",maskednum,size);
	size=doornum*sizeof(doorobj_t);
	total+=size;
	MapDebug("Number of Doors		: %4ld size = %6ld\n",doornum,size);
	size=lasttouch*sizeof(touchplatetype);
	total+=size;
	MapDebug("Number of TouchPlates : %4ld size = %6ld\n",lasttouch,size);
	size=_numelevators*sizeof(elevator_t);
	total+=size;
	MapDebug("Number of Elevators	: %4ld size = %6ld\n",_numelevators,size);
	size=statcount*sizeof(statobj_t);
	total+=size;
	MapDebug("Number of Sprites	: %4ld size = %6ld\n",statcount,size);
	size=objcount*sizeof(objtype);
	total+=size;
	MapDebug("Number of Actors		: %4ld size = %6ld\n",objcount,size);
	MapDebug("Number of Clocks		: %4ld\n",numclocks);
	MapDebug("\nTotal size of level : %6ld\n",total);
}


boolean IsWeapon(int tile)
{
	if ((tile >= 46) && (tile <= 56))
	return true;

	return  false;

}


char *WeaponName(int tile)
{
	switch(tile)
	{
	case 46:
		return "Bat			";
		break;

	case 47:
		return "Knife			";
		break;

	case 48:
		return "Double Pistol ";
		break;

	case 49:
		return "MP40			";
		break;

	case 50:
		return "Bazooka		";
		break;

	case 51:
		return "Firebomb		";
		break;

	case 52:
		return "Heatseeker	";
		break;

	case 53:
		return "Drunk Missile ";
		break;

	case 54:
		return "Flamewall	";
		break;

	case 55:
		return "Split Missile ";
		break;

	case 56:
		return "KES			";
		break;
	}
	return " ";
}


#if 0
int GetLumpForTile(int tile)
{
	int wallstart;
	int exitstart;

	wallstart=W_GetNumForName("WALLSTRT");
	exitstart=W_GetNumForName("EXITSTRT");
	elevatorstart = W_GetNumForName("ELEVSTRT");

	if ((tile >= 1) && (tile <= 32))
		{
		return (tile + wallstart);
		}
	else if ((tile >= 36) && (tile <= 45))
		{
		return (tile + wallstart - 3);
		}
	else if (tile == 46)
		{
		return (wallstart + 74);
		}
	else if ((tile >= 47) && (tile <= 48))
		{
		return (tile + exitstart - 46);
		}
	else if ((tile >= 49) && (tile <= 71))
		{
		return (tile + wallstart - 8);
		}
	else if ((tile >= 72) && (tile <= 79))
		{
		return (tile - 72 + elevatorstart + 1);
		}
	else if ((tile >= 80) && (tile <= 89))
		{
		return (tile + wallstart - 16);
		}
	return -1;
}
#endif

#if 1

char *rt_wallnames[128]={
"WALLSTRT",	
"WALL1",	"WALL2",	"WALL3",	"WALL4",	
"WALL5",	"WALL6",	"WALL7",	"WALL8",	
"WALL9",	"WALL10",	"WALL11",	"WALL12",	
"WALL13",	"WALL14",	"WALL15",	"WALL16",	
"WALL17",	"WALL18",	"WALL19",	"WALL20",	
"WALL21",	"WALL22",	"WALL23",	"WALL24",	
"WALL25",	"WALL26",	"WALL27",	"WALL28",	
"WALL29",	"WALL30",	"WALL31",	"WALL32",	
"WALL33",	"WALL34",	"WALL35",	"WALL36",	
"WALL37",	"WALL38",	"WALL39",	"WALL40",	
"WALL41",	"WALL42",	"WALL43",	"WALL44",	
"WALL45",	"WALL46",	"WALL47",	"WALL48",	
"WALL49",	"WALL50",	"WALL51",	"WALL52",	
"WALL53",	"WALL54",	"WALL55",	"WALL56",	
"WALL57",	"WALL58",	"WALL59",	"WALL60",	
"WALL61",	"WALL62",	"WALL63",	"WALL64",	
"WALL65",	"WALL66",	"WALL67",	"WALL68",	
"WALL69",	"WALL70",	"WALL71",	"WALL72",	
"WALL73",	"WALL74",	
"WALLSTOP",	"EXITSTRT",	
"EXIT",		"ENTRANCE",	"EXITARCH",	"EXITARCA",	
"ENTRARCH",	"EXITSTOP",	"ELEVSTRT",	
"ELEV1",	"ELEV2",	"ELEV3",	"ELEV4",	
"ELEV5",	"ELEV6",	"ELEV7",	"ELEV8",	
"ELEVSTOP",	
NULL
};

int LookupWallNameIndex(char *name)
{
	int i;
	
	for(i=0; rt_wallnames[i]; i++)
		if(!strcmp(name, rt_wallnames[i]))
			return(i);
	return(-1);
}

int GetLumpForTile(int tile)
{
	char tb[9];
	char *s0;
	int wallstart;
	int exitstart;
	int wallidx, walllump;

	elevatorstart = W_GetNumForName("ELEVSTRT");

//	wallstart=W_GetNumForName("WALLSTRT");
//	exitstart=W_GetNumForName("EXITSTRT");
//	elevatorstart = W_GetNumForName("ELEVSTRT");
//	rott_wallstrt=wallstart;
//	rott_wallstop=W_GetNumForName("WALLSTOP");

	wallstart=LookupWallNameIndex("WALLSTRT");
	exitstart=LookupWallNameIndex("EXITSTRT");
//	elevatorstart = LookupWallNameIndex("ELEVSTRT");
	rott_wallstrt=wallstart;
	rott_wallstop=LookupWallNameIndex("WALLSTOP");

	wallidx = -1;
	
	if(rott_iswolf)
	{
//		if((tile >= 0x01) && (tile <= 0x46))
		if((tile >= 0x01) && (tile < 0x6A))
		{
			wallidx = tile;
		}
	}
	else
	{
		if ((tile >= 1) && (tile <= 32))
		{
	//		return (tile + wallstart);
			wallidx = tile;
		}
		else if ((tile >= 36) && (tile <= 45))
		{
	//		return (tile + wallstart - 3);
			wallidx = tile-3;
		}
		else if (tile == 46)
		{
	//		return (wallstart + 74);
			wallidx = 74;
		}
		else if ((tile >= 47) && (tile <= 48))
		{
	//		return (tile + exitstart - 46);
			wallidx = (tile-46) + (exitstart-wallstart);
		}
		else if ((tile >= 49) && (tile <= 71))
		{
	//		return (tile + wallstart - 8);
			wallidx = tile-8;
		}
		else if ((tile >= 72) && (tile <= 79))
		{
	//		return (tile - 72 + elevatorstart + 1);
			wallidx = (tile-71) + (elevatorstart-wallstart);
		}
		else if ((tile >= 80) && (tile <= 89))
		{
	//		return (tile + wallstart - 16);
			wallidx = tile-16;
		}
	}

	if(wallidx<=0)
		return(-1);

	rott_wallcache[wallidx]=wallidx+wallstart;

//	sprintf(tb, "WALL%d", wallidx);
//	walllump = W_CheckNumForName(tb);
	s0=rt_wallnames[wallidx];
	walllump = W_CheckNumForName(s0);

	if(walllump>0)
	{
		rott_wallcache[wallidx]=walllump;
//		return(wallidx+wallstart);
		return(walllump);
	}

//	return(wallidx+wallstart);
	__debugbreak();
	
	return -1;
}
#endif




#if (DEVELOPMENT == 1)


/*
==================
=
= Insane Dump
=
==================
*/

void InsaneDump(void)
{
	int i,j,level;
	word *map,tile;
	int tally[1000];
	int inlevel[1000][10];

	if (TILESTATS==false)
		return;

	OpenMapDebug();


// WALLS
	memset(tally,0,sizeof(tally));
	memset(inlevel,0,sizeof(inlevel));
	MapDebug("=======================\n");
	MapDebug("= WALLS\n");
	MapDebug("=======================\n");
	mapheight = mapwidth = 128;
	BATTLEMODE = 1;
	for(level=0;level<8;level ++)
	{
	GetEpisode(level);
	LoadROTTMap(level);
	map = mapplanes[0];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{tile = *map++;
			if (IsWall(i,j)==true)
				{tally[tile]++;
				inlevel[tile][level]=1;
				}

			}
		}
	}

	MapDebug("Wall #	Frequency	Levels\n");
	MapDebug("----------------------------\n");
	for (i=0;i<1000;i++)
	if (i < 90)
		{MapDebug("%4d		%4d		%s",i,tally[i],
					W_GetNameForNum(GetLumpForTile(i)));
		MapDebug("	");
		for(level=0;level < 10;level ++)
			if (inlevel[i][level])
			MapDebug("%d,",level);
		MapDebug("\n");
		}





// Doors
	memset(tally,0,sizeof(tally));
	memset(inlevel,0,sizeof(inlevel));
	MapDebug("=======================\n");
	MapDebug("= DOORS\n");
	MapDebug("=======================\n");
	for(level=0;level<10;level ++)
	{
	GetEpisode(level);
	LoadROTTMap(level);
	map = mapplanes[0];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{tile = *map++;
			if (IsDoor(i,j)==true)
				{tally[tile]++;
				inlevel[tile][level]=1;
				}

			}
		}
	}

	MapDebug("Door #	Frequency	Levels\n");
	MapDebug("----------------------------\n");
	for (i=0;i<1000;i++)
	if (tally[i]!=0)
		{MapDebug("%4d		%4d			",i,tally[i]);
		for(level=0;level < 10;level ++)
			if (inlevel[i][level])
			MapDebug("%d,",level);
		MapDebug("\n");

		}

// MaskedWalls
	memset(tally,0,sizeof(tally));
	memset(inlevel,0,sizeof(inlevel));
	MapDebug("=======================\n");
	MapDebug("= MASKED WALLS\n");
	MapDebug("=======================\n");
	for(level=0;level<10;level ++)
	{
	GetEpisode(level);
	LoadROTTMap(level);
	map = mapplanes[0];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{tile = *map++;
			if ((IsMaskedWall(i,j)) && (!IsPlatform(i,j)))
				{tally[tile]++;
				inlevel[tile][level]=1;
				}

			}
		}
	}

	MapDebug("MWall #	Frequency	Levels\n");
	MapDebug("----------------------------\n");
	for (i=0;i<1000;i++)
	if (tally[i]!=0)
		{MapDebug("%4d		%4d			",i,tally[i]);
		for(level=0;level < 10;level ++)
			if (inlevel[i][level])
			MapDebug("%d,",level);
		MapDebug("\n");

		}

}

#endif

/*
==================
=
= PrintTileStats
=
==================
*/
void PrintTileStats (void)
{
	int i,j;
	word *map;
	int easytotal;
	int hardtotal;
	int tally[1000];

	if (TILESTATS==false)
		return;

	OpenMapDebug();

	MapDebug("TILE STATS Map Number %ld\n",gamestate.mapon);
	MapDebug("=======================\n\n");


// Weapons
	memset(tally,0,sizeof(tally));
	MapDebug("=======================\n");
	MapDebug("= WEAPONS\n");
	MapDebug("=======================\n");
	map = mapplanes[1];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			if (IsWeapon(*map))
			MapDebug("\n %s at %3d,%3d",WeaponName(*map),i,j);
			map++;
			}
		}
	MapDebug("\n\n");
// WALLS
	memset(tally,0,sizeof(tally));
	MapDebug("=======================\n");
	MapDebug("= WALLS\n");
	MapDebug("=======================\n");
	map = mapplanes[0];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			if (IsWall(i,j)==true)
				tally[(*map)]++;
			map++;
			}
		}
	MapDebug("Wall #		Frequency\n");
	MapDebug("-----------------------\n");
	for (i=0;i<1000;i++)
	if (tally[i]!=0)
		MapDebug("  %4ld	%4ld\n",i,tally[i]);

// Doors
	memset(tally,0,sizeof(tally));
	MapDebug("=======================\n");
	MapDebug("= DOORS\n");
	MapDebug("=======================\n");
	map = mapplanes[0];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			if (IsDoor(i,j)==true)
				tally[(*map)]++;
			map++;
			}
		}
	MapDebug("Door #		Frequency\n");
	MapDebug("-----------------------\n");
	for (i=0;i<1000;i++)
	if (tally[i]!=0)
		MapDebug("  %4ld	%4ld\n",i,tally[i]);

// MaskedWalls
	memset(tally,0,sizeof(tally));
	MapDebug("=======================\n");
	MapDebug("= MASKEDWALLS\n");
	MapDebug("=======================\n");
	map = mapplanes[0];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			if (IsMaskedWall(i,j)==true)
				if (IsPlatform(i,j)==false)
					tally[(*map)]++;
			map++;
			}
		}
	MapDebug("Mwall #		Frequency\n");
	MapDebug("-----------------------\n");
	for (i=0;i<1000;i++)
	if (tally[i]!=0)
		MapDebug("  %4ld	%4ld\n",i,tally[i]);
// Platforms
	memset(tally,0,sizeof(tally));
	MapDebug("=======================\n");
	MapDebug("= PLATFORMS\n");
	MapDebug("=======================\n");
	map = mapplanes[2];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			if (IsPlatform(i,j)==true)
				tally[(*map)]++;
			map++;
			}
		}
	MapDebug("Pform #		Frequency\n");
	MapDebug("-----------------------\n");
	for (i=0;i<1000;i++)
	if (tally[i]!=0)
		MapDebug("  %4ld	%4ld\n",i,tally[i]);

// Actors
	memset(tally,0,sizeof(tally));
	MapDebug("=======================\n");
	MapDebug("= ACTORS\n");
	MapDebug("=======================\n");
	map = mapplanes[1];
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			if ((*map)>0)
				tally[(*map)]++;
			map++;
			}
		}

// Low Guards
	easytotal=0;
	hardtotal=0;
	for (i=108;i<=119;i++)
		easytotal+=tally[i];
	for (i=126;i<=137;i++)
		hardtotal+=tally[i];
	MapDebug("\nLowGuards\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// Sneaky Low Guards
	easytotal=0;
	hardtotal=0;
	for (i=120;i<=120;i++)
		easytotal+=tally[i];
	for (i=138;i<=138;i++)
		hardtotal+=tally[i];
	MapDebug("\nSneakyLowGuards\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// High Guards
	easytotal=0;
	hardtotal=0;
	for (i=144;i<=155;i++)
		easytotal+=tally[i];
	for (i=162;i<=173;i++)
		hardtotal+=tally[i];
	MapDebug("\nHighGuards\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// OverPatrol Guards
	easytotal=0;
	hardtotal=0;
	for (i=216;i<=227;i++)
		easytotal+=tally[i];
	for (i=234;i<=245;i++)
		hardtotal+=tally[i];
	MapDebug("\nOverPatrolGuards\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// Strike Guards
	easytotal=0;
	hardtotal=0;
	for (i=180;i<=191;i++)
		easytotal+=tally[i];
	for (i=198;i<=204;i++)
		hardtotal+=tally[i];
	MapDebug("\nStrikeGuards\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// TriadEnforcer Guards
	easytotal=0;
	hardtotal=0;
	for (i=288;i<=299;i++)
		easytotal+=tally[i];
	for (i=306;i<=317;i++)
		hardtotal+=tally[i];
	MapDebug("\nTriadEnforcer Guards\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// Lightning Guards
	easytotal=0;
	hardtotal=0;
	for (i=324;i<=335;i++)
		easytotal+=tally[i];
	for (i=342;i<=353;i++)
		hardtotal+=tally[i];
	MapDebug("\nLightningGuards\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// Random Actors
	easytotal=0;
	hardtotal=0;
	for (i=122;i<=125;i++)
		easytotal+=tally[i];
	MapDebug("\nRandom Actors\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",easytotal);

// Monks
	easytotal=0;
	hardtotal=0;
	for (i=360;i<=371;i++)
		easytotal+=tally[i];
	for (i=378;i<=389;i++)
		hardtotal+=tally[i];
	MapDebug("\nMonks\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// Fire Monks
	easytotal=0;
	hardtotal=0;
	for (i=396;i<=407;i++)
		easytotal+=tally[i];
	for (i=414;i<=425;i++)
		hardtotal+=tally[i];
	MapDebug("\nFire Monks\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// Robo Guards
	easytotal=0;
	hardtotal=0;
	for (i=158;i<=161;i++)
		easytotal+=tally[i];
	for (i=176;i<=179;i++)
		hardtotal+=tally[i];
	MapDebug("\nRoboGuards\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// Ballistikrafts
	easytotal=0;
	hardtotal=0;
	for (i=408;i<=411;i++)
		easytotal+=tally[i];
	for (i=426;i<=429;i++)
		hardtotal+=tally[i];
	MapDebug("\nBallistikrafts\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// Boulders
	easytotal=0;
	hardtotal=0;
	for (i=278;i<=281;i++)
		easytotal+=tally[i];
	for (i=395;i<=395;i++)
		hardtotal+=tally[i];
	MapDebug("\nBoulders\n");
	MapDebug("-----------------------\n");
	MapDebug("Boulders=%4ld\n",easytotal);
	MapDebug("BoulderHoles=%4ld\n",hardtotal);

// PushColumns
	easytotal=0;
	hardtotal=0;
	for (i=285;i<=287;i++)
		easytotal+=tally[i];
	for (i=303;i<=305;i++)
		easytotal+=tally[i];
	for (i=321;i<=323;i++)
		easytotal+=tally[i];
	for (i=339;i<=341;i++)
		easytotal+=tally[i];
	for (i=357;i<=359;i++)
		easytotal+=tally[i];
	MapDebug("\nPushColumns\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",easytotal);

// Gun Emplacements
	easytotal=0;
	hardtotal=0;
	for (i=194;i<=197;i++)
		easytotal+=tally[i];
	for (i=212;i<=215;i++)
		hardtotal+=tally[i];
	MapDebug("\nGun Emplacements\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// 4-way guns
	easytotal=0;
	hardtotal=0;
	for (i=89;i<=89;i++)
		easytotal+=tally[i];
	for (i=211;i<=211;i++)
		hardtotal+=tally[i];
	MapDebug("\n4-way guns\n");
	MapDebug("-----------------------\n");
	MapDebug("EasyTotal=%4ld\n",easytotal);
	MapDebug("HardTotal=%4ld\n",hardtotal);
	MapDebug("	Total=%4ld\n",easytotal+hardtotal);

// Stabbers from above
	MapDebug("\nStabbers from above\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",tally[412]);

// Stabbers from below
	MapDebug("\nStabbers from below\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",tally[430]);

// Crushing pillar from above
	MapDebug("\nCrushing pillar from above\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",tally[413]);

// Crushing pillar from below
	MapDebug("\nCrushing pillar from below\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",tally[431]);

// Above Spinner
	MapDebug("\nAbove Spinner\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",tally[156]);

// Ground Spinner
	MapDebug("\nGround Spinner\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",tally[174]);

// Spinner from above
	MapDebug("\nSpinner from above\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",tally[157]);

// Spinner from below
	MapDebug("\nSpinner from below\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",tally[175]);

// Bosses
	easytotal=0;
	for (i=99;i<=103;i++)
		easytotal+=tally[i];
	MapDebug("\nBosses\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",easytotal);

// Spring Boards
	MapDebug("\nSpring Boards\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",tally[193]);

// Above FlameJets
	easytotal=0;
	hardtotal=0;
	for (i=372;i<=376;i++)
		easytotal+=tally[i];
	for (i=390;i<=394;i++)
		hardtotal+=tally[i];
	MapDebug("\nFlameJets\n");
	MapDebug("-----------------------\n");
	MapDebug("	Above=%4ld\n",easytotal);
	MapDebug("	Ground=%4ld\n",hardtotal);

// Fire Chutes
	easytotal=0;
	for (i=140;i<=143;i++)
		easytotal+=tally[i];
	MapDebug("\nFireChutes\n");
	MapDebug("-----------------------\n");
	MapDebug("	Total=%4ld\n",easytotal);

// Sprites
	MapDebug("=======================\n");
	MapDebug("= SPRITES\n");
	MapDebug("=======================\n");
	MapDebug("Sprite #		Frequency\n");
	MapDebug("-----------------------\n");
	for (i=1;i<=72;i++)
		if (tally[i]!=0)
			MapDebug("  %4ld	%4ld\n",i,tally[i]);
	for (i=210;i<=210;i++)
		if (tally[i]!=0)
			MapDebug("  %4ld	%4ld\n",i,tally[i]);
	for (i=228;i<=233;i++)
		if (tally[i]!=0)
			MapDebug("  %4ld	%4ld\n",i,tally[i]);
	for (i=246;i<=255;i++)
		if (tally[i]!=0)
			MapDebug("  %4ld	%4ld\n",i,tally[i]);
	for (i=260;i<=273;i++)
		if (tally[i]!=0)
			MapDebug("  %4ld	%4ld\n",i,tally[i]);
	for (i=282;i<=284;i++)
		if (tally[i]!=0)
			MapDebug("  %4ld	%4ld\n",i,tally[i]);
}

//***************************************************************************
//
// GetSongForLevel - returns song to play for current level
//
//***************************************************************************
int GetSongForLevel ( void )
{
	int i;
	int num;

	for (i=0;i<mapwidth;i++)
		{
		num = MAPSPOT(i,0,2);
		if ( (num>>8) == 0xba )
			return (num&0xff);
		}
//	Error("GetSongForLevel: could not find song in level %ld\n",gamestate.mapon);
//	return -1;
	return 0;
}

/*
==================
=
= DoSharewareConversionBackgroundPlane
=
==================
*/
void DoSharewareConversionBackgroundPlane (void)
{
	int i,j;
	word * map;

	if(rott_iswolf)
		return;

	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			map=&(mapplanes[0][MAPSIZE*(j)+(i)]);
			switch (*map)
				{

				// Tom Face
				case 45:
					*map=44;
					break;
				// Doors
				case 90:
				case 92:
				case 93:
				case 98:
				case 99:
				case 100:
					*map=91;
					break;
				case 103:
				case 104:
					*map=101;
					break;
				case 154:
					*map=33;
					break;
				case 155:
					*map=34;
					break;
				case 156:
					*map=35;
					break;

				//locked doors
				case 94:
					*map = 101;
					*(&(mapplanes[1][MAPSIZE*(j)+(i)]))=29;
					break;
				case 95:
					*map = 101;
					*(&(mapplanes[1][MAPSIZE*(j)+(i)]))=30;
					break;
				case 96:
					*map = 101;
					*(&(mapplanes[1][MAPSIZE*(j)+(i)]))=31;
					break;
				case 97:
					*map = 101;
					*(&(mapplanes[1][MAPSIZE*(j)+(i)]))=32;
					break;
				// Tall pillar
				case 161:
					*map=0;
					break;
				// Masked Walls
				case 162:
				case 166:
					*map=164;
					break;
				case 163:
				case 167:
				case 170:
				case 171:
					*map=165;
					break;

				// Floors and Ceilings
				case 180:
				case 183:
				case 184:
					*map=181;
					break;
				case 198:
				case 201:
				case 202:
					*map=199;
					break;
				case 188:
					*map=187;
					break;
				case 206:
					*map=205;
					break;
				case 190:
					*map=191;
					break;
				case 208:
					*map=209;
					break;
				case 192:
				case 193:
				case 194:
				case 195:
					*map=189;
					break;
				case 210:
				case 211:
				case 212:
				case 213:
					*map=207;
					break;
				// Skys
				case 237:
				case 238:
				case 239:
					*map=234;
					break;
				// Animating walls
				case 107:
					*map=106;
					break;
				case 228:
				case 229:
				case 230:
				case 242:
					*map=21;
					break;
				case 233:
					*map=44;
					break;
				case 232:
					*map=231;
					break;
				}
			}
		}
}


/*
========================================
=
= DoLowMemoryConversionBackgroundPlane
=
========================================
*/
void DoLowMemoryConversionBackgroundPlane (void)
	{
	int i,j;
	word * map;


	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			map=&(mapplanes[0][MAPSIZE*(j)+(i)]);
			switch (*map)
				{
				//Walls

				case 2:
				case 3:
				case 4:
					*map = 1;
					break;

				case 6:
				case 7:
				case 8:
					*map = 5;
					break;

				case 14:
				case 15:
				case 16:
					*map = 13;
					break;

				case 18:
				case 19:
				case 20:
					*map = 17;
					break;

				case 26:
				case 27:
				case 28:
					*map = 25;
					break;

				case 30:
				case 31:
				case 32:
					*map = 29;
					break;

#if 0
				case 37:
				case 38:
				case 39:
					*map = 36;
					break;

				case 41:
				case 42:
				case 43:
					*map = 40;
					break;
#endif

				case 50:
				case 51:
				case 52:
					*map = 49;
					break;

#if 0
				case 55:
				case 56:
				case 57:
					*map = 54;
					break;

				case 59:
				case 60:
				case 61:
					*map = 58;
					break;
#endif

				case 66:
				case 67:
				case 68:
					*map = 65;
					break;

				case 70:
				case 71:
					*map = 69;
					break;

				case 81:
				case 82:
				case 84:
					*map = 83;
					break;

				// Masked Walls
				case 158:
				case 159:
				case 160:
				case 168:
				case 169:
				case 176:
				case 178:
					*map=177;
					break;
				case 162:
				case 163:
				case 164:
				case 166:
				case 167:
					*map=165;
					break;

				//Doors
				case 90:
				case 91:
				case 92:
				case 93:
				case 98:
				case 99:
				case 100:
				case 101:
				case 103:
				case 104:
				case 33:
				case 34:
				case 35:
				case 154:
				case 155:
				case 156:
					*map = 101;
					break;

				//Animating Walls
				case 22:
				case 23:
				case 24:
				case 228:
				case 229:
				case 230:
				case 231:
				case 232:
				case 242:
				case 243:
				case 244:
					*map = 21;
					break;
				case 233:
					*map = 44;
					break;

#if 0
				//Skys
				case 234:
				case 235:
				case 236:
				case 237:
				case 238:
				case 239:
					*map=(*(&(mapplanes[0][MAPSIZE*(0)+(0)]))) + 18;
					break;
#endif
				}
			}
		}
	}


/*
========================================
=
= DoLowMemoryConversionIconPlane
=
========================================
*/
void DoLowMemoryConversionIconPlane (void)
	{
#if 0
	int i,j;
	word * map;


	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			map=&(mapplanes[2][MAPSIZE*(j)+(i)]);
			switch (*map)
				{
				case 13:
					*(&(mapplanes[0][MAPSIZE*(j)+(i)]))=21;
					*map=0;
					break;
				}
			}
		}
#endif
	}



/*
========================================
=
= DoLowMemoryConversionForegroundPlane
=
========================================
*/

void DoLowMemoryConversionForegroundPlane (void)
	{
	int i,j;
	word * map;


	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			map=&MAPSPOT(i,j,1);
			switch (*map)
				{
				// light sourcing
				case 139:
					*map=0;
					break;

				//sprites
				case 42:
				case 43:
				case 63:
				case 64:
					*map = 43;
					break;

				case 246:
				case 247:
				case 248:
				case 264:
				case 265:
				case 267:
				case 283:
					*map = 266;
					break;

				//lightning
				case 377:
					*map = 0;
					break;

				// actor guards

				// normal low guards
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:

				case 126:
				case 127:
				case 128:
				case 129:
				case 130:
				case 131:
				case 132:
				case 133:
				case 134:
				case 135:
				case 136:
				case 137:
					(*map)+=216;
					break;

				// sneaky low guards
				case 120:
				case 138:
					*map = 0;
					break;

				// normal over patrol
				case 216:
				case 217:
				case 218:
				case 219:
				case 220:
				case 221:
				case 222:
				case 223:
				case 224:
				case 225:
				case 226:
				case 227:


				case 234:
				case 235:
				case 236:
				case 237:
				case 238:
				case 239:
				case 240:
				case 241:
				case 242:
				case 243:
				case 244:
				case 245:
					(*map)-=36;
					break;

				//environment dangers

#if (SHAREWARE==0)
				case 412:		//spears to firejets
					*map = 372;
					break;

				case 430:
					*map = 390;
					break;

				case 413:		//cylinders down to firejets
					*map = 372;
					break;
#endif

				case 156:
				case 157:
					*map = 372;	//spinblade stabbers to firejets
					break;

				case 174:
				case 175:
					*map = 390;
					break;

				case 301:			// directional spin blades
					*map = 373;
					break;

				case 319:			// directional spin blades
					*map = 374;
					break;

				case 337:			// directional spin blades
					*map = 375;
					break;

				case 355:			// directional spin blades
					*map = 376;
					break;

				case 302:			// directional spin blades
					*map = 391;
					break;

				case 320:			// directional spin blades
					*map = 392;
					break;

				case 338:			// directional spin blades
					*map = 393;
					break;

				case 356:			// directional spin blades
					*map = 394;
					break;

				case 194:		// directional emplacements to four-way
				case 195:		// easy
				case 196:
				case 197:
					*map = 89;
					break;

				case 212:		// hard
				case 213:
				case 214:
				case 215:
					*map = 211;
					break;

				}
			}
		}
	}


/*
==================
=
= DoSharewareConversionForegroundPlane
=
==================
*/
void DoSharewareConversionForegroundPlane (void)
{
	int i,j;
	word * map;

	if(rott_iswolf)
		return;

	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			map=&(mapplanes[1][MAPSIZE*(j)+(i)]);
			switch (*map)
				{
				case 32:  // Crystal Key
				case 47:  // Knife
				case 65:  // DIP BALL D
				case 66:  // DIP BALL I
				case 67:  // DIP BALL P
				case 99:  // Boss
				case 100:  // Boss
				case 101:  // Boss
				case 102:  // Boss
				case 103:  // Boss
				case 210:  // Scott's head
				case 278:  // Boulder
				case 279:  // Boulder
				case 280:  // Boulder
				case 281:  // Boulder
				case 395:  // Boulder
					*map=0;
					break;
				case 41:  // 3-UP to 1-UP
					*map=40;
					break;
				case 46:  // Bat
					*map=50;
					break;
				case 55:  // Split Missile
					*map=52;
					break;
				case 56:  // KES
					*map=53;
					break;
				case 253:  // Dog Mode
					*map=254;
					break;
				case 262:  // Tom Larva
					*map=263;
					break;
				}
			}
		}
}

/*
========================================
=
= DoRegisterConversionBackgroundPlane
=
========================================
*/
void DoRegisterConversionBackgroundPlane (void)
	{
	int i,j;
	word * map;


	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			map=&(mapplanes[0][MAPSIZE*(j)+(i)]);
			switch (*map)
				{
				//locked doors

				case 94:
					*map = 101;
					*(&(mapplanes[1][MAPSIZE*(j)+(i)]))=29;
					break;
				case 95:
					*map = 101;
					*(&(mapplanes[1][MAPSIZE*(j)+(i)]))=30;
					break;
				case 96:
					*map = 101;
					*(&(mapplanes[1][MAPSIZE*(j)+(i)]))=31;
					break;
				case 97:
					*map = 101;
					*(&(mapplanes[1][MAPSIZE*(j)+(i)]))=32;
					break;

				case 232:
					*map = 231; //map chains to machinery
					break;

				case 228:
					*map = 230; //map gray water to blue water
					break;

				}
			}
		}
	}



/*
========================================
=
= DoRegisterConversionForegroundPlane
=
========================================
*/
void DoRegisterConversionForegroundPlane (void)
	{
//	int i,j;
//	word * map;


#if 0
	for (j=0;j<mapheight;j++)
		{
		for(i=0;i<mapwidth;i++)
			{
			map=&MAPSPOT(i,j,1);
			switch (*map)
				{
				//sprites
				case 42:
				case 43:
				case 63:
				case 64:
					*map = 43;
					break;

				}
			}
		}
#endif
	}

/*
==================
=
= DoSharewareConversion
=
==================
*/
void DoSharewareConversion (void)
{
	DoSharewareConversionBackgroundPlane ();
	DoSharewareConversionForegroundPlane ();
}


/*
==================
=
= DoRegisterConversion
=
==================
*/
void DoRegisterConversion (void)
{
	DoRegisterConversionBackgroundPlane ();
	DoRegisterConversionForegroundPlane ();
}

/*
=======================
=
= DoPanicMapping
=
=======================
*/
boolean DoPanicMapping (void)
	{
	if ((lowmemory==true) && (modemgame==false) && (demorecord==false) && (demoplayback==false))
		return true;
	else
		return false;
	}

/*
=======================
=
= DoLowMemoryConversion
=
=======================
*/
void DoLowMemoryConversion (void)
	{
	DoLowMemoryConversionBackgroundPlane ();
	if ((modemgame==false) && (demorecord==false) && (demoplayback==false))
		DoLowMemoryConversionForegroundPlane ();
	DoLowMemoryConversionIconPlane ();
	}


const char *rt_shapenames[3072]=
{
"SHAPSTRT",	"LWGSHOO1",	"LWGSHOO2",	"LWGSHOO3",	
"LWGSHOO4",	"LWGS1",	"LWGS2",	"LWGS3",	
"LWGS4",	"LWGS5",	"LWGS6",	"LWGS7",	
"LWGS8",	"LWGW11",	"LWGW12",	"LWGW13",	
"LWGW14",	"LWGW15",	"LWGW16",	"LWGW17",	
"LWGW18",	"LWGW21",	"LWGW22",	"LWGW23",	
"LWGW24",	"LWGW25",	"LWGW26",	"LWGW27",	
"LWGW28",	"LWGW31",	"LWGW32",	"LWGW33",	
"LWGW34",	"LWGW35",	"LWGW36",	"LWGW37",	
"LWGW38",	"LWGW41",	"LWGW42",	"LWGW43",	
"LWGW44",	"LWGW45",	"LWGW46",	"LWGW47",	
"LWGW48",	"LWGPAIN1",	"LWGPAIN2",	"LWGDIE1",	
"LWGDIE2",	"LWGDIE3",	"LWGDIE4",	"LWGDEAD",	
"LWGWPN1",	"LWGWPN2",	"LWGWDIE1",	"LWGWDIE2",	
"LWGWDIE3",	"LWGWDIE4",	"LWGWDEAD",	"SNGDEAD",	
"SNGRISE1",	"SNGRISE2",	"SNGRISE3",	"SNGRISE4",	
"HG2SHOO1",	"HG2SHOO2",	"HG2SHOO3",	"HG2SHOO4",	
"HG2S1",	"HG2S2",	"HG2S3",	"HG2S4",	
"HG2S5",	"HG2S6",	"HG2S7",	"HG2S8",	
"HG2W11",	"HG2W12",	"HG2W13",	"HG2W14",	
"HG2W15",	"HG2W16",	"HG2W17",	"HG2W18",	
"HG2W21",	"HG2W22",	"HG2W23",	"HG2W24",	
"HG2W25",	"HG2W26",	"HG2W27",	"HG2W28",	
"HG2W31",	"HG2W32",	"HG2W33",	"HG2W34",	
"HG2W35",	"HG2W36",	"HG2W37",	"HG2W38",	
"HG2W41",	"HG2W42",	"HG2W43",	"HG2W44",	
"HG2W45",	"HG2W46",	"HG2W47",	"HG2W48",	
"HG2PAIN1",	"HG2PAIN2",	"HG2DIE1",	"HG2DIE2",	
"HG2DIE3",	"HG2DIE4",	"HG2DIE5",	"HG2DEAD",	
"HG2WPN1",	"HG2WPN2",	"HG2WDIE1",	"HG2WDIE2",	
"HG2WDIE3",	"HG2WDIE4",	"HG2WDIE5",	"HG2WDEAD",	
"ANGSHOO1",	"ANGSHOO2",	"ANGSHOO3",	"ANGSHOO4",	
"ANKSHOO1",	"ANKSHOO2",	"ANKSHOO3",	"ANGS1",	
"ANGS2",	"ANGS3",	"ANGS4",	"ANGS5",	
"ANGS6",	"ANGS7",	"ANGS8",	"ANGW11",	
"ANGW12",	"ANGW13",	"ANGW14",	"ANGW15",	
"ANGW16",	"ANGW17",	"ANGW18",	"ANGW21",	
"ANGW22",	"ANGW23",	"ANGW24",	"ANGW25",	
"ANGW26",	"ANGW27",	"ANGW28",	"ANGW31",	
"ANGW32",	"ANGW33",	"ANGW34",	"ANGW35",	
"ANGW36",	"ANGW37",	"ANGW38",	"ANGW41",	
"ANGW42",	"ANGW43",	"ANGW44",	"ANGW45",	
"ANGW46",	"ANGW47",	"ANGW48",	"ANGPAIN1",	
"ANGPAIN2",	"ANGDIE1",	"ANGDIE2",	"ANGDIE3",	
"ANGDIE4",	"ANGDEAD",	"ANGDEAD2",	"ANGDEAD3",	
"ANGWPN1",	"ANGWPN2",	"ANGWDIE1",	"ANGWDIE2",	
"ANGWDIE3",	"ANGWDIE4",	"ANGWDEAD",	"ANGWDED2",	
"ANGWDED3",	"ANRROLL1",	"ANRROLL2",	"ANRROLL3",	
"ANRROLL4",	"ANRROLL5",	"ANRROLL6",	"ANLROLL1",	
"ANLROLL2",	"ANLROLL3",	"ANLROLL4",	"ANLROLL5",	
"ANLROLL6",	"LIGSHOO1",	"LIGSHOO2",	"LIGSHOO3",	
"LIGSHOO4",	"LIGS1",	"LIGS2",	"LIGS3",	
"LIGS4",	"LIGS5",	"LIGS6",	"LIGS7",	
"LIGS8",	"LIGW11",	"LIGW12",	"LIGW13",	
"LIGW14",	"LIGW15",	"LIGW16",	"LIGW17",	
"LIGW18",	"LIGW21",	"LIGW22",	"LIGW23",	
"LIGW24",	"LIGW25",	"LIGW26",	"LIGW27",	
"LIGW28",	"LIGW31",	"LIGW32",	"LIGW33",	
"LIGW34",	"LIGW35",	"LIGW36",	"LIGW37",	
"LIGW38",	"LIGW41",	"LIGW42",	"LIGW43",	
"LIGW44",	"LIGW45",	"LIGW46",	"LIGW47",	
"LIGW48",	"LIGPAIN1",	"LIGPAIN2",	"LIGDIE1",	
"LIGDIE2",	"LIGDIE3",	"LIGDIE4",	"LIGDEAD1",	
"LIGDEAD2",	"LIGWPN1",	"LIGWPN2",	"LIGWDIE1",	
"LIGWDIE2",	"LIGWDIE3",	"LIGWDIE4",	"LIGWDED1",	
"LIGWDED2",	"LIGRISE1",	"LIGRISE2",	"LIGRISE3",	
"LIGRISE4",	"LIHUSE11",	"LIHUSE12",	"LIHUSE13",	
"LIHUSE14",	"LIHUSE15",	"LIHUSE16",	"LIHUSE17",	
"LIHUSE18",	"LIHUSE21",	"LIHUSE22",	"LIHUSE23",	
"LIHUSE24",	"LIHUSE25",	"LIHUSE26",	"LIHUSE27",	
"LIHUSE28",	"LIPLEAD1",	"LIPLEAD2",	"LIPLEAD3",	
"LIPLEAD4",	"LIPLEAD5",	"LIPLEAD6",	"LIPLEAD7",	
"LIPLEAD8",	"LIPLEAD9",	"LIPEAD10",	"LIPEAD11",	
"TRISHOO1",	"TRISHOO2",	"TRISHOO3",	"TRISHOO4",	
"TRIS1",	"TRIS2",	"TRIS3",	"TRIS4",	
"TRIS5",	"TRIS6",	"TRIS7",	"TRIS8",	
"TRIW11",	"TRIW12",	"TRIW13",	"TRIW14",	
"TRIW15",	"TRIW16",	"TRIW17",	"TRIW18",	
"TRIW21",	"TRIW22",	"TRIW23",	"TRIW24",	
"TRIW25",	"TRIW26",	"TRIW27",	"TRIW28",	
"TRIW31",	"TRIW32",	"TRIW33",	"TRIW34",	
"TRIW35",	"TRIW36",	"TRIW37",	"TRIW38",	
"TRIW41",	"TRIW42",	"TRIW43",	"TRIW44",	
"TRIW45",	"TRIW46",	"TRIW47",	"TRIW48",	
"TRITOSS1",	"TRITOSS2",	"TRITOSS3",	"TRITOSS4",	
"TRITOSS5",	"TRITOSS6",	"TRITOSS7",	"TRITOSS8",	
"TRIPAIN1",	"TRIPAIN2",	"TRIDIE1",	"TRIDIE2",	
"TRIDIE3",	"TRIDIE4",	"TRIDEAD",	"TRIWPN1",	
"TRIWPN2",	"TRIWDIE1",	"TRIWDIE2",	"TRIWDIE3",	
"TRIWDIE4",	"TRIWDEAD",	"ROBOGRD1",	"ROBOGRD2",	
"ROBOGRD3",	"ROBOGRD4",	"ROBOGRD5",	"ROBOGRD6",	
"ROBOGRD7",	"ROBOGRD8",	"ROBOGRD9",	"ROBGRD10",	
"ROBGRD11",	"ROBGRD12",	"ROBGRD13",	"ROBGRD14",	
"ROBGRD15",	"ROBGRD16",	"ROBODIE1",	"ROBODIE2",	
"ROBODIE3",	"ROBODIE4",	"ROBODIE5",	"ROBODIE6",	
"ROBODIE7",	"ROBODIE8",	"ROBODIE9",	"ROBODEAD",	
"EXPLOS1",	"EXPLOS2",	"EXPLOS3",	"EXPLOS4",	
"EXPLOS5",	"EXPLOS6",	"EXPLOS7",	"EXPLOS8",	
"EXPLOS9",	"EXPLOS10",	"EXPLOS11",	"EXPLOS12",	
"EXPLOS13",	"EXPLOS14",	"EXPLOS15",	"EXPLOS16",	
"EXPLOS17",	"EXPLOS18",	"EXPLOS19",	"EXPLOS20",	
"GREXP1",	"GREXP2",	"GREXP3",	"GREXP4",	
"GREXP5",	"GREXP6",	"GREXP7",	"GREXP8",	
"GREXP9",	"GREXP10",	"GREXP11",	"GREXP12",	
"GREXP13",	"GREXP14",	"GREXP15",	"GREXP16",	
"GREXP17",	"GREXP18",	"GREXP19",	"GREXP20",	
"GREXP21",	"GREXP22",	"GREXP23",	"GREXP24",	
"GREXP25",	"EXP1",		"EXP2",		"EXP3",	
"EXP4",		"EXP5",		"EXP6",		"EXP7",	
"EXP8",		"EXP9",		"EXP10",	"EXP11",	
"EXP12",	"EXP13",	"EXP14",	"EXP15",	
"EXP16",	"EXP17",	"EXP18",	"EXP19",	
"EXP20",	"UBLADE1",	"UBLADE2",	"UBLADE3",	
"UBLADE4",	"UBLADE5",	"UBLADE6",	"UBLADE7",	
"UBLADE8",	"UBLADE9",	"FJUP0",	"FJUP1",	
"FJUP2",	"FJUP3",	"FJUP4",	"FJUP5",	
"FJUP6",	"FJUP7",	"FJUP8",	"FJUP9",	
"FJUP10",	"FJUP11",	"FJUP12",	"FJUP13",	
"FJUP14",	"FJUP15",	"FJUP16",	"FJUP17",	
"FJUP18",	"FJUP19",	"FJUP20",	"FJUP21",	
"FJUP22",	"CRDOWN1",	"CRDOWN2",	"CRDOWN3",	
"CRDOWN4",	"CRDOWN5",	"CRDOWN6",	"CRDOWN7",	
"CRDOWN8",	"SPEARUP1",	"SPEARUP2",	"SPEARUP3",	
"SPEARUP4",	"SPEARUP5",	"SPEARUP6",	"SPEARUP7",	
"SPEARUP8",	"SPEARUP9",	"SPERUP10",	"SPERUP11",	
"SPERUP12",	"SPERUP13",	"SPERUP14",	"SPERUP15",	
"SPERUP16",	"SPRING1",	"SPRING2",	"SPRING3",	
"SPRING4",	"SPRING5",	"SPRING6",	"SPRING7",	
"SPRING8",	"SPRING9",	"SPRING10",	"FWALL1",	
"FWALL2",	"FWALL3",	"FWALL4",	"FWALL5",	
"FWALL6",	"FWALL7",	"FWALL8",	"FWALL9",	
"FWALL10",	"FWALL11",	"FWALL12",	"FWALL13",	
"FWALL14",	"FWALL15",	"GUTS1",	"GUTS2",	
"GUTS3",	"GUTS4",	"GUTS5",	"GUTS6",	
"GUTS7",	"GUTS8",	"GUTS9",	"GUTS10",	
"GUTS11",	"GUTS12",	"PART1",	"PART2",	
"PART5",	"PART6",	"PART7",	"PART8",	
"PART9",	"PART10",	"PART11",	"PART12",	
"PART13",	"PART14",	"ORGAN1",	"ORGAN2",	
"ORGAN3",	"ORGAN4",	"ORGAN5",	"ORGAN6",	
"ORGAN7",	"ORGAN8",	"ORGAN9",	"ORGAN10",	
"ORGAN11",	"ORGAN12",	"RIB1",		"RIB2",	
"RIB3",		"RIB4",		"RIB5",		"RIB6",	
"RIB7",		"RIB8",		"RIB9",		"RIB10",	
"RIB11",	"RIB12",	"GPINK1",	"GPINK2",	
"GPINK3",	"GPINK4",	"GPINK5",	"GPINK6",	
"GPINK7",	"GPINK8",	"GPINK9",	"GPINK10",	
"GPINK11",	"GPINK12",	"GHEAD1",	"GHEAD2",	
"GHEAD3",	"GHEAD4",	"GHEAD5",	"GHEAD6",	
"GHEAD7",	"GHEAD8",	"GHEAD9",	"GHEAD10",	
"GHEAD11",	"GHEAD12",	"GARM1",	"GARM2",	
"GARM3",	"GARM4",	"GARM5",	"GARM6",	
"GARM7",	"GARM8",	"GARM9",	"GARM10",	
"GARM11",	"GARM12",	"GLEG1",	"GLEG2",	
"GLEG3",	"GLEG4",	"GLEG5",	"GLEG6",	
"GLEG7",	"GLEG8",	"GLEG9",	"GLEG10",	
"GLEG11",	"GLEG12",	"GHUM1",	"GHUM2",	
"GHUM3",	"GHUM4",	"GHUM5",	"GHUM6",	
"GHUM7",	"GHUM8",	"GHUM9",	"GHUM10",	
"GHUM11",	"GHUM12",	"GHIP1",	"GHIP2",	
"GHIP3",	"GHIP4",	"GHIP5",	"GHIP6",	
"GHIP7",	"GHIP8",	"GHIP9",	"GHIP10",	
"GHIP11",	"GHIP12",	"GLIMB1",	"GLIMB2",	
"GLIMB3",	"GLIMB4",	"GLIMB5",	"GLIMB6",	
"GLIMB7",	"GLIMB8",	"GLIMB9",	"GLIMB10",	
"GLIMB11",	"GLIMB12",	"DHEAD",	"WGIB1",	
"WGIB2",	"WGIB3",	"WGIB4",	"GEYE1",	
"GEYE2",	"GEYE3",	"VAPO1",	"VAPO2",	
"VAPO3",	"VAPO4",	"VAPO5",	"VAPO6",	
"VAPO7",	"VAPO8",	"BIGSOUL",	"LITSOUL",	
"COLEC1",	"COLEC3",	"COLEC5",	"COLEC7",	
"COLEC9",	"COLEC11",	"COLEC13",	"COLEC15",	
"ITM1",		"ITM2",		"ITM3",		"ITM4",	
"ITM5",		"ITM6",		"ITM7",		"ITM8",	
"BSPURT1",	"BSPURT2",	"BSPURT3",	"BSPURT4",	
"BSPURT5",	"BSPURT6",	"BSPURT7",	"COOLGLO1",	
"COOLGLO2",	"COOLGLO3",	"COOLGLO4",	"COOLGLO5",	
"COOLGLO6",	"COOLGLO7",	"COOLGLO8",	"SKEL1",	
"SKEL2",	"SKEL3",	"SKEL4",	"SKEL5",	
"SKEL6",	"SKEL7",	"SKEL8",	"SKEL9",	
"SKEL10",	"SKEL11",	"SKEL12",	"SKEL13",	
"SKEL14",	"SKEL15",	"SKEL16",	"SKEL17",	
"SKEL18",	"SKEL19",	"SKEL20",	"SKEL21",	
"SKEL22",	"SKEL23",	"SKEL24",	"SKEL25",	
"SKEL26",	"SKEL27",	"SKEL28",	"SKEL29",	
"SKEL30",	"SKEL31",	"SKEL32",	"SKEL33",	
"SKEL34",	"SKEL35",	"SKEL36",	"SKEL37",	
"SKEL38",	"SKEL39",	"SKEL40",	"SKEL41",	
"SKEL42",	"SKEL43",	"SKEL44",	"SKEL45",	
"SKEL46",	"SKEL47",	"SKEL48",	"PUSHCOL1",	
"PSHCOL1A",	"BLOODS1",	"BLOODS2",	"BLOODS3",	
"BLOODS4",	"BLOODS5",	"BLOODS6",	"BLOODS7",	
"BLOODS8",	"GUNSMKE1",	"GUNSMKE2",	"GUNSMKE3",	
"GUNSMKE4",	"GUNSMKE5",	"GUNSMKE6",	"GUNSMKE7",	
"GUNSMKE8",	"HITMET1",	"HITMET2",	"HITMET3",	
"HITMET4",	"HITMACT1",	"HITMACT2",	"HITMACT3",	
"HITMACT4",	"PLATFRM1",	"PLATFRM2",	"PLATFRM3",	
"PLATFRM4",	"PLATFRM5",	"CRFIRE11",	"CRFIRE12",	
"CRFIRE13",	"CRFIRE14",	"CRFIRE15",	"CRFIRE16",	
"CRFIRE17",	"CRFIRE18",	"CRFIRE31",	"CRFIRE32",	
"CRFIRE33",	"CRFIRE34",	"CRFIRE35",	"CRFIRE36",	
"CRFIRE37",	"CRFIRE38",	"CREXP1",	"CREXP2",	
"CREXP3",	"CREXP4",	"CREXP5",	"GODFIRE1",	
"GODFIRE2",	"GODFIRE3",	"GODFIRE4",	"TEGREN1",	
"TEGREN2",	"TEGREN3",	"TEGREN4",	"TEGREN5",	
"TEGREN6",	"TEGREN7",	"TEGREN8",	"TEGREN9",	
"TEGREN10",	"TGRENF1",	"TGRENF2",	"TGRENF3",	
"TGRENF4",	"TGRENF5",	"TGRENF6",	"MINE1",	
"MINE2",	"MINE3",	"MINE4",	"BJMISS1",	
"BJMISS2",	"BJMISS3",	"BJMISS4",	"BJMISS5",	
"BJMISS6",	"BJMISS7",	"BJMISS8",	"BJMISS9",	
"BJMISS10",	"BJMISS11",	"BJMISS12",	"BJMISS13",	
"BJMISS14",	"BJMISS15",	"BJMISS16",	"BSTAR1",	
"BSTAR2",	"BSTAR3",	"BSTAR4",	"GODUP1",	
"GODUP2",	"GODUP3",	"GODUP4",	"GODUP5",	
"GODUP6",	"GODUP7",	"GODUP8",	"ELASTUP1",	
"ELASTUP2",	"ELASTUP3",	"ELASTUP4",	"ELASTUP5",	
"ELASTUP6",	"ELASTUP7",	"ELASTUP8",	"RNDOMUP1",	
"RNDOMUP2",	"RNDOMUP3",	"RNDOMUP4",	"RNDOMUP5",	
"RNDOMUP6",	"RNDOMUP7",	"RNDOMUP8",	"FEETUP1",	
"FEETUP2",	"FEETUP3",	"FEETUP4",	"FEETUP5",	
"FEETUP6",	"FEETUP7",	"FEETUP8",	"MUSHUP1",	
"MUSHUP2",	"MUSHUP3",	"MUSHUP4",	"MUSHUP5",	
"MUSHUP6",	"MUSHUP7",	"MUSHUP8",	"ONEUP1",	
"ONEUP2",	"ONEUP3",	"ONEUP4",	"ONEUP5",	
"ONEUP6",	"ONEUP7",	"ONEUP8",	"LIFE_A1",	
"LIFE_A2",	"LIFE_A3",	"LIFE_A4",	"LIFE_A5",	
"LIFE_A6",	"LIFE_A7",	"LIFE_A8",	"LIFE_B1",	
"LIFE_B2",	"LIFE_B3",	"LIFE_B4",	"LIFE_B5",	
"LIFE_B6",	"LIFE_B7",	"LIFE_B8",	"LIFE_C1",	
"LIFE_C2",	"LIFE_C3",	"LIFE_C4",	"LIFE_C5",	
"LIFE_C6",	"LIFE_C7",	"LIFE_C8",	"LIFE_C9",	
"LIFE_C10",	"LIFE_C11",	"LIFE_C12",	"LIFE_C13",	
"LIFE_C14",	"LIFE_C15",	"LIFE_D1",	"LIFE_D2",	
"LIFE_D3",	"LIFE_D4",	"LIFE_D5",	"LIFE_D6",	
"LIFE_D7",	"LIFE_D8",	"RUBBLE1",	"RUBBLE2",	
"RUBBLE3",	"RUBBLE4",	"RUBBLE5",	"RUBBLE6",	
"RUBBLE7",	"RUBBLE8",	"RUBBLE9",	"RUBBLE10",	
"WFRAG1",	"WFRAG2",	"WFRAG3",	"WFRAG4",	
"WFRAG5",	"WFRAG6",	"WFRAG7",	"WFRAG8",	
"WFRAG9",	"WFRAG10",	"WFRAG11",	"WFRAG12",	
"WFRAG13",	"WFRAG14",	"MISSMO11",	"MISSMO12",	
"MISSMO13",	"MISSMO14",	"ETOUCH1",	"ETOUCH2",	
"ETOUCH3",	"GKEY1",	"GKEY2",	"GKEY3",	
"GKEY4",	"GKEY5",	"GKEY6",	"GKEY7",	
"GKEY8",	"GKEY9",	"GKEY10",	"GKEY11",	
"GKEY12",	"GKEY13",	"GKEY14",	"GKEY15",	
"GKEY16",	"GIBS1",	"GIBS2",	"GIBS3",	
"BBARREL",	"TP1",		"TP2",		"TP3",	
"TP4",		"GARBAG3",	"SHITBUK",	"URN",	
"HAY",		"BULLETHO",	"ALTBHO",	"STNPOLE1",	
"STNPOLE2",	"STNPOLE3",	"STNPOLE4",	"STNPOLE5",	
"STNPOLE6",	"STNPOLE7",	"STNPOLE8",	"HGRATE1",	
"HGRATE2",	"HGRATE3",	"HGRATE4",	"YLIGHT",	
"RLIGHT",	"GLIGHT",	"BLIGHT",	"CHAND",	
"LAMPOFF",	"LAMP",		"MONKMEAL",	"ABRAZOFF",	
"ABRZO20",	"EXPLOSI",	"GARBAG1",	"GARBAG2",	
"GRATE",	"MSHARDS",	"PEDESTA",	"ETABLE",	
"STOOL",	"TREE",		"PLANT",	"IBARREL",	
"FBASIN1",	"FBASIN2",	"FBASIN3",	"EBASIN",	
"PPOR1",	"PPOR21",	"PPOR3",	"PPOR4",	
"PPOR5",	"PPOR6",	"MONKC11",	"MONKC12",	
"MONKC13",	"MONKC14",	"MONKC15",	"MONKC16",	
"MONKC21",	"MONKC22",	"MONKC23",	"MONKC24",	
"MONKC25",	"MONKC26",	"MONKC27",	"ABRAZ1",	
"ABRAZ2",	"ABRAZ3",	"ABRAZ4",	"ABRAZ5",	
"ABRAZ6",	"ABRAZ7",	"ABRAZ8",	"ABRAZ9",	
"ABRAZ10",	"ABRAZ11",	"ABRAZ12",	"ABRAZ13",	
"ABRAZ14",	"ABRAZ15",	"FFLAME1",	"FFLAME2",	
"FFLAME3",	"FFLAME4",	"FFLAME5",	"FFLAME6",	
"FFLAME7",	"TWOPIST",	"MP40",		"BAZOOKA",	
"FIREBOMB",	"HEATSEEK",	"DRUNK",	"FIREWALL",	
"KES",		"SPLITM",	"GASUP",	"PROOFUP",	
"ASBESTOS",	"PREPIT",	"POSTPIT",	"CASSHO11",	
"CASSHO12",	"CASSHO13",	"CASSHO14",	"CASSHO15",	
"CASSHO16",	"CASSHO17",	"CASSHO18",	"CASSHO21",	
"CASSHO22",	"CASSHO23",	"CASSHO24",	"CASSHO25",	
"CASSHO26",	"CASSHO27",	"CASSHO28",	"CAMSHO11",	
"CAMSHO12",	"CAMSHO13",	"CAMSHO14",	"CAMSHO15",	
"CAMSHO16",	"CAMSHO17",	"CAMSHO18",	"CAMSHO21",	
"CAMSHO22",	"CAMSHO23",	"CAMSHO24",	"CAMSHO25",	
"CAMSHO26",	"CAMSHO27",	"CAMSHO28",	"CASS1",	
"CASS2",	"CASS3",	"CASS4",	"CASS5",	
"CASS6",	"CASS7",	"CASS8",	"CASW11",	
"CASW12",	"CASW13",	"CASW14",	"CASW15",	
"CASW16",	"CASW17",	"CASW18",	"CASW21",	
"CASW22",	"CASW23",	"CASW24",	"CASW25",	
"CASW26",	"CASW27",	"CASW28",	"CASW31",	
"CASW32",	"CASW33",	"CASW34",	"CASW35",	
"CASW36",	"CASW37",	"CASW38",	"CASW41",	
"CASW42",	"CASW43",	"CASW44",	"CASW45",	
"CASW46",	"CASW47",	"CASW48",	"CASDIE1",	
"CASDIE2",	"CASDIE3",	"CASDIE4",	"CASDIE5",	
"CASDIE6",	"CASDEAD",	"CASWDIE1",	"CASWDIE2",	
"CASWDIE3",	"CASWDIE4",	"CASWDIE5",	"CASWDIE6",	
"CASWDEAD",	"BARSHO11",	"BARSHO12",	"BARSHO13",	
"BARSHO14",	"BARSHO15",	"BARSHO16",	"BARSHO17",	
"BARSHO18",	"BARSHO21",	"BARSHO22",	"BARSHO23",	
"BARSHO24",	"BARSHO25",	"BARSHO26",	"BARSHO27",	
"BARSHO28",	"BAMSHO11",	"BAMSHO12",	"BAMSHO13",	
"BAMSHO14",	"BAMSHO15",	"BAMSHO16",	"BAMSHO17",	
"BAMSHO18",	"BAMSHO21",	"BAMSHO22",	"BAMSHO23",	
"BAMSHO24",	"BAMSHO25",	"BAMSHO26",	"BAMSHO27",	
"BAMSHO28",	"BARS1",	"BARS2",	"BARS3",	
"BARS4",	"BARS5",	"BARS6",	"BARS7",	
"BARS8",	"BAMW11",	"BAMW12",	"BAMW13",	
"BAMW14",	"BAMW15",	"BAMW16",	"BAMW17",	
"BAMW18",	"BAMW21",	"BAMW22",	"BAMW23",	
"BAMW24",	"BAMW25",	"BAMW26",	"BAMW27",	
"BAMW28",	"BAMW31",	"BAMW32",	"BAMW33",	
"BAMW34",	"BAMW35",	"BAMW36",	"BAMW37",	
"BAMW38",	"BAMW41",	"BAMW42",	"BAMW43",	
"BAMW44",	"BAMW45",	"BAMW46",	"BAMW47",	
"BAMW48",	"BARDIE1",	"BARDIE2",	"BARDIE3",	
"BARDIE4",	"BARDIE5",	"BARDIE6",	"BARDEAD",	
"BARWDIE1",	"BARWDIE2",	"BARWDIE3",	"BARWDIE4",	
"BARWDIE5",	"BARWDIE6",	"BARWDEAD",	"WENSHO11",	
"WENSHO12",	"WENSHO13",	"WENSHO14",	"WENSHO15",	
"WENSHO16",	"WENSHO17",	"WENSHO18",	"WENSHO21",	
"WENSHO22",	"WENSHO23",	"WENSHO24",	"WENSHO25",	
"WENSHO26",	"WENSHO27",	"WENSHO28",	"WNMSHO11",	
"WNMSHO12",	"WNMSHO13",	"WNMSHO14",	"WNMSHO15",	
"WNMSHO16",	"WNMSHO17",	"WNMSHO18",	"WNMSHO21",	
"WNMSHO22",	"WNMSHO23",	"WNMSHO24",	"WNMSHO25",	
"WNMSHO26",	"WNMSHO27",	"WNMSHO28",	"WENS1",	
"WENS2",	"WENS3",	"WENS4",	"WENS5",	
"WENS6",	"WENS7",	"WENS8",	"WENW11",	
"WENW12",	"WENW13",	"WENW14",	"WENW15",	
"WENW16",	"WENW17",	"WENW18",	"WENW21",	
"WENW22",	"WENW23",	"WENW24",	"WENW25",	
"WENW26",	"WENW27",	"WENW28",	"WENW31",	
"WENW32",	"WENW33",	"WENW34",	"WENW35",	
"WENW36",	"WENW37",	"WENW38",	"WENW41",	
"WENW42",	"WENW43",	"WENW44",	"WENW45",	
"WENW46",	"WENW47",	"WENW48",	"WENDIE1",	
"WENDIE2",	"WENDIE3",	"WENDIE4",	"WENDIE5",	
"WENDIE6",	"WENDEAD",	"WENWDIE1",	"WENWDIE2",	
"WENWDIE3",	"WENWDIE4",	"WENWDIE5",	"WENWDIE6",	
"WENWDEAD",	"LNISHO11",	"LNISHO12",	"LNISHO13",	
"LNISHO14",	"LNISHO15",	"LNISHO16",	"LNISHO17",	
"LNISHO18",	"LNISHO21",	"LNISHO22",	"LNISHO23",	
"LNISHO24",	"LNISHO25",	"LNISHO26",	"LNISHO27",	
"LNISHO28",	"LNMSHO11",	"LNMSHO12",	"LNMSHO13",	
"LNMSHO14",	"LNMSHO15",	"LNMSHO16",	"LNMSHO17",	
"LNMSHO18",	"LNMSHO21",	"LNMSHO22",	"LNMSHO23",	
"LNMSHO24",	"LNMSHO25",	"LNMSHO26",	"LNMSHO27",	
"LNMSHO28",	"LNIS1",	"LNIS2",	"LNIS3",	
"LNIS4",	"LNIS5",	"LNIS6",	"LNIS7",	
"LNIS8",	"LNIW11",	"LNIW12",	"LNIW13",	
"LNIW14",	"LNIW15",	"LNIW16",	"LNIW17",	
"LNIW18",	"LNIW21",	"LNIW22",	"LNIW23",	
"LNIW24",	"LNIW25",	"LNIW26",	"LNIW27",	
"LNIW28",	"LNIW31",	"LNIW32",	"LNIW33",	
"LNIW34",	"LNIW35",	"LNIW36",	"LNIW37",	
"LNIW38",	"LNIW41",	"LNIW42",	"LNIW43",	
"LNIW44",	"LNIW45",	"LNIW46",	"LNIW47",	
"LNIW48",	"LNIDIE1",	"LNIDIE2",	"LNIDIE3",	
"LNIDIE4",	"LNIDIE5",	"LNIDIE6",	"LNIDEAD",	
"LNIWDIE1",	"LNIWDIE2",	"LNIWDIE3",	"LNIWDIE4",	
"LNIWDIE5",	"LNIWDIE6",	"LNIWDEAD",	"IPFSHO11",	
"IPFSHO12",	"IPFSHO13",	"IPFSHO14",	"IPFSHO15",	
"IPFSHO16",	"IPFSHO17",	"IPFSHO18",	"IPFSHO21",	
"IPFSHO22",	"IPFSHO23",	"IPFSHO24",	"IPFSHO25",	
"IPFSHO26",	"IPFSHO27",	"IPFSHO28",	"IPMSHO11",	
"IPMSHO12",	"IPMSHO13",	"IPMSHO14",	"IPMSHO15",	
"IPMSHO16",	"IPMSHO17",	"IPMSHO18",	"IPMSHO21",	
"IPMSHO22",	"IPMSHO23",	"IPMSHO24",	"IPMSHO25",	
"IPMSHO26",	"IPMSHO27",	"IPMSHO28",	"IPFS1",	
"IPFS2",	"IPFS3",	"IPFS4",	"IPFS5",	
"IPFS6",	"IPFS7",	"IPFS8",	"IPFW11",	
"IPFW12",	"IPFW13",	"IPFW14",	"IPFW15",	
"IPFW16",	"IPFW17",	"IPFW18",	"IPFW21",	
"IPFW22",	"IPFW23",	"IPFW24",	"IPFW25",	
"IPFW26",	"IPFW27",	"IPFW28",	"IPFW31",	
"IPFW32",	"IPFW33",	"IPFW34",	"IPFW35",	
"IPFW36",	"IPFW37",	"IPFW38",	"IPFW41",	
"IPFW42",	"IPFW43",	"IPFW44",	"IPFW45",	
"IPFW46",	"IPFW47",	"IPFW48",	"IPFDIE1",	
"IPFDIE2",	"IPFDIE3",	"IPFDIE4",	"IPFDIE5",	
"IPFDIE6",	"IPFDEAD",	"IPFWDIE1",	"IPFWDIE2",	
"IPFWDIE3",	"IPFWDIE4",	"IPFWDIE5",	"IPFWDIE6",	
"IPFWDEAD",	"DOGW11",	"DOGW12",	"DOGW13",	
"DOGW14",	"DOGW15",	"DOGW16",	"DOGW17",	
"DOGW18",	"DOGW21",	"DOGW22",	"DOGW23",	
"DOGW24",	"DOGW25",	"DOGW26",	"DOGW27",	
"DOGW28",	"DOGW31",	"DOGW32",	"DOGW33",	
"DOGW34",	"DOGW35",	"DOGW36",	"DOGW37",	
"DOGW38",	"DOGW41",	"DOGW42",	"DOGW43",	
"DOGW44",	"DOGW45",	"DOGW46",	"DOGW47",	
"DOGW48",	"DOGAT1",	"DOGAT2",	"DOGAT3",	
"DOGAT4",	"DOGAT5",	"DOGAT6",	"DOGAT7",	
"DOGAT8",	"OBPSHOO1",	"OBPSHOO2",	"OBPSHOO3",	
"OBPSHOO4",	"OBPBSHO1",	"OBPBSHO2",	"OBPBSHO3",	
"OBPBSHO4",	"OBPBSHO5",	"OBPS1",	"OBPS2",	
"OBPS3",	"OBPS4",	"OBPS5",	"OBPS6",	
"OBPS7",	"OBPS8",	"OBPW11",	"OBPW12",	
"OBPW13",	"OBPW14",	"OBPW15",	"OBPW16",	
"OBPW17",	"OBPW18",	"OBPW21",	"OBPW22",	
"OBPW23",	"OBPW24",	"OBPW25",	"OBPW26",	
"OBPW27",	"OBPW28",	"OBPW31",	"OBPW32",	
"OBPW33",	"OBPW34",	"OBPW35",	"OBPW36",	
"OBPW37",	"OBPW38",	"OBPW41",	"OBPW42",	
"OBPW43",	"OBPW44",	"OBPW45",	"OBPW46",	
"OBPW47",	"OBPW48",	"OBPPAIN1",	"OBPPAIN2",	
"OBPADIE1",	"OBPADIE2",	"OBPADIE3",	"OBPADIE4",	
"OBPADIE5",	"OBPADEAD",	"OBPWPN1",	"OBPWPN2",	
"OBPWDIE1",	"OBPWDIE2",	"OBPWDIE3",	"OBPWDIE4",	
"OBPWDIE5",	"OBPWDEAD",	"OBPDIE1",	"OBPDIE2",	
"OBPDIE3",	"OBPDIE4",	"OBPDIE5",	"OBPDIE6",	
"OBPDEAD",	"MONKDR1",	"MONKDR2",	"MONKDR3",	
"MONKDR4",	"MONKDR5",	"MONKDR6",	"MONS1",	
"MONS2",	"MONS3",	"MONS4",	"MONS5",	
"MONS6",	"MONS7",	"MONS8",	"MONW11",	
"MONW12",	"MONW13",	"MONW14",	"MONW15",	
"MONW16",	"MONW17",	"MONW18",	"MONW21",	
"MONW22",	"MONW23",	"MONW24",	"MONW25",	
"MONW26",	"MONW27",	"MONW28",	"MONW31",	
"MONW32",	"MONW33",	"MONW34",	"MONW35",	
"MONW36",	"MONW37",	"MONW38",	"MONW41",	
"MONW42",	"MONW43",	"MONW44",	"MONW45",	
"MONW46",	"MONW47",	"MONW48",	"MONPAIN1",	
"MONPAIN2",	"MONDIE1",	"MONDIE2",	"MONDIE3",	
"MONDIE4",	"MONDEAD",	"ALLKSH1",	"ALLKSH2",	
"ALLKSH3",	"ALLKSH4",	"ALLKSH5",	"ALLKSH6",	
"ALLKSH7",	"ALLS1",	"ALLS2",	"ALLS3",	
"ALLS4",	"ALLS5",	"ALLS6",	"ALLS7",	
"ALLS8",	"ALLW11",	"ALLW12",	"ALLW13",	
"ALLW14",	"ALLW15",	"ALLW16",	"ALLW17",	
"ALLW18",	"ALLW21",	"ALLW22",	"ALLW23",	
"ALLW24",	"ALLW25",	"ALLW26",	"ALLW27",	
"ALLW28",	"ALLW31",	"ALLW32",	"ALLW33",	
"ALLW34",	"ALLW35",	"ALLW36",	"ALLW37",	
"ALLW38",	"ALLW41",	"ALLW42",	"ALLW43",	
"ALLW44",	"ALLW45",	"ALLW46",	"ALLW47",	
"ALLW48",	"ALLPAIN1",	"ALLPAIN2",	"ALLDIE1",	
"ALLDIE2",	"ALLDIE3",	"ALLDIE4",	"ALLDEAD1",	
"ALLDEAD2",	"ALLDEAD3",	"ALLDEAD4",	"ALLDEAD5",	
"ALLDEAD6",	"ALLDEAD7",	"BCRAFT1",	"BCRAFT2",	
"BCRAFT3",	"BCRAFT4",	"BCRAFT5",	"BCRAFT6",	
"BCRAFT7",	"BCRAFT8",	"BCRAFT9",	"BCRAFT10",	
"BCRAFT11",	"BCRAFT12",	"BCRAFT13",	"BCRAFT14",	
"BCRAFT15",	"BCRAFT16",	"DARSHOO1",	"DARSHOO2",	
"DARSHOO3",	"DARSHOO4",	"DARDIS1",	"DARDIS2",	
"DARDIS3",	"DARDIS4",	"DARDIS5",	"DARDIS6",	
"DARDIS7",	"DARDIS8",	"DARS1",	"DARS2",	
"DARS3",	"DARS4",	"DARS5",	"DARS6",	
"DARS7",	"DARS8",	"DARW11",	"DARW12",	
"DARW13",	"DARW14",	"DARW15",	"DARW16",	
"DARW17",	"DARW18",	"DARW21",	"DARW22",	
"DARW23",	"DARW24",	"DARW25",	"DARW26",	
"DARW27",	"DARW28",	"DARW31",	"DARW32",	
"DARW33",	"DARW34",	"DARW35",	"DARW36",	
"DARW37",	"DARW38",	"DARW41",	"DARW42",	
"DARW43",	"DARW44",	"DARW45",	"DARW46",	
"DARW47",	"DARW48",	"DARPAIN1",	"DARPAIN2",	
"DARDIE1",	"DARDIE2",	"DARDIE3",	"DARDIE4",	
"DARDIE5",	"DARDIE6",	"DARDIE7",	"DARDIE8",	
"DARDIE9",	"DARDIE10",	"DARDEAD",	"DARWPN1",	
"DARWPN2",	"DARWDIE1",	"DARWDIE2",	"DARWDIE3",	
"DARWDIE4",	"DARWDIE5",	"DARWDIE6",	"DARWDIE7",	
"DARWDIE8",	"DARWDIE9",	"DARWDE10",	"DARWDEAD",	
"DARUSE11",	"DARUSE12",	"DARUSE13",	"DARUSE14",	
"DARUSE15",	"DARUSE16",	"DARUSE17",	"DARUSE18",	
"DARUSE21",	"DARUSE22",	"DARUSE23",	"DARUSE24",	
"DARUSE25",	"DARUSE26",	"DARUSE27",	"DARUSE28",	
"HSIT1",	"HSIT2",	"HSIT3",	"HSIT4",	
"HSIT5",	"HSIT6",	"HSIT7",	"HSIT8",	
"HLEFT1",	"HLEFT2",	"HLEFT3",	"HLEFT4",	
"HLEFT5",	"HLEFT6",	"HLEFT7",	"HLEFT8",	
"HSHOOT1",	"HSHOOT2",	"HSHOOT3",	"HSHOOT4",	
"HSHOOT5",	"HSHOOT6",	"HSHOOT7",	"HSHOOT8",	
"HSHOOT9",	"HSHOOT10",	"HSHOOT11",	"HDIE1",	
"HDIE2",	"HDEAD1",	"HDEAD2",	"HDEAD3",	
"HDEAD4",	"HDEAD5",	"HDEAD6",	"HDEAD7",	
"HDEAD8",	"HRIGHT1",	"HRIGHT2",	"HRIGHT3",	
"HRIGHT4",	"HRIGHT5",	"HRIGHT6",	"HRIGHT7",	
"HRIGHT8",	"HFOR1",	"HFOR2",	"HFOR3",	
"HFOR4",	"HFOR5",	"HFOR6",	"HFOR7",	
"HFOR8",	"HMRIGHT1",	"HMRIGHT2",	"HMRIGHT3",	
"HMRIGHT4",	"HMRIGHT5",	"HMRIGHT6",	"HMRIGHT7",	
"HMRIGHT8",	"HDOPE6",	"HDOPE7",	"HDOPE8",	
"RHEAD101",	"RHEAD102",	"RHEAD103",	"RHEAD104",	
"RHEAD105",	"RHEAD106",	"RHEAD107",	"RHEAD108",	
"RHEAD109",	"RHEAD110",	"RHEAD111",	"RHEAD112",	
"RHEAD113",	"RHEAD114",	"RHEAD115",	"RHEAD116",	
"RHEAD201",	"RHEAD202",	"RHEAD203",	"RHEAD204",	
"RHEAD205",	"RHEAD206",	"RHEAD207",	"RHEAD208",	
"RHEAD209",	"RHEAD210",	"RHEAD211",	"RHEAD212",	
"RHEAD213",	"RHEAD214",	"RHEAD215",	"RHEAD216",	
"RBODY101",	"RBODY102",	"RBODY103",	"RBODY104",	
"RBODY105",	"RBODY106",	"RBODY107",	"RBODY108",	
"RBODY109",	"RBODY110",	"RBODY111",	"RBODY112",	
"RBODY113",	"RBODY114",	"RBODY115",	"RBODY116",	
"RBODY201",	"RBODY202",	"RBODY203",	"RBODY204",	
"RBODY205",	"RBODY206",	"RBODY207",	"RBODY208",	
"RBODY209",	"RBODY210",	"RBODY211",	"RBODY212",	
"RBODY213",	"RBODY214",	"RBODY215",	"RBODY216",	
"RBODY301",	"RBODY302",	"RBODY303",	"RBODY304",	
"RBODY305",	"RBODY306",	"RBODY307",	"RBODY308",	
"RBODY309",	"RBODY310",	"RBODY311",	"RBODY312",	
"RBODY313",	"RBODY314",	"RBODY315",	"RBODY316",	
"RBODY401",	"RBODY402",	"RBODY403",	"RBODY404",	
"RBODY405",	"RBODY406",	"RBODY407",	"RBODY408",	
"RBODY409",	"RBODY410",	"RBODY411",	"RBODY412",	
"RBODY413",	"RBODY414",	"RBODY415",	"RBODY416",	
"RSW01",	"RSW02",	"RSW03",	"RSW04",	
"RSW05",	"RSW06",	"RSW07",	"RSW08",	
"RSW09",	"RSW10",	"RSW11",	"RSW12",	
"RSW13",	"RSW14",	"RSW15",	"RSW16",	
"RFW01",	"RFW02",	"RFW03",	"RFW04",	
"RFW05",	"RFW06",	"RFW07",	"RFW08",	
"RFW09",	"RFW10",	"RFW11",	"RFW12",	
"RFW13",	"RFW14",	"RFW15",	"RFW16",	
"RRW01",	"RRW02",	"RRW03",	"RRW04",	
"RRW05",	"RRW06",	"RRW07",	"RRW08",	
"RRW09",	"RRW10",	"RRW11",	"RRW12",	
"RRW13",	"RRW14",	"RRW15",	"RRW16",	
"RSDW01",	"RSDW02",	"RSDW03",	"RSDW04",	
"RSDW05",	"RSDW06",	"RSDW07",	"RSDW08",	
"RSDW09",	"RSDW10",	"RSDW11",	"RSDW12",	
"RSDW13",	"RSDW14",	"RSDW15",	"RSDW16",	
"RLW01",	"RLW02",	"RLW03",	"RLW04",	
"RLW05",	"RLW06",	"RLW07",	"RLW08",	
"RLW09",	"RLW10",	"RLW11",	"RLW12",	
"RLW13",	"RLW14",	"RLW15",	"RLW16",	
"ROCK01",	"ROCK02",	"ROCK03",	"ROCK04",	
"ROCK05",	"ROCK06",	"ROCK07",	"ROCK08",	
"ROCK09",	"ROCK10",	"ROCK11",	"ROCK12",	
"ROCK13",	"ROCK14",	"ROCK15",	"ROCK16",	
"ROCK201",	"ROCK202",	"ROCK203",	"ROCK204",	
"ROCK205",	"ROCK206",	"ROCK207",	"ROCK208",	
"ROCK209",	"ROCK210",	"ROCK211",	"ROCK212",	
"ROCK213",	"ROCK214",	"ROCK215",	"ROCK216",	
"NMEBALL1",	"NMEBALL2",	"NMEBALL3",	"NMEBALL4",	
"NMESAUC1",	"NMESAUC2",	"NMESAUC3",	"NMESAUC4",	
"TOMS1",	"TOMS2",	"TOMS3",	"TOMS4",	
"TOMS5",	"TOMS6",	"TOMS7",	"TOMS8",	
"TOMFLY11",	"TOMFLY12",	"TOMFLY13",	"TOMFLY14",	
"TOMFLY15",	"TOMFLY16",	"TOMFLY17",	"TOMFLY18",	
"TOMFLY21",	"TOMFLY22",	"TOMFLY23",	"TOMFLY24",	
"TOMFLY25",	"TOMFLY26",	"TOMFLY27",	"TOMFLY28",	
"TOMLG1",	"TOMLG2",	"TOMLG3",	"TOMLG4",	
"TOMLG5",	"TOMLG6",	"TOMLG7",	"TOMLG8",	
"TOMLG9",	"TOMLG10",	"TOMLG11",	"TOMFS1",	
"TOMFS2",	"TOMFS3",	"TOMFS4",	"TOMFS5",	
"TOMFS6",	"TOMBR1",	"TOMBR2",	"TOMBR3",	
"TOMBR4",	"TOMBR5",	"TOMBR6",	"TOMBR7",	
"TOMBR8",	"TOMHEAD1",	"TOMHEAD2",	"TOMHEAD3",	
"TOMHEAD4",	"TOMHEAD5",	"TOMHEAD6",	"TOMHEAD7",	
"TOMHEAD8",	"TPREP1",	"THDIE1",	"THDIE2",	
"TAWAKEN1",	"TAWAKEN2",	"TAWAKEN3",	"TAWAKEN4",	
"TAWAKEN5",	"THBALL1",	"THBALL2",	"THBALL3",	
"THBALL4",	"THBALL5",	"THBALL6",	"THBALL7",	
"THBALL8",	"THBALL9",	"TSPHERE1",	"TSPHERE2",	
"TSPHERE3",	"TSPHERE4",	"TSPHERE5",	"TSPHERE6",	
"TSPHERE7",	"TSPHERE8",	"TSPHERE9",	"TSPHER10",	
"TBBALL1",	"TBBALL2",	"TBBALL3",	"TBBALL4",	
"TBBALL5",	"TBBALL6",	"TBBALL7",	"TBBALL8",	
"TBBALL9",	"TSCAREB1",	"TSCAREB2",	"TSCAREB3",	
"TSCAREB4",	"TSCAREB5",	"TOMDIE1",	"TOMDIE2",	
"TOMDIE3",	"TOMDIE4",	"TOMDIE5",	"TOMDIE6",	
"TOMDIE7",	"TOMDIE8",	"TOMRH1",	"TOMRH2",	
"TOMRH3",	"TOMRH4",	"TOMRH5",	"TOMRH6",	
"TOMRH7",	"TOMRH8",	"TOHRH1",	"TOHRH2",	
"TOHRH3",	"TOHRH4",	"TOHRH5",	"TOHRH6",	
"TOHRH7",	"TOHRH8",	"SPEARDN1",	"SPEARDN2",	
"SPEARDN3",	"SPEARDN4",	"SPEARDN5",	"SPEARDN6",	
"SPEARDN7",	"SPEARDN8",	"SPEARDN9",	"SPERDN10",	
"SPERDN11",	"SPERDN12",	"SPERDN13",	"SPERDN14",	
"SPERDN15",	"SPERDN16",	"DBLADE1",	"DBLADE2",	
"DBLADE3",	"DBLADE4",	"DBLADE5",	"DBLADE6",	
"DBLADE7",	"DBLADE8",	"DBLADE9",	"FJDOWN0",	
"FJDOWN1",	"FJDOWN2",	"FJDOWN3",	"FJDOWN4",	
"FJDOWN5",	"FJDOWN6",	"FJDOWN7",	"FJDOWN8",	
"FJDOWN9",	"FJDOWN10",	"FJDOWN11",	"FJDOWN12",	
"FJDOWN13",	"FJDOWN14",	"FJDOWN15",	"FJDOWN16",	
"FJDOWN17",	"FJDOWN18",	"FJDOWN19",	"FJDOWN20",	
"FJDOWN21",	"FJDOWN22",	"CRUP1",	"CRUP2",	
"CRUP3",	"CRUP4",	"CRUP5",	"CRUP6",	
"CRUP7",	"CRUP8",	"SPSTUP1",	"SPSTUP2",	
"SPSTUP3",	"SPSTUP4",	"SPSTUP5",	"SPSTUP6",	
"SPSTUP7",	"SPSTUP8",	"SPSTUP9",	"SPSTUP10",	
"SPSTUP11",	"SPSTUP12",	"SPSTUP13",	"SPSTUP14",	
"SPSTUP15",	"SPSTUP16",	"SPSTDN1",	"SPSTDN2",	
"SPSTDN3",	"SPSTDN4",	"SPSTDN5",	"SPSTDN6",	
"SPSTDN7",	"SPSTDN8",	"SPSTDN9",	"SPSTDN10",	
"SPSTDN11",	"SPSTDN12",	"SPSTDN13",	"SPSTDN14",	
"SPSTDN15",	"SPSTDN16",	"DIPBAL11",	"DIPBAL21",	
"DIPBAL31",	"TOMLARV1",	"TOMLARV2",	"TOMLARV3",	
"TOMLARV4",	"SCTHEAD1",	"SCTHEAD2",	"SCTHEAD3",	
"SCTHEAD4",	"SCTHEAD5",	"SCTHEAD6",	"SCTHEAD7",	
"KSTATUE1",	"KSTATUE2",	"KSTATUE3",	"KSTATUE4",	
"KSTATUE5",	"KSTATUE6",	"KSTATUE7",	"KSTATUE8",	
"ESTATUE1",	"ESTATUE2",	"ESTATUE3",	"ESTATUE4",	
"ESTATUE5",	"ESTATUE6",	"ESTATUE7",	"ESTATUE8",	
"BATSPR1",	"BATSPR2",	"BATSPR3",	"BATSPR4",	
"BATSPR5",	"BATSPR6",	"BATSPR7",	"BATSPR8",	
"BATSPR9",	"BATSPR10",	"BATSPR11",	"BATSPR12",	
"BATSPR13",	"BATSPR14",	"BATSPR15",	"BATSPR16",	
"DOGUP1",	"DOGUP2",	"DOGUP3",	"DOGUP4",	
"DOGUP5",	"DOGUP6",	"DOGUP7",	"DOGUP8",	
"THREEUP1",	"THREEUP2",	"THREEUP3",	"THREEUP4",	
"THREEUP5",	"THREEUP6",	"THREEUP7",	"THREEUP8",	
"BOL11",	"BOL21",	"BOL31",	"BOL41",	
"BDROP1",	"BDROP2",	"BDROP3",	"BDROP4",	
"BDROP5",	"BDROP6",	"BDROP7",	"BDROP8",	
"BDROP9",	"BDROP10",	"BDROP11",	"BSINK1",	
"BSINK2",	"BSINK3",	"BSINK4",	"BSINK5",	
"BSINK6",	"BSINK7",	"BSINK8",	"BSINK9",	
"GRISE11",	"GRISE12",	"GRISE13",	"GRISE14",	
"GRISE15",	"GRISE16",	"GRISE17",	"GRISE18",	
"GRISE21",	"GRISE22",	"GRISE23",	"GRISE24",	
"GRISE25",	"GRISE26",	"GRISE27",	"GRISE28",	
"GRISE31",	"GRISE32",	"GRISE33",	"GRISE34",	
"GRISE35",	"GRISE36",	"GRISE37",	"GRISE38",	
"GRISE41",	"GRISE42",	"GRISE43",	"GRISE44",	
"GRISE45",	"GRISE46",	"GRISE47",	"GRISE48",	
"GRISE51",	"GRISE52",	"GRISE53",	"GRISE54",	
"GRISE55",	"GRISE56",	"GRISE57",	"GRISE58",	
"GFIRE1",	"GFIRE2",	"GFIRE3",	"GFIRE4",	
"GFIRE5",	"GFIRE6",	"GFIRE7",	"GFIRE8",	
"GDEAD1",	"GDEAD2",	"GUNEMP1",	"GUNEMP2",	
"GUNEMP3",	"GUNEMP4",	"GUNEMP5",	"GUNEMP6",	
"GUNEMP7",	"GUNEMP8",	"GUNEMPF1",	"GUNEMPF2",	
"GUNEMPF3",	"GUNEMPF4",	"GUNEMPF5",	"GUNEMPF6",	
"GUNEMPF7",	"GUNEMPF8",	"LIGNING1",	"LIGNING2",	
"LIGNING3",	"LIGNING4",	"LIGNING5",	"LIGNING6",	
"LIGNING7",	"LIGNING8",	"TSPHERE1",	"TSPHERE2",	
"TSPHERE3",	"TSPHERE4",	"HNDBALL1",	"HNDBALL2",	
"FACBALL1",	"FACBALL2",	"FSPARK1",	"FSPARK2",	
"FSPARK3",	"FSPARK4",	"SPIT1",	"SPIT2",	
"SPIT3",	"SPIT4",	"SPITHIT1",	"SPITHIT2",	
"SPITHIT3",	"SPITHIT4",	"MONFIRE1",	"MONFIRE2",	
"MONFIRE3",	"MONFIRE4",	"BATFIRE1",	"BATFIRE2",	
"BATFIRE3",	"BATFIRE4",	"KSPHERE1",	"KSPHERE2",	
"KSPHERE3",	"KSPHERE4",	"KSPHERE5",	"KSPHERE6",	
"KSPHERE7",	"KSPHERE8",	"OBBOLO1",	"OBBOLO2",	
"OBBOLO3",	"OBBOLO4",	"SHAPSTOP",	
NULL
};

/*
==================
=
= SetupGameLevel
=
==================
*/
void SetupGameLevel (void)
{
	char *s;
	int crud;
	int i, j, k;

#if 0
	mapwidth = mapheight = 128;

	InsaneDump();
	/*
	for(i=0;i<11;i++)
	{GetEpisode(i);
		LoadROTTMap(i);
		MapDebug("\n//================================//");
		MapDebug("\n//	SHAREWARE LEVEL %d				//",i);
		MapDebug("\n//================================//\n\n");

		PrintTileStats();
	}
	*/
	Error("okay");
#endif

	insetupgame=true;

	InitializeRNG ();

	if ((demoplayback==true) || (demorecord==true))
		SetRNGindex ( 0 );

	if (gamestate.randomseed!=-1)
		SetRNGindex ( gamestate.randomseed );

	if (tedlevel)
		{
		GetEpisode (tedlevelnum);
		LoadROTTMap(tedlevelnum);
		gamestate.mapon=tedlevelnum;
		}
	else
	{
		GetEpisode (gamestate.mapon);
		LoadROTTMap(gamestate.mapon);
	}

	rott_iswolf=false;
	if ((word)MAPSPOT(3,0,1)==99)
		rott_iswolf=true;

	if (DoPanicMapping())
		{
		DoLowMemoryConversion();
		}

	if ( gamestate.Product == ROTT_SHAREWARE )
		{
		DoSharewareConversion ();
		}
	else
		{
		DoRegisterConversion ();
		}

	if ( (NewGame) || (lastlevelloaded!=gamestate.mapon) )
		{
		SetupPreCache();
		lastlevelloaded=gamestate.mapon;
		MU_StartSong(song_level);
		}
	shapestart = W_GetNumForName("SHAPSTRT");
	shapestop = W_GetNumForName("SHAPSTOP");
	gunsstart=W_GetNumForName("GUNSTART");

	rott_shapestrt = shapestart;
	rott_shapestop = shapestop;

	printf("Sprite Count %d\n", (shapestop-shapestart));

	for(i=0; i<(shapestop-shapestart); i++)
	{
//		j = shapestart+i;
//		s = W_GetNameForNum(j);
		s = rt_shapenames[i];
		if(!s)
			break;
//		if(!strncmp(s, "MON", 3))
//			__debugbreak();
		k = W_GetNumForName(s);
		if(j!=k)
		{
//			if((k>shapestart) && (k<rott_shapestop))
//				k=j;
		}
		if(j!=k)
			printf("Remap Sprite %d->%d\n", j, k);
		rott_shapecache[i] = k;
	}

	playstate = ex_stillplaying;
	SNAKELEVEL = 0;
	whichpath = 0;

	InitializePlayerstates();

	ResetCheatCodes();

	gamestate.killtotal	= gamestate.killcount	= 0;
	gamestate.secrettotal	= gamestate.secretcount	= 0;
	gamestate.treasuretotal = gamestate.treasurecount = 0;
	gamestate.supertotal	= gamestate.supercount	= 0;
	gamestate.healthtotal	= gamestate.healthcount	= 0;
	gamestate.missiletotal  = gamestate.missilecount  = 0;
	gamestate.democratictotal = gamestate.democraticcount = 0;
	gamestate.planttotal	= gamestate.plantcount	= 0;
	gamestate.DODEMOCRATICBONUS1 = true;
	gamestate.DOGROUNDZEROBONUS  = false;

	if (gamestate.mapon == 30)
	SNAKELEVEL = 1;
	else if (gamestate.mapon == 32)
	SNAKELEVEL = 2;
	else if (gamestate.mapon == 33)
	SNAKELEVEL = 3;

	InitAreas();
	InitDoorList();
	InitElevators();
	if (loadedgame==false)
		{
		InitStaticList ();
		InitActorList();
		}
	memset (tilemap,0,sizeof(tilemap));
	memset (actorat,0,sizeof(actorat));
	memset (sprites,0,sizeof(sprites));
	memset (mapseen,0,sizeof(mapseen));
	memset (LightsInArea,0,sizeof(LightsInArea));

	PrintTileStats();

	SetupLightLevels();

	crud=(word)MAPSPOT(0,0,1);
	if ((crud>=90) && (crud<=97))
		{
		levelheight=crud-89;
		maxheight = (levelheight << 6)-32;
		nominalheight = maxheight-32;
		}
	else if ((crud>=450) && (crud<=457))
		{
		levelheight=crud-450+9;
		maxheight = (levelheight << 6)-32;
		nominalheight = maxheight-32;
		}
	else
		Error("You must specify a valid height sprite icon at (2,0) on map %ld\n",gamestate.mapon);

/*
	if ( ( BATTLEMODE ) && ( !gamestate.BattleOptions.SpawnDangers ) )
		{
		RemoveDangerWalls();
		}
*/
// pheight=maxheight-32;
	CountAreaTiles();
	SetupWalls();

	SetupClocks();
	SetupAnimatedWalls();

	if (loadedgame==false)
		{
		SetupSwitches();
		SetupStatics ();
		SetupMaskedWalls();
		SetupDoors();
		SetupPushWalls();
		SetupPlayers();
		if (!BATTLEMODE)
			{
			SetupActors();
			SetupRandomActors();
			}
		SetupElevators();
		SetupDoorLinks();
		SetupPushWallLinks();
		FixDoorAreaNumbers();
		FixMaskedWallAreaNumbers();
		SetupWindows();
		SetupLights();
		SetupInanimateActors();
		}
	else
		FixTiles();

	if (gamestate.SpawnEluder || gamestate.SpawnDeluder)
		{
//MED
		for (i=0;i<25;i++)
			RespawnEluder();
		}


	if ( ( BATTLEMODE ) && ( MapSpecials & MAP_SPECIAL_TOGGLE_PUSHWALLS ) )
		{
		ActivateAllPushWalls();
		}
	Illuminate();

	if (SNAKELEVEL == 1)
		SetupSnakePath();

	LoftSprites();

	SetPlaneViewSize();
	if (loadedgame==false)
		{
		ConnectAreas();
#if (DEVELOPMENT == 1)
#if (PRECACHETEST == 1)
		SoftError("Start PreCaching\n");
#endif
#endif
#if (DEVELOPMENT == 1)
		PrintMapStats();
#endif
		PreCache();
#if (DEVELOPMENT == 1)
#if (PRECACHETEST == 1)
		SoftError("Done PreCaching\n");
#endif
#endif
		SetupPlayScreen();
		SetupScreen(false);
		}

	if (BATTLEMODE)
		{
		SetModemLightLevel ( gamestate.BattleOptions.LightLevel );
		}

	for (i=0;i<100;i++)
		UpdateLightLevel(player->areanumber);
	insetupgame=false;

	tedlevel = false;	// turn it off once we have done any ted stuff
}


void InitializePlayerstates(void)
{int i;
	playertype * pstate;

	if (NewGame || (gamestate.mapon == 0) || tedlevel)
		{for(i=0;i<numplayers;i++)
			InitializeWeapons(&PLAYERSTATE[i]);
		}

	for(i=0;i<numplayers;i++)
	{
	pstate=&PLAYERSTATE[i];
	if (
			(pstate->missileweapon == wp_godhand)
#if (SHAREWARE == 0)
			||
			(pstate->missileweapon == wp_dog)
#endif
		)
		{
		pstate->weapon=pstate->new_weapon=pstate->oldweapon;
		pstate->missileweapon = pstate->oldmissileweapon;

		}

	ResetPlayerstate(pstate);
	}

	NewGame = false;

}


void SetupSnakePath(void)
{
#if (SHAREWARE == 0)
	int i,j;
	word *map,tile;

	if(rott_iswolf)
		return;

	map = mapplanes[1];

	for(j=0;j<mapheight;j++)
	for(i=0;i<mapwidth;i++)
	{tile = *map++;
	if ((tile >= 72) && (tile <= 79) && (!tilemap[i][j]))
	{SNAKEPATH[whichpath].x = i;
		SNAKEPATH[whichpath].y = j;
		whichpath ++;
	}

	}
#endif
}


void SetupRandomActors(void)
{
	int i, j, k, lim;
	word *map,tile;
	int starti,totalrandom=0,count=0,ambush,locindex,orig;
	byte actorpresent[10]={0},index=0,randomtype,used[100]={0};
	_2Dpoint randloc[100];

	map = mapplanes[1];
	map+=5;
	for(i=0;i<10;i++)
	{
		if (RANDOMACTORTYPE[i])
			actorpresent[index++]=i;
	}

	for(i=0;i<100;i++)
		used[i]=0;

	if (!index)
		return;

	for (j=0;j<mapheight;j++)
	{
		if (j==0)
			starti=5;
		else
			starti=0;
		for(i=starti;i<mapwidth;i++)
		{
			tile= *map++;

			if ((tile >= 122) && (tile <= 125))
			{
				randloc[totalrandom].x = i;
				randloc[totalrandom].y = j;
				totalrandom++;
				if (totalrandom >= 100)
					Error("Max random actors (100) exceeded");
			}

		}
	}

	orig = totalrandom;
	switch(gamestate.difficulty)
	{
	case gd_baby:
		totalrandom = 7*totalrandom/10;
		break;

	case gd_easy:
		totalrandom = 8*totalrandom/10;
		break;

	case gd_medium:
		totalrandom = 9*totalrandom/10;
		break;

	default:
		break;
	}

#if 1
	lim=totalrandom*10;
//	while(count<totalrandom)
	while((count<totalrandom) && ((lim--)>0))
	{
		locindex = (GameRandomNumber("rand loc index",0) % orig);

		if (!used[locindex])
		{
			randomtype = actorpresent[
				GameRandomNumber("SetupRandomActors",0) % index];
			ambush = (GameRandomNumber("rand actor",0) < 128);
			i = randloc[locindex].x;
			j = randloc[locindex].y;
			SpawnStand(randomtype,i,j,tile-122,ambush);
			used[locindex] = 1;
			PreCacheActor(randomtype,0);
			count++;
		}
	}
	
	if(count<totalrandom)
	{
		printf("SetupRandomActors %d/%d\n", count, totalrandom);
	}
#endif

#if 0
	for(i=0; i<orig; i++)
		used[i]=i;
	for(i=0; i<orig; i++)
	{
		j=GameRandomNumber("SetupRandomActors",0) % orig;
		k=used[i];
		used[i]=used[j];
		used[j]=k;
	}

	for(count=0; count<totalrandom; count++)
	{
		locindex = used[count];

		randomtype = actorpresent[
			GameRandomNumber("SetupRandomActors",0) % index];
		ambush = (GameRandomNumber("rand actor",0) < 128);
		i = randloc[locindex].x;
		j = randloc[locindex].y;
		SpawnStand(randomtype,i,j,tile-122,ambush);
		PreCacheActor(randomtype,0);
	}
#endif
}

// void SetupActors_Wolf(int x, int w, int tile)
// {
// }

void SetupActors(void)
{
	int i,j;
	word *map,tile;
	int starti;


	//GetRainActors();

	map = mapplanes[1];
	map+=5;

	for (j=0;j<mapheight;j++)
		{
		if (j==0)
			starti=5;
		else
			starti=0;

		for(i=starti;i<mapwidth;i++)
		{
			tile= *map++;

			if(rott_iswolf)
			{
//				SetupActors_Wolf(i, j, tile);
//				continue;
				tile=RemapObjTile_Wolf(i, j, tile);
				if(tile<=0)
					continue;
			}

			switch(tile)
			{

				case 126:
				case 127:
				case 128:
				case 129:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 108:
				case 109:
				case 110:
				case 111:
					SpawnStand(lowguardobj,i,j,tile-108,0);
					break;




				case 130:
				case 131:
				case 132:
				case 133:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 112:
				case 113:
				case 114:
				case 115:
					SpawnPatrol(lowguardobj,i,j,tile-112);
					break;

				case 134:
				case 135:
				case 136:
				case 137:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 116:
				case 117:
				case 118:
				case 119:
					if(rott_iswolf)
					{
						SpawnStand(blitzguardobj,i,j,tile-116,1);
						break;
					}

					SpawnStand(lowguardobj,i,j,tile-116,1);
					break;

				case 138:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 120:
//				case 121:
//				case 122:
//				case 123:
					if(rott_iswolf)
					{
						SpawnPatrol(blitzguardobj,i,j,tile-120);
						break;
					}

					SpawnSneaky(i,j);
					break;

				case 162:
				case 163:
				case 164:
				case 165:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 144:
				case 145:
				case 146:
				case 147:
					SpawnStand(highguardobj,i,j,tile-144,0);
					break;

				case 170:
				case 171:
				case 172:
				case 173:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 152:
				case 153:
				case 154:
				case 155:
					SpawnStand(highguardobj,i,j,tile-152,1);
					break;



				case 166:
				case 167:
				case 168:
				case 169:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 148:
				case 149:
				case 150:
				case 151:
					SpawnPatrol(highguardobj,i,j,tile-148);
					break;

				case 176:
				case 177:
				case 178:
				case 179:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 158:
				case 159:
				case 160:
				case 161:
					SpawnPatrol(roboguardobj,i,j,tile-158);
					break;

				case 212:
				case 213:
				case 214:
				case 215:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 194:
				case 195:
				case 196:
				case 197:
					SpawnGunThingy(patrolgunobj,i,j,tile-194);
					break;

				case 198:
				case 199:
				case 200:
				case 201:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 180:
				case 181:
				case 182:
				case 183:
					SpawnStand(strikeguardobj,i,j,tile-180,0);
					break;

				case 206:
				case 207:
				case 208:
				case 209:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 188:
				case 189:
				case 190:
				case 191:
					SpawnStand(strikeguardobj,i,j,tile-188,1);
					break;

				case 202:
				case 203:
				case 204:
				case 205:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 184:
				case 185:
				case 186:
				case 187:
					SpawnPatrol(strikeguardobj,i,j,tile-184);
					break;

				case 234:
				case 235:
				case 236:
				case 237:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 216:
				case 217:
				case 218:
				case 219:
					SpawnStand(overpatrolobj,i,j,tile-216,0);
					break;

				case 242:
				case 243:
				case 244:
				case 245:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 224:
				case 225:
				case 226:
				case 227:
					SpawnStand(overpatrolobj,i,j,tile-224,1);
					break;

				case 238:
				case 239:
				case 240:
				case 241:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 220:
				case 221:
				case 222:
				case 223:
					SpawnPatrol(overpatrolobj,i,j,tile-220);
					break;
				case 306:
				case 307:
				case 308:
				case 309:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 288:
				case 289:
				case 290:
				case 291:
					SpawnStand(triadenforcerobj,i,j,tile-288,0);
					break;

				case 314:
				case 315:
				case 316:
				case 317:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 296:
				case 297:
				case 298:
				case 299:
					SpawnStand(triadenforcerobj,i,j,tile-296,1);
					break;

				case 310:
				case 311:
				case 312:
				case 313:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 292:
				case 293:
				case 294:
				case 295:
					SpawnPatrol(triadenforcerobj,i,j,tile-292);
					break;

				case 342:
				case 343:
				case 344:
				case 345:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 324:
				case 325:
				case 326:
				case 327:
					SpawnStand(blitzguardobj,i,j,tile-324,0);
					break;

				case 350:
				case 351:
				case 352:
				case 353:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 332:
				case 333:
				case 334:
				case 335:
					SpawnStand(blitzguardobj,i,j,tile-332,1);
					break;

				case 346:
				case 347:
				case 348:
				case 349:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;
				case 328:
				case 329:
				case 330:
				case 331:
					SpawnPatrol(blitzguardobj,i,j,tile-328);
					break;

				case 378:
				case 379:
				case 380:
				case 381:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 360:
				case 361:
				case 362:
				case 363:
					SpawnStand(deathmonkobj,i,j,tile-360,0);
					break;

				case 386:
				case 387:
				case 388:
				case 389:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 368:
				case 369:
				case 370:
				case 371:
					SpawnStand(deathmonkobj,i,j,tile-368,1);
					break;

				case 382:
				case 383:
				case 384:
				case 385:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 364:
				case 365:
				case 366:
				case 367:
					SpawnPatrol(deathmonkobj,i,j,tile-364);
					break;

				case 414:
				case 415:
				case 416:
				case 417:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 396:
				case 397:
				case 398:
				case 399:
					SpawnStand(dfiremonkobj,i,j,tile-396,0);
					break;



				case 422:
				case 423:
				case 424:
				case 425:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;


				case 404:
				case 405:
				case 406:
				case 407:
					SpawnStand(dfiremonkobj,i,j,tile-404,1);
					break;

				case 418:
				case 419:
				case 420:
				case 421:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 400:
				case 401:
				case 402:
				case 403:
					SpawnPatrol(dfiremonkobj,i,j,tile-400);
					break;

				case 99:
					SpawnStand(b_darianobj,i,j,tile-99,0);
					break;
				case 100:
					SpawnStand(b_heinrichobj,i,j,tile-100,0);
					break;
				case 101:
					SpawnStand(b_darkmonkobj,i,j,tile-101,0);
					MISCVARS->TOMLOC.x = i;
					MISCVARS->TOMLOC.y = j;
					break;
				case 102:
					SpawnMultiSpriteActor(b_robobossobj,i,j,tile-102);
					break;

				case 103:
					SpawnSnake(i,j);
					break;

				case 426:
				case 427:
				case 428:
				case 429:
					if (gamestate.difficulty < gd_hard)
						break;
					tile -= 18;

				case 408:
				case 409:
				case 410:
				case 411:
					SpawnPatrol(wallopobj,i,j,tile-408);
					break;


			}
		}
	}
}

void SetupStatics(void)
{
	int i,j,spawnz;
	word *map,tile;
	int starti;

	map = mapplanes[1];
	map+=5;

	BATTLE_NumCollectorItems = 0;
	for (j=0;j<mapheight;j++)
		{
		if (j==0)
			starti=5;
		else
			starti=0;
		for(i=starti;i<mapwidth;i++)
			{
			tile= *map++;
			spawnz = (MAPSPOT(i,j,2))?(MAPSPOT(i,j,2)):(-1);

			if(rott_iswolf)
			{
				tile=RemapObjTile_Wolf(i, j, tile);
				if(tile<=0)
					continue;
			}

			if ( gamestate.BattleOptions.RandomWeapons )
				{
				int num;

				switch( tile )
					{
					case 46:
					case 48:
					case 49:
					case 50:
					case 51:
					case 52:
					case 53:
					case 54:
					case 55:
					case 56:
						if ( gamestate.Product == ROTT_SHAREWARE )
							{
							num = ( GameRandomNumber( "Random Weapon", 0 ) % 7 );
							tile = SharewareWeaponTiles[ num ];
							}
						else
							{
							num = ( GameRandomNumber( "Random Weapon", 1 ) % 10 );
							tile = NormalWeaponTiles[ num ];
							}
						break;
					}
				}

			switch (tile)
				{

				// Add light sourcing to these objects

				case 23:
				case 24:
				case 25:
				case 26:
				case 27:
				case 28:
				case 42:
				case 43:
				case 63:
				case 64:
						SpawnStatic(i,j,tile-23,spawnz);
					break;

				case 44:
						SpawnStatic(i,j,tile-23,spawnz);
					if (loadedgame == false)
					{
						gamestate.healthtotal ++;
						gamestate.democratictotal ++;
					}
					break;


				case 36:
				case 37:
				case 38:
				case 39:
						SpawnStatic(i,j,tile-23,spawnz);
					if (loadedgame == false)
						gamestate.healthtotal ++;
					break;

				case 29:
				case 30:
				case 31:
				case 32:
					if (IsDoor (i, j) == 0)
						{
						if ( BATTLEMODE )
							{
							// Spawn empty table
							SpawnStatic( i, j, 247 - 246 + 57, spawnz );
							}
						else
							{
							// Spawn key table
							SpawnStatic( i, j, tile - 23, spawnz );
							}
						}
					break;

				case 33:
				case 34:
				case 35:
				case 40:
				case 41:
				case 45:
						SpawnStatic(i,j,tile-23,spawnz);
					break;

				case 46:
					#if (SHAREWARE == 1)
					Error("\n tried to spawn excalibat at %d,%d in shareware !",i,j);
					#endif


					SD_PreCacheSoundGroup(SD_EXCALIBOUNCESND,SD_EXCALIBLASTSND);


					PreCacheGroup(W_GetNumForName("EXBAT1"),
									W_GetNumForName("EXBAT7"));



						SpawnStatic(i,j,tile-23,spawnz);
					if (loadedgame == false)
						gamestate.missiletotal ++;
					break;
				case 47:
					PreCacheGroup(W_GetNumForName("KNIFE1"),
									W_GetNumForName("KNIFE10"));
					PreCacheGroup(W_GetNumForName("ESTATUE1"),
									W_GetNumForName("ESTATUE8"));

						SpawnStatic(i,j,tile-23,spawnz);
					break;

				case 48:
					SD_PreCacheSound(SD_ATKTWOPISTOLSND);

					if ((locplayerstate->player == 1) || (locplayerstate->player == 3))
					PreCacheGroup(W_GetNumForName("RFPIST1"),
										W_GetNumForName("LFPIST3"));

					else if (locplayerstate->player == 2)
					PreCacheGroup(W_GetNumForName("RBMPIST1"),
										W_GetNumForName("LBMPIST3"));

					else
					PreCacheGroup(W_GetNumForName("RMPIST1"),
										W_GetNumForName("LMPIST3"));

					SpawnStatic(i,j,tile-23,spawnz);

					break;
				case 49:

					SD_PreCacheSound(SD_ATKMP40SND);
					PreCacheGroup(W_GetNumForName("MP401"),
									W_GetNumForName("MP403"));
						SpawnStatic(i,j,tile-23,spawnz);
					break;

				case 50:
					SD_PreCacheSound(SD_MISSILEHITSND);
					SD_PreCacheSound(SD_MISSILEFLYSND);
					SD_PreCacheSound(SD_BAZOOKAFIRESND);
					PreCacheGroup(W_GetNumForName("BAZOOKA1"),
									W_GetNumForName("BAZOOKA4"));
						SpawnStatic(i,j,tile-23,spawnz);
					if (loadedgame == false)
						gamestate.missiletotal ++;
					break;
				case 51:


					SD_PreCacheSound(SD_MISSILEHITSND);
					SD_PreCacheSound(SD_MISSILEFLYSND);
					SD_PreCacheSound(SD_FIREBOMBFIRESND);
					PreCacheGroup(W_GetNumForName("FBOMB1"),
									W_GetNumForName("FBOMB4"));
						SpawnStatic(i,j,tile-23,spawnz);
					if (loadedgame == false)
						gamestate.missiletotal ++;
					break;
				case 52:
					SD_PreCacheSound(SD_MISSILEHITSND);
					SD_PreCacheSound(SD_MISSILEFLYSND);
					SD_PreCacheSound(SD_HEATSEEKFIRESND);
					PreCacheGroup(W_GetNumForName("HSEEK1"),
									W_GetNumForName("HSEEK4"));
						SpawnStatic(i,j,tile-23,spawnz);
					if (loadedgame == false)
						gamestate.missiletotal ++;
					break;
				case 53:
					SD_PreCacheSound(SD_MISSILEHITSND);
					SD_PreCacheSound(SD_MISSILEFLYSND);
					SD_PreCacheSound(SD_DRUNKFIRESND);
					PreCacheGroup(W_GetNumForName("DRUNK1"),
									W_GetNumForName("DRUNK4"));
						SpawnStatic(i,j,tile-23,spawnz);
					if (loadedgame == false)
						gamestate.missiletotal ++;
					break;
				case 54:
					SD_PreCacheSound(SD_MISSILEHITSND);
					SD_PreCacheSound(SD_MISSILEFLYSND);
					SD_PreCacheSound(SD_FLAMEWALLFIRESND);
					SD_PreCacheSound(SD_FLAMEWALLSND);
					PreCacheGroup(W_GetNumForName("FIREW1"),
									W_GetNumForName("FIREW3"));
					PreCacheGroup(W_GetNumForName("FWALL1"),
									W_GetNumForName("FWALL15"));
					PreCacheGroup(W_GetNumForName("SKEL1"),
									W_GetNumForName("SKEL48"));
						SpawnStatic(i,j,tile-23,spawnz);
					if (loadedgame == false)
						gamestate.missiletotal ++;
					break;
				case 55:
					#if (SHAREWARE == 1)
					Error("\n tried to spawn split missile at %d,%d in shareware !",i,j);
					#endif
					SD_PreCacheSound(SD_MISSILEHITSND);
					SD_PreCacheSound(SD_MISSILEFLYSND);
					SD_PreCacheSound(SD_SPLITFIRESND);
					SD_PreCacheSound(SD_SPLITSND);
					PreCacheGroup(W_GetNumForName("SPLIT1"),
									W_GetNumForName("SPLIT4"));
						SpawnStatic(i,j,tile-23,spawnz);
					if (loadedgame == false)
						gamestate.missiletotal ++;
					break;
				case 56:
					#if (SHAREWARE == 1)
					Error("\n tried to spawn kes at %d,%d in shareware !",i,j);
					#endif



					SD_PreCacheSound(SD_GRAVSND);
					SD_PreCacheSound(SD_GRAVHITSND);
					SD_PreCacheSound(SD_GRAVFIRESND);
					SD_PreCacheSound(SD_GRAVBUILDSND);

					PreCacheGroup(W_GetNumForName("KES1"),
									W_GetNumForName("KES6"));
					PreCacheGroup(W_GetNumForName("KSPHERE1"),
									W_GetNumForName("KSPHERE4"));
						SpawnStatic(i,j,tile-23,spawnz);
					if (loadedgame == false)
						gamestate.missiletotal ++;
					break;

				case 57:
				case 58:
				case 59:
				case 60:
				case 61:
				case 62:
				case 65:
				case 66:
				case 67:
						SpawnStatic(i,j,tile-23,spawnz);
					break;

				case 68:
				case 69:
				case 70:
				case 71:
						SpawnStatic(i,j,tile-23,spawnz);
					break;

				case  98:
						SpawnStatic(i,j,tile-98+49,spawnz);
					break;

				case 210:
						SpawnStatic(i,j,stat_scotthead,spawnz);
					break;

				case 228:
				case 229:
				case 230:
				case 231:
				case 232:
				case 233:
						SpawnStatic(i,j,tile-228+51,spawnz);
					break;
				case 246:
				case 247:
				case 248:
				case 249:
				case 250:
				case 251:
						SpawnStatic(i,j,tile-246+57,spawnz);
					break;
				case 264:
				case 265:
						SpawnStatic(i,j,tile-264+63,spawnz);
					gamestate.planttotal ++;
					break;

				case 266:
						SpawnStatic(i,j,stat_urn,spawnz);
					break;

				case 268:
					SpawnStatic(i,j,tile-265+63,spawnz);
					break;

				case 269:
						SpawnStatic(i,j,tile-265+63,spawnz);
					break;

				case 267:
						SpawnStatic(i,j,stat_emptystatue,spawnz);
					break;

				case 282:
					SpawnStatic(i,j,stat_heatgrate,spawnz);
					break;

				case 283:
					SpawnStatic(i,j,stat_standardpole,spawnz);
					break;

				case 284:
					if ( !BATTLEMODE )
						{
						SpawnStatic(i,j,stat_pit,spawnz);
						}
					break;




				case 252:
					SD_PreCacheSound(SD_GRAVSND);
					SD_PreCacheSound(SD_GRAVHITSND);
					SD_PreCacheSoundGroup(SD_GODMODEFIRESND,SD_LOSEMODESND);
					if ((locplayerstate->player == 1) || (locplayerstate->player ==3))
					SD_PreCacheSound(SD_GODWOMANSND);
					else
					SD_PreCacheSound(SD_GODMANSND);


					PreCacheGroup(W_GetNumForName("GODHAND1"),
									W_GetNumForName("GODHAND8"));

					PreCacheGroup(W_GetNumForName("VAPO1"),
									W_GetNumForName("LITSOUL"));

					PreCacheGroup(W_GetNumForName("GODFIRE1"),
									W_GetNumForName("GODFIRE4"));

						SpawnStatic(i,j,stat_godmode,spawnz);
					if (loadedgame == false)
						gamestate.supertotal ++;
					break;

				case 253:

					#if (SHAREWARE == 1)
						Error("DogMode Power up in shareware at x=%ld y=%ld\n",i,j);
					#endif

					SD_PreCacheSoundGroup(SD_DOGMODEPANTSND,SD_DOGMODELICKSND);
					if ((locplayerstate->player == 1) || (locplayerstate->player ==3))
					SD_PreCacheSound(SD_DOGWOMANSND);
					else
					SD_PreCacheSound(SD_DOGMANSND);



					PreCacheGroup(W_GetNumForName("DOGNOSE1"),
									W_GetNumForName("DOGPAW4"));
						SpawnStatic(i,j,stat_dogmode,spawnz);
					if (loadedgame == false)
						gamestate.supertotal ++;
					break;

				case 254:
						SpawnStatic(i,j,stat_fleetfeet,spawnz);
					if (loadedgame == false)
						gamestate.supertotal ++;
					break;

				case 255:
						SpawnStatic(i,j,stat_random,spawnz);
					if (loadedgame == false)
						gamestate.supertotal ++;
					break;

				case 260:
						SpawnStatic(i,j,stat_elastic,spawnz);
					if (loadedgame == false)
						gamestate.supertotal ++;
					break;

				case 261:
						SpawnStatic(i,j,stat_mushroom,spawnz);
					if (loadedgame == false)
						{
						gamestate.supertotal ++;
						gamestate.democratictotal ++;
						}
					break;


				case 262:
						SpawnStatic(i,j,stat_tomlarva,spawnz);
					break;

				case 263:
						if (gamestate.SpawnCollectItems)
							{
							SpawnStatic(i,j,stat_collector,spawnz);
							LASTSTAT->flags |= FL_COLORED;
							LASTSTAT->hitpoints =
								( GameRandomNumber("colors",0) % MAXPLAYERCOLORS );
							BATTLE_NumCollectorItems++;
							}
					break;

				case 270:
						SpawnStatic(i,j,stat_bulletproof,spawnz);
					if (loadedgame == false)
						gamestate.supertotal ++;
					break;
				case 271:
						SpawnStatic(i,j,stat_asbesto,spawnz);
					if (loadedgame == false)
						gamestate.supertotal ++;
					break;
				case 272:
						SpawnStatic(i,j,stat_gasmask,spawnz);
					if (loadedgame == false)
						gamestate.supertotal ++;
					break;
				case 461:
						SpawnStatic(i,j,stat_disk,spawnz);
					break;
				}
			}
		}
	}



void RaiseSprites( int x, int y, int count, int dir )
{
	int a,c;
	int dx,dy;
	int h;
	int i;
	int xx;
	int hc;
	int d;

	dx=0;
	dy=0;
	if (dir==1)
		dx=1;
	else
		dy=1;


	if (((statobj_t *)sprites[x][y])->z==-65)
		{
		c=(maxheight+20)<<8;
		hc=(count+1)<<7;
		a=(c<<8)/(hc*hc);
		for (i=0;i<count;i++)
			{
			xx=-hc+((i+1)<<8);
			h=(c-FixedMulShift(a,(xx*xx),8) )>>8;
			((statobj_t *)sprites[x+(dx*i)][y+(dy*i)])->z=maxheight-h;
			}
		}
	else
		{
		if (ActorIsSpring(x-(dx),y-(dy)))
			d=1;
		else if (ActorIsSpring(x+(dx*count),y+(dy*count)))
			d=0;
		else
			Error("Cannot find a spring board around a ramp ascension near x=%ld y=%ld\n",x,y);

		hc=((maxheight+20)<<16)/(count+1);
		h=hc<<1;
		for (i=0;i<count;i++)
			{
			if (d==1)
				((statobj_t *)sprites[x+(dx*i)][y+(dy*i)])->z=maxheight-(h>>16);
			else
				((statobj_t *)sprites[x+(dx*(count-i-1))][y+(dy*(count-i-1))])->z=maxheight-(h>>16);
			h+=hc;
			}
		}
}

void LoftSprites( void )
{
	int x,y;
	int count;

	for(y=1;y<mapheight-1;y++)
		{
		for(x=1;x<mapwidth-1;x++)
			{
			if (StaticUndefined(x,y))
				{
				if (StaticUndefined(x+1,y))
					{
					count=1;
					while (StaticUndefined(x+count,y))
						count++;
					if (count<3)
						Error ("Are You kidding me? You are trying to loft <3 sprites in an arc??? \n x=%ld y=%ld\n",x,y);
					RaiseSprites(x,y,count,1);
					}
				else if (StaticUndefined(x,y+1))
					{
					count=1;
					while (StaticUndefined(x,y+count))
						count++;
					if (count<3)
						Error ("Are You kidding me? You are trying to loft <3 sprites??? \n x=%ld y=%ld\n",x,y);
					RaiseSprites(x,y,count,0);
					}
				else
					Error ("Sprite Lofter is confused around x=%ld y=%ld\n",x,y);
				}
			}
		}
}

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// RT_TEXT.C

#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "RT_DEF.H"
//#pragma	hdrstop
//MED
// #include "memcheck.h"

/*
=============================================================================

TEXT FORMATTING COMMANDS
------------------------
^C<hex digit>  			Change text color
^E[enter]				   End of layout (all pages)
^G<y>,<x>,<pic>[enter]	Draw a graphic and push margins
^P[enter]				   start new page, must be the first chars in a layout
^L<x>,<y>[ENTER]		   Locate to a specific spot, x in pixels, y in lines

=============================================================================
*/

/*
=============================================================================

						 LOCAL CONSTANTS

=============================================================================
*/

#define BACKCOLOR		   0x11


#define WORDLIMIT       80
#define FONTHEIGHT      10
#define TOPMARGIN       16
#define BOTTOMMARGIN    32
#define LEFTMARGIN      16
#define RIGHTMARGIN		16
#define PICMARGIN       8
#define TEXTROWS        ((200-TOPMARGIN-BOTTOMMARGIN)/FONTHEIGHT)
#define SPACEWIDTH      7
#define SCREENPIXWIDTH  320
#define SCREENMID       (SCREENPIXWIDTH/2)

/*
=============================================================================

						 LOCAL VARIABLES

=============================================================================
*/

int      pagenum,
         numpages;
unsigned leftmargin[TEXTROWS],
         rightmargin[TEXTROWS];
char	   *text;
unsigned rowon;
int		picx,
         picy,
         picnum,
         picdelay;
boolean	layoutdone;

int      GFX_STRT;
int      FONTCOLOR;
pic_t    *Pic;
char		str[80],
         str2[20];


//===========================================================================

/*
=====================
=
= RipToEOL
=
=====================
*/

void RipToEOL (void)
{
	while (*text++ != '\n')		// scan to end of line
	;
}


/*
=====================
=
= ParseNumber
=
=====================
*/

int	ParseNumber (void)
{
	char	ch;
	char	num[80],*numptr;

//
// scan until a number is found
//
	ch = *text;
	while (ch < '0' || ch >'9')
		ch = *++text;

//
// copy the number out
//
	numptr = num;
	do
	{
		*numptr++ = ch;
		ch = *++text;
	} while (ch >= '0' && ch <= '9');
	*numptr = 0;

	return atoi (num);
}



/*
=====================
=
= ParsePicCommand
=
= Call with text pointing just after a ^P
= Upon exit text points to the start of next line
=
=====================
*/

void	ParsePicCommand (void)
{
	picy=ParseNumber();
	picx=ParseNumber();
	picnum=ParseNumber();
	RipToEOL ();
}


void	ParseTimedCommand (void)
{
	picy=ParseNumber();
	picx=ParseNumber();
	picnum=ParseNumber();
	picdelay=ParseNumber();
	RipToEOL ();
}


/*
=====================
=
= TimedPicCommand
=
= Call with text pointing just after a ^P
= Upon exit text points to the start of next line
=
=====================
*/

void	TimedPicCommand (void)
{
   int delay;

	ParseTimedCommand ();

//
// update the screen, and wait for time delay
//
	VW_UpdateScreen ();

//
// wait for time
//
   delay = ticcount;
	while (ticcount < (delay+picdelay))
	;

//
// draw pic
//
   Pic = (pic_t *) W_CacheLumpNum (GFX_STRT+(picnum-1), PU_CACHE);
   VWB_DrawPic (picx & ~7, picy, Pic);
}


/*
=====================
=
= HandleCommand
=
=====================
*/

void HandleCommand (void)
{
	int	i,margin,top,bottom;
	int	picwidth,picheight,picmid;

	switch (toupper(*++text))
	{
	case 'B':
		picy=ParseNumber();
		picx=ParseNumber();
		picwidth=ParseNumber();
		picheight=ParseNumber();
		VWB_Bar(picx,picy,picwidth,picheight,BACKCOLOR);
		RipToEOL();
		break;
	case ';':		// comment
		RipToEOL();
		break;
	case 'P':		// ^P is start of next page, ^E is end of file
	case 'E':
		layoutdone = true;
		text--;    	// back up to the '^'
		break;

	case 'C':		// ^c<hex digit> changes text color
		i = toupper(*++text);
		if (i>='0' && i<='9')
			FONTCOLOR = i-'0';
		else if (i>='A' && i<='F')
			FONTCOLOR = i-'A'+10;

		FONTCOLOR *= 16;
		i = toupper(*++text);
		if (i>='0' && i<='9')
			FONTCOLOR += i-'0';
		else if (i>='A' && i<='F')
			FONTCOLOR += i-'A'+10;
//		text++;
		break;

	case '>':
		px = 160;
		text++;
		break;

	case 'L':
		py=ParseNumber();
		rowon = (py-TOPMARGIN)/FONTHEIGHT;
		py = TOPMARGIN+rowon*FONTHEIGHT;
		px=ParseNumber();
		while (*text++ != '\n')		// scan to end of line
		;
		break;

	case 'T':		// ^Tyyy,xxx,ppp,ttt waits ttt tics, then draws pic
		TimedPicCommand ();
		break;

	case 'G':		// ^Gyyy,xxx,ppp draws graphic
		ParsePicCommand ();

      Pic = (pic_t *) W_CacheLumpNum (GFX_STRT+(picnum-1), PU_CACHE);
      VWB_DrawPic (picx, picy, Pic);
//      VWB_DrawPic (picx & ~7, picy, Pic);

		picwidth = Pic->width<<2;
		picheight = Pic->height;
		//
		// adjust margins
		//
		picmid = picx + picwidth/2;
		if (picmid > SCREENMID)
			margin = picx-PICMARGIN;			// new right margin
		else
			margin = picx+picwidth+PICMARGIN;	// new left margin

		top = (picy-TOPMARGIN)/FONTHEIGHT;
		if (top<0)
			top = 0;
		bottom = (picy+picheight-TOPMARGIN)/FONTHEIGHT;
		if (bottom>=TEXTROWS)
			bottom = TEXTROWS-1;

		for (i=top;i<=bottom;i++)
			if (picmid > SCREENMID)
				rightmargin[i] = margin;
			else
				leftmargin[i] = margin;

		//
		// adjust this line if needed
		//
		if (px < leftmargin[rowon])
			px = leftmargin[rowon];
		break;
	}
}


/*
=====================
=
= NewLine
=
=====================
*/

void NewLine (void)
{
	char	ch;

	if (++rowon == TEXTROWS)
	{
	//
	// overflowed the page, so skip until next page break
	//
		layoutdone = true;
		do
		{
			if (*text == '^')
			{
				ch = toupper(*(text+1));
				if (ch == 'E' || ch == 'P')
				{
					layoutdone = true;
					return;
				}
			}
			text++;

		} while (1);

	}
	px = leftmargin[rowon];
	py+= FONTHEIGHT;
}



/*
=====================
=
= HandleCtrls
=
=====================
*/

void HandleCtrls (void)
{
	char	ch;

	ch = *text++;			// get the character and advance

	if (ch == '\n')
	{
		NewLine ();
		return;
	}

}


/*
=====================
=
= HandleWord
=
=====================
*/

void HandleWord (void)
{
	char	word[WORDLIMIT];
	int	wordindex,
	      wwidth,
         wheight,
         newpos;


	//
	// copy the next word into [word]
	//
	word[0] = *text++;
	wordindex = 1;
	while (*text>32)
	{
		word[wordindex] = *text++;
		if (++wordindex == WORDLIMIT)
			Error ("PageLayout: Word limit exceeded");
	}
	word[wordindex] = 0;		// stick a null at end for C

	//
	// see if it fits on this line
	//
	VW_MeasurePropString (word, &wwidth, &wheight);

	while (px+wwidth > rightmargin[rowon])
	{
		NewLine ();
		if (layoutdone)
			return;		// overflowed page
	}

	//
	// print it
	//
	newpos = px+wwidth;
	VWB_DrawPropString (word);
	px = newpos;

	//
	// suck up any extra spaces
	//
	while (*text == ' ')
	{
		px += SPACEWIDTH;
		text++;
	}
}

/*
=====================
=
= PageLayout
=
= Clears the screen, draws the pics on the page, and word wraps the text.
= Returns a pointer to the terminating command
=
=====================
*/

void PageLayout (boolean shownumber)
{
	int	i, oldFONTCOLOR;
	char	ch;

	oldFONTCOLOR = FONTCOLOR;

	FONTCOLOR = 0;

//
// clear the screen
//
	VWB_Bar (0,0,320,200,BACKCOLOR);
//	VWB_DrawPic (0,0,H_TOPWINDOWPIC);
//	VWB_DrawPic (0,8,H_LEFTWINDOWPIC);
//	VWB_DrawPic (312,8,H_RIGHTWINDOWPIC);
//	VWB_DrawPic (8,176,H_BOTTOMINFOPIC);


	for (i=0;i<TEXTROWS;i++)
	{
		leftmargin[i] = LEFTMARGIN;
		rightmargin[i] = SCREENPIXWIDTH-RIGHTMARGIN;
	}

	px = LEFTMARGIN;
	py = TOPMARGIN;
	rowon = 0;
	layoutdone = false;

//
// make sure we are starting layout text (^P first command)
//
	while (*text <= 32)
		text++;

	if (*text != '^' || toupper(*++text) != 'P')
		Error ("PageLayout: Text not headed with ^P");

	while (*text++ != '\n')
	;


//
// process text stream
//
	do
	{
		ch = *text;

		if (ch == '^')
			HandleCommand ();
		else
		if (ch == 9)
		{
		 px = (px+8)&0xf8;
		 text++;
		}
		else if (ch <= 32)
			HandleCtrls ();
		else
			HandleWord ();

	} while (!layoutdone);

	pagenum++;

	if (shownumber)
	{
		strcpy (str,"pg ");
		itoa (pagenum,str2,10);
		strcat (str,str2);
		strcat (str," of ");
		itoa (numpages,str2,10);
		strcat (str,str2);
		FONTCOLOR = 0x4f; 			   //12^BACKCOLOR;

		py = 183;
		px = 213;
		VWB_DrawPropString (str);
	}

	FONTCOLOR = oldFONTCOLOR;
}

//===========================================================================

/*
=====================
=
= BackPage
=
= Scans for a previous ^P
=
=====================
*/

void BackPage (void)
{
	pagenum--;
	do
	{
		text--;
		if (*text == '^' && toupper(*(text+1)) == 'P')
			return;
	} while (1);
}


//===========================================================================


/*
=====================
=
= CacheLayoutGraphics
=
= Scans an entire layout file (until a ^E) marking all graphics used, and
= counting pages, then caches the graphics in
=
=====================
*/
void CacheLayoutGraphics (void)
{
	char	*bombpoint,
         *textstart;
	char	ch;

	textstart = text;
	bombpoint = text+30000;
	numpages = pagenum = 0;

	do
	{
		if (*text == '^')
		{
			ch = toupper(*++text);
			if (ch == 'P')		// start of a page
				numpages++;
			if (ch == 'E')		// end of file, so load graphics and return
			{
//				CA_MarkGrChunk(H_TOPWINDOWPIC);
//				CA_MarkGrChunk(H_LEFTWINDOWPIC);
//				CA_MarkGrChunk(H_RIGHTWINDOWPIC);
//				CA_MarkGrChunk(H_BOTTOMINFOPIC);
//				CA_CacheMarks ();
				text = textstart;
				return;
			}
			if (ch == 'G')		// draw graphic command, so mark graphics
			{
				ParsePicCommand ();
//				CA_MarkGrChunk (picnum);
			}
			if (ch == 'T')		// timed draw graphic command, so mark graphics
			{
				ParseTimedCommand ();
//				CA_MarkGrChunk (picnum);
			}
		}
		else
			text++;

	} while (text<bombpoint);

	Error ("CacheLayoutGraphics: No ^E to terminate file!");
}


/*
=====================
=
= ShowArticle
=
=====================
*/

void ShowArticle (char *article)
{
//	unsigned	oldfontnumber;
//	unsigned	temp;
	boolean 	newpage,firstpage;

   GFX_STRT = (W_GetNumForName ("TEXTSTRT"))+1;

	text = article;
//	CA_MarkGrChunk(STARTFONT);
	VWB_Bar (0, 0, 320, 200, BACKCOLOR);
	CacheLayoutGraphics ();

	newpage = true;
	firstpage = true;

	do
	{
		if (newpage)
		{
			newpage = false;
//			CA_CacheScreen(enames[which*2 + pagenum - 1]);

			PageLayout (true);
			VW_UpdateScreen ();
			if (firstpage)
			{
            MenuFadeIn ();
				firstpage = false;
			}
		}

		LastScan = 0;
		while (!LastScan)
		;

		switch (LastScan)
		{
		case sc_UpArrow:
		case sc_PgUp:
		case sc_LeftArrow:
			if (pagenum>1)
			{
				BackPage ();
				BackPage ();
				newpage = true;
			}
			break;

		case sc_Enter:
		case sc_DownArrow:
		case sc_PgDn:
		case sc_RightArrow:		// the text allready points at next page
			if (pagenum<numpages)
			{
				newpage = true;
			}
			break;
		}
	} while (LastScan != sc_Escape);

	IN_ClearKeysDown ();
//	fontnumber = oldfontnumber;
}


//===========================================================================

#if 0

#ifndef JAPAN
#ifdef ARTSEXTERN
int 	endextern = T_ENDART1;
#ifndef SPEAR
int		helpextern = T_HELPART;
#endif
#endif
char helpfilename[13] = "HELPART.",
	 endfilename[13] = "ENDART1.";
#endif

#endif

/*
=================
=
= HelpScreens
=
=================
*/
void HelpScreens (void)
{
#if 0
	int			artnum;
	char far 	*text;
	memptr		layout;


	CA_UpLevel ();
	MM_SortMem ();

#ifdef ARTSEXTERN
	artnum = helpextern;
	CA_CacheGrChunk (artnum);
	text = (char _seg *)grsegs[artnum];
	MM_SetLock (&grsegs[artnum], true);
#else
	CA_LoadFile (helpfilename,&layout);
	text = (char _seg *)layout;
	MM_SetLock (&layout, true);
#endif

	ShowArticle (text);

#ifdef ARTSEXTERN
	MM_FreePtr (&grsegs[artnum]);
#else
	MM_FreePtr (&layout);
#endif

	VW_FadeOut();

	FreeMusic ();
	CA_DownLevel ();
	MM_SortMem ();
#endif
}


/*
=================
=
= EndText - END ARTICLES
=
=================
*/

void EndText (void)
{
#if 0
	int			artnum;
	char far 	*text;
	memptr		layout;


	ClearMemory ();

	CA_UpLevel ();
	MM_SortMem ();


#ifdef ARTSEXTERN
	artnum = endextern+gamestate.episode;
	CA_CacheGrChunk (artnum);
	text = (char _seg *)grsegs[artnum];
	MM_SetLock (&grsegs[artnum], true);
#else
	endfilename[6] = '1'+gamestate.episode;
	CA_LoadFile (endfilename,&layout);
	text = (char _seg *)layout;
	MM_SetLock (&layout, true);
#endif

	ShowArticle (text);

#ifdef ARTSEXTERN
	MM_FreePtr (&grsegs[artnum]);
#else
	MM_FreePtr (&layout);
#endif

	VW_FadeOut();
	SETFONTCOLOR(0,15);
	IN_ClearKeysDown();
	if (MousePresent)
		Mouse(MDelta);	// Clear accumulated mouse movement

	FreeMusic ();
	CA_DownLevel ();
	MM_SortMem ();
#endif
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "rt_def.h"
// #include <malloc.h>
// #include <dos.h>
#include <stdarg.h>
// #include <fcntl.h>
#include <errno.h>
// #include <conio.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
// #include <io.h>
#include <stdlib.h>
// #include <sys\stat.h>
#include "watcom.h"
#include "_rt_util.h"
#include "rt_util.h"
#include "isr.h"
#include "z_zone.h"
#include "rt_dr_a.h"
#include "rt_in.h"
#include "rt_main.h"
#include "scriplib.h"
#include "rt_menu.h"
#include "rt_playr.h"
#include "version.h"
#include "develop.h"
#include "rt_vid.h"
#include "rt_view.h"
#include "modexlib.h"
#include "rt_cfg.h"
// #include <direct.h>
//MED
// #include "memcheck.h"

int	egacolor[16];
byte	*  origpal;
FILE	*  errout;
FILE	*  debugout;
FILE	*  mapdebugout;

static boolean SoftErrorStarted=false;
static boolean DebugStarted=false;
static boolean MapDebugStarted=false;

static unsigned char egargb[48]={ 0x00,0x00,0x00,
									0x00,0x00,0xab,
									0x00,0xab,0x00,
									0x00,0xab,0xab,
									0xab,0x00,0x00,
									0xab,0x00,0xab,
									0xab,0x57,0x00,
									0xab,0xab,0xab,
									0x57,0x57,0x57,
									0x57,0x57,0xff,
									0x57,0xff,0x57,
									0x57,0xff,0xff,
									0xff,0x57,0x57,
									0xff,0x57,0xff,
									0xff,0xff,0x57,
									0xff,0xff,0xff};

// extern byte * ROTT_ERR;

#if (DEVELOPMENT == 1)
int TotalStaticMemory=0;
#endif

#define SWAP(a,b) \
	{				\
	a=(a)^(b);	\
	b=(a)^(b);	\
	a=(a)^(b);	\
	}				\

//******************************************************************************
//
// FindDistance
//
//******************************************************************************

int FindDistance(int ix, int iy)
{
  int	t;

  ix= abs(ix);		/* absolute values */
  iy= abs(iy);

  if (ix<iy)
	SWAP(ix,iy);

  t = iy + (iy>>1);

  return (ix - (ix>>5) - (ix>>7)  + (t>>2) + (t>>6));
}


//******************************************************************************
//
// Find_3D_Distance
//
//******************************************************************************

int Find_3D_Distance(int ix, int iy, int iz)
	{
	int	t;

	ix= abs(ix);			/* absolute values */
	iy= abs(iy);
	iz= abs(iz);

	if (ix<iy)
	SWAP(ix,iy);

	if (ix<iz)
	SWAP(ix,iz);

	t = iy + iz;

	return (ix - (ix>>4) + (t>>2) + (t>>3));
	}

//******************************************************************************
//
// atan2_appx
//
//******************************************************************************

int atan2_appx(int dx, int dy)
{int absdx, absdy;
 fixed angle;
 fixed ratio;


 if (!(dx||dy))
  return 0;
 absdx = abs(dx);
 absdy = abs(dy);
 if (absdx >= absdy)
  ratio = FixedDiv2(absdy,absdx);
 else
  ratio = FixedDiv2(absdx,absdy);

 if (dx >= 0)
  {if (dy >= 0)
	{if (absdx >= absdy)
		angle = ratio;		// 1st octant
	else
		angle = (2<<16) - ratio; // 2nd octant
	}
	else
	{if (absdx >= absdy)
		angle = (8<<16) - ratio; // 8th octant
	else
		angle = (6<<16) + ratio; // 7th octant
	}
  }
 else
  {if (dy >= 0)
	{if (absdx >= absdy)
		angle = (4<<16) - ratio; // 4th octant
	else
		angle = (2<<16) + ratio; // 3rd octant
	}
	else
	{if (absdx >= absdy)
		angle = (4<<16) + ratio; // 5th octant
	else
		angle = (6<<16) - ratio; // 6th octant
	}
  }

 return (((int)FixedMul(angle,ANGLESDIV8))&(FINEANGLES-1));
}



//******************************************************************************
//
// StringsNotEqual
//
//******************************************************************************
boolean StringsNotEqual (char * s1, char * s2, int length)
{
	int i;

	for (i=0;i<length;i++)
		if (s1[i]!=s2[i])
			return true;
	return false;
}



void markgetch( void )
{
	int done;
	int i;

	done=0;
	while (done==0)
		{
		IN_UpdateKeyboard ();
		for (i=0;i<127;i++)
			if (Keyboard[i]==1)
				done=i;
		}
	while (Keyboard[done])
		IN_UpdateKeyboard ();
}

/*
====================
=
= FindEGAColors
=
====================
*/

void FindEGAColors ( void )
{
	int i;

	for (i=0;i<16;i++)
		egacolor[i]=BestColor((int)egargb[i*3],(int)egargb[i*3+1],(int)egargb[i*3+2],origpal);
}

//===========================================================================


byte BestColor (int r, int g, int b, byte *palette)
{
	int	i;
	long	dr, dg, db;
	long	bestdistortion, distortion;
	int	bestcolor;
	byte	*pal;

//
// let any color go to 0 as a last resort
//
	bestdistortion = ( (long)WeightR*r*r + (long)WeightG*g*g + (long)WeightB*b*b )*2;
	bestcolor = 0;

	pal = &palette[0];
	for (i=0 ; i<= 255 ; i++,pal+=3)
	{
		dr = r - (int)pal[0];
		dg = g - (int)pal[1];
		db = b - (int)pal[2];
		distortion = WeightR*dr*dr + WeightG*dg*dg + WeightB*db*db;
		if (distortion < bestdistortion)
		{
			if (!distortion)
				return i;		// perfect match

			bestdistortion = distortion;
			bestcolor = i;
		}
	}

	return bestcolor;
}

void ClearGraphicsScreen( void )
{
VL_ClearVideo(0);
}

void ClearBuffer( char * buf, int size )
{
		memset(buf,0,size);
}

/*
=============================================================================

						MISC FUNCTIONS

=============================================================================
*/

/*
=================
=
= Error
=
= For abnormal program terminations
=
=================
*/

void Error (char *error, ...)
{
	char msgbuf[300];
	va_list	argptr;
	char i;
	int size;
	char * sptr;
	char buf[30];
	int handle;
	int x,y;
	int level;
	static int inerror = 0;
	char filename[ 128 ];


	inerror++;
	if (inerror > 1)
		return;

	ShutDown();

	TextMode ();
//	memcpy ((byte *)0xB8000, &ROTT_ERR, 160*7);
	memset (msgbuf, 0, 300);

	px = ERRORVERSIONCOL-1;
	py = ERRORVERSIONROW;
#if (SHAREWARE == 1)
	UL_printf ("S");
#else
	UL_printf ("R");
#endif

	px = ERRORVERSIONCOL;
	py = ERRORVERSIONROW;
#if (BETA == 1)
//	UL_printf ("");
	UL_printf (".");
#else
	UL_printf (itoa(ROTTMAJORVERSION,&buf[0],10));
#endif

	// Skip the dot
	px++;

	UL_printf (itoa(ROTTMINORVERSION,&buf[0],10));

	va_start (argptr, error);
	vsprintf (&msgbuf[0], error, argptr);
	va_end (argptr);

	scriptbuffer = &msgbuf[0];
	size = strlen (msgbuf);

	sptr = script_p = scriptbuffer;
	scriptend_p = script_p + size;
	scriptline = 1;
	endofscript = false;
	tokenready = false;

	px = ERRORCOL;
	py = ERRORROW;

	GetToken (true);
	while (!endofscript)
	{
		if ((script_p - sptr) >= 60)
		{
			px = ERRORCOL;
			py++;
			sptr = script_p;
		}

		UL_printf (token);
		px++;					//SPACE
		GetToken (true);
	}

	for (i = 0; i < 8; i++)
		printf ("\n");

	if (player!=NULL)
		{
		printf ("Player X	= %lx\n", player->x);
		printf ("Player Y	= %lx\n", player->y);
		printf ("Player Angle = %lx\n\n", player->angle);
		}
	printf ("Episode		= %ld\n", gamestate.episode);

	if (gamestate.episode > 1)
		level = (gamestate.mapon+1) - ((gamestate.episode-1) << 3);
	else
		level = gamestate.mapon+1;

	printf ("Area			= %ld\n", level);

#if 0
	GetPathFromEnvironment( filename, ApogeePath, ERRORFILE );
	handle=SafeOpenAppend ( filename );
	for (y=0;y<16;y++)
		{
		for (x=0;x<160;x+=2)
			SafeWrite(handle,(byte *)0xB8000+(y*160)+x,1);
		i=10;
		SafeWrite(handle,&i,1);
		i=13;
		SafeWrite(handle,&i,1);
		}

	w_close(handle);

	if ( SOUNDSETUP )
		{
		getchar();
		}
#endif

	__debugbreak();

	exit (1);
}

//#if (SOFTERROR==1)

/*
=================
=
= SoftwareError
=
=================
*/
void SoftwareError (char *error, ...)
{
	va_list	argptr;

	if (SoftErrorStarted==false)
		return;
	va_start (argptr, error);
	vfprintf (errout, error, argptr);
	va_end (argptr);
}

//#endif


//#if (DEBUG == 1)

/*
=================
=
= DebugError
=
=================
*/
void DebugError (char *error, ...)
{
	va_list	argptr;

	if (DebugStarted==false)
		return;
	va_start (argptr, error);
	vfprintf (debugout, error, argptr);
	va_end (argptr);
}

//#endif

/*
=================
=
= OpenSoftError
=
=================
*/
void OpenSoftError ( void )
{
  errout = fopen(SOFTERRORFILE,"wt+");
  SoftErrorStarted=true;
}

/*
=================
=
= MapDebug
=
=================
*/
void MapDebug (char *error, ...)
{
	va_list	argptr;

	if (MapDebugStarted==false)
		return;
	va_start (argptr, error);
	vfprintf (mapdebugout, error, argptr);
	va_end (argptr);
}

/*
=================
=
= OpenMapDebug
=
=================
*/
void OpenMapDebug ( void )
{
  char filename[ 128 ];

  if (MapDebugStarted==true)
	return;
  GetPathFromEnvironment( filename, ApogeePath, MAPDEBUGFILE );
  mapdebugout = fopen(filename,"wt+");
  MapDebugStarted=true;
}


/*
=================
=
= StartupSoftError
=
=================
*/
void StartupSoftError ( void )
{
#if (DEBUG == 1)
  if (DebugStarted==false)
	{
	debugout = fopen(DEBUGFILE,"wt+");
	DebugStarted=true;
	}
#endif
#if (SOFTERROR == 1)
  if (SoftErrorStarted==false)
	OpenSoftError();
#endif
}

/*
=================
=
= ShutdownSoftError
=
=================
*/
void ShutdownSoftError ( void )
{
  if (DebugStarted==true)
	{
	fclose(debugout);
	DebugStarted=false;
	}
  if (SoftErrorStarted==true)
	{
	fclose(errout);
	SoftErrorStarted=false;
	}
  if (MapDebugStarted==true)
	{
	fclose(mapdebugout);
	MapDebugStarted=false;
	}
}


/*
=================
=
= CheckParm
=
= Checks for the given parameter in the program's command line arguments
=
= Returns the argument number (1 to argc-1) or 0 if not present
=
=================
*/

int CheckParm (char *check)
{
	int		i;
	char	*parm;

	for (i = 1;i<_argc;i++)
	{
		parm = _argv[i];
		if ( !isalpha(*parm) )	// skip - / \ etc.. in front of parm
			{
			parm++;
			if (!*parm)
				continue;		// parm was only one char
			}

//		if ( !_fstricmp(check,parm) )
		if ( !stricmp(check,parm) )
			return i;
	}

	return 0;
}



int SafeOpenAppend (char *filename)
{
	int	handle;

//	handle = open(filename,O_RDWR | O_BINARY | O_CREAT | O_APPEND
//	, S_IREAD | S_IWRITE);
	handle = w_open(filename,"a+b");

	if (handle == -1)
		Error ("Error opening for append %s: %s",filename,strerror(errno));

	return handle;
}

int SafeOpenWrite (char *filename)
{
	int	handle;

//	handle = open(filename,O_RDWR | O_BINARY | O_CREAT | O_TRUNC
//	, S_IREAD | S_IWRITE);
	handle = w_open(filename,"w+b");

	if (handle == -1)
		Error ("Error opening %s: %s",filename,strerror(errno));

	return handle;
}

int SafeOpenRead (char *filename)
{
	int	handle;

//	handle = open(filename,O_RDONLY | O_BINARY);
	handle = w_open(filename,"rb");

	if (handle == -1)
		Error ("Error opening %s: %s",filename,strerror(errno));

	return handle;
}


void SafeRead (int handle, void *buffer, long count)
{
	unsigned	iocount;

	while (count)
	{
		iocount = count > 0x8000 ? 0x8000 : count;
		if (w_read (handle,buffer,iocount) != iocount)
			Error ("File read failure reading %ld bytes",count);
		buffer = (void *)( (byte *)buffer + iocount );
		count -= iocount;
	}
}


void SafeWrite (int handle, void *buffer, long count)
{
	unsigned	iocount;

	while (count)
	{
		iocount = count > 0x8000 ? 0x8000 : count;
		if (w_write (handle,buffer,iocount) != iocount)
			Error ("File write failure writing %ld bytes",count);
		buffer = (void *)( (byte *)buffer + iocount );
		count -= iocount;
	}
}

void SafeWriteString (int handle, char * buffer)
{
	unsigned	iocount;

	iocount=strlen(buffer);
	if (w_write (handle,buffer,iocount) != iocount)
			Error ("File write string failure writing %s\n",buffer);
}

void *SafeMalloc (long size)
{
	void *ptr;

	if (zonememorystarted==false)
		Error("Called SafeMalloc without starting zone memory\n");
	ptr = Z_Malloc (size,PU_STATIC,NULL);

	if (!ptr)
		Error ("SafeMalloc failure for %lu bytes",size);

	return ptr;
}

void *SafeLevelMalloc (long size)
{
	void *ptr;

	if (zonememorystarted==false)
		Error("Called SafeLevelMalloc without starting zone memory\n");
	ptr = Z_LevelMalloc (size,PU_STATIC,NULL);

	if (!ptr)
		Error ("SafeLevelMalloc failure for %lu bytes",size);

	return ptr;
}

void SafeFree (void * ptr)
{
	if ( ptr == NULL )
		Error ("SafeFree : Tried to free a freed pointer\n");

	Z_Free (ptr);
}

/*
==============
=
= LoadFile
=
==============
*/

long	LoadFile (char *filename, void **bufferptr)
{
	int		handle;
	long	length;

	handle = SafeOpenRead (filename);
	length = w_filelength (handle);
	*bufferptr = SafeMalloc (length);
	SafeRead (handle,*bufferptr, length);
	w_close (handle);
	return length;
}


/*
==============
=
= SaveFile
=
==============
*/

void	SaveFile (char *filename, void *buffer, long count)
{
	int		handle;

	handle = SafeOpenWrite (filename);
	SafeWrite (handle, buffer, count);
	w_close (handle);
}


void GetPathFromEnvironment( char *fullname, const char *envname, const char *filename )
	{
	char *path;

	path = getenv( envname );

	if ( path != NULL )
		{
		strcpy( fullname, path );
		if ( fullname[ strlen( fullname ) ] != '\\' )
			{
			strcat( fullname, "\\" );
			}
		strcat( fullname, filename );
		}
	else
		{
		strcpy( fullname, filename );
		}
	}

void DefaultExtension (char *path, char *extension)
{
	char	*src;
//
// if path doesn't have a .EXT, append extension
// (extension should include the .)
//
	src = path + strlen(path) - 1;

	while (*src != '\\' && src != path)
	{
		if (*src == '.')
			return;			// it has an extension
		src--;
	}

	strcat (path, extension);
}

void DefaultPath (char *path, char *basepath)
{
	char	temp[128];

	if (path[0] == '\\')
		return;							// absolute path location
	strcpy (temp,path);
	strcpy (path,basepath);
	strcat (path,temp);
}


void ExtractFileBase (char *path, char *dest)
{
	char	*src;
	int		length;

	src = path + strlen(path) - 1;

//
// back up until a \ or the start
//
	while (src != path && *(src-1) != '\\')
		src--;

//
// copy up to eight characters
//
	memset (dest,0,8);
	length = 0;
	while (*src && *src != '.')
	{
		if (++length == 9)
			Error ("Filename base of %s >8 chars",path);
		*dest++ = toupper(*src++);
	}
}


/*
==============
=
= ParseNum / ParseHex
=
==============
*/

long ParseHex (char *hex)
{
	char	*str;
	long	num;

	num = 0;
	str = hex;

	while (*str)
	{
		num <<= 4;
		if (*str >= '0' && *str <= '9')
			num += *str-'0';
		else if (*str >= 'a' && *str <= 'f')
			num += 10 + *str-'a';
		else if (*str >= 'A' && *str <= 'F')
			num += 10 + *str-'A';
		else
			Error ("Bad hex number: %s",hex);
		str++;
	}

	return num;
}


long ParseNum (char *str)
{
	if (str[0] == '$')
		return ParseHex (str+1);
	if (str[0] == '0' && str[1] == 'x')
		return ParseHex (str+2);
	return atol (str);
}




short	MotoShort (short l)
{
	byte	b1,b2;

	b1 = l&255;
	b2 = (l>>8)&255;

	return (b1<<8) + b2;
}

short	IntelShort (short l)
{
	return l;
}


long	MotoLong (long l)
{
	byte	b1,b2,b3,b4;

	b1 = l&255;
	b2 = (l>>8)&255;
	b3 = (l>>16)&255;
	b4 = (l>>24)&255;

	return ((long)b1<<24) + ((long)b2<<16) + ((long)b3<<8) + b4;
}

long	IntelLong (long l)
{
	return l;
}


/*
============================================================================

						BASIC GRAPHICS

============================================================================
*/

/*
==============
=
= GetaPalette
=
= Return an 8 bit / color palette
=
==============
*/

#if 0
void GetaPalette (byte *pal)
{
	int	i;

//	OUTP (PEL_READ_ADR,0);
//	for (i=0 ; i<768 ; i++)
//		pal[i] = inp (PEL_DATA)<<2;
}
#endif

/*
==============
=
= SetaPalette
=
= Sets an 8 bit / color palette
=
==============
*/

#if 0
void SetaPalette (byte *pal)
{
	int	i;

	OUTP (PEL_WRITE_ADR,0);
	for (i=0 ; i<768 ; i++)
		OUTP (PEL_DATA, pal[i]>>2);
}

void GetPalette(char * pal)
{
  int i;

//  OUTP(0x03c7,0);
//  for (i=0;i<256*3;i++)
//	*(pal+(unsigned char)i)=inp(0x3c9)<<2;
}
#endif

void GetPalette(char * pal)
{
	VL_GetPalette (pal);
}

void SetPalette ( char * pal )
{
	VL_SetPalette (pal);
}


//******************************************************************************
//
// US_CheckParm() - checks to see if a string matches one of a set of
//	strings. The check is case insensitive. The routine returns the
//	index of the string that matched, or -1 if no matches were found
//
//******************************************************************************

int US_CheckParm (char *parm, char **strings)
{
	char  cp,cs,
			*p,*s;
	int		i;
	int		length;

	length=strlen(parm);
	while ( (!isalpha(*parm)) && (length>0)) // Skip non-alphas
		{
		length--;
		parm++;
		}

	for (i = 0;*strings && **strings;i++)
	{
		for (s = *strings++,p = parm,cs = cp = 0;cs == cp;)
		{
			cs = *s++;
			if (!cs)
				return(i);
			cp = *p++;

			if (isupper(cs))
				cs = tolower(cs);
			if (isupper(cp))
				cp = tolower(cp);
		}
	}
	return(-1);
}

/*
=================
=
= VL_NormalizePalette
=
=================
*/

void VL_NormalizePalette (byte *palette)
{
	int	i;

	for (i = 0; i < 768; i++)
		*(palette+i)=(*(palette+i))>>2;
}


/*
=================
=
= VL_SetPalette
=
= If fast palette setting has been tested for, it is used
= -some cards don't like outsb palette setting-
=
=================
*/

#if 0
void VL_SetPalette (byte *palette)
{
	int	i;

	OUTP (PEL_WRITE_ADR, 0);

	for (i = 0; i < 768; i++)
		{
		OUTP (PEL_DATA, gammatable[(gammaindex<<6)+(*palette++)]);
		}
}
#endif


//===========================================================================

/*
=================
=
= VL_GetPalette
=
= This does not use the port string instructions,
= due to some incompatabilities
=
=================
*/

#if 0
void VL_GetPalette (byte *palette)
{
	int	i;

//	OUTP (PEL_READ_ADR, 0);
//	for (i = 0; i < 768; i++)
//		*palette++ = inp (PEL_DATA);
}
#endif


/*
=================
=
= UL_DisplayMemoryError ()
=
=================
*/

void UL_DisplayMemoryError ( int memneeded )
{
	__debugbreak();
}

#if 0
void UL_DisplayMemoryError ( int memneeded )
{
	char buf[4000];
	int i;

	ShutDown ();
	TextMode ();

	for (i = 0; i < 19; i++)
		printf ("\n");

	memcpy (buf, &ROTT_ERR, 4000);
	memcpy ((byte *)0xB8000, &buf[160*7], 4000-(160*7));

	px = ERRORVERSIONCOL;
	py = ERRORVERSIONROW;
#if (BETA == 1)
	UL_printf ("");
#else
	UL_printf (itoa(ROTTMAJORVERSION,&buf[0],10));
#endif
	px++;

	UL_printf (itoa(ROTTMINORVERSION,&buf[0],10));

	px = LOWMEMORYCOL;
	py = LOWMEMORYROW;
	UL_printf ("You need ");
	UL_printf (itoa(memneeded,&buf[0],10));
	UL_printf (" bytes more memory");
	if ( SOUNDSETUP )
		{
		getchar();
		}
	exit (0);
}
#endif


/*
=================
=
= UL_printf
=
=================
*/

#if 0
void UL_printf (byte *str)
{
	byte *s;
	byte *screen;

	s = str;
	screen = (byte *)(0xB8000 + (py*160) + (px<<1));

	while (*s)
	{
		*screen = *s;
		s++;
		screen += 2;
		px++;

		if ((*s < 32) && (*s > 0))
			s++;
	}
}
#endif

void UL_printf (byte *str)
{
	puts(str);
}

/*
=================
=
= UL_ColorBox
=
=================
*/

#if 0
void UL_ColorBox (int x, int y, int w, int h, int color)
{
	byte *screen;
	int i,j;


	for (j=0;j<h;j++)
		{
		screen = (byte *)(0xB8000 + ((y+j)*160) + (x<<1) + 1);
		for (i=0;i<w;i++)
			{
			*screen = (byte)color;
			screen+=2;
			}
		}
}
#endif

void UL_ColorBox (int x, int y, int w, int h, int color)
{
//	__debugbreak();
}

//******************************************************************************
//
// SideOfLine
//
//******************************************************************************

int SideOfLine(int x1, int y1, int x2, int y2, int x3, int y3)
{
	int a1,b1,c1;

	/* Compute a1, b1, c1, where line joining points 1 and 2
	* is "a1 x  +  b1 y  +  c1  =  0".
	*/

	a1 = y2 - y1;
	b1 = x1 - x2;
	c1 = FixedMulShift(x2,y1,16) - FixedMulShift(x1,y2,16);

	return SGN(FixedMulShift(a1,x3,16) + FixedMulShift(b1,y3,16) + c1);
}



//******************************************************************************
//
// HSORT - heap sort
//
//******************************************************************************

typedef int (*PFI)();			/* pointer to a function returning int  */
typedef void (*PFV)();			/* pointer to a function returning int  */
static PFI Comp;								/* pointer to comparison routine					*/
static PFV Switch;								/* pointer to comparison routine					*/
static int Width;							/* width of an object in bytes						*/
static char *Base;							/* pointer to element [-1] of array				*/

void hsort(char * base, int nel, int width, int (*compare)(), void (*switcher)())
{
static int i,n,stop;
		/*		Perform a heap sort on an array starting at base.  The array is
					nel elements large and width is the size of a single element in
					bytes.  Compare is a pointer to a comparison routine which will
					be passed pointers to two elements of the array.  It should
					return a negative number if the left-most argument is less than
					the rightmost, 0 if the two arguments are equal, a positive
					number if the left argument is greater than the right.  (That
					is, it acts like a "subtract" operator.) If compare is 0 then
					the default comparison routine, argvcmp (which sorts an
					argv-like array of pointers to strings), is used.													*/

	Width=width;
	Comp= compare;
	Switch= switcher;
	n=nel*Width;
	Base=base-Width;
	for (i=(n/Width/2)*Width; i>=Width; i-=Width) newsift_down(i,n);
	stop=Width+Width;
	for (i=n; i>=stop; )
		{
		(*Switch)(base, Base+i);
		newsift_down(Width,i-=Width);
		}

}

/*---------------------------------------------------------------------------*/
static newsift_down(L,U) int L,U;
{  int c;

	while(1)
		{c=L+L;
		if(c>U) break;
		if( (c+Width <= U) && ((*Comp)(Base+c+Width,Base+c)>0) ) c+= Width;
		if ((*Comp)(Base+L,Base+c)>=0) break;
		(*Switch)(Base+L, Base+c);
		L=c;
		}
}



//******************************************************************************
//
// UL_GetPath
//
// Purpose
//	To parse the directory entered by the user to make the directory.
//
// Parms
//	Path - the path to be parsed.
//
// Returns
//	Pointer to next path
//
//******************************************************************************

char * UL_GetPath (char * path, char *dir)
{
	boolean done		= 0;
	char *dr			= dir;
	int cnt			= 0;

	if (*path == SLASHES)
		path++;

	while (!done)
	{
		*dr = *path;

		cnt++;						// make sure the number of characters in the dir
		if (cnt > MAXCHARS)	// name doesn't exceed acceptable limits.
			Error ("ERROR : Directory name can only be %d characters long.\n", MAXCHARS);

		path++;
		dr++;

//		if ((*path == SLASHES) || (*path == NULL))
		if ((*path == SLASHES) || (*path == 0))
			done = true;
	}

	*dr = 0;
	return (path);
}


//******************************************************************************
//
// UL_ChangeDirectory ()
//
// Purpose
//	To change to a directory.  Checks for drive changes.
//
// Parms
//	path - The path to change to.
//
// Returns
//	TRUE  - If successful.
//	FALSE - If unsuccessful.
//
//******************************************************************************

#if 0
boolean UL_ChangeDirectory (char *path)
{
	char *p;
	char dir[9];
	char *d;

	d = &dir[0];
	p = path;
	memset (dir, 0, 9);

	// Check for a drive at the beginning of the path
	if (*(p+1) == ':')
	{
		*d++ = *p++;		// drive letter
		*d++ = *p++;		// colon

		if (UL_ChangeDrive (dir) == false)
			return (false);
	}

	if (*p == SLASHES)
	{
		chdir ("\\");
		p++;
	}

	d = &dir[0];
	while (*p)
	{
		p = UL_GetPath (p, d);

		if (chdir (d) == -1)
			return (false);
	}

	return (true);
}
#endif

boolean UL_ChangeDirectory (char *path)
{
	return (true);
}

//******************************************************************************
//
// UL_ChangeDrive ()
//
// Purpose
//	To change drives.
//
// Parms
//	drive - The drive to change to.
//
// Returns
//	TRUE  - If drive change successful.
//	FALSE - If drive change unsuccessful.
//
//******************************************************************************

#if 0
boolean UL_ChangeDrive (char *drive)
{
	unsigned d, total, tempd;

	d = toupper (*drive);

	d = d - 'A' + 1;

	_dos_setdrive (d, &total);
	_dos_getdrive (&tempd);

	if (d != tempd)
		return (false);

	return (true);
}
#endif


/*
=============
=
= AbortCheck
=
=============
*/
void AbortCheck (char * abortstring)
{
	// User abort check

	IN_UpdateKeyboard ();

	if (Keyboard[sc_Escape])
		Error("%s\n",abortstring);
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// #include <dos.h>
// #include <conio.h>

#include "rt_def.h"
#include "rt_vid.h"
#include "_rt_vid.h"
#include "rt_menu.h"
#include "rt_util.h"
#include "modexlib.h"
#include "profile.h"
#include "watcom.h"
#include "rt_str.h"
#include "rt_draw.h"
#include "rt_in.h"
#include "rt_main.h"
#include "z_zone.h"
#include "lumpy.h"
#include "rt_vh_a.h"
#include "isr.h"
#include "rt_view.h"
#include "cin_efct.h"
#include "w_wad.h"
//MED
// #include "memcheck.h"


//******************************************************************************
//
// GLOBALS
//
//******************************************************************************

byte	*updateptr;
unsigned mapwidthtable[64];
unsigned uwidthtable[UPDATEHIGH];
unsigned blockstarts[UPDATEWIDE*UPDATEHIGH];
byte	update[UPDATESIZE];
byte	palette1[256][3], palette2[256][3];
boolean  screenfaded;


//******************************************************************************
//
// LOCALS
//
//******************************************************************************

static byte  pixmasks[4] = {1,2,4,8};
static byte  leftmasks[4] = {15,14,12,8};
static byte  rightmasks[4] = {1,3,7,15};



//******************************************************************************
//
// VL_MemToScreen ()
//
//******************************************************************************

void VL_MemToScreen (byte *source, int width, int height, int x0, int y0)
{
//	byte *screen, *dest, mask;
	unsigned screen, dest;
	byte mask;
	int  plane, y;

	dest = (bufferofs+ylookup[y0]+(x0>>2));
//	dest = (byte *)(bufferofs+ylookup[y]+(x0>>2));
//	dest = (byte *)(displayofs+ylookup[y]+(x0>>2));
	mask = 1 << (x0&3);

	for (plane = 0; plane<4; plane++)
	{
		VGAMAPMASK (mask);

		screen = dest;
		for (y = 0; y < height; y++, screen += linewidth, source+=width)
		{
//			memcpy (screen, source, width);
			VGAWRITEBUF(screen, source, width);
		}

		mask <<= 1;

		if (mask == 16)
		{
			mask = 1;
			dest++;
		}
	}
}


#if 1
/*
=======================
=
= VL_CopyPlanarPage
=
=======================
*/
void VL_CopyPlanarPage ( unsigned src, unsigned dest )
{
	int plane;

	for (plane=0;plane<4;plane++)
	{
		VGAREADMAP(plane);
		VGAWRITEMAP(plane);
		VGAMEMCPY(dest,src,screensize);
	}
}

/*
=======================
=
= VL_CopyPlanarPageToMemory
=
=======================
*/
void VL_CopyPlanarPageToMemory ( unsigned src, byte * dest )
{
	byte * ptr;
	int plane,a,b;

	for (plane=0; plane<4; plane++)
	{
		ptr=dest+plane;
		VGAREADMAP(plane);
		for (a=0;a<200;a++)
			for (b=0;b<80;b++,ptr+=4)
//				*(ptr)=*(src+(a*linewidth)+b);
				*(ptr)=VGAREAD(src+(a*linewidth)+b);
	}
}

/*
=======================
=
= VL_CopyBufferToAll
=
=======================
*/
void VL_CopyBufferToAll ( unsigned buffer )
{
	int plane;

	for (plane=0;plane<4;plane++)
	{
		VGAREADMAP(plane);
		VGAWRITEMAP(plane);
		if (page1start!=buffer)
			VGAMEMCPY(page1start,buffer,screensize);
		if (page2start!=buffer)
			VGAMEMCPY(page2start,buffer,screensize);
		if (page3start!=buffer)
			VGAMEMCPY(page3start,buffer,screensize);
	}
}

void VL_CopyDisplayToHidden ( void )
{
   VL_CopyBufferToAll ( displayofs );
}
#endif


//*************************************************************************
//
// DrawTiledRegion () - Fills the specified region with a tiled image
//
//*************************************************************************
void DrawTiledRegion
	(
	int x,
	int y,
	int width,
	int height,
	int offx,
	int offy,
	pic_t *tile
	)

	{
	byte  *source;
	byte  *sourceoff;
	int	sourcex;
	int	sourcey;
	int	sourcewidth;
	int	sourceheight;
	int	mask;
	int	plane;
	int	planesize;
//	byte  *start;
	unsigned		start;
//	byte  *origdest;
	unsigned		origdest;
//	byte  *dest;
	unsigned		dest;
	int	startoffset;
	int	HeightIndex;
	int	WidthIndex;

//	start = ( byte * )( bufferofs + ( x>>2 ) + ylookup[ y ] );
	start = ( bufferofs + ( x>>2 ) + ylookup[ y ] );

	source		= &tile->data;
	sourcewidth  = tile->width;
	sourceheight = tile->height;
	offx >>= 2;
	if ( offx >= sourcewidth )
		{
		offx %= sourcewidth;
		}
	if ( offy >= sourceheight )
		{
		offy %= sourceheight;
		}

	startoffset = offy * sourcewidth;
	planesize = sourcewidth * sourceheight;

	width >>= 2;

	mask  = 1 << ( x & 3 );
	plane = 4;
	while( plane > 0 )
		{
		VGAMAPMASK( mask );
		origdest = start;

		sourcey	= offy;
		sourceoff	= source + startoffset;
		HeightIndex = height;

		while( HeightIndex-- )
			{
			dest		= origdest;
			sourcex	= offx;
			WidthIndex = width;
			while( WidthIndex-- )
				{
//				*dest = sourceoff[ sourcex ];
				VGAWRITE(dest, sourceoff[ sourcex ]);
				dest++;
				sourcex++;
				if ( sourcex >= sourcewidth )
					{
					sourcex = 0;
					}
				}

			origdest  += SCREENBWIDE;
			sourceoff += sourcewidth;
			sourcey++;
			if ( sourcey >= sourceheight )
				{
				sourcey	= 0;
				sourceoff = source;
				}
			}

		source += planesize;

		mask <<= 1;
		if ( mask > 8 )
			{
			mask = 1;
			}

		plane--;
		}
	}


//******************************************************************************
//
// VWB_DrawPic () - Draws a linear pic and marks the update block
//
//******************************************************************************

void VWB_DrawPic (int x, int y, pic_t *pic)
{
	if (VW_MarkUpdateBlock (x, y, x+(pic->width<<2)-1, y+(pic->height)-1))
		VL_MemToScreen ((byte *)&pic->data, pic->width, pic->height, x, y);
}



//******************************************************************************
//
// VL_Bar () - Draws a bar
//
//******************************************************************************

void VL_Bar (int x, int y, int width, int height, int color)
{
//	byte  *dest;
	int		dest;
	byte  leftmask,rightmask;
	int	midbytes,linedelta;

	leftmask = leftmasks[x&3];
	rightmask = rightmasks[(x+width-1)&3];
	midbytes = ((x+width+3)>>2) - (x>>2) - 2;
	linedelta = linewidth-(midbytes+1);

//	dest = (byte *)(bufferofs+ylookup[y]+(x>>2));
	dest = (bufferofs+ylookup[y]+(x>>2));

	if (midbytes < 0)
	{
	// all in one byte
		VGAMAPMASK (leftmask&rightmask);
		while (height--)
		{
//			*dest = color;
			VGAWRITE(dest, color);
			dest += linewidth;
		}
		VGAMAPMASK (15);
		return;
	}

	while (height--)
	{
		VGAMAPMASK (leftmask);
//		*dest++ = color;
		VGAWRITE(dest++, color);

		VGAMAPMASK (15);
//		memset (dest,color,midbytes);
		VGAMEMSET (dest, color, midbytes);
		dest += midbytes;

		VGAMAPMASK (rightmask);
//		*dest = color;
		VGAWRITE(dest, color);

		dest += linedelta;
	}

	VGAMAPMASK(15);
}



//******************************************************************************
//
// VWB_Bar () - Draws a block and marks the update block
//
//******************************************************************************

void VWB_Bar (int x, int y, int width, int height, int color)
{
	if (VW_MarkUpdateBlock (x,y,x+width,y+height-1) )
		VL_Bar (x, y, width, height, color);
}


//******************************************************************************
//
// VL_TBar () - Draws a bar
//
//******************************************************************************

void VL_TBar (int x, int y, int width, int height)
{
//	byte  *dest;
	int dest;
	byte  pixel;
	byte  readmask;
	byte  writemask;
	int	w = width;

	while (height--)
	{
		width = w;

//		dest = (byte*)(bufferofs+ylookup[y]+(x>>2));
		dest = (bufferofs+ylookup[y]+(x>>2));
		readmask	= (x&3);
		writemask	= 1 << readmask;

		VGAREADMAP (readmask);
		VGAMAPMASK (writemask);

		while (width--)
		{
//			pixel = *dest;
			pixel = VGAREAD(dest);

			pixel = *(colormap+(27<<8)+pixel);

//			*dest = pixel;
			VGAWRITE(dest, pixel);

			writemask <<= 1;
			if (writemask == 16)
			{
				writemask = 1;
				dest++;
			}

			readmask++;
			if (readmask == 4)
				readmask = 0;

			VGAREADMAP (readmask);
			VGAMAPMASK (writemask);
		}

		y++;
	}
}



//******************************************************************************
//
// VWB_TBar () - Draws a block and marks the update block
//
//******************************************************************************

void VWB_TBar (int x, int y, int width, int height)
{
	if (VW_MarkUpdateBlock (x,y,x+width,y+height-1))
		VL_TBar (x, y, width, height);
}


//******************************************************************************
//
// VL_Hlin () - Draws a horizontal line
//
//******************************************************************************

void VL_Hlin (unsigned x, unsigned y, unsigned width, unsigned color)
{
	unsigned xbyte;
//	byte	*dest;
	int			dest;
	byte	leftmask,
				rightmask;
	int		midbytes;

	xbyte =		x >> 2;
	leftmask	= leftmasks[x&3];
	rightmask	= rightmasks[(x+width-1)&3];
	midbytes	= ((x+width+3)>>2) - xbyte - 2;

//	dest = (byte*)(bufferofs+ylookup[y]+xbyte);
	dest = (bufferofs+ylookup[y]+xbyte);

	if (midbytes<0)
	{
	// all in one byte
		VGAMAPMASK (leftmask & rightmask);
//		*dest = color;
		VGAWRITE(dest, color);
		VGAMAPMASK(15);
		return;
	}

	VGAMAPMASK (leftmask);
//	*dest++ = color;
	VGAWRITE(dest++, color);

	VGAMAPMASK (15);
//	memset (dest, color, midbytes);
	VGAMEMSET (dest, color, midbytes);
	dest += midbytes;

	VGAMAPMASK (rightmask);
//	*dest = color;
	VGAWRITE(dest, color);

	VGAMAPMASK (15);
}


//******************************************************************************
//
// VL_Vlin () - Draws a vertical line
//
//******************************************************************************

void VL_Vlin (int x, int y, int height, int color)
{
//	byte  *dest, mask;
	unsigned dest, mask;

	mask = pixmasks[x&3];
	VGAMAPMASK (mask);

//	dest = (byte *)(bufferofs+ylookup[y]+(x>>2));
	dest = (bufferofs+ylookup[y]+(x>>2));

	while (height--)
	{
//		*dest = color;
		VGAWRITE(dest, color);
		dest += linewidth;
	}

	VGAMAPMASK (15);
}



//******************************************************************************
//
// VWB_Hlin () - Draws a horizontal line and marks the update block
//
//******************************************************************************

void VWB_Hlin (int x1, int x2, int y, int color)
{
	if (VW_MarkUpdateBlock (x1,y,x2,y))
		VW_Hlin(x1,x2,y,color);
}


//******************************************************************************
//
// VWB_Vlin () - Draws a vertical line and marks the update block
//
//******************************************************************************

void VWB_Vlin (int y1, int y2, int x, int color)
{
	if (VW_MarkUpdateBlock (x,y1,x,y2))
		VW_Vlin(y1,y2,x,color);
}




//******************************************************************************
//
// VL_THlin ()
//
//******************************************************************************

void VL_THlin (unsigned x, unsigned y, unsigned width, boolean up)
{
//	byte	*dest;
	int		dest;
	byte	pixel;
	byte	readmask;
	byte	writemask;


	readmask	= (x&3);
	writemask	= 1 << readmask;

//	dest = (byte*)(bufferofs+ylookup[y]+(x>>2));
	dest = (bufferofs+ylookup[y]+(x>>2));

	VGAREADMAP (readmask);
	VGAMAPMASK (writemask);

	while (width--)
	{
//		pixel = *dest;
		pixel = VGAREAD(dest);

		if (up)
			pixel = *(colormap+(13<<8)+pixel);
		else
			pixel = *(colormap+(27<<8)+pixel);

//		*dest = pixel;
		VGAWRITE(dest, pixel);

		writemask <<= 1;
		if (writemask == 16)
		{
			writemask = 1;
			dest++;
		}

		readmask++;
		if (readmask == 4)
			readmask = 0;

		VGAREADMAP (readmask);
		VGAMAPMASK (writemask);
	}
}



//******************************************************************************
//
// VL_TVlin ()
//
//******************************************************************************

void VL_TVlin (unsigned x, unsigned y, unsigned height, boolean up)
{
//	byte	*dest;
	int		dest;
	byte	pixel;
	byte	readmask;
	byte	writemask;



	readmask	= (x&3);
	writemask	= 1 << readmask;

//	dest = (byte*)(bufferofs+ylookup[y]+(x>>2));
	dest = (bufferofs+ylookup[y]+(x>>2));

	VGAREADMAP (readmask);
	VGAMAPMASK (writemask);

	while (height--)
	{
//		pixel = *dest;
		pixel = VGAREAD(dest);

		if (up)
			pixel = *(colormap+(13<<8)+pixel);
		else
			pixel = *(colormap+(27<<8)+pixel);

//		*dest = pixel;
		VGAWRITE(dest, pixel);

		dest += linewidth;
	}
}



//******************************************************************************
//
// VWB_THlin () - Draws a horizontal line and marks the update block
//
//******************************************************************************

void VWB_THlin (int x1, int x2, int y, boolean up)
{
	if (VW_MarkUpdateBlock (x1,y,x2,y))
		VW_THlin (x1,x2,y,up);
}


//******************************************************************************
//
// VWB_TVlin () - Draws a vertical line and marks the update block
//
//******************************************************************************

void VWB_TVlin (int y1, int y2, int x, boolean up)
{
	if (VW_MarkUpdateBlock (x,y1,x,y2))
		VW_TVlin (y1,y2,x,up);
}



/*
================================================================================

				Double buffer management routines

================================================================================
*/


//******************************************************************************
//
// VW_MarkUpdateBlock
//
// Takes a pixel bounded block and marks the tiles in bufferblocks
// Returns 0 if the entire block is off the buffer screen
//
//******************************************************************************

int VW_MarkUpdateBlock (int x1, int y1, int x2, int y2)
{
	int	x,
			y,
			xt1,
			yt1,
			xt2,
			yt2,
			nextline;
	byte  *mark;

	xt1 = x1 >> PIXTOBLOCK;
	yt1 = y1 >> PIXTOBLOCK;

	xt2 = x2 >> PIXTOBLOCK;
	yt2 = y2 >> PIXTOBLOCK;

	if (xt1 < 0)
		xt1 = 0;
	else
		if (xt1 >= UPDATEWIDE)
			return 0;

	if (yt1 < 0)
		yt1 = 0;
	else
		if (yt1 > UPDATEHIGH)
			return 0;

	if (xt2 < 0)
		return 0;
	else
		if (xt2 >= UPDATEWIDE)
			xt2 = UPDATEWIDE-1;

	if (yt2 < 0)
		return 0;
	else
		if (yt2 >= UPDATEHIGH)
			yt2 = UPDATEHIGH-1;

	mark = updateptr + uwidthtable[yt1] + xt1;
	nextline = UPDATEWIDE - (xt2-xt1) - 1;

	for (y = yt1; y <= yt2; y++)
	{
		for (x = xt1; x <= xt2; x++)
			*mark++ = 1;						// this tile will need to be updated

		mark += nextline;
	}

	return 1;
}


//******************************************************************************
//
// VW_UpdateScreen ()
//
//******************************************************************************


void VW_UpdateScreen (void)
{
	VH_UpdateScreen ();
}



/*
=============================================================================

						PALETTE OPS

		To avoid snow, do a WaitVBL BEFORE calling these

=============================================================================
*/


/*
=================
=
= VL_FillPalette
=
=================
*/

#if 0
void VL_FillPalette (int red, int green, int blue)
{
	int	i;

	OUTP (PEL_WRITE_ADR,0);
	for (i=0;i<256;i++)
	{
		OUTP (PEL_DATA,red);
		OUTP (PEL_DATA,green);
		OUTP (PEL_DATA,blue);
	}
}
#endif

//===========================================================================

/*
=================
=
= VL_SetColor
=
=================
*/

#if 0
void VL_SetColor  (int color, int red, int green, int blue)
{
	OUTP (PEL_WRITE_ADR,color);
	OUTP (PEL_DATA,red);
	OUTP (PEL_DATA,green);
	OUTP (PEL_DATA,blue);
}
#endif

//===========================================================================

/*
=================
=
= VL_GetColor
=
=================
*/

#if 0
void VL_GetColor  (int color, int *red, int *green, int *blue)
{
//	OUTP (PEL_READ_ADR,color);
//	*red	= inp (PEL_DATA);
//	*green = inp (PEL_DATA);
//	*blue  = inp (PEL_DATA);
}
#endif

//===========================================================================

//===========================================================================

/*
=================
=
= VL_FadeOut
=
= Fades the current palette to the given color in the given number of steps
=
=================
*/

void VL_FadeOut (int start, int end, int red, int green, int blue, int steps)
{
	int		i,j,orig,delta;
	byte  *origptr, *newptr;

	if (screenfaded)
		return;

	WaitVBL ();
	VL_GetPalette (&palette1[0][0]);
	memcpy (palette2, palette1, 768);

//
// fade through intermediate frames
//
	for (i = 0; i < steps; i++)
	{
		origptr = &palette1[start][0];
		newptr = &palette2[start][0];

		for (j = start; j <= end; j++)
		{
			orig = *origptr++;
			delta = red-orig;
			*newptr++ = orig + delta * i / steps;
			orig = *origptr++;
			delta = green-orig;
			*newptr++ = orig + delta * i / steps;
			orig = *origptr++;
			delta = blue-orig;
			*newptr++ = orig + delta * i / steps;
		}

		WaitVBL ();
		VL_SetPalette (&palette2[0][0]);
	}

//
// final color
//
	VL_FillPalette (red, green, blue);

	screenfaded = true;
}


/*
=================
=
= VL_FadeToColor
=
= Fades the current palette to the given color in the given number of steps
=
=================
*/

void VL_FadeToColor (int time, int red, int green, int blue)
{
	int		i,j,orig,delta;
	byte  *origptr, *newptr;
	int dmax,dmin;

	if (screenfaded)
		return;

	WaitVBL ();
	VL_GetPalette (&palette1[0][0]);
	memcpy (palette2, palette1, 768);

	dmax=(maxshade<<16)/time;
	dmin=(minshade<<16)/time;
//
// fade through intermediate frames
//
	for (i = 0; i < time; i+=tics)
	{
		origptr = &palette1[0][0];
		newptr = &palette2[0][0];

		for (j = 0; j <= 255; j++)
		{
			orig = *origptr++;
			delta = ((red>>2)-orig)<<16;
			*newptr++ = orig + FixedMul(delta/time,i);
			orig = *origptr++;
			delta = ((green>>2)-orig)<<16;
			*newptr++ = orig + FixedMul(delta/time,i);
			orig = *origptr++;
			delta = ((blue>>2)-orig)<<16;
			*newptr++ = orig + FixedMul(delta/time,i);
		}

		maxshade=(dmax*(time-i))>>16;
		minshade=(dmin*(time-i))>>16;
		WaitVBL ();
		VL_SetPalette (&palette2[0][0]);
		ThreeDRefresh();
		CalcTics();

	}

//
// final color
//
	VL_FillPalette (red>>2,green>>2,blue>>2);

	screenfaded = true;
}




/*
=================
=
= VL_FadeIn
=
=================
*/

void VL_FadeIn (int start, int end, byte *palette, int steps)
{
	int		i,j,delta;

	WaitVBL ();
	VL_GetPalette (&palette1[0][0]);

	memcpy (&palette2[0][0], &palette1[0][0], sizeof(palette1));

	start *= 3;
	end = end*3+2;

//
// fade through intermediate frames
//
	for (i=0;i<steps;i++)
	{
		for (j=start;j<=end;j++)
		{
			delta = palette[j]-palette1[0][j];
			palette2[0][j] = palette1[0][j] + delta * i / steps;
		}

		WaitVBL ();
		VL_SetPalette (&palette2[0][0]);
	}

//
// final color
//
	VL_SetPalette (palette);
	screenfaded = false;
}



//******************************************************************************
//
// SwitchPalette
//
//******************************************************************************

void SwitchPalette (byte * newpal, int steps)
{
	int temp;

	VL_FadeOut(0,255,0,0,0,steps>>1);

	temp = bufferofs;
	bufferofs = displayofs;
	VL_Bar (0, 0, 320, 200, 0);
	bufferofs = temp;

	VL_FadeIn(0,255,newpal,steps>>1);
}


#if 0

/*
=================
=
= VL_TestPaletteSet
=
= Sets the palette with outsb, then reads it in and compares
= If it compares ok, fastpalette is set to true.
=
=================
*/

void VL_TestPaletteSet (void)
{
	int	i;

	for (i=0;i<768;i++)
		palette1[0][i] = i;

	fastpalette = true;
	VL_SetPalette (&palette1[0][0]);
	VL_GetPalette (&palette2[0][0]);
	if (_fmemcmp (&palette1[0][0],&palette2[0][0],768))
		fastpalette = false;
}


/*
==================
=
= VL_ColorBorder
=
==================
*/

void VL_ColorBorder (int color)
{
	_AH=0x10;
	_AL=1;
	_BH=color;
	geninterrupt (0x10);
	bordercolor = color;
}


#endif


//==========================================================================

//****************************************************************************
//
// VL_DecompressLBM ()
//
// LIMITATIONS - Only works with 320x200!!!
//
//****************************************************************************

void VL_DecompressLBM (lbm_t *lbminfo, boolean flip)
{
//	byte *screen = (byte *)bufferofs;
	int		screen = bufferofs;
//	byte *orig;
	int		orig;
	int  count;
	byte b,
		rept;
	byte *source = (byte *)&lbminfo->data;
	byte *buf;
//	int		buf;
	int  ht = lbminfo->height;
	int  planes;
	byte writemask;
	int  x = 0;
	int  y;
	byte *origbuf;
	byte pal[768];

	writemask	= 1 << (x&3);
	orig = screen;

	buf = (byte *) SafeMalloc (64000);

	origbuf = buf;

	VL_ClearBuffer (displayofs, 0);

	memcpy(&pal[0],lbminfo->palette,768);

	VL_NormalizePalette (&pal[0]);

	VW_MarkUpdateBlock (0, 0, 320, 200);

	while (ht--)
	{
		count = 0;

		do
		{
			rept = *source++;

			if (rept > 0x80)
			{
				rept = (rept^0xff)+2;
				b = *source++;
				memset (buf, b, rept);
				buf += rept;
			}
			else if (rept < 0x80)
			{
				rept++;
				memcpy (buf, source, rept);
				buf += rept;
				source += rept;
			}
			else
				rept = 0;					// rept of 0x80 is NOP

			count += rept;

		} while (count < lbminfo->width);
	}

	for (planes = 0; planes < 4; planes++)
	{
		int cnt;

		cnt = 0;
		screen = orig;
		buf = origbuf;
		VGAMAPMASK (writemask);

		for (y = 0; y < ((lbminfo->height*lbminfo->width)>>2); y++)
		{
//			*screen++ = *(buf+(y*4)+planes);
			VGAWRITE(screen++, *(buf+(y*4)+planes));
			cnt++;

			if (cnt == 80)
			{
				screen += 16;
				cnt = 0;
			}
		}

		writemask <<= 1;
	}

	SafeFree(origbuf);

	if (flip==true)
		VW_UpdateScreen ();

	VL_FadeIn (0, 255, &pal[0], 15);

}

//****************************************************************************
//
// SetBorderColor
//
//****************************************************************************

#if 0
void SetBorderColor (int color)
{
//	inp  (STATUS_REGISTER_1);
//	outp (ATR_INDEX,0x31);
//	outp (ATR_INDEX,color);
}
#endif

//****************************************************************************
//
// SetBorderColorInterrupt
//
//****************************************************************************

#if 0
void SetBorderColorInterrupt (int color)
{
	union REGS regs;

	regs.w.ax = 0x1001;
	regs.w.bx = color<<8;
	int386(0x10,&regs,&regs);
}
#endif


//****************************************************************************
//
// VL_DrawPostPic
//
//****************************************************************************

void VL_DrawPostPic (int lumpnum)
{
	DrawPostPic(lumpnum);
	VW_MarkUpdateBlock (0, 0, 319, 199);
}

//****************************************************************************
//
// VL_DrawLine
//
//****************************************************************************

void VL_DrawLine (int x1, int y1, int x2, int y2, byte color)
{
	int dx;
	int dy;
	int xinc;
	int yinc;
	int count;

	dx=(x2-x1);
	dy=(y2-y1);
	if (abs(dy)>=abs(dx))
		{
		count=abs(dy);
		yinc=(dy<<16)/count;
		if (dy==0)
			{
			return;
			}
		else
			{
			xinc=(dx<<16)/count;
			}
		}
	else
		{
		count=abs(dx);
		xinc=(dx<<16)/count;
		if (dx==0)
			{
			return;
			}
		else
			{
			yinc=(dy<<16)/count;
			}
		}
	x1<<=16;
	y1<<=16;
	while (count>0)
	{
		VGAWRITEMAP((x1>>16)&3);
//		*((byte *)bufferofs+(x1>>18)+(ylookup[y1>>16]))=color;
		VGAWRITE(bufferofs+(x1>>18)+(ylookup[y1>>16]), color);
//		*((byte *)bufferofs+(x1>>16)+(ylookup[y1>>16]))=color;
		x1+=xinc;
		y1+=yinc;
		count--;
	}
}


//******************************************************************************
//
// DrawXYPic
//
//******************************************************************************

#if 1
void DrawXYPic (int x, int y, int shapenum)
{
//	byte *buffer;
	int buffer;
//	byte *buf;
	int buf;
	int xx,yy;
	int plane;
	byte *src;
	pic_t *p;

//	p = (pic_t *) W_CacheLumpNum (shapenum, PU_CACHE);
	p = (pic_t *) W_CacheWallLumpNum (shapenum, PU_CACHE);

	if ((x<0) || ((x+(p->width<<2))>=320))
		Error ("DrawXYPic: x is out of range\n");
	if ((y<0) || ((y+p->height)>=200))
		Error ("DrawXYPic: y is out of range\n");


//	buffer = (byte*)bufferofs+(x>>2)+ylookup[y];
	buffer = bufferofs+(x>>2)+ylookup[y];
//	buffer = (byte*)bufferofs+x+ylookup[y];

	src=(byte *)&p->data;
	for (plane=x;plane<x+4;plane++)
	{
		VGAWRITEMAP((plane&3));
		for (yy = 0; yy < p->height; yy++)
		{
			buf=buffer+ylookup[yy];
			for (xx = 0; xx < p->width; xx++,buf++)
//				*(buf)=*(src++);
				VGAWRITE(buf, *(src++));
		}
	}
}
#endif

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "rt_def.h"
#include "rt_view.h"
#include "z_zone.h"
#include "w_wad.h"
#include "lumpy.h"
#include "rt_util.h"
#include "rt_vid.h"
#include "rt_game.h"
#include "rt_draw.h"
#include "rt_ted.h"
// #include "isr.h"
#include "rt_rand.h"
#include "rt_sound.h"
#include "modexlib.h"
#include "rt_menu.h"
// #include <mem.h>
#include <stdlib.h>

#include "rt_main.h"
#include "rt_battl.h"
#include "rt_floor.h"
#include "rt_str.h"
#include "watcom.h"
#include "develop.h"
//MED
// #include "memcheck.h"

#define LIGHTNINGLEVEL 4
#define MINLIGHTNINGLEVEL   2
#define MAXLIGHTNINGLEVEL   10

/*
=============================================================================

                               GLOBALS

=============================================================================
*/
int    StatusBar = 0;
int    lightninglevel=0;
boolean  lightning=false;
int    normalshade;
int    darknesslevel;
int    maxshade;
int    minshade;
int    baseminshade;
int    basemaxshade;
int    viewheight;
int    viewwidth;
longword   heightnumerator;
fixed  scale;
int    screenofs;
int    centerx;
int    centery;
int    centeryfrac;
int    fulllight;
int    weaponscale;
int    viewsize;
byte * colormap;
byte * redmap;
byte * greenmap;
byte * playermaps[MAXPLAYERCOLORS];
short  pixelangle[MAXVIEWWIDTH];
byte   gammatable[GAMMAENTRIES];
int    gammaindex;
int    focalwidth=FOCALWIDTH;
int    yzangleconverter;
byte   uniformcolors[MAXPLAYERCOLORS]={
                                       25,
                                       222,
                                       29,
                                       206,
                                       52,
                                       6,
                                       155,
                                       16,
                                       90,
                                       129,
                                       109
                                       };

byte    mapmasks1[4][9] = {
{1 ,3 ,7 ,15,15,15,15,15,15},
{2 ,6 ,14,14,14,14,14,14,14},
{4 ,12,12,12,12,12,12,12,12},
{8 ,8 ,8 ,8 ,8 ,8 ,8 ,8 ,8} };

byte    mapmasks2[4][9] = {
{0 ,0 ,0 ,0 ,1 ,3 ,7 ,15,15},
{0 ,0 ,0 ,1 ,3 ,7 ,15,15,15},
{0 ,0 ,1 ,3 ,7 ,15,15,15,15},
{0 ,1 ,3 ,7 ,15,15,15,15,15} };

byte    mapmasks3[4][9] = {
{0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1},
{0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,3},
{0 ,0 ,0 ,0 ,0 ,0 ,1 ,3 ,7},
{0 ,0 ,0 ,0 ,0 ,1 ,3 ,7 ,15} };



/*
=============================================================================

                               LOCAL

=============================================================================
*/

static char *YourComputerSucksString = "Buy a 486! :)";

static int viewsizes[MAXVIEWSIZES*2]={ 80,48,
                           128,72,
                           160,88,
                           192,104,
                           224,120,
                           256,136,
                           288,152,
                           320,168,
                           320,184,
                           320,200,
                           320,200};

static int ColorMapLoaded=0;

static int      lightningtime=0;
static int      lightningdelta=0;
static int      lightningdistance=0;
static int      lightningsoundtime=0;
static boolean  periodic=false;
static int      periodictime=0;

/*
====================
=
= ResetFocalWidth
=
====================
*/
void ResetFocalWidth ( void )
{
   focalwidth=FOCALWIDTH;
   SetViewDelta();
}

/*
====================
=
= ChangeFocalWidth
=
====================
*/
void ChangeFocalWidth ( int amount )
{
   focalwidth=FOCALWIDTH+amount;
   SetViewDelta();
}


/*
====================
=
= SetViewDelta
=
====================
*/

void SetViewDelta ( void )
{

//
// calculate scale value for vertical height calculations
// and sprite x calculations
//
   scale = (centerx*focalwidth)/160;

//
// divide heightnumerator by a posts distance to get the posts height for
// the heightbuffer.  The pixel height is height>>HEIGHTFRACTION
//
   heightnumerator = (((focalwidth/10)*centerx*4096)<<HEIGHTFRACTION);
}

/*
====================
=
= CalcProjection
=
====================
*/

void CalcProjection ( void )
{
    int   i;
    int   frac;
    long  intang;
    byte * table;
    byte * ptr;
    int   length;
    int  * pangle;



// Already being called in ResetFocalWidth
//    SetViewDelta();

//
// load in tables file
//


//Hey, isn't this stuff already loaded in?
//Why don't we make this a lump?
   table=W_CacheLumpName("tables",PU_STATIC);
   ptr=table;

//
// get size of table
//

   memcpy(&length,ptr,sizeof(int));
   ptr+=sizeof(int);
   pangle=SafeMalloc(length*sizeof(int));
   memcpy(pangle,ptr,length*sizeof(int));

   frac=((length*65536/centerx))>>1;
   for (i=0;i<centerx;i++)
      {
      // start 1/2 pixel over, so viewangle bisects two middle pixels
      intang=pangle[frac>>16];
      pixelangle[centerx-1-i] =(short) intang;
      pixelangle[centerx+i] =(short) -intang;
      frac+=(length*65536/centerx);
      }
   table=W_CacheLumpName("tables",PU_CACHE);
   SafeFree(pangle);
}


/*
==========================
=
= SetViewSize
=
==========================
*/

void SetViewSize
   (
   int size
   )

   {
   int height;
   int maxheight;
   int screenx;
   int screeny;
   int topy;

   if ((size<0) || (size>=MAXVIEWSIZES))
      Error("Illegal screen size = %ld\n",size);

   viewwidth  = viewsizes[ size << 1 ];         // must be divisable by 16
   viewheight = viewsizes[ ( size << 1 ) + 1 ]; // must be even

   maxheight = 200;
   topy      = 0;

   // Only keep the kills flag
   StatusBar &= ~( BOTTOM_STATUS_BAR | TOP_STATUS_BAR |
      STATUS_PLAYER_STATS );

   if ( SHOW_KILLS() )
      {
      // Account for height of kill boxes
      maxheight -= 24;
      }

   if ( size < 9 )
      {
      StatusBar |= TOP_STATUS_BAR;

      // Account for height of top status bar
      maxheight -= 16;
      topy      += 16;
      }

   if ( size < 8 )
      {
      // Turn on health and ammo bar
      StatusBar |= BOTTOM_STATUS_BAR;
      maxheight -= 16;
      }
   else if ( size < 10 )
      {
      // Turn on transparent health and ammo bar
      StatusBar |= STATUS_PLAYER_STATS;
      }

   height = viewheight;
   if ( height > 168 )
      {
      // Prevent weapon from being scaled too big
      height = 168;
      }

   weaponscale = ( height << 16 ) / 168;
   centerx     = viewwidth >> 1;
   centery     = viewheight >> 1;
   centeryfrac = (centery << 16);
   yzangleconverter = ( 0xaf85 * viewheight ) / 200;

   // Center the view horizontally
   screenx = ( 320 - viewwidth ) >> 1;

   if ( viewheight >= maxheight )
      {
      screeny = topy;
      viewheight = maxheight;
      }
   else
      {
      // Center the view vertically
      screeny = ( ( maxheight - viewheight ) >> 1 ) + topy;
      }

   // Calculate offset of view window
   screenofs = ( screenx >> 2 ) + ylookup[ screeny ];

//
// calculate trace angles and projection constants
//

   ResetFocalWidth();


// Already being called in ResetFocalWidth
//   SetViewDelta();

   CalcProjection();
   }


//******************************************************************************
//
// DrawCPUJape ()
//
//******************************************************************************

void DrawCPUJape
   (
   void
   )

   {
   int width;
   int height;

   CurrentFont = tinyfont;
   VW_MeasurePropString( YourComputerSucksString, &width, &height );

   DrawGameString( 160 - width / 2, 100 + 48 / 2 + 2,
      YourComputerSucksString, true );
   }


/*
==========================
=
= SetupScreen
=
==========================
*/

void SetupScreen ( boolean flip )
{
   pic_t *shape;

   SetViewSize(viewsize);
   if ( viewsize < 7 )
      {
      shape = W_CacheLumpName( "backtile", PU_CACHE );
      DrawTiledRegion( 0, 16, 320, 200 - 32, 0, 16, shape );
      }

   if ( viewsize == 0 )
      {
      DrawCPUJape();
      }

   DrawPlayScreen (true);
   if (flip==true)
      {
      ThreeDRefresh();
      VL_CopyDisplayToHidden();
      }
}



void LoadColorMap( void )
{
   int i,j;
   int lump, length;

   if (ColorMapLoaded==1)
      Error("Called LoadColorMap twice\n");
   ColorMapLoaded=1;
//
//   load in the light tables
//   256 byte align tables
//

	lump = W_GetNumForName("colormap");
	length = W_LumpLength (lump) + 255;
	colormap = SafeMalloc (length);
	colormap = (byte *)( ((nlint)colormap + 255)&~0xff);
	W_ReadLump (lump,colormap);

// Fix fire colors in colormap

   for (i=31;i>=16;i--)
		for (j=0xea;j<0xf9;j++)
         colormap[i*256+j]=colormap[(((i-16)/4+16))*256+j];

// Get special maps

	lump = W_GetNumForName("specmaps");
	length = W_LumpLength (lump+1) + 255;
	redmap = SafeMalloc (length);
	redmap = (byte *)( ((nlint)redmap + 255)&~0xff);
	W_ReadLump (lump+1,redmap);
   greenmap = redmap+(16*256);

// Get player colormaps

//   if (modemgame==true)
      {
      lump = W_GetNumForName("playmaps")+1;
      for (i=0;i<MAXPLAYERCOLORS;i++)
         {
	      length = W_LumpLength (lump+i) + 255;
	      playermaps[i] = SafeMalloc (length);
	      playermaps[i] = (byte *)( ((nlint)playermaps[i] + 255)&~0xff);
	      W_ReadLump (lump+i,playermaps[i]);
         }
      }

   if (!quiet)
      printf("RT_VIEW: Colormaps Initialized\n");

}

boolean rott_iswolf;


/*
==========================
=
= SetupLightLevels
=
==========================
*/
#define LIGHTRATEBASE 252
#define LIGHTRATEEND  267
#define LIGHTLEVELBASE 216
#define LIGHTLEVELEND  223
void SetupLightLevels ( void )
{
   int glevel;

   periodic=false;
	fog=0;
	lightsource=0;

	rott_iswolf=false;
//	if ((word)MAPSPOT(3,0,1)==99)
//		rott_iswolf=true;

// Set up light level for level

	if (((word)MAPSPOT(2,0,1)>=104) && ((word)MAPSPOT(2,0,1)<=105))
		fog=(word)MAPSPOT(2,0,1)-104;
	else
		Error ("There is no Fog icon on map %ld\n",gamestate.mapon);
	if ((word)MAPSPOT(3,0,1)==139)
      {
      if (fog==0)
         {
		   lightsource=1;
         lights=Z_Malloc(MAPSIZE*MAPSIZE*(sizeof(unsigned long)),PU_LEVEL,NULL);
         memset (lights,0,MAPSIZE*MAPSIZE*(sizeof(unsigned long)));
         }
      else
		   Error("You cannot use light sourcing on a level with fog on map %ld\n",gamestate.mapon);
      }
	else if ((word)MAPSPOT(3,0,1)==99)
	{
		rott_iswolf=true;
	}
	else if ((word)MAPSPOT(3,0,1))
		Error("You must use the lightsource icon or nothing at all at (3,0) in plane 1 on map %ld\n",gamestate.mapon);
   if (((word)MAPSPOT(2,0,0)>=LIGHTLEVELBASE) && ((word)MAPSPOT(2,0,0)<=LIGHTLEVELEND))
      glevel=(MAPSPOT(2,0,0)-LIGHTLEVELBASE);
	else
		Error("You must specify a valid darkness level icon at (2,0) on map %ld\n",gamestate.mapon);

   SetLightLevels ( glevel );

   if (((word)MAPSPOT(3,0,0)>=LIGHTRATEBASE) && ((word)MAPSPOT(3,0,0)<=LIGHTRATEEND))
      glevel=(MAPSPOT(3,0,0)-LIGHTRATEBASE);
	else
      {
//      Error("You must specify a valid darkness rate icon at (3,0) on map %ld\n",gamestate.mapon);
      glevel = 4;
      }

   SetLightRate ( glevel );
   lightningtime=0;
   lightningdistance=0;
   lightninglevel=0;
   lightningdelta=0;
   lightningsoundtime=0;
}

/*
==========================
=
= SetLightLevels
=
==========================
*/
void SetLightLevels ( int darkness )
{
   if (fog==0)
      {
      baseminshade=0x10+((7-darkness)>>1);
      basemaxshade=0x1f-(darkness>>1);
      }
   else
      {
      baseminshade=darkness;
      basemaxshade=0x10;
      }
   minshade=baseminshade;
   maxshade=basemaxshade;
   darknesslevel=darkness;
}

/*
==========================
=
= GetLightLevelTile
=
==========================
*/
int GetLightLevelTile ( void )
{
   if (fog==0)
      {
      return ((7-((baseminshade-0x10)<<1))+LIGHTLEVELBASE);
      }
   else
      {
      return (baseminshade+LIGHTLEVELBASE);
      }
}


/*
==========================
=
= SetLightRate
=
==========================
*/
void SetLightRate ( int rate )
{
   normalshade=(HEIGHTFRACTION+8)-rate;
   if (normalshade>14) normalshade=14;
   if (normalshade<3) normalshade=3;
}

/*
==========================
=
= GetLightRate
=
==========================
*/
int GetLightRate ( void )
{
   return ((HEIGHTFRACTION+8)-normalshade);
}

/*
==========================
=
= GetLightRateTile
=
==========================
*/
int GetLightRateTile ( void )
{
   return ((HEIGHTFRACTION+8)-normalshade+LIGHTRATEBASE);
}



/*
==========================
=
= UpdateLightLevel
=
==========================
*/
void UpdateLightLevel (int area)
{
   int numlights;
   int targetmin;
   int targetmax;
   int numtiles;

   if (fog==true)
      return;

   numtiles=(numareatiles[area]>>5)-2;
   numlights=(LightsInArea[area]-numtiles)>>1;

   if (numlights<0)
      numlights=0;
   if (numlights>GENERALNUMLIGHTS)
      numlights=GENERALNUMLIGHTS;
   targetmin=baseminshade+(GENERALNUMLIGHTS-numlights);
   targetmax=basemaxshade-numlights;
   if (targetmax<baseminshade)
      targetmax=baseminshade;
   if (targetmin>targetmax)
      targetmin=targetmax;

   if (minshade>targetmin)
      minshade-=1;
   else if (minshade<targetmin)
      minshade+=1;

   if (maxshade>targetmax)
      maxshade-=1;
   else if (maxshade<targetmax)
      maxshade+=1;

#if 0
   targetlevel=baseminshade+(GENERALNUMLIGHTS-numlights);
   if (abs(minshade-targetlevel)==1)
      minshade=targetlevel;
   else if (minshade>targetlevel)
      minshade-=2;
   else if (minshade<targetlevel)
      minshade+=2;
#endif
}

/*
==========================
=
= SetIllumination
=
= Postive value lightens
= Negative value darkens
=
==========================
*/
void SetIllumination (int level)
{
   if (fog)
      return;
	maxshade-=level;
   if (maxshade>31)
      maxshade=31;
   if (maxshade<0x10)
      maxshade=0x10;
	minshade-=level;
   if (minshade<0x10)
      minshade=0x10;
   if (minshade>31)
      minshade=31;
}

/*
==========================
=
= GetIlluminationDelta
=
==========================
*/
int GetIlluminationDelta (void)
{
   if (fog)
      return 0;
   else
      return maxshade-basemaxshade;
}

/*
==========================
=
= UpdateLightning
=
==========================
*/
void UpdateLightning (void)
{
   if (periodic==true)
      {
      UpdatePeriodicLighting();
      return;
      }
   if ((fog==1) || (lightning==false))
      return;

   if (lightningtime<=0)
      {
      if (lightningsoundtime>0)
         SD_Play3D (SD_LIGHTNINGSND, 0, lightningdistance);
      lightningtime=GameRandomNumber("UpdateLightning",0)<<1;
      lightningdistance=GameRandomNumber("UpdateLightning",0);
      lightninglevel=(255-lightningdistance)>>LIGHTNINGLEVEL;
      if (lightninglevel<MINLIGHTNINGLEVEL)
         lightninglevel=MINLIGHTNINGLEVEL;
      if (lightninglevel>MAXLIGHTNINGLEVEL)
         lightninglevel=MAXLIGHTNINGLEVEL;
      lightningdelta=lightninglevel>>1;
      lightningsoundtime=lightningdistance>>1;
      if (lightningdistance<100)
         {
         SetIllumination(lightninglevel);
         }
      }
   else if (lightninglevel>0)
      {
      lightninglevel-=lightningdelta;
      if (lightninglevel<=0)
         {
         lightninglevel=0;
         }
      }
   else
      lightningtime--;
   if (lightningsoundtime)
      {
      lightningsoundtime--;
      if (lightningsoundtime<=0)
         {
         int volume;

         volume=255-lightningdistance;
         if (volume>170) volume=170;
         SD_PlayPitchedSound ( SD_LIGHTNINGSND, volume,-(lightningdistance<<2));
         lightningsoundtime=0;
         }
      }
}

/*
==========================
=
= UpdatePeriodicLighting
=
==========================
*/
#define PERIODICMAG (6)
#define PERIODICSTEP (20)
#define PERIODICBASE (0x0f)
void UpdatePeriodicLighting (void)
{
   int val;

   val=FixedMul(PERIODICMAG,sintable[periodictime]);
   periodictime=(periodictime+PERIODICSTEP)&(FINEANGLES-1);
   basemaxshade=PERIODICBASE+(PERIODICMAG)+val;
   baseminshade=basemaxshade-GENERALNUMLIGHTS-1;
}

/*
==========================
=
= SetModemLightLevel
=
==========================
*/
void SetModemLightLevel ( int type )
{
   periodic=false;
   fulllight=false;
   switch (type)
      {
      case bo_light_dark:
         MAPSPOT(2,0,0)=(word)216;
         MAPSPOT(3,0,0)=(word)255;
         MAPSPOT(3,0,1)=(word)139;
         MAPSPOT(2,0,1)=(word)104;
         SetupLightLevels ();
         break;
      case bo_light_normal:
         break;
      case bo_light_bright:
         MAPSPOT(2,0,0)=(word)223;
         MAPSPOT(3,0,0)=(word)267;
         MAPSPOT(3,0,1)=(word)0;
         MAPSPOT(2,0,1)=(word)104;
         SetupLightLevels ();
         break;
      case bo_light_fog:
         MAPSPOT(2,0,0)=(word)219;
         MAPSPOT(3,0,0)=(word)259;
         MAPSPOT(2,0,1)=(word)105;
         MAPSPOT(3,0,1)=(word)0;
         SetupLightLevels ();
         break;
      case bo_light_periodic:
         fog=0;
         MAPSPOT(2,0,1)=(word)104;
         MAPSPOT(3,0,1)=(word)139;
         SetupLightLevels ();
         periodic=true;
         break;
      case bo_light_lightning:
         if (sky!=0)
            {
            MAPSPOT(2,0,0)=(word)222;
            MAPSPOT(3,0,0)=(word)255;
            MAPSPOT(3,0,1)=(word)139;
            MAPSPOT(2,0,1)=(word)104;
            SetupLightLevels ();
            lightning=true;
            }
         break;
      }
}

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// scriplib.c

#ifdef __NeXT__
// #include <libc.h>
#endif

#ifndef __NeXT__
// #include <io.h>
// #include <dos.h>
// #include <fcntl.h>
#include <string.h>
#endif

#include "rt_def.h"
#include "scriplib.h"
#include "rt_util.h"
//MED
// #include "memcheck.h"

/*
=============================================================================

						PARSING STUFF

=============================================================================
*/

char    token[MAXTOKEN];
char    name[MAXTOKEN*2];
char    scriptfilename[30];
char    *scriptbuffer,*script_p,*scriptend_p;
int     scriptline;
boolean endofscript;
boolean tokenready;                     // only true if UnGetToken was just called

/*
==============
=
= LoadScriptFile
=
==============
*/

void LoadScriptFile (char *filename)
{
	long            size;

	size = LoadFile (filename, (void **)&scriptbuffer);

   strcpy(&scriptfilename[0],filename);
	script_p = scriptbuffer;
	scriptend_p = script_p + size;
	scriptline = 1;
	endofscript = false;
	tokenready = false;
}


/*
==============
=
= UnGetToken
=
= Signals that the current token was not used, and should be reported
= for the next GetToken.  Note that

GetToken (true);
UnGetToken ();
GetToken (false);

= could cross a line boundary.
=
==============
*/

void UnGetToken (void)
{
	tokenready = true;
}


/*
==============
=
= GetToken
=
==============
*/

void GetToken (boolean crossline)
{
	char    *token_p;

	if (tokenready)                         // is a token allready waiting?
	{
		tokenready = false;
		return;
	}

	if (script_p >= scriptend_p)
	{
		if (!crossline)
         Error ("Line %i is incomplete\nin file %s\n",
                 scriptline,scriptfilename);
		endofscript = true;
		return;
	}

//
// skip space
//
skipspace:
	while (*script_p <= 32)
	{
		if (script_p >= scriptend_p)
		{
			if (!crossline)
            Error ("Line %i is incomplete\nin file %s\n",
                   scriptline,scriptfilename);
			endofscript = true;
			return;
		}
		if (*script_p++ == '\n')
		{
			if (!crossline)
            Error ("Line %i is incomplete\nin file %s\n",
                  scriptline,scriptfilename);
			scriptline++;
		}
	}

	if (script_p >= scriptend_p)
	{
		if (!crossline)
         Error ("Line %i is incomplete\nin file %s\n",
                 scriptline,scriptfilename);
		endofscript = true;
		return;
	}

	if (*script_p == ';')   // semicolon is comment field
	{
		if (!crossline)
         Error ("Line %i is incomplete\nin file %s\n",
                 scriptline,scriptfilename);
		while (*script_p++ != '\n')
			if (script_p >= scriptend_p)
			{
				endofscript = true;
				return;
			}
		goto skipspace;
	}

//
// copy token
//
	token_p = token;

	while ( *script_p > 32 && *script_p != ';')
	{
		*token_p++ = *script_p++;
		if (script_p == scriptend_p)
			break;
		if (token_p == &token[MAXTOKEN])
         Error ("Token too large on line %i\nin file %s\n",
                 scriptline,scriptfilename);
   }

	*token_p = 0;
}



/*
==============
=
= GetTokenEOL
=
==============
*/

void GetTokenEOL (boolean crossline)
{
   char    *name_p;

	if (tokenready)                         // is a token allready waiting?
	{
		tokenready = false;
		return;
	}

	if (script_p >= scriptend_p)
	{
		if (!crossline)
         Error ("Line %i is incomplete\nin file %s\n",
                 scriptline,scriptfilename);
      endofscript = true;
		return;
	}

//
// skip space
//
skipspace:
	while (*script_p <= 32)
	{
		if (script_p >= scriptend_p)
		{
			if (!crossline)
            Error ("Line %i is incomplete\nin file %s\n",
                   scriptline,scriptfilename);
			endofscript = true;
			return;
		}
		if (*script_p++ == '\n')
		{
			if (!crossline)
            Error ("Line %i is incomplete\nin file %s\n",
                   scriptline,scriptfilename);
			scriptline++;
		}
	}

	if (script_p >= scriptend_p)
	{
		if (!crossline)
         Error ("Line %i is incomplete\nin file %s\n",
                 scriptline,scriptfilename);
		endofscript = true;
		return;
	}

	if (*script_p == ';')   // semicolon is comment field
	{
		if (!crossline)
         Error ("Line %i is incomplete\nin file %s\n",
                 scriptline,scriptfilename);
		while (*script_p++ != '\n')
			if (script_p >= scriptend_p)
			{
				endofscript = true;
				return;
			}
		goto skipspace;
	}

//
// copy token
//
   name_p  = name;

	while (*script_p >= 32)
	{
		*name_p++ = *script_p++;
		if (script_p == scriptend_p)
			break;
		if (name_p == &name[MAXTOKEN*2])
         Error ("Name too large on line %i\nin file %s\n",
                 scriptline,scriptfilename);
	}

	*name_p = 0;
}



/*
==============
=
= TokenAvailable
=
= Returns true if there is another token on the line
=
==============
*/

boolean TokenAvailable (void)
{
	char    *search_p;

	search_p = script_p;

	if (search_p >= scriptend_p)
		return false;

	while ( *search_p <= 32)
	{
		if (*search_p == '\n')
			return false;
		search_p++;
		if (search_p == scriptend_p)
			return false;

	}

	if (*search_p == ';')
		return false;

	return true;
}


/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

int32  texture_u;
int32  texture_v;
int32  texture_count;
int32  texture_du;
int32  texture_dv;
byte * texture_source;
byte * texture_dest;
byte * texture_destincr;

void XDominantFill(void)
   {
   int32 sx,sx1,sx2;
   byte  color;
   int32 i;
   int32 offset;
   int32 buffpos;
   int32 *buffptr;
   scan_t *scantrav;
   fixed u1,v1,u2,v2,u,v,du,dv,oneoverw1,oneoverw2,dx,startx,endx;

   _numscanlines = _maxscanline - _minscanline;
   PreprocessScanlines();

   offset = Xmax*(_minscanline-2);

   for(i = 0; i <= _numscanlines+3;offset += Xmax,i++)
      {
      if (Scanline[i] == Scanline[i]->next)
         continue;

      scantrav = Scanline[i];
      oneoverw1 = FixedDiv2(FIXED1,scantrav->next->w);
      u1 = FixedMul(scantrav->next->u,oneoverw1);
      v1 = FixedMul(scantrav->next->v,oneoverw1);

      oneoverw2 = FixedDiv2(FIXED1,scantrav->prev->w);
      u2 = FixedMul(scantrav->prev->u,oneoverw2);
      v2 = FixedMul(scantrav->prev->v,oneoverw2);

      startx = scantrav->next->value;
      endx = scantrav->prev->value;

      dx = ((endx - startx)<<16);
      if (dx)
         {
         du = FixedDiv2(u2-u1,dx);
         dv = FixedDiv2(v2-v1,dx);
         }
      else
         {
         du = dv = 0;
         }

      u = u1;
      v = v1;
      for(scantrav = Scanline[i]->next;scantrav != Scanline[i];)
         {
         texture_count = scantrav->next->value-scantrav->value;
         scantrav = scantrav->next->next;
         texture_destincr = &BufferPosition[scantrav->value];
         texture_dest = &display_buffer[offset];
         texture_source = &_texture[0];
         texture_u = u;
         texture_v = v;
         texture_du = du;
         texture_dv = dv;
         TextureLine();
         }
      }
   }

/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// W_wad.c

#include <stdio.h>
// #include <conio.h>
#include <stdlib.h>
#include <string.h>
// #include <malloc.h>
// #include <io.h>
// #include <fcntl.h>
// #include <sys/stat.h>
#include "rt_def.h"
#include "rt_util.h"
#include "_w_wad.h"
#include "w_wad.h"
#include "z_zone.h"
#include "isr.h"
#include "develop.h"

#include "rt_crc.h"
#include "rt_main.h"


//=============
// GLOBALS
//=============

int			numlumps;
void			**lumpcache;

int			lumphash[64];


//=============
// STATICS
//=============

static lumpinfo_t	*lumpinfo;			// location of each lump on disk


#if (DATACORRUPTIONTEST == 1)
static byte *lumpcheck;
#endif


//===================

// #ifdef NeXT
#if 0

#define strcmpi strcasecmp

void strupr (char *s)
{
	while (*s)
		*s++ = toupper(*s);
}

/*
================
=
= filelength
=
================
*/

// int filelength (int handle)
{
	struct stat fileinfo;

	if (fstat (handle,&fileinfo) == -1)
		Error ("Error fstating");

	return fileinfo.st_size;
}

#endif


void w_strupr (char *s)
{
	while (*s) { *s = toupper(*s); s++; }
}

void w_strupr_n (char *t, char *s, int n)
{
	int i;
	for(i=0; *s && (i<n); i++)
		{ *t++ = toupper(*s++); }
	for(; i<n; i++)
		*t++=0;
}

int w_chkaccess(char *name)
{
	FILE *fd;
	int st;
	
	fd=fopen(name, "rb");
	if(fd)
	{
		fclose(fd);
		return(0);
	}
	return(-1);
}

FILE *w_openfiles[32];
unsigned int w_m_openfiles;

int w_open(char *name, char *mode)
{
	FILE *fd;
	int i;
	
	fd=fopen(name, mode);
	if(!fd)
		return(-1);
		
	for(i=0; i<32; i++)
		if(!(w_m_openfiles&(1<<i)))
			break;
	
	if(i>=32)
		return(-1);
	
	w_m_openfiles|=(1<<i);
//	i=w_n_openfiles++;
	w_openfiles[i]=fd;
	return(i);
}

int w_read(int hdl, void *buf, int sz)
{
	FILE *fd;
	int i;
	
	if(hdl<0)
		__debugbreak();
//		return(-1);
	if(hdl>=32)
		__debugbreak();
//		return(-1);
	
	fd=w_openfiles[hdl];
	if(!fd)
		__debugbreak();
//		return(-1);
	
	i=fread(buf, 1, sz, fd);
	return(i);
}

int w_write(int hdl, void *buf, int sz)
{
	FILE *fd;
	int i;
	
	if(hdl<0)
		__debugbreak();
//		return(-1);
	if(hdl>=32)
		__debugbreak();
//		return(-1);
	
	fd=w_openfiles[hdl];
	if(!fd)
		__debugbreak();
//		return(-1);
	
	i=fwrite(buf, 1, sz, fd);
	return(i);
}

int w_lseek(int hdl, int ofs, int set)
{
	FILE *fd;
	int i;
	
	if(hdl<0)
		__debugbreak();
//		return(-1);
	if(hdl>=32)
		__debugbreak();
//		return(-1);
	
	fd=w_openfiles[hdl];
	if(!fd)
		__debugbreak();
//		return(-1);
	
	i=fseek(fd, ofs, set);
	return(i);
}

int w_close(int hdl)
{
	FILE *fd;
	int i;
	
	if(hdl<0)
		__debugbreak();
//		return(-1);
	if(hdl>=32)
		__debugbreak();
//		return(-1);
	
	fd=w_openfiles[hdl];
	if(!fd)
		__debugbreak();
//		return(-1);
	
	fclose(w_openfiles[hdl]);
	w_m_openfiles&=~(1<<hdl);
	w_openfiles[hdl]=NULL;
	return(0);
}

int w_filelength (int hdl) 
{
	FILE *fd;
	int i;
	
	if(hdl<0)
		__debugbreak();
//		return(-1);
	if(hdl>=32)
		__debugbreak();
//		return(-1);
	
	fd=w_openfiles[hdl];
	if(!fd)
		__debugbreak();
//		return(-1);
	
	fseek(fd, 0, 2);
	i=ftell(fd);
	fseek(fd, 0, 0);
	return(i);
}

/*
============================================================================

												LUMP BASED ROUTINES

============================================================================
*/

/*
====================
=
= W_AddFile
=
= All files are optional, but at least one file must be found
= Files with a .wad extension are wadlink files with multiple lumps
= Other files are single lumps with the base filename for the lump name
=
====================
*/

void W_AddFile (char *filename)
{
	char				tb[16];
	wadinfo_t			header;
	lumpinfo_t			*lump_p;
	unsigned			i;
	int					handle, length;
	int					startlump;
	filelump_t			*fileinfo, singleinfo;
	FILE				*tfd;

//
// read the entire file in
//	FIXME: shared opens

//		if ( (handle = open (filename,O_RDWR | O_BINARY)) == -1)
	if ( (handle = w_open (filename, "rb")) == -1)
		return;

	startlump = numlumps;

	if ( (strcmpi (filename+strlen(filename)-3 , "wad" ) ) &&
		(strcmpi (filename+strlen(filename)-3 , "rts" ) ) )
	{
	// single lump file
		if (!quiet)
			printf("	Adding single file %s.\n",filename);
		fileinfo = &singleinfo;
		singleinfo.filepos = 0;
		singleinfo.size = LONG(w_filelength(handle));
		ExtractFileBase (filename, singleinfo.name);
		numlumps++;
	}
	else
	{
	// WAD file
		if (!quiet)
			printf("	Adding %s.\n",filename);
		w_read (handle, &header, sizeof(header));
		if (strncmp(header.identification,"IWAD",4) &&
			strncmp(header.identification,"PWAD",4))
			Error ("Wad file %s doesn't have IWAD or PWAD id\n",filename);
		header.numlumps = LONG(header.numlumps);
		header.infotableofs = LONG(header.infotableofs);
		length = header.numlumps*sizeof(filelump_t);
//		fileinfo = alloca (length);
		fileinfo = malloc (length);
		if (!fileinfo)
		Error ("Wad file could not allocate header info on stack");
		w_lseek (handle, header.infotableofs, SEEK_SET);
		w_read (handle, fileinfo, length);
		numlumps += header.numlumps;
	}

//
// Fill in lumpinfo
//
	Z_Realloc(&lumpinfo,numlumps*sizeof(lumpinfo_t));
//		lumpinfo = realloc (lumpinfo, numlumps*sizeof(lumpinfo_t));
//		if (!lumpinfo)
//		Error("W_AddFile: Could not realloc %ld bytes",numlumps*sizeof(lumpinfo_t));
	lump_p = &lumpinfo[startlump];

	for (i=startlump ; i<numlumps ; i++,lump_p++, fileinfo++)
	{
		lump_p->handle = handle;
		lump_p->position = LONG(fileinfo->filepos);
		lump_p->size = LONG(fileinfo->size);
//		strncpy (lump_p->name, fileinfo->name, 8);
		w_strupr_n (lump_p->name, fileinfo->name, 8);
	}

#if 0	//BGB: dump WAD list
	lump_p = &lumpinfo[startlump];
	tfd=fopen("t_wadlist.txt", "wt");
	if(tfd)
	{
		for (i=startlump ; i<numlumps ; i++,lump_p++)
		{
			strncpy (tb, lump_p->name, 8);
			tb[8]=0;
			fprintf(tfd, "\"%s\",\n", tb);
		}
		fclose(tfd);
	}
#endif
}



/*
====================
=
= W_CheckWADIntegrity
=
====================
*/

void W_CheckWADIntegrity ( void )
{
   int crc;

   crc = CalculateCRC ((byte *)lumpinfo, numlumps*sizeof(lumpinfo_t) );
   if (crc != WADCHECKSUM)
	{
	printf("==============================================================================\n");
	printf("ATTENTION: This version of ROTT has been modified.  If you would like to get\n");
	printf("a copy of the original game, call 1-800-APOGEE1 or run ROTTHELP.EXE.\n");
	printf("	You will not receive technical support for this modified version.\n");
	printf("						Press any key to continue\n");
	printf("==============================================================================\n");
//	printf("crc=%ld\n",crc);
	getchar();
	}
}



/*
====================
=
= W_InitMultipleFiles
=
= Pass a null terminated list of files to use.
=
= All files are optional, but at least one file must be found
=
= Files with a .wad extension are idlink files with multiple lumps
=
= Other files are single lumps with the base filename for the lump name
=
= Lump names can appear multiple times. The name searcher looks backwards,
= so a later file can override an earlier one.
=
====================
*/

int W_HashIndexForName(char *s)
{
	int j, h;
	j = *(int *)(s);
//	h = ((j*65521)>>16)&63;
	h = ((j*16777213)>>24)&63;
	return(h);
}

void W_InitMultipleFiles (char **filenames)
{
	lumpinfo_t*		lump_p;
	int i, j, k, h;
//
// open all the files, load headers, and count lumps
//
	numlumps = 0;
	lumpinfo = SafeMalloc(5);   // will be realloced as lumps are added

	for ( ; *filenames ; filenames++)
		W_AddFile (*filenames);

	if (!numlumps)
		Error ("W_InitFiles: no files found");

	for(i=0; i<64; i++)
	{
		lumphash[i] = -1;
	}
	
//	for(i=0; i<numlumps; i++)
	for(i=numlumps-1; i>=0; i--)
	{
		lump_p = lumpinfo + i;
//		j = *(int *)(lump_p->name);
//		h = ((j*65521)>>16)&63;
		h = W_HashIndexForName(lump_p->name);
		lump_p->chain = lumphash[h];
		lumphash[h] = i;
	}
	
//
// set up caching
//
	lumpcache = calloc (numlumps, sizeof(*lumpcache));
	if (!lumpcache)
		Error("W_InitFiles: lumpcache malloc failed size=%ld\n",numlumps<<2);

	if (!quiet)
		printf("W_Wad: Wad Manager Started NUMLUMPS=%ld\n",numlumps);

#if (DATACORRUPTIONTEST == 1)
	lumpcheck=SafeMalloc(numlumps);
	memset(lumpcheck,255,numlumps);
#endif
//	if (!SOUNDSETUP)
//		W_CheckWADIntegrity ();
}




/*
====================
=
= W_InitFile
=
= Just initialize from a single file
=
====================
*/

void W_InitFile (char *filename)
{
	char	*names[2];

	names[0] = filename;
	names[1] = NULL;
	W_InitMultipleFiles (names);
}



/*
====================
=
= W_NumLumps
=
====================
*/

int	W_NumLumps (void)
{
		return numlumps;
}



/*
====================
=
= W_CheckNumForName
=
= Returns -1 if name not found
=
====================
*/

#if 0
int	W_CheckNumForName (char *name)
{
		char	name8[9];
		int			v1,v2;
		lumpinfo_t	*lump_p;
		lumpinfo_t	*endlump;

// make the name into two integers for easy compares

		strncpy (name8,name,8);
		name8[8] = 0;				// in case the name was a fill 8 chars
		strupr (name8);				// case insensitive

		v1 = *(int *)name8;
		v2 = *(int *)&name8[4];

// scan backwards so patch lump files take precedence

		lump_p = lumpinfo;
		endlump = lumpinfo + numlumps;

		while (lump_p != endlump)
		{
			if ( *(int *)lump_p->name == v1 && *(int *)&lump_p->name[4] == v2)
				return lump_p - lumpinfo;
			lump_p++;
		}

		return -1;
}
#endif

int W_CheckNumForName (char* name)
{
	return(W_CheckNumForNameBase(numlumps, name));
}

int W_CheckNumForNameBase (int base, char* name)
{
	union {
//	char	s[9];
	char	s[12];
	int	x[2];
	
	} name8;
	
	int		v1;
	int		v2;
	int 	i, h;
	lumpinfo_t*	lump_p;

	// make the name into two integers for easy compares
//	strncpy (name8.s,name,8);
	w_strupr_n(name8.s, name, 8);

	// in case the name was a fill 8 chars
//	name8.s[8] = 0;

	// case insensitive
//	w_strupr (name8.s);		

	v1 = name8.x[0];
	v2 = name8.x[1];

#if 1
	h = W_HashIndexForName(name8.s);
//	h=((v1*65521)>>16)&63;
	i=lumphash[h];

#if 1
	while(i >= base)
	{
		lump_p = lumpinfo + i;
		i = lump_p->chain;
		continue;
	}
#endif

	while(i >= 0)
	{
//		if(i >= numlumps)
//			__debugbreak();
	
		lump_p = lumpinfo + i;
		
		if (	(*(int *)(&lump_p->name[0]) == v1)	&&
				(*(int *)(&lump_p->name[4]) == v2)	)
		{
//			return(i);
			break;
		}
		i = lump_p->chain;
	}
	if(i>=0)
		return(i);
		
#endif

#if 0
	// scan backwards so patch lump files take precedence
//	lump_p = lumpinfo + numlumps;
	lump_p = lumpinfo + base;

	while (lump_p-- != lumpinfo)
	{
		if ( *(int *)lump_p->name == v1
			 && *(int *)&lump_p->name[4] == v2)
		{
			return lump_p - lumpinfo;
		}
	}
#endif

	// TFB. Not found.
	return -1;
}



/*
====================
=
= W_GetNumForName
=
= Calls W_CheckNumForName, but bombs out if not found
=
====================
*/

int	W_GetNumForName (char *name)
{
		int	i;

		i = W_CheckNumForName (name);
		if (i != -1)
				return i;

		Error ("W_GetNumForName: %s not found!",name);
		return -1;
}


/*
====================
=
= W_LumpLength
=
= Returns the buffer size needed to load the given lump
=
====================
*/

int W_LumpLength (int lump)
{
		if (lump >= numlumps)
				Error ("W_LumpLength: %i >= numlumps",lump);
		return lumpinfo[lump].size;
}

/*
====================
=
= W_GetNameForNum
=
====================
*/

char *  W_GetNameForNum (int i)
{

		if (i>=numlumps)
		Error ("W_GetNameForNum: %i >= numlumps",i);
		return &(lumpinfo[i].name[0]);
}

/*
====================
=
= W_ReadLump
=
= Loads the lump into the given buffer, which must be >= W_LumpLength()
=
====================
*/
int readinglump;
byte * lumpdest;
void W_ReadLump (int lump, void *dest)
{
		int					c;
		lumpinfo_t	*l;

		readinglump=lump;
		lumpdest=dest;
		if (lump >= numlumps)
				Error ("W_ReadLump: %i >= numlumps",lump);
		if (lump < 0)
				Error ("W_ReadLump: %i < 0",lump);
		l = lumpinfo+lump;

		w_lseek (l->handle, l->position, SEEK_SET);
		c = w_read (l->handle, dest, l->size);
		if (c < l->size)
				Error ("W_ReadLump: only read %i of %i on lump %i",c,l->size,lump);
}


/*
====================
=
= W_WriteLump
=
= Writes the lump into the given buffer, which must be >= W_LumpLength()
=
====================
*/

void W_WriteLump (int lump, void *src)
{
   int		c;
   lumpinfo_t *l;

   if (lump >= numlumps)
	Error ("W_WriteLump: %i >= numlumps",lump);
   if (lump < 0)
	Error ("W_WriteLump: %i < 0",lump);
   l = lumpinfo+lump;

   w_lseek (l->handle, l->position, SEEK_SET);
   c = w_write (l->handle, src, l->size);
   if (c < l->size)
	Error ("W_WriteLump: only wrote %i of %i on lump %i",c,l->size,lump);
}


/*
====================
=
= W_CacheLumpNum
=
====================
*/
void	*W_CacheLumpNum (int lump, int tag)
{
		if ((unsigned)lump >= numlumps)
				Error ("W_CacheLumpNum: %i >= numlumps",lump);

		else if (lump < 0)
				Error ("W_CacheLumpNum: %i < 0  Taglevel: %i",lump,tag);

		if (!lumpcache[lump])
		{
				// read the lump in
#if (PRECACHETEST == 1)
				char str[9];
				strncpy(&str[0],W_GetNameForNum(lump),8);
				str[8]=0;
				SoftError("Lump #%d, %s cached at %ld tics size=%ld tag=%ld\n",lump,str,ticcount,W_LumpLength (lump),tag);
				if (W_LumpLength(lump)==0)
				SoftError("Caching in zero length lump #%d, %s cached at %ld tics size=%ld tag=%ld\n",lump,str,ticcount,W_LumpLength (lump),tag);
#endif

#if (DATACORRUPTIONTEST == 1)
				{
				int length;

				*(lumpcheck+lump)=CHECKPERIOD;
				length=W_LumpLength(lump);
				Z_Malloc (length+sizeof(word), tag, &lumpcache[lump]);
				W_ReadLump (lump, lumpcache[lump]);

				*( (word *) ((byte *)lumpcache[lump]+length) ) = CalculateCRC (lumpcache[lump], length);
				}
#else
				Z_Malloc (W_LumpLength (lump), tag, &lumpcache[lump]);
				W_ReadLump (lump, lumpcache[lump]);
#endif
		}
		else
		{
#if (DATACORRUPTIONTEST == 1)

			if (*(lumpcheck+lump)==255)
				Error("Tried using lump%ld before reading it in\n",lump);
			(*(lumpcheck+lump))--;
			if (*(lumpcheck+lump)==0)
				{
				word storedcrc;
				word crc;
				int length;

				*(lumpcheck+lump)=CHECKPERIOD;

				length=W_LumpLength(lump);
				storedcrc = *( (word *) ((byte *)lumpcache[lump]+length) );
				crc = CalculateCRC (lumpcache[lump], length);
				if (crc!=storedcrc)
					Error("Data corruption lump=%ld\n",lump);
				}
#endif
			Z_ChangeTag (lumpcache[lump],tag);
		}

		return lumpcache[lump];
}

extern int rott_wallcache[256];
extern int rott_wallstrt;
extern int rott_wallstop;

// extern int rott_sndcache[512];
// extern int rott_sndstrt;
// extern int rott_sndstop;

int rott_shapecache[4096];
int rott_shapestrt;
int rott_shapestop;


void	*W_CacheWallLumpNum (int lump, int tag)
{
//	static int wallcache[256];
	int lump1;

#if 0
	if((lump>rott_wallstrt) && (lump<rott_wallstop))
	{
		lump1=rott_wallcache[lump-rott_wallstrt];
		return(W_CacheLumpNum(lump1, tag));
	}
#endif

	if((lump>rott_shapestrt) && (lump<rott_shapestop))
	{
		lump1=rott_shapecache[lump-rott_shapestrt];
		return(W_CacheLumpNum(lump1, tag));
	}

	return(W_CacheLumpNum(lump, tag));
}

void	*W_CacheSoundLumpNum (int lump, int tag)
{
	return(W_CacheWallLumpNum(lump, tag));
}


/*
====================
=
= W_CacheLumpName
=
====================
*/

void	*W_CacheLumpName (char *name, int tag)
{
		return W_CacheLumpNum (W_GetNumForName(name), tag);
}

int		W_CheckLumpIsNameP(int lump, char *name)
{
	char *s;
	s=W_GetNameForNum(lump&0x0FFF);
	if(s && !strcmp(s, name))
		return(true);
	return(false);
}
/*
Copyright (C) 1994-1995 Apogee Software, Ltd.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// Z_zone.c

#include <stdio.h>
#include <stdlib.h>
// #include <dos.h>
#include <string.h>
#include "rt_def.h"
#include "_z_zone.h"
#include "z_zone.h"
#include "rt_util.h"
// #include <conio.h>
#include "develop.h"
#include "rt_net.h"

#if (DEVELOPMENT == 1)
#include "rt_main.h"
#endif
//MED
// #include "memcheck.h"

int lowmemory=0;

/*
==============================================================================

						ZONE MEMORY ALLOCATION

There is never any space between memblocks, and there will never be two
contiguous free memblocks.

The rover can be left pointing at a non-empty block

It is of no value to free a cachable block, because it will get overwritten
automatically if needed

==============================================================================
*/

//Globals

int zonememorystarted=0;

// Statics

static memzone_t       *mainzone;
static memzone_t       *levelzone;
static levelzonesize=LEVELZONESIZE;
static struct meminfo
   {
   unsigned LargestBlockAvail;
   unsigned MaxUnlockedPage;
   unsigned LargestLockablePage;
   unsigned LinAddrSpace;
   unsigned NumFreePagesAvail;
   unsigned NumPhysicalPagesFree;
   unsigned TotalPhysicalPages;
   unsigned FreeLinAddrSpace;
   unsigned SizeOfPageFile;
   unsigned Reserved[3];
   } MemInfo;

/*
========================
=
= Z_ClearZone
=
========================
*/

void Z_ClearZone (memzone_t *zone)
{
	memblock_t      *block;

// set the entire zone to one free block

	zone->blocklist.next = zone->blocklist.prev = block =
		(memblock_t *)( (byte *)zone + sizeof(memzone_t) );
	zone->blocklist.user = (void *)zone;
	zone->blocklist.tag = PU_STATIC;
	zone->rover = block;

	block->prev = block->next = &zone->blocklist;
	block->user = NULL;     // free block
	block->size = zone->size - sizeof(memzone_t);
}


/*
========================
=
= Z_AllocateZone
=
========================
*/

memzone_t *Z_AllocateZone (int size)
{
	memzone_t       *header;

	header = malloc (size+sizeof(memzone_t));
	if (!header)
		Error ("Z_AllocateZone: Couldn't malloc %i bytes avail=%ld\n",
		size+sizeof(memzone_t), Z_AvailHeap());
	header->size = size;
	Z_ClearZone (header);
	return header;
}

/*
========================
=
= Z_Init
=
========================
*/
void Z_Init (int size, int min)
{
   int maxsize;
   int sz;

   if (zonememorystarted==1)
      return;
   zonememorystarted=1;

   sz = GamePacketSize();

   sz*=MAXCMDS;

   if (ConsoleIsServer() == true)
      levelzonesize+=((numplayers*2)+1)*sz;
   else
      levelzonesize+=(numplayers+1)*sz;

   maxsize=((int)(Z_AvailHeap())-size-levelzonesize);
   if (maxsize<min)
      {
      UL_DisplayMemoryError (min-maxsize);
      }
   if (maxsize>MAXMEMORYSIZE)
      maxsize=(MAXMEMORYSIZE-levelzonesize);

   mainzone = Z_AllocateZone (maxsize);
   levelzone = Z_AllocateZone (levelzonesize);

   if (!quiet)
      printf("Z_INIT: %ld bytes\n",(maxsize+levelzonesize));

   if (maxsize<(min+(min>>1)))
      {
      lowmemory = 1;

      printf("==============================================================================\n");
      printf("WARNING: You are running ROTT with very little memory.  ROTT runs best with\n");
      printf("8 Megabytes of memory and no TSR's loaded in memory.  If you can free up more\n");
      printf("memory for ROTT then you should press CTRL-BREAK at this time. If you are\n");
      printf("unable to do this you will experience momentary pauses in game-play whenever\n");
      printf("you enter new areas of the game as well as an overall decreased performance.\n");
      printf("			Press any key to continue\n");
      printf("==============================================================================\n");
      getchar();
      }
}

/*
========================
=
= Z_ShutDown
=
========================
*/

void Z_ShutDown( void )
{
   if (zonememorystarted==0)
      return;
   zonememorystarted=0;
   free(mainzone);
   free(levelzone);
}

/*
========================
=
= Z_GetSize
=
========================
*/

int Z_GetSize (void *ptr)
{
	memblock_t      *block;

	block = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));
	return (block->size - sizeof(memblock_t));
}


/*
========================
=
= Z_Free
=
========================
*/

void Z_Free (void *ptr)
{
	memblock_t      *block, *other;

	block = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));
	if (!block->user)
		Error ("Z_Free: freed a freed pointer");

	if (block->user > (void **)0x100)       // smaller values are not pointers
		*block->user = 0;	// clear the user's mark
	block->user = NULL;     // mark as free

	other = block->prev;
	if (!other->user)
	{       // merge with previous free block
		other->size += block->size;
		other->next = block->next;
		other->next->prev = other;
		if (block == mainzone->rover)
			mainzone->rover = other;
		else if (block == levelzone->rover)
			levelzone->rover = other;
		block = other;
	}

	other = block->next;
	if (!other->user)
	{       // merge the next free block onto the end
		block->size += other->size;
		block->next = other->next;
		block->next->prev = block;
		if (other == mainzone->rover)
			mainzone->rover = block;
		else if (other == levelzone->rover)
			levelzone->rover = block;
	}
}


/*
========================
=
= Z_Malloc
=
= You can pass a NULL user if the tag is < PU_PURGELEVEL
========================
*/

#if (DEVELOPMENT == 1)
int totallevelsize=0;
#endif

void *Z_Malloc (int size, int tag, void *user)
{
	int	extra;
	memblock_t      *start, *rover, *new, *base;

//	size *= 2;	//BGB: debug

//
// scan through the block list looking for the first free block
// of sufficient size, throwing out any purgable blocks along the way
//
	size += sizeof(memblock_t);     // account for size of block header


//
// if there is a free block behind the rover, back up over them
//
	base = mainzone->rover;
//	if (!base->prev->user)
	if (base->prev && !base->prev->user)
		base = base->prev;

	rover = base;
	start = base->prev;

	do
	{
		if (rover == start)     // scaned all the way around the list
			{
			SoftError("OHSHIT\n");
			Z_DumpHeap(0,200);
			Error ("Z_Malloc: failed on allocation of %i bytes",size);
			}
		if (rover->user)
		{
			if (rover->tag < PU_PURGELEVEL)
			// hit a block that can't be purged, so move base past it
				base = rover = rover->next;
			else
			{
			// free the rover block (adding the size to base)
				base = base->prev;      // the rover can be the base block
				Z_Free ((byte *)rover+sizeof(memblock_t));
				base = base->next;
				rover = base->next;
			}
		}
		else
			rover = rover->next;
	} while (base->user || base->size < size);

//
// found a block big enough
//
	extra = base->size - size;
	if (extra >  MINFRAGMENT)
	{       // there will be a free fragment after the allocated block
		new = (memblock_t *) ((byte *)base + size );
		new->size = extra;
		new->user = NULL;	// free block
		new->tag = 0;
		new->prev = base;
		new->next = base->next;
		new->next->prev = new;
		base->next = new;
		base->size = size;
	}

	if (user)
	{
		base->user = user;		// mark as an in use block
		*(void **)user = (void *) ((byte *)base + sizeof(memblock_t));
	}
	else
	{
		if (tag >= PU_PURGELEVEL)
			Error ("Z_Malloc: an owner is required for purgable blocks");
		base->user = (void *)2;	// mark as in use, but unowned
	}
	base->tag = tag;

	mainzone->rover = base->next;   // next allocation will start looking here


#if (MEMORYCORRUPTIONTEST==1)
	base->posttag=MEMORYPOSTTAG;
	base->pretag=MEMORYPRETAG;
#endif

	return (void *) ((byte *)base + sizeof(memblock_t));
}

/*
========================
=
= Z_LevelMalloc
=
= Only use this for level structures.
= You can pass a NULL user if the tag is < PU_PURGELEVEL
========================
*/

void *Z_LevelMalloc (int size, int tag, void *user)
{
	int	extra;
	memblock_t      *start, *rover, *new, *base;

//
// scan through the block list looking for the first free block
// of sufficient size, throwing out any purgable blocks along the way
//
	size += sizeof(memblock_t);     // account for size of block header


//
// if there is a free block behind the rover, back up over them
//
	base = levelzone->rover;
	if (!base->prev->user)
		base = base->prev;

	rover = base;
	start = base->prev;

	do
	{
		if (rover == start)     // scaned all the way around the list
			{
			SoftError("OHSHIT\n");
			Z_DumpHeap(0,200);
			Error ("Z_LevelMalloc: failed on allocation of %i bytes",size);
			}
		if (rover->user)
		{
			if (rover->tag < PU_PURGELEVEL)
			// hit a block that can't be purged, so move base past it
				base = rover = rover->next;
			else
			{
			// free the rover block (adding the size to base)
				base = base->prev;      // the rover can be the base block
				Z_Free ((byte *)rover+sizeof(memblock_t));
				base = base->next;
				rover = base->next;
			}
		}
		else
			rover = rover->next;
	} while (base->user || base->size < size);

//
// found a block big enough
//
	extra = base->size - size;
	if (extra >  MINFRAGMENT)
	{       // there will be a free fragment after the allocated block
		new = (memblock_t *) ((byte *)base + size );
		new->size = extra;
		new->user = NULL;	// free block
		new->tag = 0;
		new->prev = base;
		new->next = base->next;
		new->next->prev = new;
		base->next = new;
		base->size = size;
	}

	if (user)
	{
		base->user = user;		// mark as an in use block
		*(void **)user = (void *) ((byte *)base + sizeof(memblock_t));
	}
	else
	{
		if (tag >= PU_PURGELEVEL)
			Error ("Z_Malloc: an owner is required for purgable blocks");
		base->user = (void *)2;	// mark as in use, but unowned
	}
	base->tag = tag;

	levelzone->rover = base->next;   // next allocation will start looking here

#if (MEMORYCORRUPTIONTEST==1)
	base->posttag=MEMORYPOSTTAG;
	base->pretag=MEMORYPRETAG;
#endif

	return (void *) ((byte *)base + sizeof(memblock_t));
}



/*
========================
=
= Z_FreeTags
=
========================
*/

void Z_FreeTags (int lowtag, int hightag)
{
	memblock_t      *block, *next;

	for (block = mainzone->blocklist.next ; block != &mainzone->blocklist
	; block = next)
	{
		next = block->next;	// get link before freeing
		if (!block->user)
			continue;		// free block
		if (block->tag >= lowtag && block->tag <= hightag)
			Z_Free ( (byte *)block+sizeof(memblock_t));
	}
	for (block = levelzone->blocklist.next ; block != &levelzone->blocklist
	; block = next)
	{
		next = block->next;	// get link before freeing
		if (!block->user)
			continue;		// free block
		if (block->tag >= lowtag && block->tag <= hightag)
			Z_Free ( (byte *)block+sizeof(memblock_t));
	}
}

/*
========================
=
= Z_DumpHeap
=
========================
*/

void Z_DumpHeap (int lowtag, int hightag)
{
	memblock_t      *block;
	int	totalsize;

	SoftError("MAIN ZONE\n");
	SoftError("zone size: %i  location: %p\n",mainzone->size,mainzone);
	SoftError("tag range: %i to %i\n",lowtag, hightag);

	totalsize=0;

	for (block = mainzone->blocklist.next ; block; block = block->next)
	{
		if (block->tag >= lowtag && block->tag <= hightag)
			{
			SoftError("block:%p    size:%7i    user:%p    tag:%3i\n",
			block, block->size, block->user, block->tag);
			totalsize+=block->size;
			}

		if (block->next == &mainzone->blocklist)
			break;		// all blocks have been hit

		if ( (byte *)block + block->size != (byte *)block->next)
			SoftError("ERROR: block size does not touch the next block\n");
//		if ( block->next->prev != block)
		if ( block->next && (block->next->prev != block))
			SoftError("ERROR: next block doesn't have proper back link\n");
//		if (!block->user && !block->next->user)
		if (!block->user && block->next && !block->next->user)
			SoftError("ERROR: two consecutive free blocks\n");
	}
	SoftError("Total Size of blocks = %ld\n",totalsize);

	SoftError("LEVEL ZONE\n");
	SoftError("zone size: %i  location: %p\n",levelzone->size,levelzone);
	SoftError("tag range: %i to %i\n",lowtag, hightag);

	totalsize=0;

	for (block = levelzone->blocklist.next ; block; block = block->next)
	{
		if (block->tag >= lowtag && block->tag <= hightag)
			{
			SoftError("block:%p    size:%7i    user:%p    tag:%3i\n",
			block, block->size, block->user, block->tag);
			totalsize+=block->size;
			}

		if (block->next == &levelzone->blocklist)
			break;		// all blocks have been hit
		if ( (byte *)block + block->size != (byte *)block->next)
			SoftError("ERROR: block size does not touch the next block\n");
//		if ( block->next->prev != block)
		if ( block->next && (block->next->prev != block))
			SoftError("ERROR: next block doesn't have proper back link\n");
		if (!block->user && block->next && !block->next->user)
			SoftError("ERROR: two consecutive free blocks\n");
	}
	SoftError("Total Size of blocks = %ld\n",totalsize);

}

/*
========================
=
= Z_UsedHeap
=
========================
*/

int Z_UsedHeap ( void )
{
	memblock_t      *block;
	int heapsize;


	heapsize=0;
	for (block = mainzone->blocklist.next ; ; block = block->next)
	{
		if ((block->tag>0) && (block->user>0))
			heapsize+=(block->size);
		if (block->next == &mainzone->blocklist)
			break;		// all blocks have been hit
	}
	return heapsize;
}

/*
========================
=
= Z_UsedLevelHeap
=
========================
*/

int Z_UsedLevelHeap ( void )
{
	memblock_t      *block;
	int heapsize;


	heapsize=0;
	for (block = levelzone->blocklist.next ; ; block = block->next)
	{
		if ((block->tag>0) && (block->user>0))
		heapsize+=(block->size);
		if (block->next == &levelzone->blocklist)
		break;		// all blocks have been hit
	}
	return heapsize;
}


/*
========================
=
= Z_UsedStaticHeap
=
========================
*/

int Z_UsedStaticHeap ( void )
{
	memblock_t      *block;
	int heapsize;


	heapsize=0;
	for (block = mainzone->blocklist.next ; ; block = block->next)
	{
		if ((block->tag>0) && (block->tag<PU_PURGELEVEL) && (block->user>0))
		heapsize+=(block->size);
		if (block->next == &mainzone->blocklist)
		break;		// all blocks have been hit
	}
	return heapsize;
}


/*
========================
=
= Z_HeapSize
=
========================
*/

int Z_HeapSize ( void )
{
   return mainzone->size;
}


/*
========================
=
= Z_CheckHeap
=
========================
*/

void Z_CheckHeap (void)
{
	memblock_t      *block;

	// Check mainzone

	for (block = mainzone->blocklist.next ; ; block = block->next)
	{
		if (block->next == &mainzone->blocklist)
			break;		// all blocks have been hit
		if ( (byte *)block + block->size != (byte *)block->next)
			Error ("Z_CheckHeap: block size does not touch the next block\n");
		if ( block->next->prev != block)
			Error ("Z_CheckHeap: next block doesn't have proper back link\n");
		if (!block->user && !block->next->user)
			Error ("Z_CheckHeap: two consecutive free blocks\n");
#if (MEMORYCORRUPTIONTEST==1)
		if ((block->tag>0) && (block->user>0))
		{
		if (block->posttag!=MEMORYPOSTTAG)
		Error("Z_CheckHeap: Corrupted posttag\n");
		if (block->pretag!=MEMORYPRETAG)
		Error("Z_CheckHeap: Corrupted pretag\n");
		}
#endif
	}

	// Check levelzone

	for (block = levelzone->blocklist.next ; ; block = block->next)
	{
		if (block->next == &levelzone->blocklist)
			break;		// all blocks have been hit
		if ( (byte *)block + block->size != (byte *)block->next)
			Error ("Z_CheckHeap: block size does not touch the next block\n");
		if ( block->next->prev != block)
			Error ("Z_CheckHeap: next block doesn't have proper back link\n");
		if (!block->user && !block->next->user)
			Error ("Z_CheckHeap: two consecutive free blocks\n");
#if (MEMORYCORRUPTIONTEST==1)
		if ((block->tag>0) && (block->user>0))
		{
		if (block->posttag!=MEMORYPOSTTAG)
		Error("Z_CheckHeap: Corrupted posttag\n");
		if (block->pretag!=MEMORYPRETAG)
		Error("Z_CheckHeap: Corrupted pretag\n");
		}
#endif
	}
}


/*
========================
=
= Z_ChangeTag
=
========================
*/

void Z_ChangeTag (void *ptr, int tag)
{
	memblock_t      *block;

	block = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));
	block->tag = tag;
}

/*
========================
=
= Z_AvailHeap
=
========================
*/

#if 0
int Z_AvailHeap ( void )
{

   union REGS zregs;
   struct SREGS zsregs;


   zregs.x.eax = 0x00000500;
   memset( &zsregs, 0, sizeof(zsregs) );
   zsregs.es = FP_SEG( &MemInfo );
   zregs.x.edi = FP_OFF( &MemInfo );

   int386x( DPMI_INT, &zregs, &zregs, &zsregs );

   return ((int)MemInfo.LargestBlockAvail);

}
#endif

int Z_AvailHeap ( void )
{
	return(1<<25);
}

/*
========================
=
= Z_Realloc
=
========================
*/

void Z_Realloc (void ** ptr, int newsize)
{
   memblock_t      *block;
   void * newptr;
   int oldsize;

   block = (memblock_t *) ( (byte *)(*ptr) - sizeof(memblock_t));
   oldsize = block->size;
   newptr = SafeMalloc(newsize);
   if (oldsize > newsize)
      {
      oldsize = newsize;
      }
   memcpy( newptr, *ptr, oldsize );
   SafeFree( *ptr );
   *ptr = newptr;
}

