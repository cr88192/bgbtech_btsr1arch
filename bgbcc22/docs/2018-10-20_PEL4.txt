PEL4: LZ compressed PE/COFF

Overview:
* Omits the MZ header or stub.
* Uses the magic "PEL4" rather than "PE\0\0"
** If the normal magic is used, it is interpreted as uncompressed PE/COFF.
* The first 1kB is stored in an uncompressed form.
* The remainder of the image is compressed using an LZ4 variant.
** This is done in terms of 1kB blocks.
* Assumes that RVA and uncompressed offsets are equivalent for resident sections.
** The ".bss" is an partial exception to this rule.
*** The ".bss" section may overlap other non-resident sections.


=== LZ Encoding ===

Consists of a series of LZ runs, each potentially encoding a series of literal bytes.

Each run begins with a tag byte:
* High 4 bits: Length of literal bytes (0-14 bytes)
* Low 4 bits: Length of LZ Match (4-18 bytes)

If the 4 bits for a length are 15, then a variable length coding is used. This consists of zero or more values of 255, and is terminated by a value which is not 255. Each adds 255 to the prior value (in addition to the 15 or 19 due to the tag byte).

The tag byte and literal length is then followed by a run of zero or more literal bytes. These bytes are copied to the output as-is.

After the literal bytes, a distance is encoded as a 16-bit little endian integer.
This value has a range of 1 to 65535.

The distance is then, if applicable, followed by the variable-length part of a match length.

The match is copied relative to the current output byte, with the distance encoding how far back the match is (up to 64kB), and the length the number of bytes to copy to the output. This match copy may overlap with the output (if the distance is less than the length), in which case it will form a repeating pattern (RLE). In this sense, the prior 64kB are seen as a "sliding window".

Note that at the start of decoding, reading from bytes prior to the start of the output is undefined.


A distance value of 0 is special, and if encoded may signal the end of the input or a special escape sequence.

In a special, the low 4 bits of the tag byte may be interpreted as a command:
* 0: End of Data.
* 1-14: Reserved.
* 15: Will escape a longer command, also reserved.
** The command tag encoding will be equivalent to that of a length.

Ending the encoded data prior to the end of a block will imply that the compressed data for the binary image has ended.


Blocks prior to the final block will terminate on the block edge. If a match distance would fall at or past the end of a block, then the encoded data for the block will terminate at this point.

Note that each block is to be handled separately, and as such a run of literal bytes may not cross a block boundary. As such, a run of literal bytes ending at 0x3FF or 0x400 will encode the end of a block.

A 1 byte tolerance is allowed because it may not be possible in all cases to end the run exactly on a block edge.


=== PE Header ===

<pre>
struct PeMainHeader
{
//0000: PE/COFF Header
    DWORD mMagicPe;                     //0000: PE\0\0 or 0x00004550
    WORD  mMachine;                     //0004:
    WORD  mNumberOfSections;            //0006:
    DWORD mTimeDateStamp;               //0008: (Creation Time, Unix Time)
    DWORD mPointerToSymbolTable;        //000C: (Unused, 0)
    DWORD mNumberOfSymbols;             //0010: (Unused, 0)
    WORD  mSizeOfOptionalHeader;        //0014: Size of rest of header.
    WORD  mCharacteristics;             //0016:

//0018: Optional Header
    WORD  mMagic;                       //0018: 0x010b=PE32
    BYTE  mMajorLinkerVersion;          //001A: (Ignore)
    BYTE  mMinorLinkerVersion;          //001B: (Ignore)
    DWORD mSizeOfCode;                  //001C:
    DWORD mSizeOfInitializedData;       //0020:
    DWORD mSizeOfUninitializedData;     //0024:
    DWORD rvaAddressOfEntryPoint;       //0028:
    DWORD mBaseOfCode;                  //002C:
    DWORD mBaseOfData;                  //0030:
    DWORD mImageBase;                   //0034:
    DWORD mSectionAlignment;            //0038:
    DWORD mFileAlignment;               //003C:
    WORD  mMajorOperatingSystemVersion; //0040: (Ignore?)
    WORD  mMinorOperatingSystemVersion; //0042: (Ignore?)
    WORD  mMajorImageVersion;           //0044: (Ignore?)
    WORD  mMinorImageVersion;           //0046: (Ignore?)
    WORD  mMajorSubsystemVersion;       //0048: (Ignore?)
    WORD  mMinorSubsystemVersion;       //004A: (Ignore?)
    DWORD mWin32VersionValue;           //004C: (Ignore?)
    DWORD mSizeOfImage;                 //0050:
    DWORD mSizeOfHeaders;               //0054:
    DWORD mCheckSum;                    //0058: (Ignore?)
    WORD  mSubsystem;                   //005C: (Ignore?)
    WORD  mDllCharacteristics;          //005E: (Ignore?)
    DWORD mSizeOfStackReserve;          //0060:
    DWORD mSizeOfStackCommit;           //0064:
    DWORD mSizeOfHeapReserve;           //0068: (NOMMU?)
    DWORD mSizeOfHeapCommit;            //006C: (NOMMU?)
    DWORD mLoaderFlags;                 //0070: (Reserved, 0)
    DWORD mNumberOfRvaAndSizes;         //0074:

//00B8: Data Directories
    DWORD rvaExportTable;               //0078:
    DWORD szExportTable;                //007C:
    DWORD rvaImportTable;               //0080:
    DWORD szImportTable;                //0084:
    DWORD rvaResourceTable;             //0088:
    DWORD szResourceTable;              //008C:
    DWORD rvaExceptionTable;            //0090:
    DWORD szExceptionTable;             //0094:
    DWORD rvaCertTable;                 //0098:
    DWORD szCertTable;                  //009C:
    DWORD rvaBaseRelocTable;            //00A0:
    DWORD szBaseRelocTable;             //00A4:
    DWORD rvaDebugData;                 //00A8:
    DWORD szDebugData;                  //00AC:
    DWORD rvaArchData;                  //00B0:
    DWORD szArchData;                   //00B4:
    DWORD rvaGlobalPtr;                 //00B8:
    DWORD szGlobalPtr;                  //00BC:
    DWORD rvaTlsTable;                  //00C0:
    DWORD szTlsTable;                   //00C4:
    DWORD rvaLoadConfigTable;           //00C8:
    DWORD szLoadConfigTable;            //00CC:
    DWORD rvaBoundImportTable;          //00D0:
    DWORD szBoundImportTable;           //00D4:
    DWORD rvaImportAddressTable;        //00D8:
    DWORD szImportAddressTable;         //00DC:
    DWORD rvaDelayImportTable;          //00E0:
    DWORD szDelayImportTable;           //00E4:
    DWORD rvaClrHeader;                 //00E8:
    DWORD szClrHeader;                  //00EC:
    DWORD rvaResvTable;                 //00F0:
    DWORD szResvTable;                  //00F4:
//00F8:End of Header
};


struct PeMainHeader64
{
//0040: PE/COFF Header
    DWORD mMagicPe;                     //0000: PE\0\0 or 0x00004550
    WORD  mMachine;                     //0004:
    WORD  mNumberOfSections;            //0006:
    DWORD mTimeDateStamp;               //0008: (Creation Time, Unix Time)
    DWORD mPointerToSymbolTable;        //000C: (Unused, 0)
    DWORD mNumberOfSymbols;             //0010: (Unused, 0)
    WORD  mSizeOfOptionalHeader;        //0014: Size of rest of header.
    WORD  mCharacteristics;             //0016:

//0058: Optional Header
    WORD  mMagic;                       //0018: 0x020b=PE32+
    BYTE  mMajorLinkerVersion;          //001A: (Ignore)
    BYTE  mMinorLinkerVersion;          //001B: (Ignore)
    DWORD mSizeOfCode;                  //001C:
    DWORD mSizeOfInitializedData;       //0020:
    DWORD mSizeOfUninitializedData;     //0024:
    DWORD rvaAddressOfEntryPoint;       //0028:
    DWORD mBaseOfCode;                  //002C:
    QWORD mImageBase;                   //0030:
    DWORD mSectionAlignment;            //0038:
    DWORD mFileAlignment;               //003C:
    WORD  mMajorOperatingSystemVersion; //0040: (Ignore?)
    WORD  mMinorOperatingSystemVersion; //0042: (Ignore?)
    WORD  mMajorImageVersion;           //0044: (Ignore?)
    WORD  mMinorImageVersion;           //0046: (Ignore?)
    WORD  mMajorSubsystemVersion;       //0048: (Ignore?)
    WORD  mMinorSubsystemVersion;       //004A: (Ignore?)
    DWORD mWin32VersionValue;           //004C: (Ignore?)
    DWORD mSizeOfImage;                 //0050:
    DWORD mSizeOfHeaders;               //0054:
    DWORD mCheckSum;                    //0058: (Ignore?)
    WORD  mSubsystem;                   //005C: (Ignore?)
    WORD  mDllCharacteristics;          //005E: (Ignore?)
    QWORD mSizeOfStackReserve;          //0060:
    QWORD mSizeOfStackCommit;           //0068:
    QWORD mSizeOfHeapReserve;           //0070: (NOMMU?)
    QWORD mSizeOfHeapCommit;            //0078: (NOMMU?)
    DWORD mLoaderFlags;                 //0080: (Reserved, 0)
    DWORD mNumberOfRvaAndSizes;         //0084:

//00B8: Data Directories
    DWORD rvaExportTable;               //0088:
    DWORD szExportTable;                //008C:
    DWORD rvaImportTable;               //0090:
    DWORD szImportTable;                //0094:
    DWORD rvaResourceTable;             //0098:
    DWORD szResourceTable;              //009C:
    DWORD rvaExceptionTable;            //00A0:
    DWORD szExceptionTable;             //00A4:
    DWORD rvaCertTable;                 //00A8:
    DWORD szCertTable;                  //00AC:
    DWORD rvaBaseRelocTable;            //00B0:
    DWORD szBaseRelocTable;             //00B4:
    DWORD rvaDebugData;                 //00B8:
    DWORD szDebugData;                  //00BC:
    DWORD rvaArchData;                  //00C0:
    DWORD szArchData;                   //00C4:
    DWORD rvaGlobalPtr;                 //00C8:
    DWORD szGlobalPtr;                  //00CC:
    DWORD rvaTlsTable;                  //00D0:
    DWORD szTlsTable;                   //00D4:
    DWORD rvaLoadConfigTable;           //00D8:
    DWORD szLoadConfigTable;            //00DC:
    DWORD rvaBoundImportTable;          //00E0:
    DWORD szBoundImportTable;           //00E4:
    DWORD rvaImportAddressTable;        //00E8:
    DWORD szImportAddressTable;         //00EC:
    DWORD rvaDelayImportTable;          //00F0:
    DWORD szDelayImportTable;           //00F4:
    DWORD rvaClrHeader;                 //00F8:
    DWORD szClrHeader;                  //00FC:
    DWORD rvaResvTable;                 //0100:
    DWORD szResvTable;                  //0104:
//0108:End of Header
};
</pre>

Machine:
* x86-32:   0x014C
* x86-64:   0x8664
* ARM:      0x01C0
* SH-3:     0x01A2
* SH-DSP:   0x01A3
* SH-4:     0x01A6
* SH-5:     0x01A8
* BJX1-32:  0xB132 (Old)
* BJX1-64:  0xB164 (Old)
* BJX1-64C: 0xB64C (Old)
* BJX2-32:  0xB232 (Resv)
* BJX2-64:  0xB264

The main header is followed by sections.

<pre>
struct PeSectionHeader
{
    BYTE  mName[8];                     //0000
    DWORD mVirtualSize;                 //0008
    DWORD mVirtualAddress;              //000C
    DWORD mSizeOfRawData;               //0010
    DWORD mPointerToRawData;            //0014
    DWORD mPointerToRealocations;       //0018
    DWORD mPointerToLinenumbers;        //001C
    WORD  mNumberOfRealocations;        //0020
    WORD  mNumberOfLinenumbers;         //0022
    DWORD mCharacteristics;             //0024
    //28
};
</pre>


=== Base Relocations ===

Relocations:
<pre>
struct PeRelocBlock
{
    DWORD rvaPage;        //RVA of Page to be relocated
    DWORD szBlock;        //Size of relocs in this block
};
</pre>

The szBlock field is expressed in bytes. It includes the size of the RelocBlock header in addition to the associated reloc entries.

The relocations are given as 16 bit numbers:
* Low 12 bits: Offset within page.
* High 4 bits: Relocation Type
** 0: None
** 1(HI16): Fixup the high 16 bits of an address
** 2(LO16): Fixup the low 16 bits of an address
** 3(DIR32): Fixup a 32-bit address (Abs32)
** 4(HIADJ): Fixup a 32 bit address split into a high and low part.
*** The following entry gives the address of the low part.
** 5: MIPS-specific fixup.
*** 5: BJX2(DIR24): Fixup 24-bit address via instruction.
** 6: Reserved
** 7: Reserved
** 8: BJX2: PBO/GBR DIR24
*** Initial Contents: Variable address relative to the ".data" section.
** 9: MIPS-specific fixup.
** 9: BJX2: TLS/TBR DIR24
*** Initial: TLS Index, Resolved to TBR-relative address of TLS Variable
** 10: Fixup a 64-bit address (Abs64).
** 11: Reserved
** 12: Reserved
** 13: Reserved
** 14: Reserved
** 15: Reserved

TLS Index:
* This is a pointer-sized scaled index indicating a given TLS Variable.
* The index 0 will be special and correspond to the PBO Base Offset Index.
* This will be replaced by the TBR relative offset of the corresponding variable.


=== Exports ===

This is located within the '.edata' section, and referenced via the optional header.

<pre>
struct PeExportDirectory
{
    DWORD mExportFlags;                 //0x00, export flags
    DWORD mTimeDate;                    //0x04, time/date
    WORD mMajorVersion;                 //0x08, major version
    WORD mMinorVersion;                 //0x0A, minor version
    DWORD rvaDllName;                   //0x0C, name RVA
    DWORD mOrdinalBase;                 //0x10, ordinal base
    DWORD mNumberAddressEntries;        //0x14, address table entries
    DWORD nNumberNameEntries;           //0x18, number of name pointers
    DWORD rvaExportAddressTable;        //0x1C, export address table RVA
    DWORD rvaNamePointerTable;          //0x20, name pointer table RVA
    DWORD rvaOrdinalTable;              //0x24, ordinal table RVA
};
</pre>

rvaDllName:
* RVA of a string holding the name of the current DLL.

mOrdinalBase:
* Starting index for the ordinal table, normally 1.

Export Address Table:
* Array of exported addresses.
* If the address is within '.edata', it is a forwarder string.
* This table is indexed by ordinal (relative to OrdinalBase).

ExportNamePointerTable and ExportOrdinalTable
* These are used together to find exported symbols.
* ExportNamePointerTable holds addresses to the exported names as strings.
* ExportOrdinalTable maps these names to ordinal indices.


=== Imports ===

This is located within the '.idata' section, and referenced via the optional header.


<pre>
struct PeImportDirectory
{
    DWORD rvaImportLookupTable;         //0x00
    DWORD mTimeDate;                    //0x04
    DWORD mForwarderIndex;              //0x08
    DWORD rvaDllName;                   //0x0C
    DWORD rvaImportAddressTable;        //0x10
};
</pre>

rvaDllName:
* ASCII string identifying the base-name of the DLL.
* This omits both path and file extension.

rvaImportLookupTable:
* Table of pointer-sized values.
* Each Encodes an Name/Hint RVA or Ordinal.

rvaImportAddressTable:
* Initially same contents as Import Lookup Table.
* Each entry is replaced by the address of the imported symbol.

Imports are given by a Name/Hint string:
* Consists of a properly aligned WORD giving a lookup-index hint.
* The hint is followed by an ASCII string giving the name of the imported symbol.
* Located within the '.idata' section.


=== TLS Directory ===

Located in ".tls" section if TLS is used.

<pre>
struct PeTlsDirectory
{
    DWORD vaRawDataStart;               //0x00
    DWORD vaRawDataEnd;                 //0x04
    DWORD vaAddressOfIndex;             //0x08
    DWORD vaAddressCallbacks;           //0x0C
    DWORD szSizeOfZeroFill;             //0x10
    DWORD mCharacteristics;             //0x14
};
</pre>

vaAddressOfIndex:
* Address of a slot used to hold the TLS Index (as a pointer-sized value).
* The pointed-to address may be initialized with the VA of a string identifying the TLS section.

vaAddressCallbacks:
* Optional array of callback functions for thread creation and destruction.
* Testkern: Ignored.

Upon thread creation, a TLS section is allocated and its address is assigned to its associated TLS variable slot.


=== Exception Handling ===

Exception handler data will be present in the ".pdata" section.

<pre>
struct PePData
{
    DWORD rvaFuncAddress;               //RVA of Function Entry
    DWORD szFuncLength;                 //Length of Function
};
</pre>

szFuncLength:
* 0..21: Length of function in WORD or DWORD units.
* 22: Set to indicate a DWORD instruction unit, otherwise WORD.
** BJX2: Will be Set for the Fixed32 subset.
** BJX2: Will be Clear for the variable-length ISA.
* 23: Set to indicate an exception handler exists.

Directly following the function, there will be one of:
* A branch to the start of the Epilog sequence.
* The entry point for the exception handler.

If no exception handler is present, the function will be unwound following the pattern given in the epilog sequence. Otherwise, control will be transferred to the exception handler. The exception handler then will be responsible any dispatching or unwinding.

