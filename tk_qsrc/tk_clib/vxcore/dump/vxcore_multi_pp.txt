/*"stdio.h"34*/ typedef unsigned int size_t;
/*45*/ typedef __builtin_va_list __va_list;
/*82*/ typedef struct _iobuf FILE;
/*85*/ struct _iobuf
{
/*96*/ int hfile;
/*112*/ int quickBin;
int quickText;
int textMode;
int intFno;
unsigned long bufStartR;
/*121*/ char*fbuf;
/*123*/ size_t szfbuf;
/*126*/ char*upto;
char*endbuf;
/*129*/ int errorInd;
int eofInd;
int ungetCh;
int bufTech;
char*intBuffer;
int noNl;
int mode;
int update;
int theirBuffer;
int permfile;
int isopen;
char modeStr[4];
};
/*143*/ typedef unsigned long fpos_t;
/*187*/ FILE* *__get_stdin();
FILE* *__get_stdout();
FILE* *__get_stderr();
/*195*/ int printf(const char*format,...);
FILE*fopen(const char*filename,const char*mode);
int fclose(FILE*stream);
size_t fread(void*ptr,size_t size,size_t nmemb,FILE*stream);
size_t fwrite(const void*ptr,size_t size,size_t nmemb,FILE*stream);
int fputc(int c,FILE*stream);
int fputs(const char*s,FILE*stream);
int fprintf(FILE*stream,const char*format,...);
int vfprintf(FILE*stream,const char*format,__va_list arg);
int remove(const char*filename);
int rename(const char*old,const char*new);
int sprintf(char*s,const char*format,...);
int vsprintf(char*s,const char*format,__va_list arg);
char*fgets(char*s,int n,FILE*stream);
int ungetc(int c,FILE*stream);
int fgetc(FILE*stream);
int fseek(FILE*stream,long int offset,int whence);
long int ftell(FILE*stream);
int fsetpos(FILE*stream,const fpos_t*pos);
int fgetpos(FILE*stream,fpos_t*pos);
void rewind(FILE*stream);
void clearerr(FILE*stream);
void perror(const char*s);
int setvbuf(FILE*stream,char*buf,int mode,size_t size);
int setbuf(FILE*stream,char*buf);
FILE*freopen(const char*filename,const char*mode,FILE*stream);
int fflush(FILE*stream);
char*tmpnam(char*s);
FILE*tmpfile(void);
int fscanf(FILE*stream,const char*format,...);
int scanf(const char*format,...);
int sscanf(const char*s,const char*format,...);
char*gets(char*s);
int puts(const char*s);
/*231*/ int getchar(void);
int putchar(int c);
int getc(FILE*stream);
int putc(int c,FILE*stream);
int feof(FILE*stream);
int ferror(FILE*stream);
/*"string.h"28*/ void*memcpy(void*s1,const void*s2,size_t n);
void*memmove(void*s1,const void*s2,size_t n);
char*strcpy(char*s1,const char*s2);
char*strncpy(char*s1,const char*s2,size_t n);
char*strcat(char*s1,const char*s2);
char*strncat(char*s1,const char*s2,size_t n);
int memcmp(const void*s1,const void*s2,size_t n);
int strcmp(const char*s1,const char*s2);
int strcoll(const char*s1,const char*s2);
int strncmp(const char*s1,const char*s2,size_t n);
size_t strxfrm(char*s1,const char*s2,size_t n);
void*memchr(const void*s,int c,size_t n);
char*strchr(const char*s,int c);
size_t strcspn(const char*s1,const char*s2);
char*strpbrk(const char*s1,const char*s2);
char*strrchr(const char*s,int c);
size_t strspn(const char*s1,const char*s2);
char*strstr(const char*s1,const char*s2);
char*strtok(char*s1,const char*s2);
void*memset(void*s,int c,size_t n);
char*strerror(int errnum);
size_t strlen(const char*s);
/*"stdlib.h"31*/ typedef unsigned short wchar_t;
/*33*/ typedef struct{int quot;int rem;}div_t;
typedef struct{long int quot;long int rem;}ldiv_t;
/*47*/ extern void(*__userExit[32])(void);
/*49*/ void*malloc(size_t size);
void*calloc(size_t nmemb,size_t size);
void*realloc(void*ptr,size_t size);
void free(void*ptr);
/*57*/ void abort(void);
void exit(int status);
/*60*/ void qsort(void*,size_t,size_t,int(*)(const void*,const void*));
/*62*/ void srand(unsigned int seed);
int rand(void);
double atof(const char*nptr);
double strtod(const char*nptr,char* *endptr);
int atoi(const char*nptr);
long int atol(const char*nptr);
long int strtol(const char*nptr,char* *endptr,int base);
unsigned long int strtoul(const char*nptr,char* *endptr,int base);
int mblen(const char*s,size_t n);
int mbtowc(wchar_t*pwc,const char*s,size_t n);
int wctomb(char*s,wchar_t wchar);
size_t mbstowcs(wchar_t*pwcs,const char*s,size_t n);
size_t wcstombs(char*s,const wchar_t*pwcs,size_t n);
int abs(int j);
div_t div(int numer,int denom);
long int labs(long int j);
ldiv_t ldiv(long int numer,long int denom);
int atexit(void(*func)(void));
char*getenv(const char*name);
int system(const char*string);
void*bsearch(const void*key,const void*base,size_t nmemb,size_t size,int(*compar)(const void*,const void*));
/*"stdarg.h"27*/ typedef __builtin_va_list va_list;
/*"errno.h"75*/ int*__get_errno();
/*"stddef.h"16*/ typedef int ptrdiff_t;
/*"pdpc201/stdio.c"70*/ int __read(int handle,void*buf,size_t len,int*errind);
int __write(int handle,const void*buf,size_t len,int*errind);
void __seek(int handle,long offset,int whence);
void __close(int handle);
void __remove(const char*filename);
void __rename(const char*old,const char*new);
long __tell(int handle);
/*78*/ static FILE permFiles[3];
/*95*/ void tk_printf(char*str,...);
/*98*/ FILE*__stdin= &permFiles[0];
FILE*__stdout= &permFiles[1];
FILE*__stderr= &permFiles[2];
/*102*/ FILE*__userFiles[(256-3)];
static FILE*myfile;
static int spareSpot;
static int err;
static int inreopen=0;
/*108*/ static const char*fnm;
static const char*modus;
static int modeType;
/*112*/ void __init_stdin(void)
{
__stdin= &permFiles[0];
__stdout= &permFiles[1];
__stderr= &permFiles[2];
}
/*119*/ FILE* *__get_stdin()
{return(&__stdin);}
FILE* *__get_stdout()
{return(&__stdout);}
FILE* *__get_stderr()
{return(&__stderr);}
/*126*/ static void dblcvt(double num,char cnvtype,size_t nwidth,int nprecision,char*result);
/*128*/ static int vvprintf(const char*format,va_list arg,FILE*fq,char*s);
static int vvscanf(const char*format,va_list arg,FILE*fp,const char*s);
static void fopen2(void);
static void fopen3(void);
static void findSpareSpot(void);
static void checkMode(void);
static void osfopen(void);
/*137*/ static void fwriteSlow(const void*ptr,size_t size,size_t nmemb,FILE*stream,size_t towrite,size_t*elemWritten);
/*143*/ static void fwriteSlowT(const void*ptr,FILE*stream,size_t towrite,size_t*actualWritten);
/*147*/ static void fwriteSlowB(const void*ptr,FILE*stream,size_t towrite,size_t*actualWritten);
/*151*/ static void freadSlowT(void*ptr,FILE*stream,size_t toread,size_t*actualRead);
/*155*/ static void freadSlowB(void*ptr,FILE*stream,size_t toread,size_t*actualRead);
/*161*/ static int examine(const char* *formt,FILE*fq,char*s,va_list*arg,int chcount);
/*165*/ int printf(const char*format,...)
{
char tbuf[1024];
va_list arg;
int ret;
/*171*/ __builtin_va_start(arg,format);
/*173*/ ret=vsprintf(tbuf,format,arg);
__builtin_va_end(arg);
/*176*/ tk_puts(tbuf);
/*178*/ return(ret);
}
/*181*/ int fprintf(FILE*stream,const char*format,...)
{
va_list arg;
int ret;
/*186*/ __builtin_va_start(arg,format);
ret=vfprintf(stream,format,arg);
__builtin_va_end(arg);
return(ret);
}
/*192*/ int vfprintf(FILE*stream,const char*format,va_list arg)
{
int ret;
/*196*/ stream->quickText=0;
ret=vvprintf(format,arg,stream,((void*)0));
return(ret);
}
/*201*/ FILE*fopen(const char*filename,const char*mode)
{
fnm=filename;
modus=mode;
err=0;
findSpareSpot();
if(!err)
{
myfile=malloc(sizeof(FILE));
if(myfile==((void*)0))
{
tk_puts("fopen: malloc fail\n");
err=1;
}
else
{
fopen2();
if(err)
{
free(myfile);
}
}
}
if(err)
{
myfile=((void*)0);
}
return(myfile);
}
/*231*/ static void fopen2(void)
{
checkMode();
if(!err)
{
strcpy(myfile->modeStr,modus);
osfopen();
if(!err)
{
__userFiles[spareSpot]=myfile;
myfile->intFno=spareSpot;
fopen3();
}else
{
tk_puts("fopen2: error status B\n");
}
}else
{
tk_puts("fopen2: error status A\n");
}
return;
}
/*254*/ static void fopen3(void)
{
myfile->intBuffer=malloc(6144+8);
if(myfile->intBuffer==((void*)0))
{
tk_puts("fopen3: intBuffer malloc fail\n");
err=1;
}
else
{
myfile->theirBuffer=0;
myfile->fbuf=myfile->intBuffer+2;
*myfile->fbuf++ ='\x00';
*myfile->fbuf++ ='\x00';
myfile->szfbuf=6144;
myfile->quickText=0;
myfile->noNl=0;
myfile->endbuf=myfile->fbuf+myfile->szfbuf;
*myfile->endbuf='\n';
/*274*/ myfile->upto=myfile->endbuf;
myfile->bufStartR= -(long)myfile->szfbuf;
myfile->errorInd=0;
myfile->eofInd=0;
myfile->ungetCh= -1;
myfile->update=0;
if(!inreopen)
{
myfile->permfile=0;
}
myfile->isopen=1;
/*286*/ if(!myfile->textMode)
{
myfile->quickBin=1;
}
else
{
myfile->quickBin=0;
}
/*295*/ myfile->mode=2;
switch(modeType)
{
case 2:
case 3:
case 5:
case 6:
case 8:
case 9:
case 11:
case 12:
myfile->bufStartR=0;
myfile->upto=myfile->fbuf;
myfile->mode=1;
break;
}
switch(modeType)
{
case 7:
case 8:
case 10:
case 11:
case 12:
myfile->update=1;
break;
}
}
return;
}
/*325*/ static void findSpareSpot(void)
{
int x;
/*329*/ for(x=0;x<(256-3);x++)
{
if(__userFiles[x]==((void*)0))
{
break;
}
}
if(x==(256-3))
{
err=1;
tk_puts("findSpareSpot: find spot fail\n");
}
else
{
spareSpot=x;
}
return;
}
/*362*/ static void checkMode(void)
{
if(strncmp(modus,"r+b",3)==0)
{
modeType=10;
}
else if(strncmp(modus,"rb+",3)==0)
{
modeType=10;
}
else if(strncmp(modus,"w+b",3)==0)
{
modeType=11;
}
else if(strncmp(modus,"wb+",3)==0)
{
modeType=11;
}
else if(strncmp(modus,"a+b",3)==0)
{
modeType=12;
}
else if(strncmp(modus,"ab+",3)==0)
{
modeType=12;
}
else if(strncmp(modus,"r+",2)==0)
{
modeType=7;
}
else if(strncmp(modus,"w+",2)==0)
{
modeType=8;
}
else if(strncmp(modus,"a+",2)==0)
{
modeType=9;
}
else if(strncmp(modus,"rb",2)==0)
{
modeType=4;
}
else if(strncmp(modus,"wb",2)==0)
{
modeType=5;
}
else if(strncmp(modus,"ab",2)==0)
{
modeType=6;
}
else if(strncmp(modus,"r",1)==0)
{
modeType=1;
}
else if(strncmp(modus,"w",1)==0)
{
modeType=2;
}
else if(strncmp(modus,"a",1)==0)
{
modeType=3;
}
else
{
err=1;
return;
}
if((modeType==4)||(modeType==5)||(modeType==6)||(modeType==10)||(modeType==11)||(modeType==12))
/*435*/ {
myfile->textMode=0;
}
else
{
myfile->textMode=1;
}
/*445*/ return;
}
/*448*/ static void osfopen(void)
{
int mode;
int errind;
/*457*/ if(modeType==1)
{
mode=0;
}
else if(modeType==4)
{
mode=0;
}
else if((modeType==2)||(modeType==5))
{
mode=1;
}
else
{
mode=2;
/*475*/ err=1;
(*(__get_errno()))=2;
/*478*/ tk_printf("osfopen: bad mode %d\n",modeType);
return;
}
/*482*/ myfile->hfile=__open(fnm,mode,(int)&errind);
if(errind)
{
err=1;
(*(__get_errno()))=myfile->hfile;
tk_puts("osfopen: got error status\n");
}
return;
}
/*492*/ int fclose(FILE*stream)
{
if(!stream)
return(-1);
/*497*/ if(!stream->isopen)
{
return(-1);
}
fflush(stream);
__close(stream->hfile);
return(0);
}
/*506*/ size_t fread(void*ptr,size_t size,size_t nmemb,FILE*stream)
/*510*/ {
size_t toread;
size_t elemRead;
size_t actualRead;
int errind;
size_t tempRead;
/*517*/ if(!stream)
return(-1);
/*520*/ if(nmemb==1)
{
toread=size;
}
else if(size==1)
{
toread=nmemb;
}
else
{
toread=size*nmemb;
}
if(toread<stream->szfbuf)
{
stream->quickBin=0;
}
/*538*/ stream->quickBin=1;
/*540*/ if(stream->ungetCh!= -1)
{
* --stream->upto=(char)stream->ungetCh;
stream->ungetCh= -1;
}
if(!stream->quickBin)
{
if(stream->textMode)
{
freadSlowT(ptr,stream,toread,&actualRead);
}
else
{
if(toread<=(stream->endbuf-stream->upto))
{
memcpy(ptr,stream->upto,toread);
actualRead=toread;
stream->upto+=toread;
}
else
{
freadSlowB(ptr,stream,toread,&actualRead);
}
}
if(nmemb==1)
{
if(actualRead==size)
{
elemRead=1;
}
else
{
elemRead=0;
}
}
else if(size==1)
{
elemRead=actualRead;
}
else
{
if(size==0)
{
elemRead=0;
}
else
{
elemRead=actualRead/size;
}
}
return(elemRead);
}
else
{
tempRead=__read(stream->hfile,ptr,toread,&errind);
if(errind)
{
(*(__get_errno()))=tempRead;
actualRead=0;
stream->errorInd=1;
}
else
{
actualRead=tempRead;
}
/*606*/ if(nmemb==1)
{
if(actualRead==size)
{
elemRead=1;
}
else
{
elemRead=0;
stream->eofInd=1;
}
}
else if(size==1)
{
elemRead=actualRead;
if(nmemb!=actualRead)
{
stream->eofInd=1;
}
}
else
{
if(size==0)
{
elemRead=0;
}
else
{
elemRead=actualRead/size;
}
if(toread!=actualRead)
{
stream->eofInd=1;
}
}
stream->bufStartR+=actualRead;
return(elemRead);
}
}
/*654*/ static void freadSlowT(void*ptr,FILE*stream,size_t toread,size_t*actualRead)
/*658*/ {
int finReading=0;
size_t avail;
size_t need;
char*p;
size_t got;
size_t tempRead;
int errind;
/*667*/ *actualRead=0;
while(!finReading)
{
if(stream->upto==stream->endbuf)
{
tempRead=__read(stream->hfile,stream->fbuf,stream->szfbuf,&errind);
/*676*/ if(errind)
{
(*(__get_errno()))=tempRead;
tempRead=0;
stream->errorInd=1;
}
/*683*/ if(tempRead==0)
{
stream->eofInd=1;
break;
}
stream->bufStartR+=(stream->upto-stream->fbuf);
stream->endbuf=stream->fbuf+tempRead;
*stream->endbuf='\n';
stream->upto=stream->fbuf;
}
avail=(size_t)(stream->endbuf-stream->upto)+1;
need=toread- *actualRead;
p=memchr(stream->upto,'\n',avail);
got=(size_t)(p-stream->upto);
if(need<got)
{
memcpy((char*)ptr+ *actualRead,stream->upto,need);
stream->upto+=need;
*actualRead+=need;
}
else
{
memcpy((char*)ptr+ *actualRead,stream->upto,got);
stream->upto+=got;
*actualRead+=got;
if(p!=stream->endbuf)
{
if(*(stream->upto-1)=='\r')
{
*((char*)ptr+ *actualRead-1)='\n';
stream->upto++;
}
else if(need!=got)
{
*((char*)ptr+ *actualRead)='\n';
*actualRead+=1;
stream->upto++;
}
}
else
{
if(*(stream->upto-1)=='\r')
{
*actualRead-=1;
}
}
}
if(*actualRead==toread)
{
finReading=1;
}
}
return;
}
/*738*/ static void freadSlowB(void*ptr,FILE*stream,size_t toread,size_t*actualRead)
/*742*/ {
size_t avail;
size_t tempRead;
int errind;
/*747*/ avail=(size_t)(stream->endbuf-stream->upto);
memcpy(ptr,stream->upto,avail);
*actualRead=avail;
stream->bufStartR+=(stream->endbuf-stream->fbuf);
if(toread>=stream->szfbuf)
{
stream->upto=stream->endbuf;
stream->quickBin=1;
/*756*/ tempRead=__read(stream->hfile,(char*)ptr+ *actualRead,toread- *actualRead,&errind);
/*760*/ if(errind)
{
(*(__get_errno()))=tempRead;
tempRead=0;
stream->errorInd=1;
}
else if(tempRead!=(toread- *actualRead))
{
stream->eofInd=1;
}
*actualRead+=tempRead;
stream->bufStartR+=tempRead;
}
else
{
size_t left;
/*777*/ stream->upto=stream->fbuf;
/*779*/ tempRead=__read(stream->hfile,stream->fbuf,stream->szfbuf,&errind);
/*783*/ left=toread- *actualRead;
if(errind)
{
(*(__get_errno()))=tempRead;
tempRead=0;
stream->errorInd=1;
}
else if(tempRead<left)
{
stream->eofInd=1;
}
stream->endbuf=stream->fbuf+tempRead;
*stream->endbuf='\n';
avail=(size_t)(stream->endbuf-stream->upto);
if(avail>left)
{
avail=left;
}
memcpy((char*)ptr+ *actualRead,stream->upto,avail);
/*804*/ stream->upto+=avail;
*actualRead+=avail;
}
return;
}
/*810*/ size_t fwrite(const void*ptr,size_t size,size_t nmemb,FILE*stream)
/*814*/ {
size_t towrite;
size_t elemWritten;
size_t actualWritten;
int errind;
/*820*/ if(!stream)
return(-1);
/*823*/ if(nmemb==1)
{
towrite=size;
}
else if(size==1)
{
towrite=nmemb;
}
else
{
towrite=size*nmemb;
}
if(towrite<stream->szfbuf)
{
stream->quickBin=0;
if((stream->bufTech==3)&& !stream->textMode)
{
stream->quickBin=1;
}
}
if(!stream->quickBin)
{
fwriteSlow(ptr,size,nmemb,stream,towrite,&elemWritten);
return(elemWritten);
}
else
{
actualWritten=__write(stream->hfile,ptr,towrite,&errind);
/*854*/ if(errind)
{
stream->errorInd=1;
actualWritten=0;
(*(__get_errno()))=actualWritten;
}
/*861*/ if(nmemb==1)
{
if(actualWritten==size)
{
elemWritten=1;
}
else
{
elemWritten=0;
}
}
else if(size==1)
{
elemWritten=actualWritten;
}
else
{
elemWritten=actualWritten/size;
}
stream->bufStartR+=actualWritten;
return(elemWritten);
}
}
/*885*/ static void fwriteSlow(const void*ptr,size_t size,size_t nmemb,FILE*stream,size_t towrite,size_t*elemWritten)
/*891*/ {
size_t actualWritten;
/*902*/ if(stream->upto==stream->endbuf)
{
stream->bufStartR+=(stream->endbuf-stream->fbuf);
stream->upto=stream->fbuf;
stream->mode=1;
}
if((stream->textMode)||(stream->bufTech==2))
{
fwriteSlowT(ptr,stream,towrite,&actualWritten);
}
else
{
fwriteSlowB(ptr,stream,towrite,&actualWritten);
}
if(nmemb==1)
{
if(actualWritten==size)
{
*elemWritten=1;
}
else
{
*elemWritten=0;
}
}
else if(size==1)
{
*elemWritten=actualWritten;
}
else
{
*elemWritten=actualWritten/size;
}
return;
}
/*942*/ static void fwriteSlowT(const void*ptr,FILE*stream,size_t towrite,size_t*actualWritten)
/*946*/ {
char*p;
char*tptr;
char*oldp;
size_t diffp;
size_t rem;
int fin;
size_t tempWritten;
int errind;
/*956*/ *actualWritten=0;
tptr=(char*)ptr;
p=tptr;
oldp=p;
p=(char*)memchr(oldp,'\n',towrite-(size_t)(oldp-tptr));
while(p!=((void*)0))
{
diffp=(size_t)(p-oldp);
fin=0;
while(!fin)
{
rem=(size_t)(stream->endbuf-stream->upto);
if(diffp<rem)
{
memcpy(stream->upto,oldp,diffp);
stream->upto+=diffp;
*actualWritten+=diffp;
fin=1;
}
else
{
memcpy(stream->upto,oldp,rem);
oldp+=rem;
diffp-=rem;
/*981*/ tempWritten=__write(stream->hfile,stream->fbuf,stream->szfbuf,&errind);
/*985*/ if(errind)
{
stream->errorInd=1;
return;
}
else
{
*actualWritten+=rem;
stream->upto=stream->fbuf;
stream->bufStartR+=tempWritten;
}
}
}
rem=(size_t)(stream->endbuf-stream->upto);
if(rem<3)
{
tempWritten=__write(stream->hfile,stream->fbuf,(size_t)(stream->upto-stream->fbuf),&errind);
/*1005*/ if(errind)
{
stream->errorInd=1;
(*(__get_errno()))=tempWritten;
return;
}
/*1012*/ stream->upto=stream->fbuf;
stream->bufStartR+=tempWritten;
}
/*1016*/ memcpy(stream->upto,"\n",1);
stream->upto+=1;
/*1019*/ *actualWritten+=1;
oldp=p+1;
p=(char*)memchr(oldp,'\n',towrite-(size_t)(oldp-tptr));
}
/*1024*/ if((stream->bufTech==2)&&(stream->upto!=stream->fbuf)&&(oldp!=tptr))
/*1027*/ {
tempWritten=__write(stream->hfile,stream->fbuf,(size_t)(stream->upto-stream->fbuf),&errind);
/*1032*/ if(errind)
{
stream->errorInd=1;
(*(__get_errno()))=tempWritten;
return;
}
/*1039*/ stream->upto=stream->fbuf;
stream->bufStartR+=tempWritten;
}
/*1043*/ diffp=towrite- *actualWritten;
while(diffp!=0)
{
rem=(size_t)(stream->endbuf-stream->upto);
if(diffp<rem)
{
memcpy(stream->upto,oldp,diffp);
stream->upto+=diffp;
*actualWritten+=diffp;
}
else
{
memcpy(stream->upto,oldp,rem);
/*1057*/ tempWritten=__write(stream->hfile,stream->fbuf,stream->szfbuf,&errind);
/*1061*/ if(errind)
{
stream->errorInd=1;
(*(__get_errno()))=tempWritten;
return;
}
else
{
*actualWritten+=rem;
stream->upto=stream->fbuf;
}
stream->bufStartR+=tempWritten;
oldp+=rem;
}
diffp=towrite- *actualWritten;
}
if((stream->bufTech==3)&&(stream->upto!=stream->fbuf))
/*1079*/ {
tempWritten=__write(stream->hfile,stream->fbuf,(size_t)(stream->upto-stream->fbuf),&errind);
/*1084*/ if(errind)
{
stream->errorInd=1;
(*(__get_errno()))=tempWritten;
return;
}
/*1091*/ stream->upto=stream->fbuf;
stream->bufStartR+=tempWritten;
}
return;
}
/*1100*/ static void fwriteSlowB(const void*ptr,FILE*stream,size_t towrite,size_t*actualWritten)
/*1104*/ {
size_t spare;
size_t tempWritten;
int errind;
/*1109*/ spare=(size_t)(stream->endbuf-stream->upto);
if(towrite<spare)
{
memcpy(stream->upto,ptr,towrite);
*actualWritten=towrite;
stream->upto+=towrite;
return;
}
memcpy(stream->upto,ptr,spare);
/*1119*/ tempWritten=__write(stream->hfile,stream->fbuf,stream->szfbuf,&errind);
/*1123*/ if(errind)
{
stream->errorInd=1;
(*(__get_errno()))=tempWritten;
return;
}
/*1130*/ *actualWritten=spare;
stream->upto=stream->fbuf;
stream->bufStartR+=tempWritten;
if(towrite>stream->szfbuf)
{
stream->quickBin=1;
/*1137*/ tempWritten=__write(stream->hfile,(char*)ptr+ *actualWritten,towrite- *actualWritten,&errind);
/*1141*/ if(errind)
{
stream->errorInd=1;
(*(__get_errno()))=tempWritten;
return;
}
/*1148*/ *actualWritten+=tempWritten;
stream->bufStartR+=tempWritten;
}
else
{
memcpy(stream->fbuf,(char*)ptr+ *actualWritten,towrite- *actualWritten);
/*1156*/ stream->upto+=(towrite- *actualWritten);
*actualWritten=towrite;
}
stream->bufStartR+= *actualWritten;
return;
}
/*1163*/ static int vvprintf(const char*format,va_list arg,FILE*fq,char*s)
{
int fin;
int vint;
double vdbl;
unsigned int uvint;
const char*vcptr;
int chcount;
size_t len;
char numbuf[50];
char*nptr;
int*viptr;
/*1176*/ fin=0;
chcount=0;
/*1179*/ while(!fin)
{
if(*format=='\x00')
{
fin=1;
}
else if(*format=='%')
{
format++;
if(*format=='d')
{
vint=__builtin_va_arg(arg,int);
/*1192*/ if(vint<0)
{uvint= -vint;}
else
{uvint=vint;}
/*1197*/ nptr=numbuf;
do
{
*nptr++ =(char)('0'+uvint%10);
uvint/=10;
}while(uvint>0);
/*1204*/ if(vint<0)
{*nptr++ ='-';}
do
{
nptr--;
((fq==((void*)0))? *s++ =(char)*nptr:(fputc((*nptr),(fq))));
chcount++;
}while(nptr!=numbuf);
/*1213*/ }
else if(*format=='s')
{
vcptr=__builtin_va_arg(arg,const char*);
/*1218*/ if(!vcptr)
{
vcptr="(null)";
}
/*1224*/ if(!fq)
{
len=strlen(vcptr);
memcpy(s,vcptr,len);
s+=len;
chcount+=len;
}
else
{
fputs(vcptr,fq);
chcount+=strlen(vcptr);
}
}
else if(*format=='c')
{
vint=__builtin_va_arg(arg,int);
((fq==((void*)0))? *s++ =(char)vint:(fputc((vint),(fq))));
chcount++;
}
else if(*format=='n')
{
viptr=__builtin_va_arg(arg,int*);
*viptr=chcount;
}
else if(*format=='%')
{
((fq==((void*)0))? *s++ =(char)'%':(fputc(('%'),(fq))));
chcount++;
}
else if(strchr("eEgGfF",*format)!=((void*)0)&& *format!=0)
{
/*1256*/ vdbl=__builtin_va_arg(arg,double);
dblcvt(vdbl,*format,0,6,numbuf);
len=strlen(numbuf);
/*1260*/ if(fq==((void*)0))
{
memcpy(s,numbuf,len);
s+=len;
}
else
{
fputs(numbuf,fq);
}
chcount+=len;
}
else
{
int extraCh;
/*1275*/ extraCh=examine(&format,fq,s,&arg,chcount);
chcount+=extraCh;
if(s!=((void*)0))
{
s+=extraCh;
}
}
}
else
{
((fq==((void*)0))? *s++ =(char)*format:(fputc((*format),(fq))));
chcount++;
}
format++;
}
/*1291*/ return(chcount);
}
/*1294*/ static int examine(const char* *formt,FILE*fq,char*s,va_list*arg,int chcount)
/*1296*/ {
int extraCh=0;
int flagMinus=0;
int flagPlus=0;
int flagSpace=0;
int flagHash=0;
int flagZero=0;
int width=0;
int precision= -1;
int half=0;
int lng=0;
int specifier=0;
int fin;
long lvalue;
short int hvalue;
int ivalue;
unsigned long ulvalue;
double vdbl;
char*svalue;
char work[50];
int x;
int y;
int rem;
const char*format;
int base;
int fillCh;
int neg;
int length;
size_t slen;
/*1326*/ ((void)(chcount));
format= *formt;
/*1329*/ fin=0;
while(!fin)
{
switch(*format)
{
case'-':flagMinus=1;
break;
case'+':flagPlus=1;
break;
case' ':flagSpace=1;
break;
case'#':flagHash=1;
break;
case'0':flagZero=1;
break;
case'*':width=__builtin_va_arg(*arg,int);
if(width<0)
{
flagMinus=1;
width= -width;
}
break;
default:fin=1;
break;
}
if(!fin)
{
format++;
}
else
{
if(flagSpace&&flagPlus)
{
flagSpace=0;
}
if(flagMinus)
{
flagZero=0;
}
}
}
/*1372*/ if(isdigit((unsigned char)*format))
{
while(isdigit((unsigned char)*format))
{
width=width*10+(*format-'0');
format++;
}
}
/*1382*/ if(*format=='.')
{
format++;
if(*format=='*')
{
precision=__builtin_va_arg(*arg,int);
format++;
}
else
{
precision=0;
while(isdigit((unsigned char)*format))
{
precision=precision*10+(*format-'0');
format++;
}
}
}
/*1402*/ if(*format=='h')
{
/*1408*/ }
else if(*format=='l')
{
lng=1;
}
else if(*format=='L')
{
lng=1;
}
else
{
format--;
}
format++;
/*1424*/ specifier= *format;
/*1426*/ if(strchr("dxXuiop",specifier)!=((void*)0)&&specifier!=0)
{
if(precision<0)
{
precision=1;
}
/*1438*/ if(lng)
{
lvalue=__builtin_va_arg(*arg,long);
}
else if(half)
{
/*1445*/ hvalue=__builtin_va_arg(*arg,int);
if(specifier=='u')lvalue=(unsigned short)hvalue;
else lvalue=hvalue;
}
else
{
ivalue=__builtin_va_arg(*arg,int);
if(specifier=='u')lvalue=(unsigned int)ivalue;
else lvalue=ivalue;
}
ulvalue=(unsigned long)lvalue;
if((lvalue<0)&&((specifier=='d')||(specifier=='i')))
{
neg=1;
ulvalue= -lvalue;
}
else
{
neg=0;
}
/*1471*/ if((specifier=='X')||(specifier=='x')||(specifier=='p'))
{
base=16;
}
else if(specifier=='o')
{
base=8;
}
else
{
base=10;
}
if(specifier=='p')
{
/*1488*/ precision=8;
/*1490*/ }
x=0;
while(ulvalue>0)
{
rem=(int)(ulvalue%base);
if(rem<10)
{
work[x]=(char)('0'+rem);
}
else
{
if((specifier=='X')||(specifier=='p'))
{
work[x]=(char)('A'+(rem-10));
}
else
{
work[x]=(char)('a'+(rem-10));
}
}
x++;
/*1518*/ ulvalue=ulvalue/base;
}
/*1530*/ while(x<precision)
{
work[x]='0';
x++;
}
if(neg)
{
work[x++]='-';
}
else if(flagPlus)
{
work[x++]='+';
}
if(flagZero)
{
fillCh='0';
}
else
{
fillCh=' ';
}
y=x;
if(!flagMinus)
{
while(y<width)
{
((fq==((void*)0))? *s++ =(char)fillCh:(fputc((fillCh),(fq))));
extraCh++;
y++;
}
}
if(flagHash&&(toupper((unsigned char)specifier)=='X'))
{
((fq==((void*)0))? *s++ =(char)'0':(fputc(('0'),(fq))));
((fq==((void*)0))? *s++ =(char)'x':(fputc(('x'),(fq))));
extraCh+=2;
}
x--;
while(x>=0)
{
((fq==((void*)0))? *s++ =(char)work[x]:(fputc((work[x]),(fq))));
extraCh++;
x--;
}
if(flagMinus)
{
while(y<width)
{
((fq==((void*)0))? *s++ =(char)fillCh:(fputc((fillCh),(fq))));
extraCh++;
y++;
}
}
}
else if(strchr("eEgGfF",specifier)!=((void*)0)&&specifier!=0)
{
if(precision<0)
{
precision=6;
}
vdbl=__builtin_va_arg(*arg,double);
dblcvt(vdbl,specifier,width,precision,work);
slen=strlen(work);
if(fq==((void*)0))
{
memcpy(s,work,slen);
s+=slen;
}
else
{
fputs(work,fq);
}
extraCh+=slen;
}
else if(specifier=='s')
{
if(precision<0)
{
precision=1;
}
svalue=__builtin_va_arg(*arg,char*);
fillCh=' ';
if(precision>1)
{
char*p;
/*1616*/ p=memchr(svalue,'\x00',precision);
if(p!=((void*)0))
{
length=(int)(p-svalue);
}
else
{
length=precision;
}
}
else
{
length=strlen(svalue);
}
if(!flagMinus)
{
if(length<width)
{
extraCh+=(width-length);
for(x=0;x<(width-length);x++)
{
((fq==((void*)0))? *s++ =(char)fillCh:(fputc((fillCh),(fq))));
}
}
}
for(x=0;x<length;x++)
{
((fq==((void*)0))? *s++ =(char)svalue[x]:(fputc((svalue[x]),(fq))));
}
extraCh+=length;
if(flagMinus)
{
if(length<width)
{
extraCh+=(width-length);
for(x=0;x<(width-length);x++)
{
((fq==((void*)0))? *s++ =(char)fillCh:(fputc((fillCh),(fq))));
}
}
}
}
*formt=format;
return(extraCh);
}
/*1662*/ int fputc(int c,FILE*stream)
{
char buf[1];
/*1667*/ stream->quickBin=0;
if((stream->upto<(stream->endbuf-2))&&(stream->bufTech!=3))
/*1670*/ {
if(stream->textMode)
{
if(c=='\n')
{
if(stream->bufTech==1)
{
*stream->upto++ ='\r';
*stream->upto++ ='\n';
}
else
{
buf[0]=(char)c;
if(fwrite(buf,1,1,stream)!=1)
{
return(-1);
}
}
}
else
{
*stream->upto++ =(char)c;
}
}
else
{
*stream->upto++ =(char)c;
}
}
else
/*1701*/ {
buf[0]=(char)c;
if(fwrite(buf,1,1,stream)!=1)
{
return(-1);
}
}
return(c);
}
/*1712*/ int fputs(const char*s,FILE*stream)
{
size_t len;
size_t ret;
/*1717*/ len=strlen(s);
ret=fwrite(s,len,1,stream);
if(ret!=1)return(-1);
else return(0);
}
/*1724*/ int remove(const char*filename)
{
int ret;
__remove(filename);
ret=0;
return(ret);
}
/*1732*/ int rename(const char*old,const char*new)
{
int ret;
__rename(old,new);
ret=0;
return(ret);
}
/*1740*/ int sprintf(char*s,const char*format,...)
{
va_list arg;
int ret;
/*1745*/ __builtin_va_start(arg,format);
ret=vsprintf(s,format,arg);
__builtin_va_end(arg);
return(ret);
}
/*1751*/ int vsprintf(char*s,const char*format,va_list arg)
{
int ret;
/*1755*/ ret=vvprintf(format,arg,((void*)0),s);
if(ret>=0)
{
*(s+ret)='\x00';
}
return(ret);
}
/*1773*/ char*fgets(char*s,int n,FILE*stream)
{
char*p;
register char*t;
register char*u=s;
int c;
int processed;
size_t actualRead;
int errind;
/*1783*/ if(stream->quickText)
{
p=stream->upto+n-1;
t=stream->upto;
if(p<stream->endbuf)
{
c= *p;
*p='\n';
while((*u++ = *t++)!='\n');
/*1793*/ *p=(char)c;
if(t<=p)
{
if(*(t-2)=='\r')
{
*(u-2)='\n';
*(u-1)='\x00';
}
else
{
*u='\x00';
}
stream->upto=t;
return(s);
}
else
{
processed=(int)(t-stream->upto)-1;
stream->upto=t-1;
u--;
}
}
else
{
while((*u++ = *t++)!='\n');
if(t<=stream->endbuf)
{
if(*(t-2)=='\r')
{
*(u-2)='\n';
*(u-1)='\x00';
}
else
{
*u='\x00';
}
stream->upto=t;
return(s);
}
else
{
processed=(int)(t-stream->upto)-1;
stream->upto=t-1;
u--;
}
}
}
else
{
processed=0;
}
/*1845*/ if(n<1)
{
return(((void*)0));
}
if(n<2)
{
*u='\x00';
return(s);
}
if(stream->ungetCh!= -1)
{
processed++;
*u++ =(char)stream->ungetCh;
stream->ungetCh= -1;
}
while(1)
{
t=stream->upto;
p=stream->upto+(n-processed)-1;
if(p<stream->endbuf)
{
c= *p;
*p='\n';
}
if(stream->noNl)
{
while(((*u++ = *t)!='\n')&&(*t++ !='\r'));
if(*(u-1)=='\n')
{
t++;
}
else
{
u--;
while((*u++ = *t++)!='\n');
}
}
else
{
while((*u++ = *t++)!='\n');
}
if(p<stream->endbuf)
{
*p=(char)c;
}
if(((t<=p)&&(p<stream->endbuf))||((t<=stream->endbuf)&&(p>=stream->endbuf)))
/*1892*/ {
if(stream->textMode)
{
if(stream->noNl)
{
if((*(t-1)=='\r')||(*(t-1)=='\n'))
{
*(u-1)='\x00';
}
else
{
*u='\x00';
}
}
else if(*(t-2)=='\r')
{
*(u-2)='\n';
*(u-1)='\x00';
}
else
{
*u='\x00';
}
}
stream->upto=t;
if(stream->textMode)
{
stream->quickText=1;
}
return(s);
}
else if(((t>p)&&(p<stream->endbuf))||((t>stream->endbuf)&&(p>=stream->endbuf)))
/*1925*/ {
int leave=1;
/*1928*/ if(stream->textMode)
{
if(t>stream->endbuf)
{
if((t-stream->upto)>1)
{
if(*(t-2)=='\r')
{
processed-=1;
}
}
leave=0;
}
else
{
if((*(t-2)=='\r')&&(*(t-1)=='\n'))
{
*(u-2)='\n';
*(u-1)='\x00';
}
else
{
t--;
*(u-1)='\x00';
}
}
}
else if(t>stream->endbuf)
{
leave=0;
}
else
{
*u='\x00';
}
if(leave)
{
stream->upto=t;
if(stream->textMode)
{
stream->quickText=1;
}
return(s);
}
}
processed+=(int)(t-stream->upto)-1;
u--;
stream->bufStartR+=(stream->endbuf-stream->fbuf);
/*1977*/ actualRead=__read(stream->hfile,stream->fbuf,stream->szfbuf,&errind);
/*1981*/ if(errind)
{
(*(__get_errno()))=actualRead;
actualRead=0;
stream->errorInd=1;
}
/*1988*/ stream->endbuf=stream->fbuf+actualRead;
*stream->endbuf='\n';
if(actualRead==0)
{
*u='\x00';
if((u-s)<=1)
{
stream->eofInd=1;
return(((void*)0));
}
else
{
return(s);
}
}
stream->upto=stream->fbuf;
}
}
/*2008*/ int ungetc(int c,FILE*stream)
{
if((stream->ungetCh!= -1)||(c== -1))
{
return(-1);
}
stream->ungetCh=(unsigned char)c;
stream->quickText=0;
stream->quickBin=0;
return((unsigned char)c);
}
/*2020*/ int fgetc(FILE*stream)
{
unsigned char x[1];
size_t ret;
/*2025*/ ret=fread(x,1,1,stream);
if(ret==0)
{
return(-1);
}
return((int)(x[0]));
}
/*2033*/ int fseek(FILE*stream,long int offset,int whence)
{
long oldpos;
long newpos;
/*2038*/ oldpos=stream->bufStartR+(stream->upto-stream->fbuf);
if(stream->mode==1)
{
fflush(stream);
}
if(whence==0)
{
newpos=offset;
}
else if(whence==1)
{
newpos=oldpos+offset;
}
/*2052*/ if(whence==2)
{
__seek(stream->hfile,offset,2);
newpos=__tell(stream->hfile);
/*2057*/ stream->endbuf=stream->fbuf+stream->szfbuf;
stream->upto=stream->endbuf;
stream->bufStartR=newpos-stream->szfbuf;
/*2066*/ }
else if((newpos>=stream->bufStartR)&&(newpos<(stream->bufStartR+(stream->endbuf-stream->fbuf)))&&(stream->update||(stream->mode==2)))
/*2070*/ {
stream->upto=stream->fbuf+(size_t)(newpos-stream->bufStartR);
}
else
{
__seek(stream->hfile,newpos,whence);
stream->endbuf=stream->fbuf+stream->szfbuf;
stream->upto=stream->endbuf;
stream->bufStartR=newpos-stream->szfbuf;
}
/*2081*/ stream->quickBin=0;
stream->quickText=0;
stream->ungetCh= -1;
return(0);
}
/*2087*/ long int ftell(FILE*stream)
{
return(stream->bufStartR+(stream->upto-stream->fbuf));
}
/*2092*/ int fsetpos(FILE*stream,const fpos_t*pos)
{
fseek(stream,*pos,0);
return(0);
}
/*2098*/ int fgetpos(FILE*stream,fpos_t*pos)
{
*pos=ftell(stream);
return(0);
}
/*2104*/ void rewind(FILE*stream)
{
fseek(stream,0 L,0);
return;
}
/*2110*/ void clearerr(FILE*stream)
{
stream->errorInd=0;
stream->eofInd=0;
return;
}
/*2117*/ void perror(const char*s)
{
if((s!=((void*)0))&&(*s!='\x00'))
{
printf("%s: %s\n",s,strerror((*(__get_errno()))));
}else
{
printf("%s\n",strerror((*(__get_errno()))));
}
/*2127*/ return;
}
/*2139*/ int setvbuf(FILE*stream,char*buf,int mode,size_t size)
{
char*mybuf;
/*2143*/ if(mode==3)
{
stream->bufTech=mode;
return(0);
}
if(buf==((void*)0))
{
if(size<2)
{
return(-1);
}
mybuf=malloc(size+8);
if(mybuf==((void*)0))
{
return(-1);
}
}
else
{
if(size<10)
{
return(-1);
}
mybuf=buf;
stream->theirBuffer=1;
size-=8;
}
if(!stream->permfile)
{
free(stream->intBuffer);
}
stream->intBuffer=mybuf;
stream->fbuf=stream->intBuffer+2;
*stream->fbuf++ ='\x00';
*stream->fbuf++ ='\x00';
stream->szfbuf=size;
stream->endbuf=stream->fbuf+stream->szfbuf;
*stream->endbuf='\n';
if(stream->mode==1)
{
stream->upto=stream->fbuf;
}
else
{
stream->upto=stream->endbuf;
}
stream->bufTech=mode;
if(!stream->textMode&&(stream->bufTech==2))
{
stream->quickBin=0;
}
return(0);
}
/*2197*/ int setbuf(FILE*stream,char*buf)
{
int ret;
/*2201*/ if(buf==((void*)0))
{
ret=setvbuf(stream,((void*)0),3,0);
}
else
{
ret=setvbuf(stream,buf,1,6144);
}
return(ret);
}
/*2212*/ FILE*freopen(const char*filename,const char*mode,FILE*stream)
/*2214*/ {
inreopen=1;
fclose(stream);
/*2218*/ myfile=stream;
fnm=filename;
modus=mode;
err=0;
spareSpot=stream->intFno;
fopen2();
if(err&& !stream->permfile)
{
__userFiles[stream->intFno]=((void*)0);
free(stream);
}
/*2230*/ inreopen=0;
if(err)
{
return(((void*)0));
}
return(stream);
}
/*2238*/ int fflush(FILE*stream)
{
int errind;
size_t actualWritten;
/*2243*/ if((stream->upto!=stream->fbuf)&&(stream->mode==1))
{
actualWritten=__write(stream->hfile,stream->fbuf,(size_t)(stream->upto-stream->fbuf),&errind);
/*2249*/ if(errind)
{
stream->errorInd=1;
(*(__get_errno()))=actualWritten;
return(-1);
}
/*2256*/ stream->bufStartR+=actualWritten;
stream->upto=stream->fbuf;
}
return(0);
}
/*2262*/ char*tmpnam(char*s)
{
static char buf[]="ZZZZZZZA.$$$";
buf[7]++;
/*2267*/ if(s==((void*)0))
{
return(buf);
}
strcpy(s,buf);
return(s);
}
/*2275*/ FILE*tmpfile(void)
{
return(fopen("ZZZZZZZA.$$$","wb+"));
}
/*2280*/ int fscanf(FILE*stream,const char*format,...)
{
va_list arg;
int ret;
/*2285*/ __builtin_va_start(arg,format);
ret=vvscanf(format,arg,stream,((void*)0));
__builtin_va_end(arg);
return(ret);
}
/*2291*/ int scanf(const char*format,...)
{
va_list arg;
int ret;
/*2296*/ __builtin_va_start(arg,format);
ret=vvscanf(format,arg,(*(__get_stdin())),((void*)0));
__builtin_va_end(arg);
return(ret);
}
/*2302*/ int sscanf(const char*s,const char*format,...)
{
va_list arg;
int ret;
/*2307*/ __builtin_va_start(arg,format);
ret=vvscanf(format,arg,((void*)0),s);
__builtin_va_end(arg);
return(ret);
}
/*2315*/ static int vvscanf(const char*format,va_list arg,FILE*fp,const char*s)
{
int ch;
int fin=0;
int cnt=0;
char*cptr;
int*iptr;
unsigned int*uptr;
long*lptr;
unsigned long*luptr;
short*hptr;
unsigned short*huptr;
double*dptr;
float*fptr;
long startpos;
const char*startp;
int skipvar;
int modlong;
int modshort;
int informatitem;
/*2338*/ if(fp!=((void*)0))
{
startpos=ftell(fp);
}
else
{
startp=s;
}
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
informatitem=0;
if((fp!=((void*)0)&&ch== -1)||(fp==((void*)0)&&ch==0))return-1;
/*2350*/ while(!fin)
{
if(*format=='\x00')
{
fin=1;
}
else if(*format=='%'||informatitem)
{
if(*format=='%')
{
format++;
modlong=0;
modshort=0;
skipvar=0;
if(*format=='*')
{
skipvar=1;
format++;
}
}
if(*format=='%')
{
if(ch!='%')return(cnt);
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
informatitem=0;
}
else if(*format=='l')
{
/*2379*/ modlong=1;
informatitem=1;
}
else if(*format=='h')
{
/*2385*/ modshort=1;
informatitem=1;
}
else
{
informatitem=0;
if(*format=='s')
{
if(!skipvar)
{
cptr=__builtin_va_arg(arg,char*);
}
/*2398*/ while(ch>=0&&isspace(ch))((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
if((fp!=((void*)0)&&ch== -1)||(fp==((void*)0)&&ch==0))
/*2401*/ {
fin=1;
if(!skipvar)
{
*cptr=0;
}
}
else
{
for(;;)
{
if(isspace(ch))break;
if((fp!=((void*)0)&&ch== -1)||(fp==((void*)0)&&ch==0))
/*2415*/ {
fin=1;
break;
}
if(!skipvar)
{
*cptr++ =(char)ch;
}
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
if(!skipvar)
{
*cptr='\x00';
}
cnt++;
}
}
else if(*format=='[')
{
int reverse=0;
int found;
const char*first;
const char*last;
size_t size;
size_t mcnt=0;
/*2441*/ if(!skipvar)
{
cptr=__builtin_va_arg(arg,char*);
}
format++;
if(*format=='^')
{
reverse=1;
format++;
}
if(*format=='\x00')break;
first=format;
format++;
last=strchr(format,']');
if(last==((void*)0))return(cnt);
size=(size_t)(last-first);
while(1)
{
/*2462*/ found=(memchr(first,ch,size)!=((void*)0));
if(found&&reverse)break;
if(!found&& !reverse)break;
if(!skipvar)
{
*cptr++ =(char)ch;
}
mcnt++;
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
/*2472*/ if((fp!=((void*)0)&&ch== -1)||(fp==((void*)0)&&ch==0))
/*2474*/ {
break;
}
}
if(mcnt>0)
{
if(!skipvar)
{
*cptr++ ='\x00';
}
cnt++;
}
else
{
break;
}
format=last+1;
}
else if(*format=='c')
{
if(!skipvar)
{
cptr=__builtin_va_arg(arg,char*);
}
if((fp!=((void*)0)&&ch== -1)||(fp==((void*)0)&&ch==0))fin=1;
/*2501*/ else
{
if(!skipvar)
{
*cptr=ch;
}
cnt++;
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
}
else if(*format=='n')
{
uptr=__builtin_va_arg(arg,unsigned int*);
if(fp!=((void*)0))
{
*uptr=(unsigned int)(ftell(fp)-startpos);
}
else
{
*uptr=(unsigned int)(startp-s);
}
}
else if(*format=='d'|| *format=='u'|| *format=='x'|| *format=='o'|| *format=='p'|| *format=='i')
/*2527*/ {
int neg=0;
unsigned long x=0;
int undecided=0;
int base=10;
int mcnt=0;
/*2534*/ if(*format=='x')base=16;
else if(*format=='p')base=16;
else if(*format=='o')base=8;
else if(*format=='i')base=0;
if(!skipvar)
{
if((*format=='d')||(*format=='i'))
{
if(modlong)lptr=__builtin_va_arg(arg,long*);
else if(modshort)hptr=__builtin_va_arg(arg,short*);
else iptr=__builtin_va_arg(arg,int*);
}
else
{
if(modlong)luptr=__builtin_va_arg(arg,unsigned long*);
else if(modshort)huptr=
__builtin_va_arg(arg,unsigned short*);
else uptr=__builtin_va_arg(arg,unsigned int*);
}
}
/*2555*/ while(ch>=0&&isspace(ch))((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
if(ch=='-')
{
neg=1;
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
else if(ch=='+')((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
/*2566*/ if(base==0)
{
undecided=1;
}
while(!((fp!=((void*)0)&&ch== -1)||(fp==((void*)0)&&ch==0)))
/*2572*/ {
if(isdigit((unsigned char)ch))
{
if(base==0)
{
if(ch=='0')
{
base=8;
}
else
{
base=10;
undecided=0;
}
}
x=x*base+(ch-'0');
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
/*2597*/ else if(isalpha((unsigned char)ch))
{
if((ch=='X')||(ch=='x'))
{
if((base==0)||((base==8)&&undecided))
{
base=16;
undecided=0;
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
else if(base==16)
{
/*2611*/ ((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
else
{
break;
}
}
else if(base<=10)
{
break;
}
else
{
x=x*base+
(toupper((unsigned char)ch)-'A')+10;
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
}
else
{
break;
}
mcnt++;
}
/*2640*/ if(mcnt==0)
{
break;
}
/*2646*/ if(!skipvar)
{
if((*format=='d')||(*format=='i'))
{
long lval;
/*2652*/ if(neg)
{
lval=(long)-x;
}
else
{
lval=(long)x;
}
if(modlong)*lptr=lval;
/*2662*/ else if(modshort)*hptr=(short)lval;
/*2664*/ else*iptr=(int)lval;
}
else
{
if(modlong)*luptr=(unsigned long)x;
else if(modshort)*huptr=(unsigned short)x;
else*uptr=(unsigned int)x;
}
}
cnt++;
}
else if(*format=='e'|| *format=='f'|| *format=='g'|| *format=='E'|| *format=='G')
/*2677*/ {
/*2679*/ int negsw1,negsw2,dotsw,expsw,ndigs1,ndigs2,nfdigs;
int ntrailzer,expnum,expsignsw;
double fpval,pow10;
/*2683*/ if(!skipvar)
{
if(modlong)dptr=__builtin_va_arg(arg,double*);
else fptr=__builtin_va_arg(arg,float*);
}
negsw1=0;
negsw2=0;
dotsw=0;
expsw=0;
ndigs1=0;
ndigs2=0;
nfdigs=0;
ntrailzer=0;
expnum=0;
expsignsw=0;
fpval=0.0;
/*2700*/ while(ch>=0&&isspace(ch))((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
if(ch=='-')
{
negsw1=1;
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
else if(ch=='+')((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
while(ch>0)
{
if(ch=='.'&&dotsw==0&&expsw==0)dotsw=1;
else if(isdigit(ch))
{
if(expsw)
{
ndigs2++;
expnum=expnum*10+(ch-'0');
}
else
{
/*2723*/ ndigs1++;
if(dotsw)nfdigs++;
if(ch=='0'&&fpval!=0.)
{
/*2728*/ ntrailzer++;
}
else
{
/*2733*/ while(ntrailzer>0)
{
fpval*=10.;
ntrailzer--;
}
fpval=fpval*10.0+(ch-'0');
}
}
}
else if((ch=='e'||ch=='E')&&expsw==0)expsw=1;
else if((ch=='+'||ch=='-')&&expsw==1&&ndigs2==0&&expsignsw==0)
/*2745*/ {
expsignsw=1;
if(ch=='-')negsw2=1;
}
else break;
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
if((fp!=((void*)0)&&ch== -1)||(fp==((void*)0)&&ch==0))fin=1;
/*2755*/ if(ndigs1==0||(expsw&&ndigs2==0))return(cnt);
/*2757*/ if(negsw2)expnum= -expnum;
expnum+=ntrailzer-nfdigs;
if(expnum!=0&&fpval!=0.0)
{
negsw2=0;
if(expnum<0)
{
expnum= -expnum;
negsw2=1;
}
/*2769*/ pow10=10.0;
for(;;)
{
if(expnum&1)
{
if(negsw2)fpval/=pow10;
else fpval*=pow10;
}
expnum>>=1;
if(expnum==0)break;
pow10*=pow10;
}
}
if(negsw1)fpval= -fpval;
if(!skipvar)
{
/*2786*/ if(modlong)*dptr=fpval;
else*fptr=(float)fpval;
}
cnt++;
}
}
}
else if(isspace((unsigned char)(*format)))
{
/*2798*/ while(ch>=0&&isspace(ch))
{
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
}
else
{
if(ch!= *format)return(cnt);
((fp==((void*)0))?(ch=(unsigned char)*s++):(ch=(fgetc((fp)))));
}
format++;
if((fp!=((void*)0)&&ch== -1)||(fp==((void*)0)&&ch==0))fin=1;
/*2811*/ }
if(fp!=((void*)0))ungetc(ch,fp);
return(cnt);
}
/*2816*/ char*gets(char*s)
{
char*ret;
/*2820*/ (*(__get_stdin()))->quickText=0;
(*(__get_stdin()))->noNl=1;
ret=fgets(s,2147483647,(*(__get_stdin())));
(*(__get_stdin()))->noNl=0;
(*(__get_stdin()))->quickText=1;
return(ret);
}
/*2828*/ int puts(const char*s)
{
int ret;
/*2832*/ ret=fputs(s,(*(__get_stdout())));
if(ret== -1)
{
return(ret);
}
return((fputc(('\n'),((*(__get_stdout()))))));
}
/*2849*/ int getc(FILE*stream)
{
return(fgetc(stream));
}
/*2854*/ int putc(int c,FILE*stream)
{
return(fputc(c,stream));
}
/*2859*/ int getchar(void)
{
return(getc((*(__get_stdin()))));
}
/*2864*/ int putchar(int c)
{
return(putc(c,(*(__get_stdout()))));
}
/*2869*/ int feof(FILE*stream)
{
return(stream->eofInd);
}
/*2874*/ int ferror(FILE*stream)
{
return(stream->errorInd);
}
/*2891*/ static void dblcvt(double num,char cnvtype,size_t nwidth,int nprecision,char*result)
/*2893*/ {
double b,round;
int i,j,exp,pdigits,format;
char sign,work[45];
/*2900*/ if(num<0)
{
b= -num;
sign='-';
}
else
{
b=num;
sign=' ';
}
/*2915*/ exp=0;
if(b>1.0)
{
while((b>=10.0)&&(exp<35))
{
++exp;
/*2922*/ b=b*0.1;
}
}
else if(b==0.0)
{
exp=0;
}
/*2930*/ else if(b<1.0)
{
while((b<1.0)&&(exp> -35))
{
--exp;
b=b*10.0;
}
}
if((exp<= -35)||(exp>=35))
{
exp=0;
b=0.0;
}
/*2951*/ switch(cnvtype)
{
case'E':
case'e':
format=0;
break;
case'f':
case'F':
if(exp>=0)
{
format=1;
}
else
{
format= -1;
}
break;
default:
/*2973*/ if(exp>=0)
{
if(nprecision>exp)
{
format=1;
}
else
{
format=0;
}
}
else
{
/*2987*/ if(exp>= -4)
{
format= -1;
}
else
{
format=0;
}
}
break;
}
/*3001*/ switch(format)
{
case 0:
if(nprecision<53)
{
j=nprecision;
}
else
{
j=53;
}
round=1.0/2.0;
i=0;
while(++i<=j)
{
/*3017*/ round=round*0.1;
/*3019*/ }
b=b+round;
if(b>=10.0)
{
/*3024*/ b=b*0.1;
exp=exp+1;
}
break;
/*3029*/ case 1:
/*3031*/ if(exp+nprecision<53)
{
j=exp+nprecision;
}
else
{
j=53;
}
round=0.5;
i=0;
while(i++ <j)
{
/*3044*/ round=round*0.1;
}
b=b+round;
if(b>=10.0)
{
/*3050*/ b=b*0.1;
exp=exp+1;
}
break;
/*3055*/ case-1:
if(nprecision<53)
{
j=nprecision+exp+1;
}
else
{
j=53;
}
round=5.0;
i=0;
while(i++ <j)
{
/*3069*/ round=round*0.1;
}
if(j>=0)
{
b=b+round;
}
if(b>=10.0)
{
/*3078*/ b=b*0.1;
exp=exp+1;
}
if(exp>=0)
{
format=1;
}
break;
}
/*3091*/ if(format== -1)
{
/*3097*/ result[0]=sign;
result[1]='0';
result[2]='.';
result[3]=0x00;
while(++exp)
{
--nprecision;
strcat(result,"0");
}
i=b;
--nprecision;
work[0]=(char)('0'+i%10);
work[1]=0x00;
strcat(result,work);
/*3112*/ pdigits=nprecision;
/*3114*/ while(pdigits-- >0)
{
b=b-i;
b=b*10.0;
i=b;
work[0]=(char)('0'+i%10);
work[1]=0x00;
strcat(result,work);
}
}
/*3127*/ else if(format== +1)
{
i=b;
result[0]=sign;
result[1]='\x00';
work[0]=(char)('0'+i%10);
work[1]=0x00;
strcat(result,work);
nprecision=nprecision+exp;
pdigits=nprecision;
/*3138*/ while(pdigits-- >0)
{
if(((nprecision-pdigits-1)==exp))
{
strcat(result,".");
}
b=b-i;
b=b*10.0;
i=b;
work[0]=(char)('0'+i%10);
work[1]=0x00;
strcat(result,work);
}
}
/*3155*/ else
{
i=b;
result[0]=sign;
result[1]='\x00';
work[0]=(char)('0'+i%10);
work[1]=0x00;
strcat(result,work);
strcat(result,".");
/*3165*/ pdigits=nprecision;
/*3167*/ while(pdigits-- >0)
{
b=b-i;
b=b*10.0;
i=b;
work[0]=(char)('0'+i%10);
work[1]=0x00;
strcat(result,work);
}
}
/*3178*/ if(format==0)
{
work[0]='E';
if(exp<0)
{
exp= -exp;
work[1]='-';
}
else
{
work[1]='+';
}
work[2]=(char)('0'+(exp/10)%10);
work[3]=(char)('0'+exp%10);
work[4]=0x00;
strcat(result,work);
}
else
{
/*3198*/ if(cnvtype=='G'||cnvtype=='g')
{
char*p;
/*3202*/ p=strchr(result,'.');
if(p!=((void*)0))
{
p++;
p=p+strlen(p)-1;
while(*p!='.'&& *p=='0')
{
*p='\x00';
p--;
}
if(*p=='.')
{
*p='\x00';
}
}
}
}
/*3224*/ if(result[0]==' ')strcpy(work,result+1);else strcpy(work,result);
pdigits=nwidth-strlen(work);
result[0]=0x00;
while(pdigits>0)
{
strcat(result," ");
pdigits--;
}
strcat(result,work);
return;
}
/*"pdpc201/string.c"21*/ void*memmove(void*s1,const void*s2,size_t n)
{
char*p=s1;
const char*cs2=s2;
size_t x;
/*27*/ if(p<=cs2)
{
for(x=0;x<n;x++)
{
*p= *cs2;
p++;
cs2++;
}
}
else
{
if(n!=0)
{
for(x=n-1;x>0;x--)
{
*(p+x)= *(cs2+x);
}
*(p+x)= *(cs2+x);
}
}
return(s1);
}
/*53*/ char*strcpy(char*s1,const char*s2)
{
char*p=s1;
/*57*/ while((*p++ = *s2++)!='\x00');
return(s1);
}
/*64*/ char*strncpy(char*s1,const char*s2,size_t n)
{
char*p=s1;
size_t x;
/*69*/ for(x=0;x<n;x++)
{
*p= *s2;
if(*s2=='\x00')break;
p++;
s2++;
}
for(;x<n;x++)
{
*p++ ='\x00';
}
return(s1);
}
/*86*/ char*strcat(char*s1,const char*s2)
{
char*p=s1;
/*90*/ while(*p!='\x00')p++;
while((*p= *s2)!='\x00')
{
p++;
s2++;
}
return(s1);
}
/*102*/ char*strncat(char*s1,const char*s2,size_t n)
{
char*p=s1;
size_t x=0;
/*107*/ while(*p!='\x00')p++;
while((*s2!='\x00')&&(x<n))
{
*p= *s2;
p++;
s2++;
x++;
}
*p='\x00';
return(s1);
}
/*122*/ int memcmp(const void*s1,const void*s2,size_t n)
{
const unsigned char*p1;
const unsigned char*p2;
size_t x=0;
/*128*/ p1=(const unsigned char*)s1;
p2=(const unsigned char*)s2;
while(x<n)
{
if(p1[x]<p2[x])return(-1);
else if(p1[x]>p2[x])return(1);
x++;
}
return(0);
}
/*142*/ int strcmp(const char*s1,const char*s2)
{
const unsigned char*p1;
const unsigned char*p2;
/*147*/ p1=(const unsigned char*)s1;
p2=(const unsigned char*)s2;
while(*p1!='\x00')
{
if(*p1< *p2)return(-1);
else if(*p1> *p2)return(1);
p1++;
p2++;
}
if(*p2=='\x00')return(0);
else return(-1);
}
/*163*/ int strcoll(const char*s1,const char*s2)
{
return(strcmp(s1,s2));
}
/*171*/ int strncmp(const char*s1,const char*s2,size_t n)
{
const unsigned char*p1;
const unsigned char*p2;
size_t x=0;
/*177*/ p1=(const unsigned char*)s1;
p2=(const unsigned char*)s2;
while(x<n)
{
if(p1[x]<p2[x])return(-1);
else if(p1[x]>p2[x])return(1);
else if(p1[x]=='\x00')return(0);
x++;
}
return(0);
}
/*192*/ size_t strxfrm(char*s1,const char*s2,size_t n)
{
size_t oldlen;
/*196*/ oldlen=strlen(s2);
if(oldlen<n)
{
memcpy(s1,s2,oldlen);
s1[oldlen]='\x00';
}
return(oldlen);
}
/*208*/ void*memchr(const void*s,int c,size_t n)
{
const unsigned char*p;
size_t x=0;
/*213*/ p=(const unsigned char*)s;
while(x<n)
{
if(*p==(unsigned char)c)return((void*)p);
p++;
x++;
}
return(((void*)0));
}
/*226*/ char*strchr(const char*s,int c)
{
while(*s!='\x00')
{
if(*s==(char)c)return((char*)s);
s++;
}
if(c=='\x00')return((char*)s);
return(((void*)0));
}
/*240*/ size_t strcspn(const char*s1,const char*s2)
{
const char*p1;
const char*p2;
/*245*/ p1=s1;
while(*p1!='\x00')
{
p2=s2;
while(*p2!='\x00')
{
if(*p1== *p2)return((size_t)(p1-s1));
p2++;
}
p1++;
}
return((size_t)(p1-s1));
}
/*262*/ char*strpbrk(const char*s1,const char*s2)
{
const char*p1;
const char*p2;
/*267*/ p1=s1;
while(*p1!='\x00')
{
p2=s2;
while(*p2!='\x00')
{
if(*p1== *p2)return((char*)p1);
p2++;
}
p1++;
}
return(((void*)0));
}
/*284*/ char*strrchr(const char*s,int c)
{
const char*p;
/*288*/ p=s+strlen(s);
while(p>=s)
{
if(*p==(char)c)return((char*)p);
p--;
}
return(((void*)0));
}
/*300*/ size_t strspn(const char*s1,const char*s2)
{
const char*p1;
const char*p2;
/*305*/ p1=s1;
while(*p1!='\x00')
{
p2=s2;
while(*p2!='\x00')
{
if(*p1== *p2)break;
p2++;
}
if(*p2=='\x00')return((size_t)(p1-s1));
p1++;
}
return((size_t)(p1-s1));
}
/*327*/ char*strstr(const char*s1,const char*s2)
{
const char*p=s1,*p1,*p2=s2;
/*331*/ while(*p)
{
if(*p== *s2)
{
p1=p;
p2=s2;
while((*p2!='\x00')&&(*p1== *p2))
{
p1++;
p2++;
}
if(*p2=='\x00')
{
return(char*)p;
}
}
p++;
}
return((void*)0);
}
/*355*/ char*strtok(char*s1,const char*s2)
{
static char*old=((void*)0);
char*p;
size_t len;
size_t remain;
/*362*/ if(s1!=((void*)0))old=s1;
if(old==((void*)0))return(((void*)0));
p=old;
len=strspn(p,s2);
remain=strlen(p);
if(remain<=len){old=((void*)0);return(((void*)0));}
p+=len;
len=strcspn(p,s2);
remain=strlen(p);
if(remain<=len){old=((void*)0);return(p);}
*(p+len)='\x00';
old=p+len+1;
return(p);
}
/*380*/ void*memset(void*s,int c,size_t n)
{
size_t x=0;
/*384*/ for(x=0;x<n;x++)
{
*((char*)s+x)=(unsigned char)c;
}
return(s);
}
/*394*/ char*strerror(int errnum)
{
/*398*/ if(errnum==0)return("No error has occurred\n");
else return("An error has occurred\n");
/*450*/ }
/*455*/ size_t strlen(const char*s)
{
const char*p;
/*459*/ int n;
/*461*/ p=s;
n=0;
/*465*/ while(*p){p++;n++;}
/*467*/ return(n);
/*469*/ }
/*478*/ void*memcpy(void*s1,const void*s2,size_t n)
{
/*483*/ const char*f,*fe;
char*t;
/*486*/ f=s2;t=s1;
fe=f+n;
/*489*/ while(f<fe)
{*t++ = *f++;}
return(s1);
}
/*"signal.h"16*/ typedef int sig_atomic_t;
/*18*/ void __sigdfl(int sig);
void __sigerr(int sig);
void __sigign(int sig);
/*33*/ typedef void(*signal_t)(int);
/*36*/ signal_t signal(int sig,signal_t func);
/*39*/ int raise(int sig);
/*"pdpc201/stdlib.c"55*/ void __allocmem(size_t size,void* *ptr);
void __freemem(void*ptr);
unsigned char*__envptr;
void __exec(char*cmd,void*env);
/*62*/ void(*__userExit[32])(void);
/*64*/ void*malloc(size_t size)
{
void*ptr;
__allocmem(size,&ptr);
return(ptr);
}
/*71*/ void*calloc(size_t nmemb,size_t size)
{
void*ptr;
size_t total;
/*76*/ if(nmemb==1)
{
total=size;
}
else if(size==1)
{
total=nmemb;
}
else
{
total=nmemb*size;
}
ptr=malloc(total);
if(ptr!=((void*)0))
{
memset(ptr,'\x00',total);
}
return(ptr);
}
/*96*/ void*realloc(void*ptr,size_t size)
{
char*newptr;
size_t oldsize;
/*101*/ if(size==0)
{
free(ptr);
return(((void*)0));
}
/*107*/ newptr=malloc(size);
if(newptr==((void*)0))
{
return(((void*)0));
}
if(ptr!=((void*)0))
{
oldsize= *((size_t*)ptr-1);
if(oldsize<size)
{
size=oldsize;
}
memcpy(newptr,ptr,size);
free(ptr);
}
return(newptr);
}
/*125*/ void free(void*ptr)
{
if(ptr!=((void*)0))
{
__freemem(ptr);
}
return;
}
/*134*/ void abort(void)
{
raise(1);
exit(1);
}
/*142*/ void __exit(int status);
/*147*/ void exit(int status)
{
__exit(status);
/*152*/ return;
/*154*/ }
/*169*/ void qsort(void*base,size_t nmemb,size_t size,int(*compar)(const void*,const void*))
/*173*/ {
char*base2=(char*)base;
size_t i,a,b,c;
/*177*/ while(nmemb>1)
{
a=0;
b=nmemb-1;
c=(a+b)/2;
for(;;)
{
while((*compar)(&base2[size*c],&base2[size*a])>0)
{
a++;
}
while((*compar)(&base2[size*c],&base2[size*b])<0)
{
b--;
}
if(a>=b)
{
break;
}
for(i=0;i<size;i++)
{
char tmp=base2[size*a+i];
/*200*/ base2[size*a+i]=base2[size*b+i];
base2[size*b+i]=tmp;
}
if(c==a)
{
c=b;
}
else if(c==b)
{
c=a;
}
a++;
b--;
}
/*215*/ b++;
if(b<nmemb-b)
/*218*/ {
qsort(base2,b,size,compar);
base2= &base2[size*b];
nmemb=nmemb-b;
}
else
{
qsort(&base2[size*b],nmemb-b,size,compar);
nmemb=b;
}
}
return;
}
/*233*/ static unsigned long myseed=1;
/*235*/ void srand(unsigned int seed)
{
myseed=seed;
return;
}
/*241*/ int rand(void)
{
int ret;
/*246*/ myseed=myseed*65521 UL+1;
/*248*/ ret=(int)((myseed>>16)&0x7fff);
return(ret);
}
/*252*/ double atof(const char*nptr)
{
return(strtod(nptr,(char* *)((void*)0)));
}
/*257*/ double strtod(const char*nptr,char* *endptr)
{
double x=0.0;
double xs=1.0;
double es=1.0;
double xf=0.0;
double xd=1.0;
/*265*/ while(isspace((unsigned char)*nptr))++nptr;
if(*nptr=='-')
{
xs= -1;
nptr++;
}
else if(*nptr=='+')
{
nptr++;
}
/*277*/ while(1)
{
if(isdigit((unsigned char)*nptr))
{
x=x*10+(*nptr-'0');
nptr++;
}
else
{
x=x*xs;
break;
}
}
if(*nptr=='.')
{
nptr++;
while(1)
{
if(isdigit((unsigned char)*nptr))
{
xf=xf*10+(*nptr-'0');
xd=xd*10;
}
else
{
x=x+xs*(xf/xd);
break;
}
nptr++;
}
}
if((*nptr=='e')||(*nptr=='E'))
{
nptr++;
if(*nptr=='-')
{
es= -1;
nptr++;
}
xd=1;
xf=0;
while(1)
{
if(isdigit((unsigned char)*nptr))
{
xf=xf*10+(*nptr-'0');
nptr++;
}
else
{
while(xf>0)
{
xd*=10;
xf--;
}
if(es<0.0)
{
x=x/xd;
}
else
{
x=x*xd;
}
break;
}
}
}
if(endptr!=((void*)0))
{
*endptr=(char*)nptr;
}
return(x);
}
/*351*/ int atoi(const char*nptr)
{
return((int)strtol(nptr,(char* *)((void*)0),10));
}
/*356*/ long int atol(const char*nptr)
{
return(strtol(nptr,(char* *)((void*)0),10));
}
/*364*/ unsigned long int strtoul(const char*nptr,char* *endptr,int base)
/*366*/ {
unsigned long x=0;
int undecided=0;
/*370*/ if(base==0)
{
undecided=1;
}
while(isspace((unsigned char)*nptr))
{
nptr++;
}
while(1)
{
if(isdigit((unsigned char)*nptr))
{
if(base==0)
{
if(*nptr=='0')
{
base=8;
}
else
{
base=10;
undecided=0;
}
}
x=x*base+(*nptr-'0');
nptr++;
}
else if(isalpha((unsigned char)*nptr))
{
if((*nptr=='X')||(*nptr=='x'))
{
if((base==0)||((base==8)&&undecided))
{
base=16;
undecided=0;
nptr++;
}
else if(base==16)
{
/*410*/ nptr++;
}
else
{
break;
}
}
else if(base<=10)
{
break;
}
else
{
x=x*base+(toupper((unsigned char)*nptr)-'A')+10;
nptr++;
}
}
else
{
break;
}
}
if(endptr!=((void*)0))
{
*endptr=(char*)nptr;
}
return(x);
}
/*439*/ long int strtol(const char*nptr,char* *endptr,int base)
{
unsigned long y;
long x;
int neg=0;
/*445*/ while(isspace((unsigned char)*nptr))
{
nptr++;
}
if(*nptr=='-')
{
neg=1;
nptr++;
}
else if(*nptr=='+')
{
nptr++;
}
y=strtoul(nptr,endptr,base);
if(neg)
{
x=(long)-y;
}
else
{
x=(long)y;
}
return(x);
}
/*470*/ int mblen(const char*s,size_t n)
{
if(s==((void*)0))
{
return(0);
}
if(n==1)
{
return(1);
}
else
{
return(-1);
}
}
/*486*/ int mbtowc(wchar_t*pwc,const char*s,size_t n)
{
if(s==((void*)0))
{
return(0);
}
if(n==1)
{
if(pwc!=((void*)0))
{
*pwc= *s;
}
return(1);
}
else
{
return(-1);
}
}
/*506*/ int wctomb(char*s,wchar_t wchar)
{
if(s!=((void*)0))
{
*s=wchar;
return(1);
}
else
{
return(0);
}
}
/*519*/ size_t mbstowcs(wchar_t*pwcs,const char*s,size_t n)
{
strncpy((char*)pwcs,s,n);
if(strlen(s)>=n)
{
return(n);
}
return(strlen((char*)pwcs));
}
/*529*/ size_t wcstombs(char*s,const wchar_t*pwcs,size_t n)
{
strncpy(s,(const char*)pwcs,n);
if(strlen((const char*)pwcs)>=n)
{
return(n);
}
return(strlen(s));
}
/*542*/ int abs(int j)
{
if(j<0)
{
j= -j;
}
return(j);
}
/*551*/ div_t div(int numer,int denom)
{
div_t x;
/*555*/ x.quot=numer/denom;
x.rem=numer%denom;
return(x);
}
/*563*/ long int labs(long int j)
{
if(j<0)
{
j= -j;
}
return(j);
}
/*572*/ ldiv_t ldiv(long int numer,long int denom)
{
ldiv_t x;
/*576*/ x.quot=numer/denom;
x.rem=numer%denom;
return(x);
}
/*581*/ int atexit(void(*func)(void))
{
int x;
/*585*/ for(x=0;x<32;x++)
{
if(__userExit[x]==0)
{
__userExit[x]=func;
return(0);
}
}
return(-1);
}
/*596*/ char*getenv(const char*name)
{
/*628*/ return(((void*)0));
}
/*635*/ int system(const char*string)
{
/*757*/ }
/*759*/ void*bsearch(const void*key,const void*base,size_t nmemb,size_t size,int(*compar)(const void*,const void*))
/*762*/ {
size_t try;
int res;
const void*ptr;
/*767*/ while(nmemb>0)
{
try=nmemb/2;
ptr=(void*)((char*)base+try*size);
res=compar(ptr,key);
if(res==0)
{
return((void*)ptr);
}
else if(res<0)
{
nmemb=nmemb-try-1;
base=(const void*)((const char*)ptr+size);
}
else
{
nmemb=try;
}
}
return(((void*)0));
}
/*"pdpc201/start.c"22*/ extern FILE*__userFiles[(256-3)];
/*66*/ int main(int argc,char* *argv);
/*69*/ void __exit(int status);
void __exita(int status);
/*72*/ char*__get_cmdline();
char* *__get_cmdenv();
/*76*/ static char buffer1[6144+8];
static char buffer2[6144+8];
static char buffer3[6144+8];
/*85*/ char* *__eplist;
char*__plist;
/*88*/ int __start()
{
int x;
int argc;
static char*argv[50+1];
int rc;
char*p;
char* *penv;
/*97*/ tk_puts("TK: Start A0\n");
__start_early();
/*100*/ p=__get_cmdline();
penv=__get_cmdenv();
/*103*/ tk_puts("A1\n");
/*105*/ __init_stdin();
/*107*/ (*(__get_stdin()))->hfile=0;
(*(__get_stdout()))->hfile=1;
(*(__get_stderr()))->hfile=2;
/*111*/ (*(__get_stdin()))->quickBin=0;
(*(__get_stdin()))->quickText=0;
(*(__get_stdin()))->textMode=1;
(*(__get_stdin()))->intFno=0;
(*(__get_stdin()))->bufStartR=0;
(*(__get_stdin()))->bufTech=2;
(*(__get_stdin()))->intBuffer=buffer1;
(*(__get_stdin()))->fbuf=(*(__get_stdin()))->intBuffer+2;
*(*(__get_stdin()))->fbuf++ ='\x00';
*(*(__get_stdin()))->fbuf++ ='\x00';
(*(__get_stdin()))->szfbuf=6144;
(*(__get_stdin()))->endbuf=(*(__get_stdin()))->fbuf+(*(__get_stdin()))->szfbuf;
*(*(__get_stdin()))->endbuf='\n';
(*(__get_stdin()))->noNl=0;
(*(__get_stdin()))->upto=(*(__get_stdin()))->endbuf;
(*(__get_stdin()))->bufStartR= -(*(__get_stdin()))->szfbuf;
(*(__get_stdin()))->mode=2;
(*(__get_stdin()))->ungetCh= -1;
(*(__get_stdin()))->update=0;
(*(__get_stdin()))->theirBuffer=0;
(*(__get_stdin()))->permfile=1;
(*(__get_stdin()))->isopen=1;
/*134*/ (*(__get_stdout()))->quickBin=0;
(*(__get_stdout()))->quickText=0;
(*(__get_stdout()))->textMode=1;
(*(__get_stdout()))->bufTech=2;
(*(__get_stdout()))->intBuffer=buffer2;
(*(__get_stdout()))->fbuf=(*(__get_stdout()))->intBuffer;
*(*(__get_stdout()))->fbuf++ ='\x00';
*(*(__get_stdout()))->fbuf++ ='\x00';
(*(__get_stdout()))->szfbuf=6144;
(*(__get_stdout()))->endbuf=(*(__get_stdout()))->fbuf+(*(__get_stdout()))->szfbuf;
*(*(__get_stdout()))->endbuf='\n';
(*(__get_stdout()))->noNl=0;
(*(__get_stdout()))->upto=(*(__get_stdout()))->fbuf;
(*(__get_stdout()))->bufStartR=0;
(*(__get_stdout()))->mode=1;
(*(__get_stdout()))->update=0;
(*(__get_stdout()))->theirBuffer=0;
(*(__get_stdout()))->permfile=1;
(*(__get_stdout()))->isopen=1;
/*154*/ (*(__get_stderr()))->quickBin=0;
(*(__get_stderr()))->quickText=0;
(*(__get_stderr()))->textMode=1;
(*(__get_stderr()))->bufTech=2;
(*(__get_stderr()))->intBuffer=buffer3;
(*(__get_stderr()))->fbuf=(*(__get_stderr()))->intBuffer;
*(*(__get_stderr()))->fbuf++ ='\x00';
*(*(__get_stderr()))->fbuf++ ='\x00';
(*(__get_stderr()))->szfbuf=6144;
(*(__get_stderr()))->endbuf=(*(__get_stderr()))->fbuf+(*(__get_stderr()))->szfbuf;
*(*(__get_stderr()))->endbuf='\n';
(*(__get_stderr()))->noNl=0;
(*(__get_stderr()))->upto=(*(__get_stderr()))->fbuf;
(*(__get_stderr()))->bufStartR=0;
(*(__get_stderr()))->mode=1;
(*(__get_stderr()))->update=0;
(*(__get_stderr()))->theirBuffer=0;
(*(__get_stderr()))->permfile=1;
(*(__get_stderr()))->isopen=1;
/*174*/ for(x=0;x<(256-3);x++)
{
__userFiles[x]=((void*)0);
}
/*179*/ tk_puts("A2\n");
/*181*/ if(*p=='\"')
{
p++;
argv[0]=p;
while(p&&((*p)!='\"'))p++;
*p++ ='\x00';
}else
{
argv[0]=p;
p=strchr(p,' ');
if(p==((void*)0))
{
p="";
}
else
{
*p='\x00';
p++;
}
}
/*202*/ tk_puts("A3\n");
/*204*/ while(*p==' ')
{
p++;
}
if(*p=='\x00')
{
argv[1]=((void*)0);
argc=1;
}
else
{
for(x=1;x<50;)
{
char srch=' ';
/*219*/ if(*p=='\"')
{
p++;
srch='\"';
}
argv[x]=p;
x++;
/*227*/ if(x>=50)
break;
/*230*/ p=strchr(p,srch);
if(p==((void*)0))
{
break;
}
else
{
*p='\x00';
p++;
while(*p==' ')p++;
if(*p=='\x00')break;
}
}
argv[x]=((void*)0);
argc=x;
}
/*247*/ tk_puts("A4\n");
/*249*/ __start_late();
/*251*/ tk_puts("TK: Start Main\n");
/*253*/ rc=main(argc,argv);
__exit(rc);
return(rc);
}
/*258*/ void __exit(int status)
{
int x;
/*262*/ for(x=0;x<(256-3);x++)
{
if(__userFiles[x]!=((void*)0))
{
fclose(__userFiles[x]);
}
}
if((*(__get_stdout()))!=((void*)0))fflush((*(__get_stdout())));
if((*(__get_stderr()))!=((void*)0))fflush((*(__get_stderr())));
/*277*/ __exita(status);
while(1);
}
/*"time.h"19*/ typedef unsigned int clock_t;
/*33*/ typedef unsigned long time_t;
/*38*/ struct tm
{
int tm_sec;
int tm_min;
int tm_hour;
int tm_mday;
int tm_mon;
int tm_year;
int tm_wday;
int tm_yday;
int tm_isdst;
};
/*53*/ time_t time(time_t*timer);
clock_t clock(void);
double difftime(time_t time1,time_t time0);
time_t mktime(struct tm*timeptr);
char*asctime(const struct tm*timeptr);
char*ctime(const time_t*timer);
struct tm*gmtime(const time_t*timer);
struct tm*localtime(const time_t*timer);
size_t strftime(char*s,size_t maxsize,const char*format,const struct tm*timeptr);
/*"pdpc201/time.c"18*/ void __datetime(void*ptr);
/*27*/ static int isleap(unsigned yr)
{
return yr%400==0||(yr%4==0&&yr%100!=0);
}
/*32*/ static unsigned months_to_days(unsigned month)
{
return(month*3057-3007)/100;
}
/*37*/ static long years_to_days(unsigned yr)
{
return yr*365 L+yr/4-yr/100+yr/400;
}
/*42*/ static long ymd_to_scalar(unsigned yr,unsigned mo,unsigned day)
{
long scalar;
/*46*/ scalar=day+months_to_days(mo);
if(mo>2)
scalar-=isleap(yr)?1:2;
yr--;
scalar+=years_to_days(yr);
return(scalar);
}
/*54*/ static void scalar_to_ymd(long scalar,unsigned*pyr,unsigned*pmo,unsigned*pday)
/*58*/ {
unsigned n;
/*61*/ n=(unsigned)((scalar*400 L)/146097 L);
while(years_to_days(n)<scalar)
{
n++;
}
for(n=(unsigned)((scalar*400 L)/146097 L);years_to_days(n)<scalar;)
n++;
*pyr=n;
n=(unsigned)(scalar-years_to_days(n-1));
if(n>59){
n+=2;
if(isleap(*pyr))
n-=n>62?1:2;
}
*pmo=(n*100+3007)/3057;
*pday=n-months_to_days(*pmo);
return;
}
/*80*/ unsigned int TK_GetTimeMs(void);
/*82*/ time_t time(time_t*timer)
{
time_t tt;
struct{
int year;
int month;
int day;
int hours;
int minutes;
int seconds;
int hundredths;
}dt;
/*97*/ tt=TK_GetTimeMs()>>10;
/*99*/ if(timer!=((void*)0))
{
*timer=tt;
}
return(tt);
}
/*106*/ clock_t clock(void)
{
return((clock_t)-1);
}
/*111*/ double difftime(time_t time1,time_t time0)
{
return((double)(time1-time0));
}
/*116*/ time_t mktime(struct tm*timeptr)
{
time_t tt;
/*120*/ if((timeptr->tm_year<70)||(timeptr->tm_year>120))
{
tt=(time_t)-1;
}
else
{
tt=ymd_to_scalar(timeptr->tm_year+1900,timeptr->tm_mon+1,timeptr->tm_mday)
/*129*/ -ymd_to_scalar(1970,1,1);
tt=tt*24+timeptr->tm_hour;
tt=tt*60+timeptr->tm_min;
tt=tt*60+timeptr->tm_sec;
}
return(tt);
}
/*137*/ char*asctime(const struct tm*timeptr)
{
static const char wday_name[7][3]={
"Sun","Mon","Tue","Wed","Thu","Fri","Sat"
};
static const char mon_name[12][3]={
"Jan","Feb","Mar","Apr","May","Jun",
"Jul","Aug","Sep","Oct","Nov","Dec"
};
static char result[26];
/*148*/ sprintf(result,"%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",wday_name[timeptr->tm_wday],mon_name[timeptr->tm_mon],timeptr->tm_mday,timeptr->tm_hour,timeptr->tm_min,timeptr->tm_sec,1900+timeptr->tm_year);
/*154*/ return result;
}
/*157*/ char*ctime(const time_t*timer)
{
return(asctime(localtime(timer)));
}
/*162*/ struct tm*gmtime(const time_t*timer)
{
return(localtime(timer));
}
/*187*/ static struct tm tms;
/*189*/ struct tm*localtime(const time_t*timer)
{
unsigned yr,mo,da;
unsigned long secs;
unsigned long days;
/*195*/ days= *timer/(60 L*60*24);
secs= *timer%(60 L*60*24);
scalar_to_ymd(days+ymd_to_scalar(1970,1,1),&yr,&mo,&da);
tms.tm_year=yr-1900;
tms.tm_mon=mo-1;
tms.tm_mday=da;
tms.tm_yday=(int)(ymd_to_scalar(tms.tm_year+1900,mo,da)-ymd_to_scalar(tms.tm_year+1900,1,1));
/*203*/ tms.tm_wday=((((((mo)+9)%12+1)<<4)%27+(da)+1+((tms.tm_year+1900)%400+400)+((tms.tm_year+1900)%400+400)/4-((tms.tm_year+1900)%400+400)/100+(((mo)<=2)?((((((tms.tm_year+1900)%4)==0)&&(((tms.tm_year+1900)%100)!=0))||(((tms.tm_year+1900)%400)==0))?5:6):0))%7);
tms.tm_isdst= -1;
tms.tm_sec=(int)(secs%60);
secs/=60;
tms.tm_min=(int)(secs%60);
secs/=60;
tms.tm_hour=(int)secs;
return(&tms);
}
/*226*/ static char*aday[]={
"Sun","Mon","Tue","Wed","Thu","Fri","Sat"
};
/*230*/ static char*day[]={
"Sunday","Monday","Tuesday","Wednesday",
"Thursday","Friday","Saturday"
};
/*235*/ static char*amonth[]={
"Jan","Feb","Mar","Apr","May","Jun",
"Jul","Aug","Sep","Oct","Nov","Dec"
};
/*240*/ static char*month[]={
"January","February","March","April","May","June",
"July","August","September","October","November","December"
};
/*245*/ static char*__tzname[2]={"" ""};
static char buf[26];
/*248*/ static void strfmt(char*str,const char*fmt,...);
/*316*/ size_t strftime(char*s,size_t maxs,const char*f,const struct tm*t)
{
char buf[32];
int w;
char*p,*q,*r;
/*322*/ p=s;
q=s+maxs-1;
while((*f!='\x00'))
{
if(*f++ =='%')
{
r=buf;
switch(*f++)
{
case'%':
r="%";
break;
/*335*/ case'a':
r=aday[t->tm_wday];
break;
/*339*/ case'A':
r=day[t->tm_wday];
break;
/*343*/ case'b':
r=amonth[t->tm_mon];
break;
/*347*/ case'B':
r=month[t->tm_mon];
break;
/*351*/ case'c':
strfmt(r,"%0 %0 %2 %2:%2:%2 %4",aday[t->tm_wday],amonth[t->tm_mon],t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec,t->tm_year+1900);
/*356*/ break;
/*358*/ case'd':
strfmt(r,"%2",t->tm_mday);
break;
/*362*/ case'H':
strfmt(r,"%2",t->tm_hour);
break;
/*366*/ case'I':
strfmt(r,"%2",(t->tm_hour%12)?t->tm_hour%12:12);
break;
/*370*/ case'j':
strfmt(r,"%3",t->tm_yday+1);
break;
/*374*/ case'm':
strfmt(r,"%2",t->tm_mon+1);
break;
/*378*/ case'M':
strfmt(r,"%2",t->tm_min);
break;
/*382*/ case'p':
r=(t->tm_hour>11)?"PM":"AM";
break;
/*386*/ case'S':
strfmt(r,"%2",t->tm_sec);
break;
/*390*/ case'U':
w=t->tm_yday/7;
if(t->tm_yday%7>t->tm_wday)
w++;
strfmt(r,"%2",w);
break;
/*397*/ case'W':
w=t->tm_yday/7;
if(t->tm_yday%7>(t->tm_wday+6)%7)
w++;
strfmt(r,"%2",w);
break;
/*404*/ case'w':
strfmt(r,"%1",t->tm_wday);
break;
/*408*/ case'x':
strfmt(r,"%3s %3s %2 %4",aday[t->tm_wday],amonth[t->tm_mon],t->tm_mday,t->tm_year+1900);
/*411*/ break;
/*413*/ case'X':
strfmt(r,"%2:%2:%2",t->tm_hour,t->tm_min,t->tm_sec);
/*416*/ break;
/*418*/ case'y':
strfmt(r,"%2",t->tm_year%100);
break;
/*422*/ case'Y':
strfmt(r,"%4",t->tm_year+1900);
break;
/*426*/ case'Z':
r=(t->tm_isdst)?__tzname[1]:__tzname[0];
break;
/*430*/ default:
buf[0]='%';
buf[1]=f[-1];
buf[2]='\x00';
if(buf[1]==0)
f--;
}
while(*r)
{
if(p==q)
{
*q='\x00';
return 0;
}
*p++ = *r++;
}
}
else
{
if(p==q)
{
*q='\x00';
return 0;
}
*p++ =f[-1];
}
}
*p='\x00';
return(size_t)(p-s);
}
/*461*/ static int pow10z[5]={1,10,100,1000,10000};
/*476*/ static void strfmt(char*str,const char*fmt,...)
{
int ival,ilen;
char*sval;
va_list vp;
/*482*/ __builtin_va_start(vp,fmt);
while(*fmt)
{
if(*fmt++ =='%')
{
ilen= *fmt++ -'0';
if(ilen==0)
{
sval=__builtin_va_arg(vp,char*);
while(*sval)
*str++ = *sval++;
}
else
{
ival=__builtin_va_arg(vp,int);
while(ilen)
{
ival%=pow10z[ilen--];
*str++ =(char)('0'+ival/pow10z[ilen]);
}
}
}
else*str++ =fmt[-1];
}
*str='\x00';
__builtin_va_end(vp);
}
/*"pdpc201/errno.c"15*/ int __errno=0;
/*17*/ int*__get_errno()
{return(&__errno);}
/*"assert.h"16*/ int __assert(char*x,char*y,int z);
/*"pdpc201/assert.c"18*/ int __assert(char*x,char*y,int z)
{
fprintf((*(__get_stderr())),"assertion failed for statement %s in " "file %s on line %d\n",x,y,z);
/*22*/ abort();
return(0);
}
/*"pdpc201/signal.c"17*/ static void(*handlers[])(int)={
__sigdfl,
__sigdfl,
__sigdfl,
__sigdfl,
__sigdfl,
__sigdfl,
__sigdfl};
/*26*/ void __sigdfl(int sig);
void __sigerr(int sig);
void __sigign(int sig);
/*35*/ signal_t signal(int sig,signal_t func)
{
handlers[sig]=func;
return(func);
}
/*42*/ int raise(int sig)
{
(handlers[sig])(sig);
return(0);
}
/*48*/ void __sigdfl(int sig)
{
handlers[sig]=__sigdfl;
if(sig==1)
{
exit(1);
}
return;
}
/*58*/ void __sigerr(int sig)
{
(void)sig;
return;
}
/*64*/ void __sigign(int sig)
{
(void)sig;
return;
}
/*"locale.h"16*/ struct lconv{
char*decimal_point;
char*thousands_sep;
char*grouping;
char*int_curr_symbol;
char*currency_symbol;
char*mon_decimal_point;
char*mon_thousands_sep;
char*mon_grouping;
char*positive_sign;
char*negative_sign;
char int_frac_digits;
char frac_digits;
char p_cs_precedes;
char p_sep_by_space;
char n_cs_precedes;
char n_sep_by_space;
char p_sign_posn;
char n_sign_posn;
};
/*45*/ char*setlocale(int category,const char*locale);
struct lconv*localeconv(void);
/*"pdpc201/locale.c"18*/ static struct lconv thislocale={
".",
"",
"",
"",
"",
"",
"",
"",
"",
"",
255,
255,
255,
255,
255,
255,
255,
255
};
/*39*/ char*setlocale(int category,const char*locale)
{
(void)category;
if(locale==((void*)0))
{
return("C");
}
else if((strcmp(locale,"C")==0)||(strcmp(locale,"")==0))
/*48*/ {
return("C");
}
else
{
return(((void*)0));
}
}
/*57*/ struct lconv*localeconv(void)
{
return(&thislocale);
}
/*62*/ int isalnum2(int c)
{
/*65*/ }
/*"pdpc201/ctype.c"21*/ static unsigned short __isbufR[257]={
0x0000 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0104 U,
0x0104 U,
0x0104 U,
0x0104 U,
0x0104 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0004 U,
0x0140 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x0459 U,
0x0459 U,
0x0459 U,
0x0459 U,
0x0459 U,
0x0459 U,
0x0459 U,
0x0459 U,
0x0459 U,
0x0459 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x0653 U,
0x0653 U,
0x0653 U,
0x0653 U,
0x0653 U,
0x0653 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x0253 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x0473 U,
0x0473 U,
0x0473 U,
0x0473 U,
0x0473 U,
0x0473 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x0073 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x00D0 U,
0x0004 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U,
0x0000 U};
/*280*/ static short __tolowR[257]={
-1,
0x00,
0x01,
0x02,
0x03,
0x04,
0x05,
0x06,
0x07,
0x08,
0x09,
0x0A,
0x0B,
0x0C,
0x0D,
0x0E,
0x0F,
0x10,
0x11,
0x12,
0x13,
0x14,
0x15,
0x16,
0x17,
0x18,
0x19,
0x1A,
0x1B,
0x1C,
0x1D,
0x1E,
0x1F,
0x20,
0x21,
0x22,
0x23,
0x24,
0x25,
0x26,
0x27,
0x28,
0x29,
0x2A,
0x2B,
0x2C,
0x2D,
0x2E,
0x2F,
0x30,
0x31,
0x32,
0x33,
0x34,
0x35,
0x36,
0x37,
0x38,
0x39,
0x3A,
0x3B,
0x3C,
0x3D,
0x3E,
0x3F,
0x40,
0x61,
0x62,
0x63,
0x64,
0x65,
0x66,
0x67,
0x68,
0x69,
0x6A,
0x6B,
0x6C,
0x6D,
0x6E,
0x6F,
0x70,
0x71,
0x72,
0x73,
0x74,
0x75,
0x76,
0x77,
0x78,
0x79,
0x7A,
0x5B,
0x5C,
0x5D,
0x5E,
0x5F,
0x60,
0x61,
0x62,
0x63,
0x64,
0x65,
0x66,
0x67,
0x68,
0x69,
0x6A,
0x6B,
0x6C,
0x6D,
0x6E,
0x6F,
0x70,
0x71,
0x72,
0x73,
0x74,
0x75,
0x76,
0x77,
0x78,
0x79,
0x7A,
0x7B,
0x7C,
0x7D,
0x7E,
0x7F,
0x80,
0x81,
0x82,
0x83,
0x84,
0x85,
0x86,
0x87,
0x88,
0x89,
0x8A,
0x8B,
0x8C,
0x8D,
0x8E,
0x8F,
0x90,
0x91,
0x92,
0x93,
0x94,
0x95,
0x96,
0x97,
0x98,
0x99,
0x9A,
0x9B,
0x9C,
0x9D,
0x9E,
0x9F,
0xA0,
0xA1,
0xA2,
0xA3,
0xA4,
0xA5,
0xA6,
0xA7,
0xA8,
0xA9,
0xAA,
0xAB,
0xAC,
0xAD,
0xAE,
0xAF,
0xB0,
0xB1,
0xB2,
0xB3,
0xB4,
0xB5,
0xB6,
0xB7,
0xB8,
0xB9,
0xBA,
0xBB,
0xBC,
0xBD,
0xBE,
0xBF,
0xC0,
0xC1,
0xC2,
0xC3,
0xC4,
0xC5,
0xC6,
0xC7,
0xC8,
0xC9,
0xCA,
0xCB,
0xCC,
0xCD,
0xCE,
0xCF,
0xD0,
0xD1,
0xD2,
0xD3,
0xD4,
0xD5,
0xD6,
0xD7,
0xD8,
0xD9,
0xDA,
0xDB,
0xDC,
0xDD,
0xDE,
0xDF,
0xE0,
0xE1,
0xE2,
0xE3,
0xE4,
0xE5,
0xE6,
0xE7,
0xE8,
0xE9,
0xEA,
0xEB,
0xEC,
0xED,
0xEE,
0xEF,
0xF0,
0xF1,
0xF2,
0xF3,
0xF4,
0xF5,
0xF6,
0xF7,
0xF8,
0xF9,
0xFA,
0xFB,
0xFC,
0xFD,
0xFE,
0xFF};
/*539*/ static short __toupR[257]={
-1,
0x00,
0x01,
0x02,
0x03,
0x04,
0x05,
0x06,
0x07,
0x08,
0x09,
0x0A,
0x0B,
0x0C,
0x0D,
0x0E,
0x0F,
0x10,
0x11,
0x12,
0x13,
0x14,
0x15,
0x16,
0x17,
0x18,
0x19,
0x1A,
0x1B,
0x1C,
0x1D,
0x1E,
0x1F,
0x20,
0x21,
0x22,
0x23,
0x24,
0x25,
0x26,
0x27,
0x28,
0x29,
0x2A,
0x2B,
0x2C,
0x2D,
0x2E,
0x2F,
0x30,
0x31,
0x32,
0x33,
0x34,
0x35,
0x36,
0x37,
0x38,
0x39,
0x3A,
0x3B,
0x3C,
0x3D,
0x3E,
0x3F,
0x40,
0x41,
0x42,
0x43,
0x44,
0x45,
0x46,
0x47,
0x48,
0x49,
0x4A,
0x4B,
0x4C,
0x4D,
0x4E,
0x4F,
0x50,
0x51,
0x52,
0x53,
0x54,
0x55,
0x56,
0x57,
0x58,
0x59,
0x5A,
0x5B,
0x5C,
0x5D,
0x5E,
0x5F,
0x60,
0x41,
0x42,
0x43,
0x44,
0x45,
0x46,
0x47,
0x48,
0x49,
0x4A,
0x4B,
0x4C,
0x4D,
0x4E,
0x4F,
0x50,
0x51,
0x52,
0x53,
0x54,
0x55,
0x56,
0x57,
0x58,
0x59,
0x5A,
0x7B,
0x7C,
0x7D,
0x7E,
0x7F,
0x80,
0x81,
0x82,
0x83,
0x84,
0x85,
0x86,
0x87,
0x88,
0x89,
0x8A,
0x8B,
0x8C,
0x8D,
0x8E,
0x8F,
0x90,
0x91,
0x92,
0x93,
0x94,
0x95,
0x96,
0x97,
0x98,
0x99,
0x9A,
0x9B,
0x9C,
0x9D,
0x9E,
0x9F,
0xA0,
0xA1,
0xA2,
0xA3,
0xA4,
0xA5,
0xA6,
0xA7,
0xA8,
0xA9,
0xAA,
0xAB,
0xAC,
0xAD,
0xAE,
0xAF,
0xB0,
0xB1,
0xB2,
0xB3,
0xB4,
0xB5,
0xB6,
0xB7,
0xB8,
0xB9,
0xBA,
0xBB,
0xBC,
0xBD,
0xBE,
0xBF,
0xC0,
0xC1,
0xC2,
0xC3,
0xC4,
0xC5,
0xC6,
0xC7,
0xC8,
0xC9,
0xCA,
0xCB,
0xCC,
0xCD,
0xCE,
0xCF,
0xD0,
0xD1,
0xD2,
0xD3,
0xD4,
0xD5,
0xD6,
0xD7,
0xD8,
0xD9,
0xDA,
0xDB,
0xDC,
0xDD,
0xDE,
0xDF,
0xE0,
0xE1,
0xE2,
0xE3,
0xE4,
0xE5,
0xE6,
0xE7,
0xE8,
0xE9,
0xEA,
0xEB,
0xEC,
0xED,
0xEE,
0xEF,
0xF0,
0xF1,
0xF2,
0xF3,
0xF4,
0xF5,
0xF6,
0xF7,
0xF8,
0xF9,
0xFA,
0xFB,
0xFC,
0xFD,
0xFE,
0xFF};
/*1583*/ unsigned short*__isbuf;
short*__tolow;
short*__toup;
/*1587*/ void __cytpe_init(void)
{
if(__isbuf)
return;
/*1592*/ __isbuf= &__isbufR[1];
__tolow= &__tolowR[1];
__toup= &__toupR[1];
}
/*1599*/ int isalnum(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0001 U);
}
/*1605*/ int isalpha(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0002 U);
}
/*1611*/ int iscntrl(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0004 U);
}
/*1617*/ int isdigit(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0008 U);
}
/*1623*/ int isgraph(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0010 U);
}
/*1629*/ int islower(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0020 U);
}
/*1635*/ int isprint(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0040 U);
}
/*1641*/ int ispunct(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0080 U);
}
/*1647*/ int isspace(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0100 U);
}
/*1653*/ int isupper(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0200 U);
}
/*1659*/ int isxdigit(int c)
{
__cytpe_init();
return(__isbuf[c]&0x0400 U);
}
/*1665*/ int tolower(int c)
{
__cytpe_init();
return(__tolow[c]);
}
/*1671*/ int toupper(int c)
{
__cytpe_init();
return(__toup[c]);
}
/*"setjmp.h"16*/ typedef struct{
/*18*/ int regs[31];
/*43*/ int retval;
}jmp_buf[1];
/*46*/ int __setj(jmp_buf env);
/*48*/ void longjmp(jmp_buf env,int val);
/*"pdpc201/setjmp.c"17*/ int __longj(void*,int val);
/*19*/ void longjmp(jmp_buf env,int val)
{
if(val==0)
{
val=1;
}
/*27*/ __longj(env,val);
return;
}
/*"math.h"31*/ double ceil(double x);
double fabs(double x);
double floor(double x);
double fmod(double x,double y);
/*39*/ double atan2(double y,double x);
double frexp(double value,int*exp);
double ldexp(double x,int exp);
double modf(double value,double*iptr);
/*48*/ double pow(double x,double y);
double sqrt(double x);
double acos(double x);
double asin(double x);
double atan(double x);
double cos(double x);
double sin(double x);
double tan(double x);
double cosh(double x);
double sinh(double x);
double tanh(double x);
double exp(double x);
double log(double x);
double log10(double x);
/*"pdpc201/math.c"56*/ static const double pi=3.1415926535897932384626433832795;
static const double ln10=2.3025850929940456840179914546844;
static const double ln2=0.69314718055994530941723212145818;
/*61*/ double ceil(double x)
{
int y;
/*65*/ y=(int)x;
if((double)y<x)
{
y++;
}
return((double)y);
}
/*76*/ double fabs(double x)
{
if(x<0.0)
{
x= -x;
}
return(x);
}
/*85*/ double floor(double x)
{
int y;
/*89*/ if(x<0.0)
{
y=(int)x;
if((double)y!=x)
{
y--;
}
}
else
{
y=(int)x;
}
return((double)y);
}
/*104*/ double fmod(double x,double y)
{
int imod;
if(y==0.0)return(0.0);
imod=x/y;
return((double)x-((double)imod*y));
}
/*122*/ double acos(double x)
{
/*128*/ if(fabs(x)>1.0)
{
(*(__get_errno()))=33;
return(9.999999999999999999999E72);
}
if(x<0.0)return(pi-acos(-x));
/*135*/ return(asin(sqrt(1.0-x*x)));
/*137*/ }
/*152*/ double asin(double y)
{
int i,n;
double term,answer,work,x,powx,coef;
/*157*/ x=y;
/*163*/ if(x<0.0)return(-asin(-x));
/*169*/ if(x>1.0)
{
(*(__get_errno()))=33;
return(9.999999999999999999999E72);
}
/*179*/ if(x>0.75)
{
x=(sqrt(1.0-(x*x)));
return((pi/2.0)-asin(x));
}
/*189*/ i=1;
answer=x;
term=1;
coef=1;
powx=x;
/*195*/ n=256;
while((n--)>0)
{
work=i;
coef=(coef*work)/(work+1);
powx=powx*x*x;
term=coef*powx/(work+2.0);
if(answer==(answer+term))break;
answer=answer+(term);
i+=2;
}
/*207*/ return(answer);
}
/*237*/ double atan(double x)
{
int i,n;
double term,answer,work,powx;
/*246*/ if(x<0.0)return(-atan(-x));
/*253*/ if(x>1.0)return((pi/2)-atan(1.0/x));
/*260*/ if(x>(2.0-sqrt(3.0)))
return((pi/6.0)+atan((x*sqrt(3.0)-1.0)/(x+sqrt(3.0))));
/*269*/ i=1;
answer=x;
term=x;
powx=x;
/*274*/ n=256;
/*276*/ while((n--)>0)
{
work=i;
powx=0.0-powx*x*x;
term=powx/(work+2.0);
if(answer==(answer+term))break;
answer=answer+(term);
i+=2;
}
/*286*/ return(answer);
/*288*/ }
/*293*/ double atan2(double y,double x)
{
return(x>=y)?
(x>= -y?atan(y/x): -pi/2-atan(x/y))
:
(x>= -y?pi/2-atan(x/y):(y>=0)?pi+atan(y/x): -pi+atan(y/x));
/*301*/ }
/*307*/ double cos(double x)
{
/*322*/ int i,n;
double term,answer,work,x1;
/*329*/ i=x/(2*pi);
x1=x-(i*(2.0*pi));
/*332*/ i=1;
term=answer=1;
/*335*/ n=256;
while((n--)>0)
{
work=i;
term= -(term*x1*x1)/(work*(work+1.0));
if(answer==(answer+term))break;
answer=answer+term;
i+=2;
}
/*345*/ return(answer);
/*347*/ }
/*352*/ double sin(double x)
{
/*367*/ int i,n;
double term,answer,work,x1;
/*373*/ i=x/(2.0*pi);
x1=x-(i*(2.0*pi));
/*379*/ i=1;
term=answer=x1;
/*384*/ n=256;
while((n--)>0)
{
work=i+1;
term= -(term*x1*x1)/(work*(work+1.0));
if(answer==(answer+term))break;
answer=answer+term;
i=i+2;
}
/*394*/ return(answer);
}
/*400*/ double tan(double x)
{
/*410*/ double temp;
/*412*/ temp=cos(x);
if(temp==0.0)
{
/*416*/ return(9.999999999999999999999E72);
}
return(sin(x)/cos(x));
}
/*429*/ double cosh(double x)
{
double dexpx;
/*433*/ dexpx=exp(x);
/*435*/ return(0.5*(dexpx+(1.0/dexpx)));
/*437*/ }
/*439*/ double sinh(double x)
{
double dexpx;
/*443*/ dexpx=exp(x);
/*445*/ return(0.5*(dexpx-(1.0/dexpx)));
}
/*452*/ double tanh(double x)
{
double dexp2;
/*456*/ dexp2=exp(-2.0*x);
return((1.0-dexp2)/(1.0+dexp2));
}
/*465*/ double exp(double x)
{
int i,n;
double term,answer,work;
/*470*/ i=2;
term=x;
answer=x;
/*474*/ n=256;
while((n--)>0)
{
work=i;
term=(term*x)/work;
if(answer==(answer+term))break;
answer=answer+(term);
i++;
}
/*484*/ answer=answer+1.0;
return(answer);
}
/*499*/ double log(double x)
{
int i,n,scale;
double term,answer,work,xs;
/*504*/ if(x<=0)
{
/*507*/ (*(__get_errno()))=33;
return(9.999999999999999999999E72);
}
if(x==1.0)return(0.0);
/*522*/ xs=frexp(x,&scale);
xs=(1.0*xs)-1.0;
scale=scale-0;
/*526*/ i=2;
term=answer=xs;
/*529*/ n=256;
while((n--)>0)
{
work=i;
term= -(term*xs);
if(answer==(answer+(term/work)))break;
answer=answer+(term/work);
i++;
}
/*539*/ answer=answer+(double)scale*ln2;
return(answer);
}
/*544*/ double log10(double x)
{
return(log(x)/ln10);
}
/*557*/ double pow(double x,double y)
{
int j,n,neg;
double yy,xx;
neg=0;
j=y;
yy=j;
if(yy==y){
xx=x;
if(y<0){neg=1;j= -j;}
if(y==0)return(1.0);
--j;
n=256;
while(j>0&&((n--)>0))
{xx=xx*x;j--;}
if(neg)xx=1.0/xx;
return(xx);
}
if(x<0.0)
{
(*(__get_errno()))=33;
return(0.0);
}
if(y==0.0)return(1.0);
/*582*/ return(exp(y*log(x)));
}
/*602*/ extern double __sqrt_d(double x);
/*604*/ double sqrt(double x)
{
double xs,yn,ynn;
double pow1;
int i,n;
/*610*/ if(x<0.0)
{
(*(__get_errno()))=33;
return(0.0);
}
/*616*/ if(x==0.0)
return(0.0);
/*619*/ if(x!=x)
return(0.0);
/*630*/ xs=x;
pow1=1;
n=256;
/*634*/ while((xs<1.0)&&((n--)>0))
{xs=xs*4.0;pow1=pow1/2.0;}
while((xs>=4.0)&&((n--)>0))
{xs=xs/4.0;pow1=pow1*2.0;}
/*639*/ if(n<=0)
{
tk_puts("sqrt fail\n");
return(0);
}
/*650*/ i=0;
yn=xs/2.0;
ynn=0;
/*654*/ while((n--)>0)
{
ynn=(yn+xs/yn)*0.5;
if(fabs(ynn-yn)<=10.0*1E-37)break;else yn=ynn;
if(i>10)break;else i++;
}
return(ynn*pow1);
}
/*664*/ double frexp(double x,int*exp)
{
/*670*/ union dblhex
{
double d;
unsigned short s[4];
};
union dblhex split;
/*677*/ if(x==0.0)
{
exp=0;
return(0.0);
}
/*683*/ split.d=x;
*exp=(((split.s[0]>>8)&0x007f)-64)*4;
split.s[0]=split.s[0]&0x80ff;
split.s[0]=split.s[0]|0x4000;
/*688*/ while((fabs(split.d)<0.5)&&(split.d!=0))
{
split.d=split.d*2;
*exp=(*exp)-1;
}
/*694*/ return(split.d);
}
/*697*/ double ldexp(double x,int exp)
{
/*702*/ int bin_exp,hex_exp,adj_exp;
union dblhex
{
double d;
unsigned short s[4];
};
union dblhex split;
/*712*/ split.d=frexp(x,&bin_exp);
bin_exp=bin_exp+exp;
/*715*/ hex_exp=(bin_exp/4);
adj_exp=bin_exp-(hex_exp*4);
if(adj_exp<0){hex_exp=hex_exp-1;adj_exp=4+adj_exp;}
split.s[0]=split.s[0]&0x80ff;
split.s[0]=split.s[0]|(((hex_exp+64)<<8)&0x7f00);
/*722*/ while(adj_exp>0)
{
split.d=split.d*2;
--adj_exp;
}
/*728*/ return(split.d);
}
/*731*/ double modf(double value,double*iptr)
{
int neg=0;
long i;
/*736*/ if(value<0)
{
neg=1;
value= -value;
}
i=(long)value;
value-=i;
if(neg)
{
value= -value;
i= -i;
}
*iptr=i;
return(value);
}
/*"__memmgr.h"24*/ typedef struct memmgrn{
/*28*/ struct memmgrn*next;
struct memmgrn*prev;
struct memmgrn*nextf;
struct memmgrn*prevf;
int fixed;
size_t size;
int allocated;
int id;
/*39*/ size_t filler;
}MEMMGRN;
/*42*/ typedef struct{
MEMMGRN*start;
MEMMGRN*startf;
}MEMMGR;
/*83*/ void __mmDef(MEMMGR*memmgr);
void __mmInit(MEMMGR*memmgr);
void __mmTerm(MEMMGR*memmgr);
void __mmSupply(MEMMGR*memmgr,void*buffer,size_t szbuf);
void*__mmAlloc(MEMMGR*memmgr,size_t bytes,int id);
void __mmFree(MEMMGR*memmgr,void*ptr);
void __mmFId(MEMMGR*memmgr,int id);
size_t __mmMaxSize(MEMMGR*memmgr);
void __mmIntegrity(MEMMGR*memmgr);
int __mmRealloc(MEMMGR*memmgr,void*ptr,size_t newsize);
/*94*/ extern int __mmDebug;
extern int __mmDbg2;
/*97*/ extern MEMMGR __memmgr;
/*"pdpc201/__memmgr.c"17*/ MEMMGR __memmgr;
/*19*/ void __mmDef(MEMMGR*memmgr)
{
return;
}
/*24*/ void __mmInit(MEMMGR*memmgr)
{
memmgr->start=((void*)0);
memmgr->startf=((void*)0);
return;
}
/*31*/ void __mmTerm(MEMMGR*memmgr)
{
return;
}
/*39*/ void __mmSupply(MEMMGR*memmgr,void*buffer,size_t szbuf)
{
MEMMGRN*p,*l,*b;
/*43*/ if(((int)buffer%8)!=0)
{
szbuf-=(8-(int)buffer%8);
buffer=(char*)buffer+(8-(int)buffer%8);
}
/*49*/ if((szbuf%8)!=0)
{
szbuf-=szbuf%8;
}
/*54*/ p=memmgr->start;
l=((void*)0);
while((p!=((void*)0))&&((MEMMGRN*)buffer>=p))
{
l=p;
p=p->next;
}
/*62*/ b=(MEMMGRN*)buffer;
/*64*/ b->prev=l;
b->next=p;
/*67*/ if(l!=((void*)0))
{
l->next=b;
}
else
{
memmgr->start=b;
}
/*76*/ if(p!=((void*)0))
{
p->prev=b;
}
/*81*/ b->fixed=1;
b->size=szbuf;
b->allocated=0;
/*86*/ b->nextf=memmgr->startf;
if(b->nextf!=((void*)0))
{
b->nextf->prevf=b;
}
b->prevf=((void*)0);
memmgr->startf=b;
/*97*/ return;
}
/*100*/ void*__mmAlloc(MEMMGR*memmgr,size_t bytes,int id)
{
MEMMGRN*p,*n;
size_t oldbytes=bytes;
/*118*/ bytes+=((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8));
if((bytes%(((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))))!=0)
{
bytes=((bytes/(((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))))+1)
*(((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8)));
}
/*133*/ if(bytes<oldbytes)
{
return(((void*)0));
}
/*138*/ p=memmgr->startf;
/*140*/ while(p!=((void*)0))
{
if(p->size>=bytes)
{
/*148*/ if(p->allocated)
{
/*151*/ *(char*)0=0;
/*153*/ exit(1);
}
/*157*/ if((p->size-bytes)>=(((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))))
{
n=(MEMMGRN*)((char*)p+bytes);
n->next=p->next;
if(n->next!=((void*)0))
{
n->next->prev=n;
}
n->prev=p;
p->next=n;
n->fixed=0;
n->size=p->size-bytes;
n->allocated=0;
/*173*/ p->size=bytes;
/*177*/ n->nextf=p->nextf;
n->prevf=p->prevf;
if(n->nextf!=((void*)0))
{
n->nextf->prevf=n;
}
if(n->prevf!=((void*)0))
{
n->prevf->nextf=n;
}
/*189*/ else if(memmgr->startf!=p)
{
/*192*/ *(char*)0=0;
/*194*/ exit(1);
}
else
{
memmgr->startf=n;
}
}
/*203*/ else
{
if(p->nextf!=((void*)0))
{
p->nextf->prevf=p->prevf;
}
if(p->prevf!=((void*)0))
{
p->prevf->nextf=p->nextf;
}
/*215*/ else if(memmgr->startf!=p)
{
/*218*/ *(char*)0=0;
/*220*/ exit(1);
}
else
{
memmgr->startf=p->nextf;
}
}
/*229*/ p->nextf=((void*)0);
p->prevf=((void*)0);
/*232*/ p->allocated=0x5a5a;
p->id=id;
break;
}
p=p->nextf;
}
if(p==((void*)0))
{
/*246*/ return(p);
}
else
{
size_t*q;
/*252*/ q=(size_t*)((char*)p+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8)));
*(q-1)=oldbytes;
/*263*/ return((char*)p+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8)));
}
}
/*267*/ void __mmFree(MEMMGR*memmgr,void*ptr)
{
MEMMGRN*p,*n,*l;
int combprev=0;
int combnext=0;
/*273*/ p=(MEMMGRN*)((char*)ptr-((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8)));
/*287*/ if(p->allocated!=0x5a5a)
{
/*290*/ *(char*)0=0;
/*292*/ exit(1);
}
/*295*/ p->allocated=0;
/*297*/ l=p->prev;
n=p->next;
/*302*/ if(!p->fixed&&(l!=((void*)0))&& !l->allocated)
{
l->size+=p->size;
l->next=p->next;
if(l->next!=((void*)0))
{
l->next->prev=l;
}
combprev=1;
}
/*313*/ if((n!=((void*)0))&& !n->allocated&& !n->fixed)
{
combnext=1;
}
/*320*/ if(combnext&& !combprev)
{
p->size+=n->size;
p->next=n->next;
if(p->next!=((void*)0))
{
p->next->prev=p;
}
p->nextf=n->nextf;
if(p->nextf!=((void*)0))
{
p->nextf->prevf=p;
}
p->prevf=n->prevf;
if(p->prevf!=((void*)0))
{
p->prevf->nextf=p;
}
else if(memmgr->startf!=n)
{
/*341*/ *(char*)0=0;
/*343*/ exit(1);
}
else
{
memmgr->startf=p;
}
}
/*366*/ else if(combnext&&combprev)
{
if(n->nextf!=((void*)0))
{
n->nextf->prevf=n->prevf;
}
if(n->prevf!=((void*)0))
{
n->prevf->nextf=n->nextf;
}
else if(memmgr->startf!=n)
{
/*379*/ *(char*)0=0;
/*381*/ exit(1);
}
else
{
memmgr->startf=n->nextf;
n->nextf->prevf=((void*)0);
}
/*392*/ l->size+=n->size;
l->next=n->next;
if(l->next!=((void*)0))
{
l->next->prev=l;
}
/*401*/ }
/*403*/ if(combnext)
{
/*409*/ n->nextf=((void*)0);
n->prevf=((void*)0);
}
if(combprev)
{
/*418*/ p->nextf=((void*)0);
p->prevf=((void*)0);
}
/*424*/ if(!combprev&& !combnext)
{
p->nextf=memmgr->startf;
memmgr->startf=p;
p->prevf=((void*)0);
if(p->nextf!=((void*)0))
{
p->nextf->prevf=p;
}
}
/*444*/ return;
}
/*447*/ void __mmFId(MEMMGR*memmgr,int id)
{
MEMMGRN*p,*l;
/*451*/ p=memmgr->start;
l=((void*)0);
/*457*/ while(p!=((void*)0))
{
if((p->id==id)&&p->allocated)
{
/*462*/ __mmFree(memmgr,p+1);
/*468*/ if(l!=((void*)0))
{
p=l;
}
}
l=p;
p=p->next;
}
/*479*/ return;
}
/*483*/ size_t __mmMaxSize(MEMMGR*memmgr)
{
MEMMGRN*p;
size_t max=0;
/*488*/ p=memmgr->startf;
/*490*/ while(p!=((void*)0))
{
if(p->size>max)
{
max=p->size;
}
p=p->next;
}
if(max!=0)
{
max-=((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8));
}
return(max);
}
/*505*/ int __mmDebug=0;
int __mmDbg2=0;
/*615*/ int __mmRealloc(MEMMGR*memmgr,void*ptr,size_t newsize)
{
MEMMGRN*p,*n,*z;
size_t oldbytes=newsize;
/*629*/ newsize+=((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8));
if((newsize%(((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))))!=0)
{
newsize=((newsize/(((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))))+1)
*(((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8)));
}
/*638*/ if(newsize<oldbytes)
{
return(-1);
}
/*644*/ if(ptr==((void*)0))
{
return(-1);
}
/*650*/ p=(MEMMGRN*)((char*)ptr-((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8)));
/*655*/ if(p->allocated!=0x5a5a)
{
/*658*/ *(char*)0=0;
/*660*/ exit(1);
}
/*678*/ if(p->size<newsize)
{
n=p->next;
if((n!=((void*)0))&& !n->allocated&& !n->fixed&&((n->size+p->size)>=newsize))
/*685*/ {
/*688*/ if((p->size+n->size)<(newsize+(((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8)))))
{
/*692*/ if(n->nextf!=((void*)0))
{
n->nextf->prevf=n->prevf;
}
if(n->prevf!=((void*)0))
{
n->prevf->nextf=n->nextf;
}
else if(memmgr->startf!=n)
{
/*703*/ *(char*)0=0;
/*705*/ exit(1);
}
else
{
memmgr->startf=n->nextf;
}
/*713*/ p->size+=n->size;
p->next=n->next;
if(p->next!=((void*)0))
{
p->next->prev=p;
}
}
else
{
/*724*/ z=(MEMMGRN*)((char*)p+newsize);
z->allocated=0;
z->fixed=0;
/*730*/ z->size=p->size+n->size-newsize;
z->prev=p;
p->next=z;
z->next=n->next;
if(z->next!=((void*)0))
{
z->next->prev=z;
}
z->nextf=n->nextf;
if(z->nextf!=((void*)0))
{
z->nextf->prevf=z;
}
z->prevf=n->prevf;
if(z->prevf!=((void*)0))
{
z->prevf->nextf=z;
}
else if(memmgr->startf!=n)
{
/*751*/ *(char*)0=0;
/*753*/ exit(1);
}
else
{
memmgr->startf=z;
}
/*760*/ p->size=newsize;
}
}
/*764*/ else
{
return(-1);
}
}
/*771*/ else if((newsize+(((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8))))<=p->size)
{
/*774*/ n=(MEMMGRN*)((char*)p+newsize);
n->next=p->next;
if(n->next!=((void*)0))
{
n->next->prev=n;
}
n->prev=p;
p->next=n;
n->fixed=0;
n->size=p->size-newsize;
n->allocated=0;
/*788*/ p->size=newsize;
/*791*/ z=n->next;
if((z!=((void*)0))&& !z->allocated&& !z->fixed)
{
/*797*/ n->size+=z->size;
n->next=z->next;
if(n->next!=((void*)0))
{
n->next->prev=n;
}
n->nextf=z->nextf;
if(n->nextf!=((void*)0))
{
n->nextf->prevf=n;
}
n->prevf=z->prevf;
if(n->prevf!=((void*)0))
{
n->prevf->nextf=n;
}
else if(memmgr->startf!=z)
{
/*816*/ *(char*)0=0;
/*818*/ exit(1);
}
else
{
memmgr->startf=n;
}
}
/*826*/ else
{
n->nextf=memmgr->startf;
if(n->nextf!=((void*)0))
{
n->nextf->prevf=n;
}
n->prevf=((void*)0);
memmgr->startf=n;
}
}
/*852*/ {
size_t*q;
/*855*/ q=(size_t*)((char*)p+((sizeof(MEMMGRN)%8==0)?sizeof(MEMMGRN):((sizeof(MEMMGRN)/8+1)*8)));
*(q-1)=oldbytes;
}
return(0);
}
/*"tk_core.h"13*/ typedef unsigned char byte;
typedef signed char sbyte;
typedef unsigned short u16;
typedef signed short s16;
typedef unsigned int u32;
typedef signed int s32;
typedef unsigned long long u64;
typedef signed long long s64;
/*22*/ typedef volatile u32 vol_u32;
/*113*/ typedef unsigned char bool;
/*128*/ typedef struct TKMM_MemLnkObj_s TKMM_MemLnkObj;
/*130*/ struct TKMM_MemLnkObj_s{
TKMM_MemLnkObj*cnext;
TKMM_MemLnkObj*cprev;
u16 ix;
byte fl;
byte check;
u32 pad;
/*140*/ u32 data[1];
};
/*145*/ typedef struct TK_FILE_VT_s TK_FILE_VT;
typedef struct TK_FILE_s TK_FILE;
typedef struct TK_FSTAT_s TK_FSTAT;
typedef struct TK_DIR_s TK_DIR;
typedef struct TK_MOUNT_s TK_MOUNT;
/*151*/ struct TK_FILE_VT_s{
char*fsname;
TK_FILE_VT*next;
/*155*/ TK_MOUNT*(*mount)(char*devfn,char*mntfn,char*fsty,char*mode,char* *opts);
/*158*/ TK_FILE*(*fopen)(TK_MOUNT*mnt,char*name,char*mode);
TK_FILE*(*fopendir)(TK_MOUNT*mnt,char*name);
TK_FILE*(*unlink)(TK_MOUNT*mnt,char*name);
TK_FILE*(*rename)(TK_MOUNT*mnt,char*oldfn,char*newfn);
TK_FILE*(*fstat)(TK_MOUNT*mnt,char*name,TK_FSTAT*st);
/*165*/ int(*fread)(void*buf,int sz1,int sz2,TK_FILE*fd);
int(*fwrite)(void*buf,int sz1,int sz2,TK_FILE*fd);
int(*fseek)(TK_FILE*fd,int ofs,int rel);
int(*ftell)(TK_FILE*fd);
int(*fclose)(TK_FILE*fd);
int(*fgetc)(TK_FILE*fd);
int(*fputc)(int ch,TK_FILE*fd);
};
/*174*/ struct TK_FILE_s{
TK_FILE_VT*vt;
void*udata0;
void*udata1;
void*udata2;
void*udata3;
byte*ram_base;
byte*ram_end;
byte*ram_ofs;
u32 ofs;
u32 size;
};
/*187*/ struct TK_MOUNT_s{
TK_FILE_VT*vt;
TK_MOUNT*next;
void*udata0;
void*udata1;
};
/*"tk_fatfs.h"3*/ typedef struct TKFAT_MBR_Entry_s TKFAT_MBR_Entry;
typedef struct TKFAT_MBR_s TKFAT_MBR;
typedef struct TKFAT_FAT16_Boot_s TKFAT_FAT16_Boot;
typedef struct TKFAT_FAT32_Boot_s TKFAT_FAT32_Boot;
typedef struct TKFAT_FAT_DirEnt_s TKFAT_FAT_DirEnt;
typedef struct TKFAT_FAT_DirLfnEnt_s TKFAT_FAT_DirLfnEnt;
/*10*/ typedef struct TKFAT_FAT_DirEntExt_s TKFAT_FAT_DirEntExt;
typedef struct TKFAT_FAT_DirInfo_s TKFAT_FAT_DirInfo;
/*13*/ struct TKFAT_MBR_Entry_s{
byte flag;
byte shead;
byte ssect[2];
byte fstype;
byte ehead;
byte esect[2];
byte lba_start[4];
byte lba_count[4];
};
/*24*/ struct TKFAT_MBR_s{
byte pad[446];
TKFAT_MBR_Entry entry[4];
byte aa55[2];
};
/*30*/ struct TKFAT_FAT16_Boot_s{
byte pad_jmp[3];
byte oem_name[8];
byte bytes_sector[2];
byte sectors_cluster;
byte reserved_sectors[2];
byte num_fats;
byte root_dirents[2];
byte lba_count16[2];
byte media_type;
byte sectors_fat[2];
byte sectors_track[2];
byte heads[2];
byte hidden_sectors[4];
byte lba_count[4];
byte drive_id;
byte drive_flag;
byte ebsig;
byte vol_sn[4];
byte vol_label[11];
byte fs_tyname[8];
byte boot_code[448];
byte aa55[2];
};
/*55*/ struct TKFAT_FAT32_Boot_s{
byte pad_jmp[3];
byte oem_name[8];
byte bytes_sector[2];
byte sectors_cluster;
byte reserved_sectors[2];
byte num_fats;
byte root_dirents[2];
byte lba_count16[2];
byte media_type;
byte sectors_fat[2];
byte sectors_track[2];
byte heads[2];
byte hidden_sectors[4];
byte lba_count[4];
byte sectors_fat32[4];
byte drive_flag2[2];
byte version[2];
byte root_cluster[4];
byte fsis_sector[2];
byte fsaltboot_sector[2];
byte resv[12];
byte drive_id;
byte drive_flag;
byte ebsig;
byte vol_sn[4];
byte vol_label[11];
byte fs_tyname[8];
};
/*85*/ struct TKFAT_FAT_DirEnt_s{
byte name[8];
byte ext[3];
byte attrib;
byte lncase;
byte ctimems;
byte ctime[2];
byte cdate[2];
byte mdate[2];
byte cluster_hi[2];
byte lmtime[2];
byte lmdate[2];
byte cluster_lo[2];
byte filesize[4];
};
/*101*/ struct TKFAT_FAT_DirLfnEnt_s{
byte seq;
byte name1[10];
byte attrib;
byte type;
byte csum;
byte name2[12];
byte cluster_lo[2];
byte name3[4];
};
/*112*/ struct TKFAT_Volume_s{
TKFAT_FAT32_Boot boot;
};
/*116*/ typedef struct TKFAT_ImageInfo_s TKFAT_ImageInfo;
/*118*/ struct TKFAT_ImageInfo_s{
byte*pImgData;
int nImgBlks;
byte fsty;
bool isfat16;
byte szclust;
byte shclust;
/*126*/ int lba_start;
int lba_count;
/*129*/ int lba_fat1;
int lba_fat2;
int lba_root;
int lba_data;
/*134*/ int tot_clust;
int clid_root;
/*137*/ TKFAT_MBR*mbr;
TKFAT_FAT16_Boot*boot16;
TKFAT_FAT32_Boot*boot32;
/*141*/ u32 sbc_lba[64];
s16 sbc_lbn[64];
void*sbc_buf[64];
int sbc_num;
/*146*/ u32 tbc_lba[256];
s16 tbc_lbn[256];
void*tbc_buf[256];
int tbc_num;
};
/*153*/ struct TKFAT_FAT_DirEntExt_s{
TKFAT_FAT_DirEnt deb;
TKFAT_ImageInfo*img;
int clid;
int idx;
byte de_name[512];
byte de_aname[512];
};
/*162*/ struct TKFAT_FAT_DirInfo_s{
TKFAT_ImageInfo*img;
int clid;
};
/*"tk_dummyavi.h"154*/ typedef struct BGBBTJ_VidCodec_s BGBBTJ_VidCodec;
typedef struct BGBBTJ_VidCodecCTX_s BGBBTJ_VidCodecCTX;
typedef struct BGBBTJ_AVI_Context_s BGBBTJ_AVI_Context;
/*158*/ typedef struct BGBBTJ_BITMAPINFOHEADER_s BGBBTJ_BITMAPINFOHEADER;
/*161*/ typedef struct{
int width;
int height;
s64 frametime;
int num_frames;
int vid_fcc,vid_cmpr;
int aud_fcc,aud_cmpr;
}BGBBTJ_Video_Stats;
/*170*/ struct BGBBTJ_VidCodec_s{
BGBBTJ_VidCodec*next;
int*fcc;
/*174*/ BGBBTJ_VidCodecCTX*(*begin_decompress)(int fcc,BGBBTJ_BITMAPINFOHEADER*in,BGBBTJ_BITMAPINFOHEADER*out);
/*176*/ BGBBTJ_VidCodecCTX*(*begin_compress)(int fcc,BGBBTJ_BITMAPINFOHEADER*in,BGBBTJ_BITMAPINFOHEADER*out);
/*178*/ int(*decompress_query)(int fcc,BGBBTJ_BITMAPINFOHEADER*in,BGBBTJ_BITMAPINFOHEADER*out);
/*180*/ int(*compress_query)(int fcc,BGBBTJ_BITMAPINFOHEADER*in,BGBBTJ_BITMAPINFOHEADER*out);
/*182*/ };
/*184*/ struct BGBBTJ_VidCodecCTX_s{
void*data;
/*187*/ byte*vidStrd;
byte*audStrd;
int sz_vidStrd;
int sz_audStrd;
int viQuality;
int viNextIFrame;
int viFlags;
/*195*/ int(*decompress_frame)(BGBBTJ_VidCodecCTX*ctx,void*src,void*dst,int ssz,int dsz);
/*197*/ int(*compress_frame)(BGBBTJ_VidCodecCTX*ctx,void*src,void*dst,int dsz,int qfl,int clrs,int*rfl);
/*199*/ int(*end_decompress)(BGBBTJ_VidCodecCTX*ctx);
int(*end_compress)(BGBBTJ_VidCodecCTX*ctx);
int(*decompress_frame_clrs)(BGBBTJ_VidCodecCTX*ctx,void*src,void*dst,int ssz,int dsz,int clrs);
/*203*/ };
/*205*/ struct BGBBTJ_VidLayer_s{
char*tagLayerName;
char*compLayerName;
void*data;
};
/*211*/ typedef struct{
s32 left;
s32 top;
s32 right;
s32 bottom;
}BGBBTJ_RECT;
/*218*/ typedef struct{
byte peRed;
byte peGreen;
byte peBlue;
byte peFlags;
}BGBBTJ_PALETTEENTRY;
/*225*/ typedef struct
{
u32 dwMicroSecPerFrame;
u32 dwMaxBytesPerSec;
u32 dwPaddingGranularity;
u32 dwFlags;
u32 dwTotalFrames;
u32 dwInitialFrames;
u32 dwStreams;
u32 dwSuggestedBufferSize;
u32 dwWidth;
u32 dwHeight;
u32 dwReserved[4];
}BGBBTJ_MainAVIHeader;
/*240*/ typedef struct{
u32 fccType;
u32 fccHandler;
u32 dwFlags;
u16 wPriority;
u16 wLanguage;
u32 dwInitialFrames;
u32 dwScale;
u32 dwRate;
u32 dwStart;
u32 dwLength;
u32 dwSuggestedBufferSize;
u32 dwQuality;
u32 dwSampleSize;
BGBBTJ_RECT rcFrame;
}BGBBTJ_AVIStreamHeader;
/*257*/ typedef struct{
u32 ckid;
u32 dwFlags;
u32 dwChunkOffset;
u32 dwChunkLength;
}BGBBTJ_AVIINDEXENTRY;
/*264*/ typedef struct{
byte bFirstEntry;
byte bNumEntries;
u16 wFlags;
BGBBTJ_PALETTEENTRY peNew[1];
}BGBBTJ_AVIPALCHANGE;
/*271*/ typedef struct{
u16 wFormatTag;
u16 nChannels;
u32 nSamplesPerSec;
u32 nAvgBytesPerSec;
u16 nBlockAlign;
u16 wBitsPerSample;
u16 cbSize;
}BGBBTJ_WAVEFORMATEX;
/*281*/ struct BGBBTJ_BITMAPINFOHEADER_s{
u32 biSize;
s32 biWidth;
s32 biHeight;
u16 biPlanes;
u16 biBitCount;
u32 biCompression;
u32 biSizeImage;
s32 biXPelsPerMeter;
s32 biYPelsPerMeter;
u32 biClrUsed;
u32 biClrImportant;
};
/*295*/ typedef struct{
byte rgbBlue;
byte rgbGreen;
byte rgbRed;
byte rgbReserved;
}BGBBTJ_RGBQUAD;
/*302*/ typedef struct{
BGBBTJ_BITMAPINFOHEADER bmiHeader;
BGBBTJ_RGBQUAD bmiColors[1];
}BGBBTJ_BITMAPINFO;
/*308*/ struct BGBBTJ_AVI_Context_s{
TK_FILE*fd;
int ofs_hdrl,ofs_movi,ofs_cur;
BGBBTJ_MainAVIHeader*avihead;
BGBBTJ_AVIStreamHeader*strhead,*vidhead,*audhead;
BGBBTJ_AVIINDEXENTRY*avi_index;
BGBBTJ_WAVEFORMATEX*wavefmt;
BGBBTJ_BITMAPINFOHEADER*bmihead;
void*fcbuf,*fdbuf;
int str_vid,str_aud;
int idxsz,frnum,cindex;
/*320*/ void*fdbuf_norm;
void*fdbuf_spec;
void*fdbuf_luma;
/*324*/ s64 frame_time;
int texnum;
int chroma_color;
/*328*/ int texnum_norm;
int texnum_spec;
int texnum_luma;
int mjpg_cty;
int mjpg_clrs;
/*334*/ BGBBTJ_VidCodecCTX*codec_ctx;
void*aud_codec_ctx;
/*337*/ int drain;
void*fadbuf;
short*sampbuf,*esampbuf;
int sz_sampbuf;
int sz_fcbuf;
/*343*/ int flags;
};
/*346*/ typedef struct{
/*348*/ void*hicd;
BGBBTJ_BITMAPINFOHEADER*ihead;
BGBBTJ_BITMAPINFOHEADER*ohead;
void*buffer;
}vfw_ctxinfo;
/*354*/ typedef struct{
/*356*/ void*hicd;
BGBBTJ_BITMAPINFOHEADER*ihead;
BGBBTJ_BITMAPINFOHEADER*ohead;
void*buffer;
}cram_ctxinfo;
/*"tk_core.h"197*/ void*TKMM_Malloc(int sz);
int TKMM_Free(void*ptr);
/*"tk_core/tk_mmpage.c"1*/ byte*tk_ird_imgbuf=((void*)0);
/*3*/ u32 tkmm_pagebase,tkmm_pageend;
/*6*/ byte tkmm_pagebmp[4096];
int tkmm_maxpage;
int tkmm_pagerov;
/*10*/ void*TKMM_MMList_Malloc(int sz);
/*12*/ int TKMM_FindFreePages(int n)
{
int i0,i1;
int i,j,m;
/*17*/ if(n<=0)
return(-1);
/*20*/ i=tkmm_pagerov;
m=tkmm_maxpage;
while(i<m)
{
if(tkmm_pagebmp[i>>3]&(1<<(i&7)))
{
while((tkmm_pagebmp[i>>3]==0xFF)&&(i<m))
{
i=(i+8)&(~7);
continue;
}
while((tkmm_pagebmp[i>>3]&(1<<(i&7)))&&(i<m))
i++;
continue;
}
i0=i;i1=i0+n;
if(i1>m)break;
while(!(tkmm_pagebmp[i>>3]&(1<<(i&7)))&&(i<i1))
i++;
if(i>=i1)
{
tkmm_pagerov=i1;
return(i0);
}
}
/*46*/ if(tkmm_pagerov!=0)
{
tkmm_pagerov=0;
i=TKMM_FindFreePages(n);
return(i);
}
/*53*/ return(-1);
}
/*56*/ int TKMM_AllocPages(int n)
{
int i,j,k;
/*60*/ i=TKMM_FindFreePages(n);
if(i<0)return(-1);
/*63*/ j=i;k=j+n;
while(j<k)
{
tkmm_pagebmp[j>>3]|=(1<<(j&7));
j++;
}
return(i);
}
/*72*/ int TKMM_FreePages(int b,int n)
{
int i;
/*76*/ for(i=b;i<(b+n);i++)
{
tkmm_pagebmp[i>>3]&= ~(1<<(i&7));
}
return(0);
}
/*83*/ void*TKMM_PageToPointer(int n)
{
byte*ptr;
ptr=((byte*)0x90000000)+(n<<12);
return(ptr);
}
/*90*/ int TKMM_PointerToPage(void*ptr)
{
int d;
/*94*/ d=((byte*)ptr)-((byte*)0x90000000);
return(d>>12);
}
/*98*/ void*TKMM_PageAlloc(int sz)
{
void*p;
int pg;
/*103*/ pg=TKMM_AllocPages((sz+4095)>>12);
if(pg<0)return(((void*)0));
p=TKMM_PageToPointer(pg);
return(p);
}
/*110*/ void TKMM_Init()
{
static int init=0;
int i;
/*115*/ if(init)return;
init=1;
/*118*/ tk_ird_init();
/*120*/ tkmm_pagebase=0x90000000;
tkmm_pageend=0x98000000;
/*123*/ if(tk_ird_imgbuf)
{
if((((u32)tk_ird_imgbuf)<tkmm_pageend)&&(((u32)tk_ird_imgbuf)>tkmm_pagebase))
/*127*/ {
tkmm_pageend=(u32)tk_ird_imgbuf;
}
}
/*132*/ tkmm_maxpage=(tkmm_pageend-tkmm_pagebase)>>12;
/*137*/ TKMM_MMList_Init();
}
/*140*/ void*TKMM_Malloc(int sz)
{
TKMM_MemLnkObj*obj;
void*ptr;
int pg,np;
/*146*/ if(sz<65536)
{
ptr=TKMM_MMList_Malloc(sz);
/*150*/ if(!ptr)
printf("TKMM_Malloc: failed A %d\n",sz);
/*153*/ return(ptr);
}
/*156*/ np=(sz+sizeof(TKMM_MemLnkObj)+4095)>>12;
pg=TKMM_AllocPages(np);
if(pg<0)
{
printf("TKMM_Malloc: failed B %d\n",sz);
return(((void*)0));
}
ptr=TKMM_PageToPointer(pg);
/*166*/ obj=ptr;
obj->cnext=((void*)0);
obj->cprev=((void*)0);
obj->ix=np;
obj->fl=5;
/*172*/ return((byte*)obj->data);
}
/*175*/ int TKMM_Free(void*ptr)
{
TKMM_MemLnkObj*obj;
int b,n;
/*180*/ if(!ptr)return(-1);
obj=(TKMM_MemLnkObj*)(((byte*)ptr)-((int)(((TKMM_MemLnkObj*)0)->data)));
/*184*/ if(obj->fl&4)
{
b=TKMM_PointerToPage(obj);
TKMM_FreePages(b,obj->ix);
return(0);
}
/*191*/ TKMM_MMList_FreeLnkObj(obj);
return(0);
}
/*"tk_core/tk_mmllist.c"1*/ TKMM_MemLnkObj*tkmm_mmlist_freelist[256];
/*3*/ byte*tkmm_mmlist_brkbuf=((void*)0);
byte*tkmm_mmlist_brkend;
byte*tkmm_mmlist_brkpos;
/*7*/ void*TKMM_MMList_AllocBrk(int sz)
{
byte*ptr;
/*11*/ if(sz>=65536)
{
ptr=TKMM_PageAlloc(sz);
return(ptr);
}
/*17*/ sz=(sz+15)&(~15);
/*19*/ if(tkmm_mmlist_brkbuf&&((tkmm_mmlist_brkpos+sz)>tkmm_mmlist_brkend))
tkmm_mmlist_brkbuf=((void*)0);
/*22*/ if(!tkmm_mmlist_brkbuf)
{
tkmm_mmlist_brkbuf=TKMM_PageAlloc(1<<20);
tkmm_mmlist_brkend=tkmm_mmlist_brkbuf+(1<<20);
tkmm_mmlist_brkpos=tkmm_mmlist_brkbuf;
}
/*29*/ ptr=tkmm_mmlist_brkpos;
tkmm_mmlist_brkpos=ptr+sz;
return(ptr);
}
/*35*/ int TKMM_SizeToFxiU(int sz)
{
int fr,ex;
int i;
/*40*/ fr=sz;
ex=0;
/*43*/ while(fr>=16)
{fr=(fr+1)>>1;ex++;}
i=(fr&7)|(ex<<3);
return(i);
}
/*50*/ int TKMM_SizeToFxiD(int sz)
{
int fr,ex;
int i;
/*55*/ fr=sz;
ex=0;
/*58*/ while(fr>=16)
{fr=fr>>1;ex++;}
i=(fr&7)|(ex<<3);
return(i);
}
/*65*/ int TKMM_FxiToSize(int ix)
{
int ex,fr;
int sz;
/*70*/ if(ix<8)return(ix);
fr=(ix&7)|8;ex=ix>>3;
sz=fr<<ex;
return(sz);
}
/*76*/ void*TKMM_MMList_Malloc(int sz)
{
TKMM_MemLnkObj*obj,*obj1;
byte*p1,*p2;
int ix,ix1;
int sz1,sz2;
/*83*/ if(sz<=0)return(((void*)0));
/*85*/ if(sz<64)sz=64;
/*89*/ sz=(sz+((int)(((TKMM_MemLnkObj*)0)->data))+15)&(~7);
/*91*/ ix=TKMM_SizeToFxiU(sz);
/*93*/ obj=tkmm_mmlist_freelist[ix];
if(obj)
{
/*97*/ tkmm_mmlist_freelist[ix]= *(TKMM_MemLnkObj* *)(obj->data);
/*99*/ obj->fl&= ~1;
/*101*/ return((byte*)obj->data);
}
/*107*/ sz1=TKMM_FxiToSize(ix);
p1=TKMM_MMList_AllocBrk(sz1);
/*110*/ p2=p1+sz1;
obj=(TKMM_MemLnkObj*)p1;
sz2=p2-((byte*)obj1->data);
obj->ix=TKMM_SizeToFxiD(sz2);
obj->fl=3;
obj->check=0x5A;
obj->cnext=(TKMM_MemLnkObj*)p2;
obj->cprev=((void*)0);
/*119*/ obj->fl&= ~1;
return((byte*)obj->data);
/*187*/ }
/*189*/ int TKMM_MMList_FreeLnkObj(TKMM_MemLnkObj*obj)
{
if(obj->check!=0x5A)
{
tk_puts("TKMM_MMList_FreeLnkObj: Check Value Fail\n");
return(-1);
}
/*197*/ obj->fl|=1;
*(TKMM_MemLnkObj* *)(obj->data)=tkmm_mmlist_freelist[obj->ix];
tkmm_mmlist_freelist[obj->ix]=obj;
return(0);
}
/*203*/ int TKMM_MMList_Free(void*ptr)
{
TKMM_MemLnkObj*obj;
/*207*/ if(!ptr)return(-1);
obj=(TKMM_MemLnkObj*)(((byte*)ptr)-((int)(((TKMM_MemLnkObj*)0)->data)));
obj->fl|=1;
/*211*/ TKMM_MMList_FreeLnkObj(obj);
}
/*214*/ int TKMM_MMList_Init(void)
{
int i;
/*218*/ for(i=0;i<256;i++)
tkmm_mmlist_freelist[i]=((void*)0);
}
/*"tk_core/tk_spi.c"37*/ u32 tkspi_ctl_speed;
u32 tkspi_ctl_status;
/*40*/ byte tkspi_init_ok;
/*42*/ void TKSPI_ChipSel(int chip)
{
u32 rv;
rv=(*(vol_u32*)(0xABCD0040+0x00));
while(rv&0x02)
{rv=(*(vol_u32*)(0xABCD0040+0x00));}
if(chip)
{
if(chip==1)
{tkspi_ctl_status=tkspi_ctl_speed;}
else if(chip==2)
{tkspi_ctl_status=tkspi_ctl_speed|0x04|0x01;}
}else
{
tkspi_ctl_status=0x01;
}
(*(vol_u32*)(0xABCD0040+0x00))=tkspi_ctl_status;
}
/*61*/ void TKSPI_SetSpeed(int speed)
{
if(!speed)
{tkspi_ctl_speed=((31)<<27);}
else
{tkspi_ctl_speed=((0)<<27);}
}
/*69*/ byte TKSPI_XchByte(byte c)
{
u32 v;
(*(vol_u32*)(0xABCD0040+0x04))=c;
(*(vol_u32*)(0xABCD0040+0x00))=tkspi_ctl_status|0x02;
v=(*(vol_u32*)(0xABCD0040+0x00));
while(v&0x02)
v=(*(vol_u32*)(0xABCD0040+0x00));
v=(*(vol_u32*)(0xABCD0040+0x04));
/*79*/ return(v&0xFF);
}
/*82*/ int TKSPI_ReadBasic(int chip,u32 addr,byte*bufptr,u32 len)
/*84*/ {
byte*ptr;
/*87*/ ptr=bufptr;
TKSPI_ChipSel(chip);
TKSPI_XchByte(0x03);
TKSPI_XchByte(addr>>16);
TKSPI_XchByte(addr>>8);
TKSPI_XchByte(addr);
while(len)
{
*ptr++ =TKSPI_XchByte(0);
len--;
}
TKSPI_ChipSel(0);
return(1);
}
/*102*/ int TKSPI_DelayUSec(int us)
{
}
/*106*/ int TKSPI_ReadData(byte*buf,u32 len)
{
byte*ct;
u32 count;
byte rv;
int n;
/*113*/ count=(1<<16);
while(count>0)
{
rv=TKSPI_XchByte(0xFF);
if(rv!=0xFF)
break;
TKSPI_DelayUSec(10);
count--;
}
if(rv!=0xFE)
{
printf("Err %02X\n",rv);
return(-1);
}
/*130*/ ct=buf;n=len;
while((n--)>0)
{
rv=TKSPI_XchByte(0xFF);
*ct++ =rv;
}
/*139*/ TKSPI_XchByte(0xFF);
TKSPI_XchByte(0xFF);
/*142*/ return(0);
}
/*145*/ int TKSPI_WaitReady(void)
{
u32 count;
byte rv;
/*150*/ count=(1<<16);
while(count>0)
{
rv=TKSPI_XchByte(0xFF);
if(rv==0xFF){
return(1);
}
TKSPI_DelayUSec(10);
count--;
}
return(0);
}
/*163*/ int TKSPI_WriteData(byte*buf,u32 len)
{
byte*ct;
u32 count;
byte rv;
int n;
/*170*/ if(!TKSPI_WaitReady())
return(-1);
/*192*/ rv=TKSPI_XchByte(0xFE);
/*194*/ ct=buf;n=len;
while((n--)>0)
{
rv=TKSPI_XchByte(*ct++);
/*199*/ }
/*203*/ TKSPI_XchByte(0xFF);
TKSPI_XchByte(0xFF);
/*206*/ return(0);
}
/*210*/ void TKSPI_Deselect(void)
{
TKSPI_ChipSel(1);
}
/*215*/ int TKSPI_Select(void)
{
TKSPI_ChipSel(0);
if(TKSPI_WaitReady())
return(1);
TKSPI_Deselect();
return(0);
}
/*224*/ void TKSPI_PowerOff(void)
{
TKSPI_Select();
TKSPI_Deselect();
}
/*230*/ byte TKSPI_SendCmd(byte cmd,u32 arg)
{
byte n,h,res;
/*234*/ if(cmd&0x80)
{
cmd&=0x7F;
res=TKSPI_SendCmd(0x37,0);
if(res>1)
return(res);
}
/*242*/ TKSPI_Deselect();
if(!TKSPI_Select())
{
printf("TKSPI_SendCmd: Select Fail\n");
return(0xFF);
}
/*249*/ TKSPI_XchByte(0x40|cmd);
TKSPI_XchByte((byte)(arg>>24));
TKSPI_XchByte((byte)(arg>>16));
TKSPI_XchByte((byte)(arg>>8));
TKSPI_XchByte((byte)arg);
h=0x01;
if(cmd==0x00)h=0x95;
if(cmd==0x08)h=0x87;
TKSPI_XchByte(h);
/*259*/ if(cmd==0x0C)
{TKSPI_XchByte(0xFF);}
n=10;
while(n>0)
{
res=TKSPI_XchByte(0xFF);
if(!(res&0x80))
break;
n--;
}
/*270*/ return(res);
}
/*273*/ int TKSPI_ReadSectors(byte*buf,s64 lba,int cnt)
{
byte*ct;
u64 la;
int n,h;
/*279*/ if(cnt>1)
{
ct=buf;la=lba;n=cnt;
if(h)TKSPI_SendCmd(0x37,h);
TKSPI_SendCmd(0x12,la);
while(n>0)
{
h=la>>32;
TKSPI_ReadData(ct,512);
ct+=512;la++;n--;
}
TKSPI_SendCmd(0x0C,0);
}else
{
ct=buf;la=lba;n=cnt;
h=la>>32;
if(h)TKSPI_SendCmd(0x37,h);
TKSPI_SendCmd(0x11,la);
TKSPI_ReadData(ct,512);
}
/*311*/ return(0);
}
/*314*/ int TKSPI_WriteSectors(byte*buf,s64 lba,int cnt)
{
byte*ct;
u64 la;
int n,h;
/*320*/ ct=buf;la=lba;n=cnt;
while(n>0)
{
h=la>>32;
if(h)TKSPI_SendCmd(0x37,h);
TKSPI_SendCmd(0x18,la);
TKSPI_WriteData(ct,512);
ct+=512;la++;n--;
}
/*330*/ return(0);
}
/*335*/ int TKSPI_InitDevice(void)
{
static const char*hexchars="0123456789ABCDEF";
byte ocr[4];
byte s,cmd,ty;
u32 n,count;
/*342*/ TKSPI_SetSpeed(0);
TKSPI_SendCmd(0x34,1);
for(n=0;n<10;n++)
TKSPI_XchByte(0xFF);
/*347*/ ty=0;
n=TKSPI_SendCmd(0x00,0);
if(n==1)
{
s=TKSPI_SendCmd(0x08,0x1AA);
if(s==1)
{
for(n=0;n<4;n++)
ocr[n]=TKSPI_XchByte(0xFF);
if((ocr[2]==0x01)&&(ocr[3]==0xAA))
{
n=1<<17;
while(n>0)
{
s=TKSPI_SendCmd(0xA9,1 UL<<30);
if(!s)
break;
TKSPI_DelayUSec(10);
n--;
}
s=TKSPI_SendCmd(0x3A,0);
if(n&& !s)
{
for(n=0;n<4;n++)
ocr[n]=TKSPI_XchByte(0xff);
/*373*/ ty=(ocr[0]&0x40)?0x43:0x03;
}
}
}
else
{
s=TKSPI_SendCmd(0xA9,0);
if(s<=1)
{
ty=2;
cmd=0xA9;
}else{
ty=1;
cmd=0x01;
}
n=1<<17;
while(n)
{
s=TKSPI_SendCmd(cmd,0);
if(!s)
break;
TKSPI_DelayUSec(10);
n--;
}
s=TKSPI_SendCmd(0x10,512);
if(!n||s)
ty=0;
}
}else
{
ty=0;
printf("TKSPI_InitDevice: Bad CMD0 %02X\n",n);
}
TKSPI_Deselect();
/*408*/ if(ty)
{
TKSPI_SetSpeed(1);
tkspi_init_ok=ty;
printf("TKSPI_InitDevice: Init OK, %d\n",ty);
}
else
{
TKSPI_PowerOff();
tkspi_init_ok=0;
printf("TKSPI_InitDevice: Init Failed\n");
}
return(tkspi_init_ok);
}
/*"tk_core/tk_fat.c"1*/ void tkfat_setChs(byte*chs,int lba)
{
int c,h,s,ts;
/*5*/ s=lba&63;
h=(lba>>6)&255;
c=lba>>10;
ts=(c<<6)|s;
/*10*/ chs[0]=h;
chs[1]=ts;
chs[2]=ts>>8;
}
/*15*/ void tkfat_setWord(byte*ptr,u16 val)
{ptr[0]=val;ptr[1]=val>>8;}
void tkfat_setDWord(byte*ptr,u32 val)
{ptr[0]=val;ptr[1]=val>>8;ptr[2]=val>>16;ptr[3]=val>>24;}
/*20*/ u16 tkfat_getWord(byte*ptr)
{return(ptr[0]|(ptr[1]<<8));}
u32 tkfat_getDWord(byte*ptr)
{return(ptr[0]|(ptr[1]<<8)|(ptr[2]<<16)|(ptr[3]<<24));}
/*30*/ byte*TKFAT_GetSectorTempBuffer(TKFAT_ImageInfo*img,int lba,int num)
/*32*/ {
u32 tba;
void*tbd;
int n,tbn;
int i,j,k;
/*38*/ n=num&255;
for(i=0;i<img->tbc_num;i++)
{
if((img->tbc_lba[i]==lba)&&(img->tbc_lbn[i]==n))
/*43*/ {
if(num&0x00000200)
img->tbc_lbn[i]|=0x00000200;
/*47*/ j=(i*7)>>3;
tbd=img->tbc_buf[i];
tba=img->tbc_lba[i];
tbn=img->tbc_lbn[i];
img->tbc_buf[i]=img->tbc_buf[j];
img->tbc_lba[i]=img->tbc_lba[j];
img->tbc_lbn[i]=img->tbc_lbn[j];
img->tbc_buf[i]=tbd;
img->tbc_lba[i]=tba;
img->tbc_lbn[i]=tbn;
return(tbd);
}
}
/*61*/ if(img->tbc_num<256)
{
i=img->tbc_num++;
tbd=malloc(n*512);
img->tbc_buf[i]=tbd;
img->tbc_lba[i]=lba;
img->tbc_lbn[i]=n;
}else
{
i=255;
/*72*/ if(img->tbc_lbn[i]&0x00000200)
{
TKSPI_WriteSectors(img->tbc_buf[i],img->tbc_lba[i],img->tbc_lbn[i]&255);
/*78*/ }
/*80*/ if(n!=img->tbc_lbn[i])
{
free(img->tbc_buf[i]);
img->tbc_buf[i]=malloc(n*512);
}
img->tbc_lba[i]=lba;
img->tbc_lbn[i]=n;
tbd=img->tbc_buf[i];
}
/*90*/ TKSPI_ReadSectors(tbd,lba,n);
return(tbd);
/*94*/ }
/*101*/ byte*TKFAT_GetSectorStaticBuffer(TKFAT_ImageInfo*img,int lba,int num)
/*103*/ {
int i;
/*106*/ for(i=0;i<img->sbc_num;i++)
if(img->sbc_lba[i]==lba)
{
return(img->sbc_buf[i]);
}
/*112*/ i=img->sbc_num++;
img->sbc_buf[i]=malloc((num&255)*512);
img->sbc_lba[i]=lba;
/*116*/ TKSPI_ReadSectors(img->sbc_buf[i],lba,num&255);
return(img->sbc_buf[i]);
/*119*/ }
/*123*/ void TKFAT_SetupImageMBR(TKFAT_ImageInfo*img)
{
int fsty;
/*127*/ if(!img->fsty)
{
fsty=0x06;
/*133*/ if(img->nImgBlks>130048)
{
fsty=0x0C;
}
}else
{
fsty=img->fsty;
}
/*142*/ img->fsty=fsty;
img->isfat16=(fsty==0x06);
img->lba_start=8;
img->lba_count=img->nImgBlks-8;
/*148*/ img->mbr=(TKFAT_MBR*)
TKFAT_GetSectorStaticBuffer(img,0,1|0x00000200);
/*151*/ memset(img->mbr,0,512);
img->mbr->entry[0].flag=0x00;
img->mbr->entry[0].fstype=fsty;
/*155*/ tkfat_setChs(&(img->mbr->entry[0].shead),img->lba_start);
tkfat_setChs(&(img->mbr->entry[0].ehead),img->lba_start+img->lba_count);
/*159*/ tkfat_setDWord(img->mbr->entry[0].lba_start,img->lba_start);
tkfat_setDWord(img->mbr->entry[0].lba_count,img->lba_count);
/*162*/ img->mbr->aa55[0]=0x55;
img->mbr->aa55[1]=0xAA;
}
/*166*/ char*tkfat_fstnameforfsty(int fsty)
{
char*s0;
/*170*/ switch(fsty)
{
case 0x00:s0="(none)";break;
case 0x06:s0="FAT16";break;
case 0x0B:s0="FAT32";break;
case 0x0C:s0="FAT32";break;
default:s0="?";break;
}
return(s0);
}
/*181*/ void TKFAT_ReadImageMBR(TKFAT_ImageInfo*img)
{
char*s0;
int lba,lbn,fsty;
int i;
/*187*/ printf("TKFAT_ReadImageMBR\n");
/*189*/ img->mbr=(TKFAT_MBR*)
TKFAT_GetSectorStaticBuffer(img,0,1);
/*193*/ for(i=0;i<4;i++)
{
fsty=img->mbr->entry[i].fstype;
lba=tkfat_getDWord(img->mbr->entry[i].lba_start);
lbn=tkfat_getDWord(img->mbr->entry[i].lba_count);
/*199*/ s0=tkfat_fstnameforfsty(fsty);
printf("  %08X %08X %02X %s\n",lba,lbn,fsty,s0);
}
/*203*/ img->fsty=img->mbr->entry[0].fstype;
img->lba_start=tkfat_getDWord(img->mbr->entry[0].lba_start);
img->lba_count=tkfat_getDWord(img->mbr->entry[0].lba_count);
/*207*/ img->isfat16=(img->fsty==0x06);
/*209*/ s0=tkfat_fstnameforfsty(img->fsty);
printf("TKFAT_ReadImageMBR: %08X %08X %02X %s\n",img->lba_start,img->lba_count,img->fsty,s0);
/*212*/ }
/*214*/ int TKFAT_GetFatEntry(TKFAT_ImageInfo*img,int clid)
{
byte*ofs;
int lba;
int i;
/*220*/ if(img->isfat16)
{
/*225*/ lba=img->lba_fat1+(clid>>8);
ofs=TKFAT_GetSectorTempBuffer(img,lba,1);
ofs+=(clid&255)*2;
/*229*/ i=ofs[0]+(ofs[1]<<8);
if(i>=0xFFF0)
i=(i<<16)>>16;
return(i);
}
/*236*/ lba=img->lba_fat1+(clid>>7);
ofs=TKFAT_GetSectorTempBuffer(img,lba,1);
ofs+=(clid&127)*4;
/*240*/ i=ofs[0]+(ofs[1]<<8)+(ofs[2]<<16)+(ofs[3]<<24);
if(i>=0x0FFFFFF0)
i=(i<<4)>>4;
return(i);
}
/*246*/ int TKFAT_SetFatEntry(TKFAT_ImageInfo*img,int clid,int val)
/*248*/ {
int lba1,lba2;
byte*ofs1,*ofs2;
int i;
/*253*/ if(img->isfat16)
{
lba1=img->lba_fat1+(clid>>8);
lba2=img->lba_fat2+(clid>>8);
ofs1=TKFAT_GetSectorTempBuffer(img,lba1,1|0x00000200);
/*259*/ ofs1+=(clid&255)*2;
ofs2=TKFAT_GetSectorTempBuffer(img,lba2,1|0x00000200);
/*262*/ ofs2+=(clid&255)*2;
/*266*/ ofs1[0]=val;ofs1[1]=val>>8;
ofs2[0]=val;ofs2[1]=val>>8;
return(0);
}
/*271*/ lba1=img->lba_fat1+(clid>>7);
lba2=img->lba_fat2+(clid>>7);
ofs1=TKFAT_GetSectorTempBuffer(img,lba1,1|0x00000200);
/*275*/ ofs1+=(clid&127)*4;
ofs2=TKFAT_GetSectorTempBuffer(img,lba2,1|0x00000200);
/*278*/ ofs2+=(clid&127)*4;
/*282*/ ofs1[0]=val;ofs1[1]=val>>8;ofs1[2]=val>>16;ofs1[3]=val>>24;
ofs2[0]=val;ofs2[1]=val>>8;ofs2[2]=val>>16;ofs2[3]=val>>24;
return(0);
}
/*288*/ int TKFAT_GetClusterLBA(TKFAT_ImageInfo*img,int clid)
{
return(img->lba_data+((clid-2)*img->szclust));
}
/*293*/ void TKFAT_SetupImageFAT(TKFAT_ImageInfo*img)
{
int fatsz,rootsz;
int cln,clsz,clsh;
int i,j,k;
/*299*/ if(img->lba_count<128)
{
printf("TKFAT_SetupImageFAT: Image LBA Size Bad\n");
return;
}
/*305*/ img->boot16=(TKFAT_FAT16_Boot*)
TKFAT_GetSectorStaticBuffer(img,img->lba_start,1|0x00000200);
/*308*/ img->boot32=(TKFAT_FAT32_Boot*)
img->boot16;
/*316*/ img->boot16->pad_jmp[0]=0xEB;
img->boot16->pad_jmp[1]=0x7F;
img->boot16->pad_jmp[2]=0x90;
img->boot16->aa55[0]=0x55;
img->boot16->aa55[1]=0xAA;
/*322*/ if(img->isfat16)
{
strcpy(img->boot16->oem_name,"BTESH2  ");
strcpy(img->boot16->vol_label,"DEFAULT    ");
strcpy(img->boot16->fs_tyname,"FAT16   ");
/*328*/ clsz=1;clsh=0;
cln=img->lba_count;
while(cln>65525)
{
clsh++;clsz=1<<clsh;
cln=img->lba_count>>clsh;
}
/*337*/ fatsz=(cln*2+511)>>9;
/*339*/ rootsz=(512*32+511)>>9;
/*341*/ tkfat_setWord(img->boot16->bytes_sector,512);
tkfat_setWord(img->boot16->reserved_sectors,2);
tkfat_setWord(img->boot16->root_dirents,512);
tkfat_setWord(img->boot16->lba_count16,0);
tkfat_setWord(img->boot16->sectors_fat,fatsz);
tkfat_setWord(img->boot16->sectors_track,64);
tkfat_setWord(img->boot16->heads,256);
/*349*/ tkfat_setDWord(img->boot16->hidden_sectors,0);
tkfat_setDWord(img->boot16->lba_count,img->lba_count);
tkfat_setDWord(img->boot16->vol_sn,rand()*rand());
/*353*/ img->boot16->sectors_cluster=clsz;
img->boot16->num_fats=2;
img->boot16->media_type=0xF8;
img->boot16->drive_id=0x80;
img->boot16->drive_flag=0x00;
img->boot16->ebsig=0x29;
/*360*/ img->lba_fat1=img->lba_start+2;
img->lba_fat2=img->lba_start+2+fatsz;
img->lba_root=img->lba_start+2+2*fatsz;
img->lba_data=img->lba_root+rootsz;
img->szclust=clsz;
img->shclust=9+clsh;
/*368*/ cln=((img->lba_start+img->lba_count)-img->lba_data)>>clsh;
img->tot_clust=cln;
/*371*/ TKFAT_SetFatEntry(img,0,0xFFFF);
TKFAT_SetFatEntry(img,1,0xFFFF);
/*374*/ printf("TKFAT_SetupImageFAT: Created FAT16\n");
printf("  LBA FAT1=%08X (Offs=%08X)\n",img->lba_fat1,img->lba_fat1<<9);
/*377*/ printf("  LBA FAT2=%08X (Offs=%08X)\n",img->lba_fat2,img->lba_fat2<<9);
/*379*/ printf("  LBA Root=%08X (Offs=%08X)\n",img->lba_root,img->lba_root<<9);
/*381*/ printf("  LBA Data=%08X (Offs=%08X)\n",img->lba_data,img->lba_data<<9);
/*383*/ printf("  %d Sectors/Cluster, %d bytes\n",clsz,512*clsz);
printf("  %d total clusters\n",img->tot_clust);
}else
{
strcpy(img->boot32->oem_name,"BTESH2  ");
strcpy(img->boot32->vol_label,"DEFAULT    ");
strcpy(img->boot32->fs_tyname,"FAT32   ");
/*391*/ clsz=1;clsh=0;
cln=img->lba_count;
while(cln>268435445)
{
clsh++;clsz=1<<clsh;
cln=img->lba_count>>clsh;
}
/*400*/ fatsz=(cln*4+511)>>9;
/*402*/ tkfat_setWord(img->boot32->bytes_sector,512);
tkfat_setWord(img->boot32->reserved_sectors,8);
tkfat_setWord(img->boot32->root_dirents,0);
tkfat_setWord(img->boot32->lba_count16,0);
tkfat_setWord(img->boot32->sectors_fat,0);
tkfat_setWord(img->boot32->sectors_track,64);
tkfat_setWord(img->boot32->heads,256);
/*410*/ tkfat_setWord(img->boot32->fsis_sector,0xFFFF);
tkfat_setWord(img->boot32->fsaltboot_sector,0xFFFF);
/*413*/ tkfat_setDWord(img->boot32->hidden_sectors,0);
tkfat_setDWord(img->boot32->lba_count,img->lba_count);
tkfat_setDWord(img->boot32->sectors_fat32,fatsz);
tkfat_setDWord(img->boot32->root_cluster,2);
tkfat_setDWord(img->boot32->vol_sn,rand()*rand());
/*419*/ img->boot32->sectors_cluster=clsz;
img->boot32->num_fats=2;
img->boot32->media_type=0xF8;
img->boot32->drive_id=0x80;
img->boot32->drive_flag=0x00;
img->boot32->ebsig=0x29;
/*426*/ img->lba_fat1=img->lba_start+8;
img->lba_fat2=img->lba_start+8+fatsz;
img->lba_data=img->lba_start+8+2*fatsz;
img->lba_root=img->lba_data;
img->szclust=clsz;
img->shclust=9+clsh;
/*434*/ cln=((img->lba_start+img->lba_count)-img->lba_data)>>clsh;
img->tot_clust=cln;
/*437*/ TKFAT_SetFatEntry(img,0,0x0FFFFFFF);
TKFAT_SetFatEntry(img,1,0x0FFFFFFF);
/*441*/ for(i=0;i<32;i++)
TKFAT_SetFatEntry(img,i+2,i+2+1);
TKFAT_SetFatEntry(img,31+2,0x0FFFFFFF);
/*445*/ printf("TKFAT_SetupImageFAT: Created FAT32\n");
/*447*/ printf("  FAT1 LBA=%08X Offs=%08X\n",img->lba_fat1,img->lba_fat1<<9);
/*449*/ printf("  FAT2 LBA=%08X Offs=%08X\n",img->lba_fat2,img->lba_fat2<<9);
/*451*/ printf("  Root LBA=%08X Offs=%08X\n",img->lba_root,img->lba_root<<9);
/*453*/ printf("  Data LBA=%08X Offs=%08X\n",img->lba_data,img->lba_data<<9);
/*455*/ printf("  %d Sectors/Cluster, %d bytes\n",clsz,512*clsz);
printf("  %d total clusters\n",img->tot_clust);
}
}
/*460*/ void TKFAT_ReadImageFAT(TKFAT_ImageInfo*img)
{
s64 lban,fatsz,cln;
int rootsz,rootnde,rootcl;
int clsz,clsh,rsvsec;
u32 i0,i1,i2,i3;
int i;
/*468*/ img->boot16=(TKFAT_FAT16_Boot*)
TKFAT_GetSectorStaticBuffer(img,img->lba_start,1);
/*471*/ img->boot32=(TKFAT_FAT32_Boot*)
img->boot16;
/*475*/ i0=tkfat_getWord(img->boot32->lba_count16);
i1=tkfat_getDWord(img->boot32->lba_count);
/*478*/ i2=tkfat_getWord(img->boot32->sectors_fat);
i3=tkfat_getDWord(img->boot32->sectors_fat32);
/*481*/ rsvsec=tkfat_getWord(img->boot32->reserved_sectors);
/*483*/ rootnde=tkfat_getWord(img->boot32->root_dirents);
clsz=img->boot32->sectors_cluster;
/*486*/ rootcl=tkfat_getDWord(img->boot32->root_cluster);
/*488*/ if((i0!=0)&&(i1!=0)&&(img->boot32->ebsig==0x29))
{
lban=(((s64)i0)<<32)|i1;
fatsz=(((s64)i2)<<32)|i3;
}else
{
lban=i0?i0:i1;
fatsz=i2?i2:i3;
if(!lban)
{
i0=tkfat_getDWord(img->boot32->fs_tyname+4);
i1=tkfat_getDWord(img->boot32->fs_tyname);
lban=(((s64)i0)<<32)|i1;
}
}
/*504*/ rootsz=0;
if(rootnde)
{rootsz=((rootnde*32)+511)>>9;}
/*508*/ if(!clsz||(clsz&(clsz-1)))
{
printf("TKFAT_ReadImageFAT: Bad Sectors/Cluster %d\n",clsz);
return;
}else
{
i=clsz;clsh=0;
while(i>1)
{i=i>>1;clsh++;}
}
/*519*/ if((img->boot32->ebsig!=0x29)|| !rootcl)
{
rootcl=1;
}
/*524*/ img->lba_fat1=img->lba_start+rsvsec;
img->lba_fat2=img->lba_start+rsvsec+fatsz;
img->lba_root=img->lba_start+rsvsec+2*fatsz;
img->lba_data=img->lba_root+rootsz;
img->szclust=clsz;
img->shclust=9+clsh;
/*533*/ cln=((img->lba_start+lban)-img->lba_data)>>clsh;
img->tot_clust=cln;
img->clid_root=rootcl;
/*537*/ img->isfat16=0;
if(cln<=65525)
img->isfat16=1;
/*541*/ printf("TKFAT_ReadImageFAT: Read FAT%d\n",img->isfat16?16:32);
printf("  LBA FAT1=%08X (Offs=%08X)\n",img->lba_fat1,img->lba_fat1<<9);
/*544*/ printf("  LBA FAT2=%08X (Offs=%08X)\n",img->lba_fat2,img->lba_fat2<<9);
/*546*/ printf("  LBA Root=%08X (Offs=%08X)\n",img->lba_root,img->lba_root<<9);
/*548*/ printf("  LBA Data=%08X (Offs=%08X)\n",img->lba_data,img->lba_data<<9);
/*550*/ printf("  %d Sectors/Cluster, %d bytes\n",clsz,512*clsz);
printf("  %d total clusters\n",img->tot_clust);
printf("  Root Cluster=%08X\n",img->clid_root);
}
/*556*/ int TKFAT_AllocFreeCluster(TKFAT_ImageInfo*img)
{
int n;
int i,j,k;
/*562*/ n=img->tot_clust;
/*564*/ for(i=2;i<n;i++)
{
j=TKFAT_GetFatEntry(img,i);
if(!j)
{
TKFAT_SetFatEntry(img,i,0x0FFFFFFF);
return(i);
}
}
return(-1);
}
/*580*/ int TKFAT_GetWalkCluster(TKFAT_ImageInfo*img,int clid,int cloffs,bool expand)
/*583*/ {
int i,j,n;
/*586*/ if(!clid)
return(-1);
/*589*/ i=clid;n=cloffs;
while(n>0)
{
j=TKFAT_GetFatEntry(img,i);
if(j<0)
{
if(!expand)
return(-1);
/*598*/ j=TKFAT_AllocFreeCluster(img);
if(j<=0)
return(-1);
TKFAT_SetFatEntry(img,i,j);
/*603*/ }
i=j;
n--;
}
return(i);
}
/*610*/ int TKFAT_GetClusterFileOffs(TKFAT_ImageInfo*img,int clid,int foffs,bool expand,int*rclid,int*rclfrac)
/*613*/ {
int cloffs,clfrac;
int cl2;
/*617*/ cloffs=foffs>>img->shclust;
clfrac=foffs&((1<<img->shclust)-1);
cl2=TKFAT_GetWalkCluster(img,clid,cloffs,expand);
if(cl2<0)return(-1);
/*622*/ *rclid=cl2;
*rclfrac=clfrac;
return(0);
}
/*627*/ int TKFAT_ReadWriteSector(TKFAT_ImageInfo*img,int lba,int offs,bool iswrite,byte*data,int size)
/*629*/ {
byte*clbuf;
/*633*/ if(iswrite)
{
clbuf=TKFAT_GetSectorTempBuffer(img,lba,1|0x00000200);
/*637*/ memcpy(clbuf+offs,data,size);
}
else
{
clbuf=TKFAT_GetSectorTempBuffer(img,lba,1);
/*643*/ memcpy(data,clbuf+offs,size);
}
return(0);
}
/*648*/ int TKFAT_ReadWriteCluster(TKFAT_ImageInfo*img,int clid,int offs,bool iswrite,byte*data,int size)
/*650*/ {
byte*clbuf;
int lba;
/*654*/ lba=TKFAT_GetClusterLBA(img,clid);
/*656*/ if(iswrite)
{
clbuf=TKFAT_GetSectorTempBuffer(img,lba,img->szclust|0x00000200);
/*660*/ memcpy(clbuf+offs,data,size);
}
else
{
clbuf=TKFAT_GetSectorTempBuffer(img,lba,img->szclust);
/*666*/ memcpy(data,clbuf+offs,size);
}
return(0);
}
/*671*/ int TKFAT_ReadWriteClusterOffset(TKFAT_ImageInfo*img,int clid,int foffs,bool iswrite,byte*data,int size)
/*674*/ {
byte*ct,*cte;
int clid1,clid2,clidt;
int offs1,offs2,szcl;
int i,j,k;
/*681*/ offs2=foffs+(size-1);
if((foffs>>img->shclust)==(offs2>>img->shclust))
{
i=TKFAT_GetClusterFileOffs(img,clid,foffs,iswrite,&clid1,&offs1);
/*686*/ if(i<0)return(i);
i=TKFAT_ReadWriteCluster(img,clid1,offs1,iswrite,data,size);
/*689*/ return(i);
}
/*692*/ i=TKFAT_GetClusterFileOffs(img,clid,foffs,iswrite,&clid1,&offs1);
/*694*/ j=TKFAT_GetClusterFileOffs(img,clid,foffs+(size-1),iswrite,&clid2,&offs2);
/*696*/ if(i<0)return(i);
if(j<0)return(j);
/*699*/ szcl=(1<<img->shclust);
ct=data;cte=data+size;
clidt=clid1;
TKFAT_ReadWriteCluster(img,clidt,offs1,iswrite,ct,szcl-offs1);
/*704*/ clidt=TKFAT_GetWalkCluster(img,clidt,1,iswrite);
ct+=szcl-offs1;
while((ct+szcl)<=cte)
{
TKFAT_ReadWriteCluster(img,clidt,0,iswrite,ct,szcl);
/*710*/ clidt=TKFAT_GetWalkCluster(img,clidt,1,iswrite);
if(clidt<0)
return(-1);
ct+=szcl;
}
if(ct<cte)
{
TKFAT_ReadWriteCluster(img,clidt,0,iswrite,ct,cte-ct);
/*719*/ }
return(0);
}
/*723*/ int TKFAT_ReadWriteDirEntOffset(TKFAT_ImageInfo*img,int clid,int idx,bool iswrite,void*de)
/*725*/ {
int i,n;
/*728*/ if(clid<=0)
return(-1);
/*731*/ if(clid==1)
{
if(idx<0)
return(-1);
n=tkfat_getWord(img->boot16->root_dirents);
if(idx>=n)
return(-1);
TKFAT_ReadWriteSector(img,img->lba_root+(idx>>4),(idx&15)<<5,iswrite,de,32);
/*740*/ return(0);
}
/*743*/ i=TKFAT_ReadWriteClusterOffset(img,clid,idx<<5,iswrite,de,32);
/*745*/ return(i);
}
/*748*/ int tkfat_name2sfn(char*name,char*sfn)
{
char*s,*t;
int i,j,k;
/*753*/ for(i=0;i<11;i++)
sfn[i]=' ';
/*756*/ s=name;t=sfn;
for(i=0;i<8;i++)
{
if(!(*s)||(*s=='.'))
break;
j= *s++;
if((j>='a')&&(j<='z'))
j='A'+(j-'a');
*t++ =j;
}
if(!(*s))
return(0);
if(*s!='.')
return(-1);
s++;
/*772*/ t=sfn+8;
for(i=0;i<3;i++)
{
if(!(*s)||(*s=='.'))
break;
j= *s++;
if((j>='a')&&(j<='z'))
j='A'+(j-'a');
*t++ =j;
}
if(*s)
return(-1);
return(0);
}
/*787*/ int tkfat_name2lfn(char*name,u16*lfn)
{
char*s;
u16*t,*te;
int i,j,k;
/*793*/ for(i=0;i<256;i++)
lfn[i]=0xFFFF;
/*796*/ s=name;t=lfn;te=t+256;
while(*s&&(t<te))
{
i= *s++;
if(!(i&0x80))
{*t++ =i;continue;}
if((i&0xE0)==0xC0)
{
j=((i&0x1F)<<6)|((*s++)&0x3F);
}else if((i&0xF0)==0xE0)
{
j=((i&0x0F)<<12)|(((s[0])&0x3F)<<6)|((s[1])&0x3F);
s+=2;
}else if((i&0xF8)==0xF0)
{
j=((i&0x07)<<18)|(((s[0])&0x3F)<<12)|
(((s[1])&0x3F)<<6)|((s[2])&0x3F);
s+=3;
}
if(j>=0x10000)
{
*t++ =0xD800+((j>>10)&1023);
*t++ =0xDC00+((j)&1023);
}else
{
*t++ =j;
}
}
*t=0;
return(0);
}
/*828*/ int tkfat_matchlfn(u16*lfn1,u16*lfn2)
{
u16*s1,*s2;
int i1,i2;
/*833*/ s1=lfn1;s2=lfn2;
i1= *s1;i2= *s2;
while(*s1&& *s2)
{
i1= *s1++;
i2= *s2++;
if((i1>='a')&&(i1<='z'))
i1='A'+(i1-'a');
if((i2>='a')&&(i2<='z'))
i2='A'+(i2-'a');
if(i1!=i2)
break;
}
if(i1>i2)return(1);
if(i2>i1)return(-1);
return(0);
}
/*851*/ int tkfat_lfnchecksum(char*name)
{
byte*s;
int i;
byte h;
/*857*/ s=(byte*)name;h=0;
for(i=0;i<11;i++)
h=((h&1)<<7)+(h>>1)+(*s++);
return(h&255);
}
/*863*/ static const int tkfat_tuc52[32]={
0x20AC,0x0081,0x201A,0x0192,0x201E,0x2026,0x2020,0x2021,
0x02C6,0x2030,0x0160,0x2039,0x0152,0x008D,0x017D,0xFFFF,
0x0090,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,
0x02DC,0x2122,0x0161,0x203A,0x0153,0x009C,0x017E,0x0178};
/*869*/ int tkfat_asc2ucs(int v)
{
if(!(v&0x80))
return(v);
if(v&0x60)
return(v);
return(tkfat_tuc52[v&0x1F]);
}
/*878*/ int tkfat_ucs2asc(int v)
{
int i;
if(!(v&0x80))
return(v);
if(v&0x60)
return(v);
for(i=0;i<32;i++)
if(v==tkfat_tuc52[i])
return(0x80+i);
return(v&255);
}
/*891*/ byte*tkfat_emitUtf8(byte*ct,int v)
{
if(v<0x80)
{*ct++ =v;}
else if(v<0x0800)
{
*ct++ =0xC0|((v>>6)&0x1F);
*ct++ =0x80|((v)&0x3F);
}
else if(v<0x10000)
{
*ct++ =0xE0|((v>>12)&0x0F);
*ct++ =0x80|((v>>6)&0x3F);
*ct++ =0x80|((v)&0x3F);
}
else if(v<0x200000)
{
*ct++ =0xF0|((v>>18)&0x07);
*ct++ =0x80|((v>>12)&0x3F);
*ct++ =0x80|((v>>6)&0x3F);
*ct++ =0x80|((v)&0x3F);
}
return(ct);
}
/*916*/ int tkfat_lfn2utf8(u16*lfn,byte*dst)
{
u16*cs;
byte*ct;
int i;
/*922*/ cs=lfn;ct=dst;
while(*cs)
{
i= *cs++;
ct=tkfat_emitUtf8(ct,i);
}
*ct++ =0;
return(0);
}
/*932*/ int tkfat_sfn2utf8(byte*sfn,int lcase,byte*dst)
{
byte*cs,*ct;
int i,j,k;
/*937*/ cs=sfn;ct=dst;
/*939*/ if(*cs<=' ')
return(-1);
if(lcase&0x20)
return(-1);
/*944*/ for(i=0;i<8;i++)
{
j= *cs++;
/*948*/ if((j<' ')||(j==0x7F))
return(-1);
/*951*/ if(j==' ')
{
for(k=i+1;k<8;k++)
if(sfn[k]>' ')
break;
if(k>=8)
break;
}
/*960*/ if(lcase&0x08)
{
if((j>='A')&&j<='Z')
j='a'+(j-'A');
}
/*966*/ j=tkfat_asc2ucs(j);
ct=tkfat_emitUtf8(ct,j);
/*969*/ }
/*971*/ cs=sfn+8;
if(*cs<' ')
return(-1);
if(*cs==' ')
{
*ct++ =0;
return(1);
}
/*980*/ *ct++ ='.';
/*982*/ for(i=0;i<3;i++)
{
j= *cs++;
/*986*/ if((j<' ')||(j==0x7F))
return(-1);
/*989*/ if(j==' ')
{
break;
}
/*994*/ if(lcase&0x10)
{
if((j>='A')&&j<='Z')
j='a'+(j-'A');
}
/*1001*/ j=tkfat_asc2ucs(j);
ct=tkfat_emitUtf8(ct,i);
}
*ct++ =0;
/*1006*/ return(1);
}
/*1009*/ int tkfat_lfn2bytes(u16*lfn,int sz,byte*dst)
{
u16*cs;
byte*ct;
int i,j,k;
/*1015*/ cs=lfn;ct=dst;
for(i=0;i<sz;i++)
{
j= *cs++;
*ct++ =tkfat_ucs2asc(j);
}
*ct++ =0;
return(0);
}
/*1025*/ int TKFAT_WalkDirEntNext(TKFAT_ImageInfo*img,TKFAT_FAT_DirEntExt*dee)
/*1027*/ {
TKFAT_FAT_DirEnt tdeb;
TKFAT_FAT_DirEnt*deb;
TKFAT_FAT_DirLfnEnt*del;
u16 bln[288];
u16 bln2[420];
u16 tln[288];
char tsn[12];
char*s;
int h0,h1,lh,clid,sidx;
int i,j,k;
/*1039*/ if(!img)
img=dee->img;
/*1042*/ clid=dee->clid;
sidx=(dee->idx>=0)?(dee->idx+1):0;
/*1045*/ deb= &tdeb;
del=(TKFAT_FAT_DirLfnEnt*)(&tdeb);
/*1048*/ for(k=0;k<288;k++)
{
bln[k]=0xFFFF;
bln2[k]=0xFFFF;
}
/*1054*/ bln[0]=0;
bln2[0]=0;
/*1057*/ for(i=sidx;i<65536;i++)
{
j=TKFAT_ReadWriteDirEntOffset(img,clid,i,0,deb);
if(j<0)break;
/*1062*/ if(deb->name[0]==0x00)
continue;
if(deb->name[0]==0xE5)
continue;
/*1067*/ if(deb->attrib==0x0F)
{
/*1071*/ j=(del->seq)&0x3F;
if((j>=0x01)&&j<=0x14)
{
h1=del->csum;
if(h1!=lh)
{
for(k=0;k<288;k++)
bln[k]=0xFFFF;
lh=h1;
}
/*1082*/ j=(del->seq)&0x1F;
/*1084*/ j=(j-1)*13;
if(del->type==0x20)
{
for(k=0;k<10;k++)
{bln[j+0+k]=tkfat_asc2ucs(del->name1[k]);}
for(k=0;k<12;k++)
{bln[j+5+k]=tkfat_asc2ucs(del->name2[k]);}
for(k=0;k<4;k++)
{bln[j+11+k]=tkfat_asc2ucs(del->name3[k]);}
if((del->seq)&0x40)
bln[j+26]=0;
}else if(del->type==0x00)
{
for(k=0;k<5;k++)
{bln[j+0+k]=tkfat_getWord(del->name1+k*2);}
/*1100*/ for(k=0;k<6;k++)
{bln[j+5+k]=tkfat_getWord(del->name2+k*2);}
/*1103*/ for(k=0;k<2;k++)
{bln[j+11+k]=tkfat_getWord(del->name3+k*2);}
/*1106*/ if((del->seq)&0x40)
bln[j+13]=0;
}
}
/*1112*/ j=(del->seq)&0x3F;
if((j>=0x21)&&j<=0x3D)
{
h1=del->csum;
if(h1!=lh)
{
for(k=0;k<288;k++)
bln2[k]=0xFFFF;
lh=h1;
}
/*1123*/ j=(del->seq)&0x1F;
/*1125*/ j=(j-1)*13;
if(del->type==0x20)
{
for(k=0;k<10;k++)
{bln2[j+0+k]=tkfat_asc2ucs(del->name1[k]);}
for(k=0;k<12;k++)
{bln2[j+5+k]=tkfat_asc2ucs(del->name2[k]);}
for(k=0;k<4;k++)
{bln2[j+11+k]=tkfat_asc2ucs(del->name3[k]);}
if((del->seq)&0x40)
bln2[j+26]=0;
}else if(del->type==0x00)
{
for(k=0;k<5;k++)
{bln2[j+0+k]=tkfat_getWord(del->name1+k*2);}
/*1141*/ for(k=0;k<6;k++)
{bln2[j+5+k]=tkfat_getWord(del->name2+k*2);}
/*1144*/ for(k=0;k<2;k++)
{bln2[j+11+k]=tkfat_getWord(del->name3+k*2);}
/*1147*/ if((del->seq)&0x40)
bln2[j+13]=0;
}
}
/*1152*/ continue;
}
/*1155*/ h0=tkfat_lfnchecksum(deb->name);
/*1159*/ if(1)
{
if(h0==h1)
{
tkfat_lfn2utf8(bln,dee->de_name);
/*1165*/ dee->de_aname[0]=0;
if(bln2[0]&&(bln2[0]!=0xFFFF))
tkfat_lfn2utf8(bln2,dee->de_aname);
if(deb->attrib==0x28)
tkfat_lfn2bytes(bln2,384,dee->de_aname);
}else
{
j=tkfat_sfn2utf8(deb->name,deb->lncase,dee->de_name);
if(j<0)
{
printf("TKFAT_WalkDirEntNext: Reject DirEnt\n");
continue;
}
dee->de_aname[0]=0;
}
/*1181*/ dee->deb= *deb;
/*1184*/ dee->idx=i;
/*1187*/ return(i);
}
}
/*1191*/ return(-1);
}
/*1195*/ int TKFAT_LookupDirEntName(TKFAT_ImageInfo*img,int clid,TKFAT_FAT_DirEntExt*dee,char*name)
/*1197*/ {
TKFAT_FAT_DirEnt tdeb;
TKFAT_FAT_DirEnt*deb;
TKFAT_FAT_DirLfnEnt*del;
u16 bln[288];
u16 bln2[420];
u16 tln[288];
char tsn[12];
char*s;
int h0,h1,lh;
int i,j,k;
/*1209*/ deb= &tdeb;
del=(TKFAT_FAT_DirLfnEnt*)(&tdeb);
/*1212*/ lh= -1;
i=tkfat_name2sfn(name,tsn);
if(i>=0)
{
for(i=0;i<65536;i++)
{
j=TKFAT_ReadWriteDirEntOffset(img,clid,i,0,deb);
if(j<0)break;
/*1221*/ if(deb->name[0]==0x00)
continue;
if(deb->name[0]==0xE5)
continue;
/*1226*/ if(!memcmp(deb->name,tsn,11))
{
dee->deb=tdeb;
dee->img=img;
dee->clid=clid;
dee->idx=i;
strcpy(dee->de_name,name);
return(i);
}
}
return(-1);
}
/*1239*/ tkfat_name2lfn(name,tln);
/*1241*/ for(i=0;i<65536;i++)
{
j=TKFAT_ReadWriteDirEntOffset(img,clid,i,0,deb);
if(j<0)break;
/*1246*/ if(deb->name[0]==0x00)
continue;
if(deb->name[0]==0xE5)
continue;
/*1251*/ if(deb->attrib==0x0F)
{
/*1255*/ j=(del->seq)&0x3F;
if((j>=0x01)&&j<=0x14)
{
h1=del->csum;
if(h1!=lh)
{
for(k=0;k<288;k++)
bln[k]=0xFFFF;
lh=h1;
}
/*1266*/ j=(del->seq)&0x1F;
/*1268*/ j=(j-1)*13;
if(del->type==0x20)
{
for(k=0;k<10;k++)
{bln[j+0+k]=tkfat_asc2ucs(del->name1[k]);}
for(k=0;k<12;k++)
{bln[j+5+k]=tkfat_asc2ucs(del->name2[k]);}
for(k=0;k<4;k++)
{bln[j+11+k]=tkfat_asc2ucs(del->name3[k]);}
if((del->seq)&0x40)
bln[j+26]=0;
}else if(del->type==0x00)
{
for(k=0;k<5;k++)
{bln[j+0+k]=tkfat_getWord(del->name1+k*2);}
/*1284*/ for(k=0;k<6;k++)
{bln[j+5+k]=tkfat_getWord(del->name2+k*2);}
/*1287*/ for(k=0;k<2;k++)
{bln[j+11+k]=tkfat_getWord(del->name3+k*2);}
/*1290*/ if((del->seq)&0x40)
bln[j+13]=0;
}
}
/*1296*/ j=(del->seq)&0x3F;
if((j>=0x21)&&j<=0x3D)
{
h1=del->csum;
if(h1!=lh)
{
for(k=0;k<288;k++)
bln2[k]=0xFFFF;
lh=h1;
}
/*1307*/ j=(del->seq)&0x1F;
/*1309*/ j=(j-1)*13;
if(del->type==0x20)
{
for(k=0;k<10;k++)
{bln2[j+0+k]=tkfat_asc2ucs(del->name1[k]);}
for(k=0;k<12;k++)
{bln2[j+5+k]=tkfat_asc2ucs(del->name2[k]);}
for(k=0;k<4;k++)
{bln2[j+11+k]=tkfat_asc2ucs(del->name3[k]);}
if((del->seq)&0x40)
bln2[j+26]=0;
}else if(del->type==0x00)
{
for(k=0;k<5;k++)
{bln2[j+0+k]=tkfat_getWord(del->name1+k*2);}
/*1325*/ for(k=0;k<6;k++)
{bln2[j+5+k]=tkfat_getWord(del->name2+k*2);}
/*1328*/ for(k=0;k<2;k++)
{bln2[j+11+k]=tkfat_getWord(del->name3+k*2);}
/*1331*/ if((del->seq)&0x40)
bln2[j+13]=0;
}
}
/*1336*/ continue;
}
/*1339*/ h0=tkfat_lfnchecksum(deb->name);
/*1341*/ if((h0==h1)&& !tkfat_matchlfn(bln,tln))
{
dee->deb= *deb;
dee->img=img;
dee->clid=clid;
dee->idx=i;
strcpy(dee->de_name,name);
return(i);
}
}
/*1352*/ return(-1);
}
/*1355*/ int TKFAT_CreateDirEntName(TKFAT_ImageInfo*img,int clid,TKFAT_FAT_DirEntExt*dee,char*name)
/*1357*/ {
TKFAT_FAT_DirEnt tdeb;
TKFAT_FAT_DirEnt*deb;
TKFAT_FAT_DirLfnEnt*del;
/*1362*/ u16 tln[258];
char tsn[12];
char*s;
int h0,h1,lh,li,n;
int i,j,k,l;
/*1368*/ i=TKFAT_LookupDirEntName(img,clid,dee,name);
if(i>=0)
return(i);
/*1372*/ deb= &tdeb;
del=(TKFAT_FAT_DirLfnEnt*)(&tdeb);
/*1375*/ lh= -1;
i=tkfat_name2sfn(name,tsn);
if(i>=0)
{
for(i=0;i<65536;i++)
{
j=TKFAT_ReadWriteDirEntOffset(img,clid,i,0,deb);
if(j<0)
{
memset(deb,0,32);
j=TKFAT_ReadWriteDirEntOffset(img,clid,i,1,deb);
/*1387*/ if(j<0)
break;
}
/*1391*/ if((deb->name[0]==0x00)||(deb->name[0]==0xE5))
{
memset(deb,0,32);
memcpy(deb->name,tsn,11);
TKFAT_ReadWriteDirEntOffset(img,clid,i,1,deb);
/*1398*/ dee->deb=tdeb;
dee->img=img;
dee->clid=clid;
dee->idx=i;
strcpy(dee->de_name,name);
return(i);
}
}
return(-1);
}
/*1412*/ tkfat_name2lfn(name,tln);
for(l=0;tln[l];l++);
lh=1+((l+13)/13);
/*1416*/ h0=0;
for(i=0;tln[i];i++)
{
/*1420*/ h0=(h0*4093)+tln[i]+1;
}
memset(tsn,0,11);
tsn[0]=' ';
tsn[1]=0;
tkfat_setDWord(tsn+2,h0);
tsn[5]=':';
h1=tkfat_lfnchecksum(tsn);
/*1429*/ li=0;
for(i=0;i<65536;i++)
{
j=TKFAT_ReadWriteDirEntOffset(img,clid,i,0,deb);
if(j<0)
{
memset(deb,0,32);
j=TKFAT_ReadWriteDirEntOffset(img,clid,i,1,deb);
/*1438*/ if(j<0)
break;
}
/*1442*/ if((deb->name[0]==0x00)||(deb->name[0]==0xE5))
{
if((i-li)>=lh)
break;
continue;
}
li=i+1;
continue;
}
/*1452*/ if((i<65536)&&(j>=0)&&(i-li)>=lh)
{
n=lh-1;
for(i=0;i<n;i++)
{
memset(del,0,32);
/*1459*/ del->seq=n-i;
if(!i)del->seq|=0x40;
del->attrib=0x0F;
del->csum=h1;
/*1464*/ j=(n-i-1)*13;
/*1466*/ for(k=0;k<5;k++)
{tkfat_setWord(del->name1+k*2,tln[j+0+k]);}
for(k=0;k<6;k++)
{tkfat_setWord(del->name2+k*2,tln[j+5+k]);}
for(k=0;k<2;k++)
{tkfat_setWord(del->name3+k*2,tln[j+11+k]);}
/*1473*/ TKFAT_ReadWriteDirEntOffset(img,clid,li+i,1,del);
/*1475*/ }
/*1477*/ memset(deb,0,32);
/*1479*/ memcpy(deb->name,tsn,11);
TKFAT_ReadWriteDirEntOffset(img,clid,li+i,1,deb);
/*1483*/ dee->deb=tdeb;
dee->img=img;
dee->clid=clid;
dee->idx=li+i;
strcpy(dee->de_name,name);
return(i);
}
/*1491*/ return(-1);
}
/*1494*/ int TKFAT_CreateDirEntPathR(TKFAT_ImageInfo*img,int clid,TKFAT_FAT_DirEntExt*dee,char*name)
/*1496*/ {
TKFAT_FAT_DirEntExt tdee;
char tb[256];
char*s,*t;
int i;
/*1502*/ s=name;
t=tb;
while(*s&&(*s!='/'))
{*t++ = *s++;}
*t++ =0;
if(*s=='/')s++;
/*1509*/ if(*s)
{
i=TKFAT_CreateDirEntName(img,clid,&tdee,tb);
if(i<0)
{
printf("TKFAT_CreateDirEntPathR: " "Failed Recurse %s\n",tb);
/*1516*/ return(i);
}
TKFAT_SetupDirEntNewDirectory(&tdee);
/*1520*/ i=TKFAT_CreateDirEntPathR(img,tdee.clid,dee,s);
return(i);
}
/*1524*/ i=TKFAT_CreateDirEntName(img,clid,dee,tb);
return(i);
}
/*1528*/ int TKFAT_CreateDirEntPath(TKFAT_ImageInfo*img,TKFAT_FAT_DirEntExt*dee,char*name)
/*1532*/ {
int clid;
int i;
/*1536*/ clid=img->isfat16?1:2;
/*1538*/ i=TKFAT_CreateDirEntPathR(img,clid,dee,name);
return(i);
}
/*1543*/ int TKFAT_LookupDirEntPathR(TKFAT_ImageInfo*img,int clid,TKFAT_FAT_DirEntExt*dee,char*name)
/*1545*/ {
TKFAT_FAT_DirEntExt tdee;
char tb[256];
char*s,*t;
int i;
/*1551*/ s=name;
t=tb;
while(*s&&(*s!='/'))
{*t++ = *s++;}
*t++ =0;
if(*s=='/')s++;
/*1558*/ if(*s)
{
i=TKFAT_LookupDirEntName(img,clid,&tdee,tb);
if(i<0)
{
printf("TKFAT_CreateDirEntPathR: " "Failed Recurse %s\n",tb);
/*1565*/ return(i);
}
/*1569*/ i=TKFAT_LookupDirEntPathR(img,tdee.clid,dee,s);
return(i);
}
/*1573*/ i=TKFAT_LookupDirEntName(img,clid,dee,tb);
return(i);
}
/*1577*/ int TKFAT_LookupDirEntPath(TKFAT_ImageInfo*img,TKFAT_FAT_DirEntExt*dee,char*name)
/*1581*/ {
int clid;
int i;
/*1585*/ clid=img->isfat16?1:2;
i=TKFAT_LookupDirEntPathR(img,clid,dee,name);
return(i);
}
/*1590*/ int TKFAT_UpdateDirEnt(TKFAT_FAT_DirEntExt*dee)
/*1592*/ {
int i;
i=TKFAT_ReadWriteDirEntOffset(dee->img,dee->clid,dee->idx,1,&(dee->deb));
/*1596*/ return(i);
}
/*1599*/ u32 TKFAT_GetDirEntCluster(TKFAT_FAT_DirEntExt*dee)
/*1601*/ {
int i,j;
i=tkfat_getWord(dee->deb.cluster_lo);
j=tkfat_getWord(dee->deb.cluster_hi);
return(i|(j<<16));
}
/*1608*/ int TKFAT_SetDirEntCluster(TKFAT_FAT_DirEntExt*dee,u32 clid)
/*1611*/ {
tkfat_setWord(dee->deb.cluster_lo,clid);
tkfat_setWord(dee->deb.cluster_hi,clid>>16);
return(0);
}
/*1617*/ u32 TKFAT_GetDirEntSize(TKFAT_FAT_DirEntExt*dee)
/*1619*/ {
u32 i;
i=tkfat_getDWord(dee->deb.filesize);
return(i);
}
/*1625*/ int TKFAT_SetDirEntSize(TKFAT_FAT_DirEntExt*dee,u32 sz)
/*1627*/ {
tkfat_setDWord(dee->deb.filesize,sz);
return(0);
}
/*1632*/ int TKFAT_ReadWriteDirEntFile(TKFAT_FAT_DirEntExt*dee,u32 offs,bool iswrite,byte*data,int size)
/*1636*/ {
u32 dcli,dsz;
bool upd;
int i,sz;
/*1641*/ if(iswrite)
{
upd=0;
dcli=TKFAT_GetDirEntCluster(dee);
dsz=TKFAT_GetDirEntSize(dee);
if(!dcli)
{
dcli=TKFAT_AllocFreeCluster(dee->img);
TKFAT_SetDirEntCluster(dee,dcli);
upd=1;
}
/*1653*/ if((offs+size)>dsz)
{
dsz=offs+size;
TKFAT_SetDirEntSize(dee,dsz);
upd=1;
}
/*1660*/ if(upd)
TKFAT_UpdateDirEnt(dee);
/*1663*/ i=TKFAT_ReadWriteClusterOffset(dee->img,dcli,offs,1,data,size);
/*1665*/ return(i);
}
/*1668*/ dcli=TKFAT_GetDirEntCluster(dee);
dsz=TKFAT_GetDirEntSize(dee);
/*1671*/ if(offs>=dsz)
return(0);
/*1674*/ sz=size;
if((offs+size)>dsz)
{sz=dsz-offs;}
/*1678*/ i=TKFAT_ReadWriteClusterOffset(dee->img,dcli,offs,0,data,sz);
/*1680*/ if(i<0)
return(i);
return(sz);
}
/*1685*/ int TKFAT_SetupDirEntNewDirectory(TKFAT_FAT_DirEntExt*dee)
/*1687*/ {
TKFAT_FAT_DirEnt tdeb;
TKFAT_FAT_DirEnt*deb;
u32 dcli,pcli;
/*1692*/ dcli=TKFAT_GetDirEntCluster(dee);
if(dcli)
{
if(dee->deb.attrib&0x10)
return(0);
return(-1);
}
/*1700*/ dee->deb.attrib|=0x10;
if(!dcli)
{
dcli=TKFAT_AllocFreeCluster(dee->img);
TKFAT_SetDirEntCluster(dee,dcli);
}
/*1707*/ TKFAT_UpdateDirEnt(dee);
/*1709*/ deb= &tdeb;
memset(deb,0,sizeof(TKFAT_FAT_DirEnt));
/*1712*/ strcpy(deb->name,".          ");
deb->attrib|=0x10;
tkfat_setWord(deb->cluster_lo,dcli);
tkfat_setWord(deb->cluster_hi,dcli>>16);
/*1717*/ TKFAT_ReadWriteDirEntOffset(dee->img,dcli,0,1,deb);
/*1720*/ pcli=dee->clid;
if(pcli<2)pcli=0;
strcpy(deb->name,"..         ");
deb->attrib|=0x10;
tkfat_setWord(deb->cluster_lo,pcli);
tkfat_setWord(deb->cluster_hi,pcli>>16);
/*1727*/ TKFAT_ReadWriteDirEntOffset(dee->img,dcli,1,1,deb);
/*1729*/ return(1);
}
/*1737*/ int TKFAT_ListDir(TKFAT_ImageInfo*img,int clid)
{
TKFAT_FAT_DirEntExt tdee;
TKFAT_FAT_DirEntExt*dee;
int i,j;
/*1743*/ dee= &tdee;
memset(dee,0,sizeof(TKFAT_FAT_DirEntExt));
/*1746*/ dee->img=img;
dee->clid=clid;
dee->idx= -1;
/*1750*/ while(1)
{
i=TKFAT_WalkDirEntNext(img,dee);
if(i<0)break;
/*1755*/ printf("%s\n",dee->de_name);
}
/*1758*/ return(0);
}
/*1761*/ char*TK_BufGetLine(char*tbuf,char*str,char*stre)
{
char*s,*t;
/*1765*/ s=str;t=tbuf;
while(*s&&(s<stre))
{
if(*s=='\r')
break;
if(*s=='\n')
break;
*t++ = *s++;
}
*t=0;
/*1776*/ if(*s=='\r')s++;
if(*s=='\n')s++;
return(s);
}
/*1781*/ char* *TK_SplitLine(char*buf)
{
static char*ta[64];
static char tb[512];
char* *a;
char*s,*t,*t0;
/*1788*/ a=ta;s=buf;t=tb;
while(*s)
{
if(*s<=' ')
{
while(*s&& *s<=' ')
s++;
continue;
}
/*1798*/ if(*s=='\"')
{
s++;
t0=t;
while(*s&&(*s!='\"'))
{
if(*s=='\\')
{
s++;
switch(*s)
{
case'b':s++;*t++ ='\x08';break;
/*1811*/ case'n':s++;*t++ ='\n';break;
case'r':s++;*t++ ='\r';break;
case't':s++;*t++ ='\t';break;
case'\\':s++;*t++ ='\\';break;
default:
*t++ = *s++;
break;
}
continue;
}
*t++ = *s++;
}
*t++ =0;
*a++ =t0;
continue;
}
/*1828*/ t0=t;
while(*s&&(*s>' '))
{*t++ = *s++;}
*t++ =0;
*a++ =t0;
}
*a++ =((void*)0);
return(ta);
}
/*"tk_core/tk_vfile.c"3*/ char kerninit[256];
/*5*/ TK_FILE*tk_vf_freelist=((void*)0);
TK_FILE_VT*tk_fsty_root=((void*)0);
TK_MOUNT*tk_vf_mount=((void*)0);
/*9*/ int tk_vf_register(TK_FILE_VT*fsty)
{
fsty->next=tk_fsty_root;
tk_fsty_root=fsty;
}
/*15*/ int tk_vfile_init()
{
static int init=0;
/*19*/ if(init)return(0);
init=1;
/*22*/ tk_ird_init();
tk_fat_init();
return(1);
}
/*27*/ TK_FILE*tk_alloc_file()
{
TK_FILE*tmp;
/*31*/ tmp=tk_vf_freelist;
if(tmp)
{
tk_vf_freelist=tmp->udata0;
memset(tmp,0,sizeof(TK_FILE));
return(tmp);
}
/*39*/ tmp=malloc(sizeof(TK_FILE));
memset(tmp,0,sizeof(TK_FILE));
return(tmp);
}
/*44*/ void tk_free_file(TK_FILE*tmp)
{
tmp->udata0=tk_vf_freelist;
tk_vf_freelist=tmp;
}
/*"tk_vf_ird.c"1*/ TK_MOUNT*tk_ird_mount(char*devfn,char*mntfn,char*fsty,char*mode,char* *opts);
/*3*/ TK_FILE*tk_ird_fopen(TK_MOUNT*mnt,char*name,char*mode);
/*5*/ int tk_ird_fread(void*buf,int sz1,int sz2,TK_FILE*fd);
int tk_ird_fseek(TK_FILE*fd,int ofs,int rel);
int tk_ird_ftell(TK_FILE*fd);
int tk_ird_fclose(TK_FILE*fd);
int tk_ird_fgetc(TK_FILE*fd);
/*11*/ TK_FILE_VT tk_vfile_ird_vt={
"initrd",
((void*)0),
tk_ird_mount,
tk_ird_fopen,
((void*)0),
((void*)0),
((void*)0),
((void*)0),
/*22*/ tk_ird_fread,
((void*)0),
tk_ird_fseek,
tk_ird_ftell,
tk_ird_fclose,
tk_ird_fgetc,
((void*)0)
};
/*31*/ int tk_ird_init()
{
u32 reladdr;
byte*ird;
/*36*/ if(tk_ird_imgbuf)
return(0);
/*39*/ reladdr=(*(vol_u32*)0x1003F010);
if(!reladdr)
{
tk_puts("tk_ird_init: no initrd\n");
tk_ird_imgbuf=((void*)0);
return(-1);
}else
{
tk_printf("tk_ird_init: OK %08X\n",reladdr);
}
/*50*/ tk_vf_register(&tk_vfile_ird_vt);
/*52*/ strcpy(kerninit,((char*)0x1003F100));
/*56*/ ird=(byte*)(0x8C000000+reladdr);
/*60*/ tk_ird_imgbuf=ird;
tk_printf("tk_ird_init: IRD=%p\n",tk_ird_imgbuf);
return(1);
}
/*65*/ TK_MOUNT*tk_ird_mount(char*devfn,char*mntfn,char*fsty,char*mode,char* *opts)
/*67*/ {
}
/*70*/ int tk_ird_decoctal_n(byte*cs,int n)
{
int i,v;
/*74*/ v=0;
for(i=0;i<n;i++)
{
v=(v*8)+(cs[i]-'0');
}
return(v);
}
/*82*/ TK_FILE*tk_ird_fopen(TK_MOUNT*mnt,char*name,char*mode)
{
TK_FILE*fd;
u32 reladdr;
byte*ird;
byte*cs;
int sz;
/*90*/ if((mode[0]!='r')||(mode[1]=='+'))
{
tk_puts("tk_ird_fopen: bad mode\n");
return(((void*)0));
}
/*96*/ ird=tk_ird_imgbuf;
if(!ird)
{
tk_puts("tk_ird_fopen: no initrd\n");
return(((void*)0));
}
/*103*/ cs=ird;
while(cs[0])
{
sz=tk_ird_decoctal_n(cs+124,11);
/*108*/ if(!strcmp(cs,name))
{
fd=tk_alloc_file();
fd->vt= &tk_vfile_ird_vt;
fd->ram_base=cs+0x200;
fd->ram_end=fd->ram_base+sz;
fd->ram_ofs=fd->ram_base;
/*116*/ tk_printf("tk_ird_fopen: %s %08X %08X\n",name,fd->ram_base,fd->ram_end);
/*118*/ return(fd);
}
/*121*/ sz=(sz+511)&(~511);
cs+=512+sz;
}
/*125*/ tk_printf("tk_ird_fopen: can\'t find %s\n",name);
return(((void*)0));
}
/*129*/ int tk_ird_fseek(TK_FILE*fd,int ofs,int rel)
{
if(fd->ram_base)
{
if(rel==0)
{
if(ofs<0)
return(-1);
if(ofs>(fd->ram_end-fd->ram_base))
return(-1);
fd->ram_ofs=fd->ram_base+ofs;
return(0);
}
/*143*/ if(rel==1)
{
fd->ram_ofs=fd->ram_ofs+ofs;
if(fd->ram_ofs>fd->ram_end)
fd->ram_ofs=fd->ram_end;
if(fd->ram_ofs<fd->ram_base)
fd->ram_ofs=fd->ram_base;
return(0);
}
/*153*/ if(rel==2)
{
if(ofs>0)
return(-1);
if((-ofs)>(fd->ram_end-fd->ram_base))
return(-1);
fd->ram_ofs=fd->ram_end+ofs;
return(0);
}
/*163*/ return(-1);
}
/*166*/ return(-1);
}
/*169*/ int tk_ird_fread(void*buf,int sz1,int sz2,TK_FILE*fd)
{
int sz;
/*173*/ if(fd->ram_base)
{
sz=sz1*sz2;
if((fd->ram_ofs+sz)>fd->ram_end)
{sz=fd->ram_end-fd->ram_ofs;}
if(sz<=0)return(0);
memcpy(buf,fd->ram_ofs,sz);
fd->ram_ofs+=sz;
return(sz);
}
/*184*/ return(-1);
}
/*187*/ int tk_ird_fgetc(TK_FILE*fd)
{
int i;
/*191*/ if(fd->ram_base)
{
if(fd->ram_ofs>=fd->ram_end)
{fd->ram_ofs=fd->ram_end;return(-1);}
/*196*/ i= *fd->ram_ofs++;
return(i);
}
/*200*/ return(-1);
}
/*203*/ int tk_ird_ftell(TK_FILE*fd)
{
int i;
if(fd->ram_base)
{
i=fd->ram_ofs-fd->ram_base;
return(i);
}
/*212*/ return(-1);
}
/*215*/ int tk_ird_fclose(TK_FILE*fd)
{
return(-1);
}
/*"tk_vf_fat.c"1*/ TK_MOUNT*tk_fat_mount(char*devfn,char*mntfn,char*fsty,char*mode,char* *opts);
/*3*/ TK_FILE*tk_fat_fopen(TK_MOUNT*mnt,char*name,char*mode);
/*5*/ int tk_fat_fread(void*buf,int sz1,int sz2,TK_FILE*fd);
int tk_fat_fwrite(void*buf,int sz1,int sz2,TK_FILE*fd);
int tk_fat_fseek(TK_FILE*fd,int ofs,int rel);
int tk_fat_ftell(TK_FILE*fd);
int tk_fat_fclose(TK_FILE*fd);
int tk_fat_fgetc(TK_FILE*fd);
int tk_fat_fputc(int ch,TK_FILE*fd);
/*13*/ TK_FILE_VT tk_vfile_fat_vt={
"vfat",
((void*)0),
tk_fat_mount,
tk_fat_fopen,
((void*)0),
((void*)0),
((void*)0),
((void*)0),
/*24*/ tk_fat_fread,
tk_fat_fwrite,
tk_fat_fseek,
tk_fat_ftell,
tk_fat_fclose,
tk_fat_fgetc,
tk_fat_fputc
};
/*33*/ int tk_fat_init()
{
tk_vf_register(&tk_vfile_fat_vt);
return(1);
}
/*39*/ TK_MOUNT*tk_fat_mount(char*devfn,char*mntfn,char*fsty,char*mode,char* *opts)
/*41*/ {
}
/*44*/ TK_FILE*tk_fat_fopen(TK_MOUNT*mnt,char*name,char*mode)
{
TKFAT_FAT_DirEntExt tdee;
TKFAT_FAT_DirEntExt*dee,*dee2;
TKFAT_ImageInfo*img;
TK_FILE*fd;
int i;
/*52*/ img=mnt->udata0;
dee= &tdee;
i=TKFAT_LookupDirEntPath(img,dee,name);
if(i<0)
{return(((void*)0));}
/*58*/ dee2=malloc(sizeof(TKFAT_FAT_DirEntExt));
memcpy(dee2,dee,sizeof(TKFAT_FAT_DirEntExt));
/*61*/ fd=tk_alloc_file();
fd->vt= &tk_vfile_fat_vt;
fd->udata0=img;
fd->udata1=dee2;
fd->ofs=0;
fd->size=TKFAT_GetDirEntSize(dee2);
/*68*/ return(fd);
}
/*71*/ int tk_fat_fseek(TK_FILE*fd,int ofs,int rel)
{
if(rel==0)
{
fd->ofs=ofs;
if(fd->ofs<0)
fd->ofs=0;
if(fd->ofs>fd->size)
fd->ofs=fd->size;
return(fd->ofs);
}
/*83*/ if(rel==1)
{
fd->ofs=fd->ofs+ofs;
if(fd->ofs<0)
fd->ofs=0;
if(fd->ofs>fd->size)
fd->ofs=fd->size;
return(fd->ofs);
}
/*93*/ if(rel==2)
{
fd->ofs=fd->size+ofs;
if(fd->ofs<0)
fd->ofs=0;
if(fd->ofs>fd->size)
fd->ofs=fd->size;
return(fd->ofs);
}
/*103*/ return(-1);
}
/*106*/ int tk_fat_ftell(TK_FILE*fd)
{
return(fd->ofs);
}
/*111*/ int tk_fat_fclose(TK_FILE*fd)
{
free(fd->udata1);
return(0);
}
/*117*/ int tk_fat_fread(void*buf,int sz1,int sz2,TK_FILE*fd)
{
int sz;
/*121*/ sz=sz1*sz2;
sz=TKFAT_ReadWriteDirEntFile(fd->udata1,fd->ofs,0,buf,sz);
/*124*/ return(sz);
}
/*127*/ int tk_fat_fwrite(void*buf,int sz1,int sz2,TK_FILE*fd)
{
int sz;
/*131*/ sz=sz1*sz2;
sz=TKFAT_ReadWriteDirEntFile(fd->udata1,fd->ofs,1,buf,sz);
/*134*/ return(sz);
}
/*137*/ int tk_fat_fgetc(TK_FILE*fd)
{
byte buf[4];
tk_fat_fread(buf,1,1,fd);
return(buf[0]);
}
/*144*/ int tk_fat_fputc(int ch,TK_FILE*fd)
{
byte buf[4];
ch=(byte)ch;
buf[0]=ch;
tk_fat_fwrite(buf,1,1,fd);
return(ch);
}
/*"tk_core/tk_vfile.c"53*/ TK_FILE*tk_fopen(char*name,char*mode)
{
TK_MOUNT*mnt;
TK_FILE*fd;
/*58*/ tk_vfile_init();
/*60*/ if((name[0]=='.')&&(name[1]=='/'))
name+=2;
if(*name=='/')
name++;
/*65*/ fd=tk_ird_fopen(((void*)0),name,mode);
if(fd)return(fd);
/*68*/ mnt=tk_vf_mount;
while(mnt)
{
fd=mnt->vt->fopen(mnt,name,mode);
if(fd)
return(fd);
mnt=mnt->next;
}
/*77*/ return(((void*)0));
}
/*80*/ int tk_fread(void*buf,int sz1,int sz2,TK_FILE*fd)
{
if(fd->vt->fread)
return(fd->vt->fread(buf,sz1,sz2,fd));
return(-1);
}
/*87*/ int tk_fwrite(void*buf,int sz1,int sz2,TK_FILE*fd)
{
if(fd->vt->fwrite)
return(fd->vt->fwrite(buf,sz1,sz2,fd));
return(-1);
}
/*94*/ int tk_fseek(TK_FILE*fd,int ofs,int rel)
{
if(fd->vt->fseek)
return(fd->vt->fseek(fd,ofs,rel));
return(-1);
}
/*101*/ int tk_ftell(TK_FILE*fd)
{
if(fd->vt->ftell)
return(fd->vt->ftell(fd));
return(-1);
}
/*108*/ int tk_fclose(TK_FILE*fd)
{
if(fd->vt->fclose)
return(fd->vt->fclose(fd));
return(-1);
}
/*115*/ int tk_fgetc(TK_FILE*fd)
{
if(fd->vt->fgetc)
return(fd->vt->fgetc(fd));
return(-1);
}
/*122*/ int tk_fputc(int ch,TK_FILE*fd)
{
if(fd->vt->fputc)
return(fd->vt->fputc(ch,fd));
return(-1);
}
/*"pdpc201/btshx_supa.c"6*/ TK_FILE*btshx_tk_handles[256];
int btshx_tk_nhandles=3;
/*9*/ void tk_setGpioOutputs(int val)
{
*(int*)0xABCD0000=val;
}
/*14*/ void tk_putc(int val)
{
while((*(vol_u32*)(0xABCD0100+0x08))&8);
/*18*/ (*(vol_u32*)(0xABCD0100+0x04))=val;
}
/*21*/ void sleep_0();
/*23*/ int tk_kbhit(void)
{return((*(vol_u32*)(0xABCD0100+0x08))&1);}
/*26*/ int tk_getch(void)
{
while(!((*(vol_u32*)(0xABCD0100+0x08))&1))
sleep_0();
return((*(vol_u32*)(0xABCD0100+0x00)));
}
/*33*/ int tk_ptrIsRam(void*ptr)
{
u32 a;
a=(u32)ptr;
a&=0x1FFFFFFF;
if(a<0x0C000000)
return(0);
if(a>=0x18000000)
return(0);
return(1);
}
/*45*/ int tk_puts(char*msg)
{
char*s;
/*49*/ s=msg;
while(*s)
{tk_putc(*s++);}
}
/*54*/ void tk_puts_n(char*msg,int n)
{
char*s;
/*58*/ s=msg;
while(n--)
{tk_putc(*s++);}
}
/*63*/ void tk_gets(char*buf)
{
char*t;
int i;
/*68*/ t=buf;
while(1)
{
i=tk_getch();
if((i=='\x08')||(i==127))
{
if(t>buf)
{
tk_puts("\x08 \x08");
t--;
}
*t=0;
continue;
}
if(i=='\r')
{tk_putc('\n');break;}
if(i=='\n')
{tk_putc('\n');break;}
tk_putc(i);
*t++ =i;
}
*t=0;
}
/*92*/ void tk_gets_n(char*msg,int n)
{
char*s;
/*96*/ s=msg;
while(n--)
{*s++ =tk_getch();}
}
/*101*/ u32 __moddi3(u32 a,u32 b)
{
u32 q,r;
/*105*/ q=a/b;
r=a-(q*b);
return(r);
}
/*110*/ u32 __umodsi3(u32 a,u32 b)
{
u32 q,r;
/*114*/ q=a/b;
r=a-(q*b);
/*122*/ return(r);
}
/*125*/ s32 __smodsi3(s32 a,s32 b)
{
s32 q,r;
/*129*/ q=a/b;
r=a-(q*b);
return(r);
}
/*135*/ typedef struct u64_obj_s u64_obj_t;
struct u64_obj_s{
u32 lo;
u32 hi;
};
/*141*/ u64_obj_t __shllli(u64_obj_t ival,int shl)
{
u64_obj_t oval;
/*145*/ if(!(shl&31))
{
if(!shl)
return(ival);
if(shl==32)
{
oval.lo=0;
oval.hi=ival.lo;
return(oval);
}
/*156*/ oval.lo=0;
oval.hi=0;
return(oval);
}
/*161*/ oval.lo=ival.lo<<shl;
oval.hi=(ival.hi<<shl)|(ival.lo<<(32-shl));
return(oval);
}
/*166*/ u64_obj_t __shrlli(u64_obj_t ival,int shl)
{
u64_obj_t oval;
/*170*/ if(!(shl&31))
{
if(!shl)
return(ival);
if(shl==32)
{
oval.lo=ival.hi;
oval.hi=0;
return(oval);
}
/*181*/ oval.lo=0;
oval.hi=0;
return(oval);
}
/*186*/ oval.hi=ival.hi>>shl;
oval.lo=(ival.lo>>shl)|(ival.hi<<(32-shl));
return(oval);
}
/*191*/ u64_obj_t __sarlli(u64_obj_t ival,int shl)
{
u64_obj_t oval;
u32 m;
/*196*/ m=0;
if(ival.hi&0x80000000)
m=(u32)(-1);
/*200*/ if(!(shl&31))
{
if(!shl)
return(ival);
if(shl==32)
{oval.lo=ival.hi;oval.hi=m;return(oval);}
if(m>0)
{oval.lo=m;oval.hi=m;return(oval);}
oval.lo=0;oval.hi=0;
return(oval);
}
/*212*/ oval.hi=(ival.hi>>shl)|(m<<(32-shl));
oval.lo=(ival.lo>>shl)|(ival.hi<<(32-shl));
return(oval);
}
/*217*/ u64_obj_t __udivlli(u64_obj_t a,u64_obj_t b)
{
u64 lc,ld;
u64_obj_t c,d,e;
/*222*/ if(!b.hi)
{
if(!a.hi)
{
c.lo=a.lo/b.lo;
c.hi=0;
return(c);
}
/*231*/ c.hi=a.hi/b.lo;
c.lo=a.lo/b.lo;
d.hi=a.hi%b.lo;
d.lo=a.lo%b.lo;
/*236*/ lc=((u64)d.hi)*((u64)b.lo);
*(u64*)(&c)+=lc;
return(c);
}
/*241*/ if(!a.hi)
{c.lo=0;c.hi=0;return(c);}
if(b.hi>a.hi)
{c.lo=0;c.hi=0;return(c);}
/*246*/ c.lo=a.hi/b.hi;
c.hi=0;
return(c);
/*253*/ }
/*259*/ s64 __sdivlli(s64 a,s64 b)
{
u64 ua,ub,uc;
int sg;
/*264*/ sg=0;
/*266*/ ua=(u64)a;
if(ua&0x8000000000000000 ULL)
{ua= -ua;sg=1;}
ub=(u64)a;
if(ub&0x8000000000000000 ULL)
{ub= -ub;sg^=1;}
uc=ua/ub;
if(sg)
{uc= -uc;}
return((s64)uc);
}
/*279*/ int __read(int handle,void*buf,size_t len,int*errind)
{
int i;
/*283*/ if(handle<3)
{
/*286*/ return(0);
}
/*289*/ if(errind)*errind=0;
i=tk_fread(buf,1,len,btshx_tk_handles[handle]);
if(i<0)
*errind=1;
/*294*/ return(i);
}
/*297*/ int __write(int handle,const void*buf,size_t len,int*errind)
{
void*ptr1;
int i;
/*302*/ if(handle<3)
{
ptr1=(void*)buf;
tk_puts_n(ptr1,len);
return(0);
}
/*309*/ if(errind)*errind=0;
ptr1=(void*)buf;
i=tk_fwrite(ptr1,1,len,btshx_tk_handles[handle]);
if(i<0)
*errind=1;
/*315*/ return(i);
}
/*318*/ void __seek(int handle,long offset,int whence)
{
tk_fseek(btshx_tk_handles[handle],offset,whence);
/*322*/ }
/*324*/ long __tell(int handle)
{
return(tk_ftell(btshx_tk_handles[handle]));
}
/*329*/ int __open(const char*a,int b,int c)
{
TK_FILE*fd;
char*s;
int i;
/*335*/ s=(char*)a;
fd=tk_fopen(s,"rb");
if(!fd)
{
*(int*)c= -1;
return(-1);
}
/*343*/ *(int*)c=0;
/*345*/ for(i=3;i<btshx_tk_nhandles;i++)
{
if(!btshx_tk_handles[i])
{
btshx_tk_handles[i]=fd;
return(i);
}
}
/*354*/ if(btshx_tk_nhandles>=256)
{
*(int*)c= -1;
return(-1);
}
/*360*/ i=btshx_tk_nhandles++;
btshx_tk_handles[i]=fd;
return(i);
/*365*/ }
/*367*/ void __close(int handle)
{
TK_FILE*fd;
/*371*/ if(handle<3)
return;
/*374*/ fd=btshx_tk_handles[handle];
btshx_tk_handles[handle]=((void*)0);
tk_fclose(fd);
/*378*/ }
/*380*/ void __remove(const char*filename)
{
/*383*/ }
/*385*/ void __rename(const char*oldfn,const char*newfn)
{
/*388*/ }
/*390*/ void __exita(int status)
{
*(int*)-1= -1;
/*394*/ }
/*396*/ u32 TK_GetTimeMs(void)
{
u32*sreg;
int ms;
/*401*/ sreg=(int*)0x007F8000;
/*403*/ ms=sreg[4];
return(ms);
}
/*407*/ void __datetime(void*ptr)
{
struct dt_s{
int year;
int month;
int day;
int hours;
int minutes;
int seconds;
int hundredths;
}dt,*pdt;
/*419*/ int ms;
/*421*/ ms=TK_GetTimeMs();
/*423*/ pdt=ptr;
pdt->hundredths=(ms/10)%100;
pdt->seconds=(ms/1000)%60;
pdt->minutes=(ms/60000)%60;
pdt->hours=0;
pdt->day=0;
pdt->month=0;
pdt->year=0;
/*433*/ }
/*435*/ void*_alloca(int sz)
{
/*438*/ return(TKMM_Malloc(sz));
}
/*441*/ void __allocmem(size_t size,void* *rptr)
{
void*ptr;
/*445*/ ptr=TKMM_Malloc(size);
tk_printf("__allocmem: %p..%p %d\n",ptr,ptr+size,size);
*rptr=ptr;
/*449*/ }
/*451*/ void __freemem(void*ptr)
{
/*455*/ }
/*457*/ unsigned char*__envptr;
/*459*/ void __exec(char*cmd,void*env)
{
/*462*/ }
/*464*/ int __start_early()
{
TKMM_Init();
}
/*469*/ int __start_late()
{
}
/*473*/ char*__get_cmdline()
{
return("");
}
/*478*/ char* *__get_cmdenv()
{
return(((void*)0));
}
/*490*/ void tk_print_hex(u32 v)
{
static char*chrs="0123456789ABCDEF";
/*494*/ tk_putc(chrs[(v>>28)&15]);
tk_putc(chrs[(v>>24)&15]);
tk_putc(chrs[(v>>20)&15]);
tk_putc(chrs[(v>>16)&15]);
tk_putc(chrs[(v>>12)&15]);
tk_putc(chrs[(v>>8)&15]);
tk_putc(chrs[(v>>4)&15]);
tk_putc(chrs[(v)&15]);
}
/*504*/ void tk_print_hex_n(u32 v,int n)
{
static char*chrs="0123456789ABCDEF";
/*508*/ if(n>7)tk_putc(chrs[(v>>28)&15]);
if(n>6)tk_putc(chrs[(v>>24)&15]);
if(n>5)tk_putc(chrs[(v>>20)&15]);
if(n>4)tk_putc(chrs[(v>>16)&15]);
if(n>3)tk_putc(chrs[(v>>12)&15]);
if(n>2)tk_putc(chrs[(v>>8)&15]);
if(n>1)tk_putc(chrs[(v>>4)&15]);
if(n>0)tk_putc(chrs[(v)&15]);
}
/*518*/ int tk_print_hex_genw(u32 v)
{
u32 w;
int i;
/*523*/ i=1;
while(v>=16)
{v=v>>4;i++;}
/*538*/ return(i);
}
/*541*/ void tk_print_decimal(int val)
{
char tb[256];
char*t;
int i,k,s;
/*547*/ if(val==0)
{
tk_putc('0');
return;
}
/*554*/ if(val==(1<<31))
{
tk_puts("-2147483648");
return;
}
/*560*/ k=val;s=0;
if(k<0)
{k= -k;s=1;}
/*564*/ t=tb;
if(!k)*t++ ='0';
while(k>0)
{
i=k%10;
*t++ ='0'+i;
k=k/10;
}
if(s)*t++ ='-';
/*574*/ if(tb[0]=='-')
*(int*)-1= -1;
/*577*/ while(t>tb)
{t--;tk_putc(*t);}
}
/*581*/ void tk_print_decimal_n(int val,int num)
{
char tb[256];
char*t;
int i,k,n,s;
/*587*/ k=val;s=0;
if(k<0)
{k= -k;s=1;}
/*591*/ t=tb;n=num;
/*593*/ while(n>0)
{
i=k%10;
*t++ ='0'+i;
k=k/10;
n--;
}
/*603*/ while(t>tb)
{t--;tk_putc(*t);}
}
/*608*/ void tk_print_float(double val)
{
int ip,fp,sg;
/*612*/ sg=0;
if(val<0)
{val= -val;sg=1;}
/*616*/ ip=(int)val;
fp=(int)((val-ip)*1000000);
/*620*/ if(ip==(1<<31))
{
/*623*/ tk_puts("#OVF");
return;
}
/*629*/ if(sg)tk_putc('-');
tk_print_decimal(ip);
tk_putc('.');
tk_print_decimal_n(fp,6);
}
/*635*/ void tk_print_float_ss(float val)
{
int ip,fp,sg;
/*639*/ sg=0;
if(val<0.0 f)
{val= -val;sg=1;}
/*643*/ ip=(int)val;
fp=(int)((val-ip)*1000000);
/*648*/ if(sg)tk_putc('-');
tk_print_decimal(ip);
tk_putc('.');
tk_print_decimal_n(fp,6);
}
/*655*/ void tk_printf(char*str,...)
{
va_list lst;
double f;
char pcfill;
char*s,*s1;
int v,w,wf;
/*663*/ __builtin_va_start(lst,str);
/*665*/ s=str;
while(*s)
{
if(*s!='%')
{tk_putc(*s++);continue;}
/*671*/ if(s[1]=='%')
{s+=2;tk_putc('%');continue;}
s++;
/*676*/ if(*s=='0')
{
pcfill='0';
s++;
}else
{
pcfill=' ';
}
/*685*/ w=0;
if((*s>='0')&&(*s<='9'))
{
while((*s>='0')&&(*s<='9'))
w=(w*10)+((*s++)-'0');
}
/*692*/ wf=0;
if(*s=='.')
{
s++;
if((*s>='0')&&(*s<='9'))
{
while((*s>='0')&&(*s<='9'))
wf=(wf*10)+((*s++)-'0');
}
}
/*705*/ switch(*s++)
{
case'c':
v=__builtin_va_arg(lst,int);
tk_putc(v);
break;
/*712*/ case'd':
/*714*/ v=__builtin_va_arg(lst,int);
/*718*/ if(w)
{tk_print_decimal_n(v,w);}
else
{tk_print_decimal(v);}
break;
case'X':
v=__builtin_va_arg(lst,int);
/*726*/ if(!w)w=tk_print_hex_genw(v);
tk_print_hex_n(v,w);
break;
case's':
s1=__builtin_va_arg(lst,char*);
tk_puts(s1);
break;
/*734*/ case'p':
s1=__builtin_va_arg(lst,char*);
tk_print_hex((u32)s1);
break;
/*740*/ case'f':
f=6969.6969;
f=__builtin_va_arg(lst,double);
tk_print_float(f);
break;
/*747*/ default:
break;
}
/*751*/ }
__builtin_va_end(lst);
}
/*756*/ void tk_vprintf(char*str,va_list lst)
{
double f;
char pcfill;
char*s,*s1;
int v,w,wf;
/*763*/ s=str;
while(*s)
{
if(*s!='%')
{tk_putc(*s++);continue;}
/*769*/ if(s[1]=='%')
{s+=2;tk_putc('%');continue;}
s++;
/*774*/ if(*s=='0')
{
pcfill='0';
s++;
}else
{
pcfill=' ';
}
/*783*/ w=0;
if((*s>='0')&&(*s<='9'))
{
while((*s>='0')&&(*s<='9'))
w=(w*10)+((*s++)-'0');
}
/*790*/ wf=0;
if(*s=='.')
{
s++;
if((*s>='0')&&(*s<='9'))
{
while((*s>='0')&&(*s<='9'))
wf=(wf*10)+((*s++)-'0');
}
}
/*803*/ switch(*s++)
{
case'c':
v=__builtin_va_arg(lst,int);
tk_putc(v);
break;
/*810*/ case'd':
/*812*/ v=__builtin_va_arg(lst,int);
/*816*/ if(w)
{tk_print_decimal_n(v,w);}
else
{tk_print_decimal(v);}
break;
case'X':
v=__builtin_va_arg(lst,int);
/*824*/ if(!w)w=tk_print_hex_genw(v);
tk_print_hex_n(v,w);
break;
case's':
s1=__builtin_va_arg(lst,char*);
tk_puts(s1);
break;
/*832*/ case'p':
s1=__builtin_va_arg(lst,char*);
tk_print_hex((u32)s1);
break;
/*838*/ case'f':
f=6969.6969;
f=__builtin_va_arg(lst,double);
tk_print_float(f);
break;
/*845*/ default:
break;
}
/*849*/ }
}
/*855*/ char*tk_sprint_hex(char*ct,u32 v)
{
static char*chrs="0123456789ABCDEF";
/*859*/ *ct++ =(chrs[(v>>28)&15]);
*ct++ =(chrs[(v>>24)&15]);
*ct++ =(chrs[(v>>20)&15]);
*ct++ =(chrs[(v>>16)&15]);
*ct++ =(chrs[(v>>12)&15]);
*ct++ =(chrs[(v>>8)&15]);
*ct++ =(chrs[(v>>4)&15]);
*ct++ =(chrs[(v)&15]);
return(ct);
}
/*870*/ char*tk_sprint_hex_n(char*ct,u32 v,int n)
{
static char*chrs="0123456789ABCDEF";
/*874*/ if(n>7)*ct++ =(chrs[(v>>28)&15]);
if(n>6)*ct++ =(chrs[(v>>24)&15]);
if(n>5)*ct++ =(chrs[(v>>20)&15]);
if(n>4)*ct++ =(chrs[(v>>16)&15]);
if(n>3)*ct++ =(chrs[(v>>12)&15]);
if(n>2)*ct++ =(chrs[(v>>8)&15]);
if(n>1)*ct++ =(chrs[(v>>4)&15]);
if(n>0)*ct++ =(chrs[(v)&15]);
return(ct);
}
/*885*/ char*tk_sprint_decimal(char*ct,int val)
{
char tb[256];
char*t;
int i,k,s;
/*891*/ if(val==0)
{
*ct++ ='0';
return(ct);
}
/*897*/ k=val;s=0;
if(k<0)
{k= -k;s=1;}
/*901*/ t=tb;
/*904*/ while(k>0)
{
i=k%10;
*t++ ='0'+i;
k=k/10;
}
if(s)*t++ ='-';
/*912*/ while(t>tb)
{t--;*ct++ = *t;}
return(ct);
}
/*917*/ char*tk_sprint_decimal_n(char*ct,int val,int num)
{
char tb[256];
char*t;
int i,k,n,s;
/*923*/ k=val;s=0;
if(k<0)
{k= -k;s=1;}
/*927*/ t=tb;n=num;
while(n>0)
{
i=k%10;
*t++ ='0'+i;
k=k/10;
n--;
}
/*938*/ while(t>tb)
{t--;*ct++ = *t;}
return(ct);
}
/*943*/ void tk_vsprintf(char*dst,char*str,va_list lst)
{
double f;
char pcfill;
char*s,*s1;
char*ct;
int v,w,wf;
/*951*/ ct=dst;
s=str;
while(*s)
{
if(*s!='%')
{*ct++ = *s++;continue;}
/*958*/ if(s[1]=='%')
{s+=2;*ct++ ='%';continue;}
s++;
/*963*/ if(*s=='0')
{
pcfill='0';
s++;
}else
{
pcfill=' ';
}
/*972*/ w=0;
if((*s>='0')&&(*s<='9'))
{
while((*s>='0')&&(*s<='9'))
w=(w*10)+((*s++)-'0');
}
/*979*/ wf=0;
if(*s=='.')
{
s++;
if((*s>='0')&&(*s<='9'))
{
while((*s>='0')&&(*s<='9'))
wf=(wf*10)+((*s++)-'0');
}
}
/*992*/ switch(*s++)
{
case'c':
v=__builtin_va_arg(lst,int);
*ct++ =v;
break;
/*999*/ case'd':
case'i':
v=__builtin_va_arg(lst,int);
if(w)
{ct=tk_sprint_decimal_n(ct,v,w);}
else
{ct=tk_sprint_decimal(ct,v);}
break;
case'X':
v=__builtin_va_arg(lst,int);
/*1010*/ if(!w)w=tk_print_hex_genw(v);
ct=tk_sprint_hex_n(ct,v,w);
break;
case's':
s1=__builtin_va_arg(lst,char*);
while(*s1)
{*ct++ = *s1++;}
break;
/*1019*/ case'p':
s1=__builtin_va_arg(lst,char*);
ct=tk_sprint_hex(ct,(u32)s1);
break;
/*1033*/ default:
break;
}
/*1037*/ }
/*1039*/ *ct++ =0;
}
/*1042*/ void tk_sprintf(char*dst,char*str,...)
{
va_list lst;
/*1046*/ __builtin_va_start(lst,str);
tk_vsprintf(dst,str,lst);
__builtin_va_end(lst);
}
